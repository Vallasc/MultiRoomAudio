
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var MultiRoomAudio = (function () {
    'use strict';

    /**
     * SSR Window 3.0.0
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2020, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: November 9, 2020
     */
    /* eslint-disable no-param-reassign */
    function isObject$3(obj) {
        return (obj !== null &&
            typeof obj === 'object' &&
            'constructor' in obj &&
            obj.constructor === Object);
    }
    function extend$3(target, src) {
        if (target === void 0) { target = {}; }
        if (src === void 0) { src = {}; }
        Object.keys(src).forEach(function (key) {
            if (typeof target[key] === 'undefined')
                target[key] = src[key];
            else if (isObject$3(src[key]) &&
                isObject$3(target[key]) &&
                Object.keys(src[key]).length > 0) {
                extend$3(target[key], src[key]);
            }
        });
    }

    var ssrDocument = {
        body: {},
        addEventListener: function () { },
        removeEventListener: function () { },
        activeElement: {
            blur: function () { },
            nodeName: '',
        },
        querySelector: function () {
            return null;
        },
        querySelectorAll: function () {
            return [];
        },
        getElementById: function () {
            return null;
        },
        createEvent: function () {
            return {
                initEvent: function () { },
            };
        },
        createElement: function () {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute: function () { },
                getElementsByTagName: function () {
                    return [];
                },
            };
        },
        createElementNS: function () {
            return {};
        },
        importNode: function () {
            return null;
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: '',
        },
    };
    function getDocument() {
        var doc = typeof document !== 'undefined' ? document : {};
        extend$3(doc, ssrDocument);
        return doc;
    }

    var ssrWindow = {
        document: ssrDocument,
        navigator: {
            userAgent: '',
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: '',
        },
        history: {
            replaceState: function () { },
            pushState: function () { },
            go: function () { },
            back: function () { },
        },
        CustomEvent: function CustomEvent() {
            return this;
        },
        addEventListener: function () { },
        removeEventListener: function () { },
        getComputedStyle: function () {
            return {
                getPropertyValue: function () {
                    return '';
                },
            };
        },
        Image: function () { },
        Date: function () { },
        screen: {},
        setTimeout: function () { },
        clearTimeout: function () { },
        matchMedia: function () {
            return {};
        },
        requestAnimationFrame: function (callback) {
            if (typeof setTimeout === 'undefined') {
                callback();
                return null;
            }
            return setTimeout(callback, 0);
        },
        cancelAnimationFrame: function (id) {
            if (typeof setTimeout === 'undefined') {
                return;
            }
            clearTimeout(id);
        },
    };
    function getWindow() {
        var win = typeof window !== 'undefined' ? window : {};
        extend$3(win, ssrWindow);
        return win;
    }

    /**
     * Dom7 3.0.0
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * https://framework7.io/docs/dom7.html
     *
     * Copyright 2020, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: November 9, 2020
     */

    function _inheritsLoose$y(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }

    function _getPrototypeOf$1(o) {
      _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$1(o);
    }

    function _setPrototypeOf$A(o, p) {
      _setPrototypeOf$A = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$A(o, p);
    }

    function _isNativeReflectConstruct$3() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _construct$3(Parent, args, Class) {
      if (_isNativeReflectConstruct$3()) {
        _construct$3 = Reflect.construct;
      } else {
        _construct$3 = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf$A(instance, Class.prototype);
          return instance;
        };
      }

      return _construct$3.apply(null, arguments);
    }

    function _isNativeFunction$1(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }

    function _wrapNativeSuper$1(Class) {
      var _cache = typeof Map === "function" ? new Map() : undefined;

      _wrapNativeSuper$1 = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction$1(Class)) return Class;

        if (typeof Class !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }

        if (typeof _cache !== "undefined") {
          if (_cache.has(Class)) return _cache.get(Class);

          _cache.set(Class, Wrapper);
        }

        function Wrapper() {
          return _construct$3(Class, arguments, _getPrototypeOf$1(this).constructor);
        }

        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf$A(Wrapper, Class);
      };

      return _wrapNativeSuper$1(Class);
    }

    function _assertThisInitialized$y(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    /* eslint-disable no-proto */
    function makeReactive(obj) {
      var proto = obj.__proto__;
      Object.defineProperty(obj, '__proto__', {
        get: function get() {
          return proto;
        },
        set: function set(value) {
          proto.__proto__ = value;
        }
      });
    }

    var Dom7 = /*#__PURE__*/function (_Array) {
      _inheritsLoose$y(Dom7, _Array);

      function Dom7(items) {
        var _this;

        _this = _Array.call.apply(_Array, [this].concat(items)) || this;
        makeReactive(_assertThisInitialized$y(_this));
        return _this;
      }

      return Dom7;
    }( /*#__PURE__*/_wrapNativeSuper$1(Array));

    function arrayFlat(arr) {
      if (arr === void 0) {
        arr = [];
      }

      var res = [];
      arr.forEach(function (el) {
        if (Array.isArray(el)) {
          res.push.apply(res, arrayFlat(el));
        } else {
          res.push(el);
        }
      });
      return res;
    }
    function arrayFilter(arr, callback) {
      return Array.prototype.filter.call(arr, callback);
    }
    function arrayUnique(arr) {
      var uniqueArray = [];

      for (var i = 0; i < arr.length; i += 1) {
        if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
      }

      return uniqueArray;
    }
    function toCamelCase(string) {
      return string.toLowerCase().replace(/-(.)/g, function (match, group) {
        return group.toUpperCase();
      });
    }

    function qsa(selector, context) {
      if (typeof selector !== 'string') {
        return [selector];
      }

      var a = [];
      var res = context.querySelectorAll(selector);

      for (var i = 0; i < res.length; i += 1) {
        a.push(res[i]);
      }

      return a;
    }

    function $$1(selector, context) {
      var window = getWindow();
      var document = getDocument();
      var arr = [];

      if (!context && selector instanceof Dom7) {
        return selector;
      }

      if (!selector) {
        return new Dom7(arr);
      }

      if (typeof selector === 'string') {
        var html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          var toCreate = 'div';
          if (html.indexOf('<li') === 0) toCreate = 'ul';
          if (html.indexOf('<tr') === 0) toCreate = 'tbody';
          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
          if (html.indexOf('<tbody') === 0) toCreate = 'table';
          if (html.indexOf('<option') === 0) toCreate = 'select';
          var tempParent = document.createElement(toCreate);
          tempParent.innerHTML = html;

          for (var i = 0; i < tempParent.childNodes.length; i += 1) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          arr = qsa(selector.trim(), context || document);
        } // arr = qsa(selector, document);

      } else if (selector.nodeType || selector === window || selector === document) {
        arr.push(selector);
      } else if (Array.isArray(selector)) {
        if (selector instanceof Dom7) return selector;
        arr = selector;
      }

      return new Dom7(arrayUnique(arr));
    }

    $$1.fn = Dom7.prototype;

    function addClass() {
      for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
        classes[_key] = arguments[_key];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        var _el$classList;

        (_el$classList = el.classList).add.apply(_el$classList, classNames);
      });
      return this;
    }

    function removeClass() {
      for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        classes[_key2] = arguments[_key2];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        var _el$classList2;

        (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
      });
      return this;
    }

    function toggleClass() {
      for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        classes[_key3] = arguments[_key3];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        classNames.forEach(function (className) {
          el.classList.toggle(className);
        });
      });
    }

    function hasClass() {
      for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        classes[_key4] = arguments[_key4];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      return arrayFilter(this, function (el) {
        return classNames.filter(function (className) {
          return el.classList.contains(className);
        }).length > 0;
      }).length > 0;
    }

    function attr$1(attrs, value) {
      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this[0]) return this[0].getAttribute(attrs);
        return undefined;
      } // Set attrs


      for (var i = 0; i < this.length; i += 1) {
        if (arguments.length === 2) {
          // String
          this[i].setAttribute(attrs, value);
        } else {
          // Object
          for (var attrName in attrs) {
            this[i][attrName] = attrs[attrName];
            this[i].setAttribute(attrName, attrs[attrName]);
          }
        }
      }

      return this;
    }

    function removeAttr(attr) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].removeAttribute(attr);
      }

      return this;
    }

    function prop(props, value) {
      if (arguments.length === 1 && typeof props === 'string') {
        // Get prop
        if (this[0]) return this[0][props];
      } else {
        // Set props
        for (var i = 0; i < this.length; i += 1) {
          if (arguments.length === 2) {
            // String
            this[i][props] = value;
          } else {
            // Object
            for (var propName in props) {
              this[i][propName] = props[propName];
            }
          }
        }

        return this;
      }

      return this;
    }

    function data(key, value) {
      var el;

      if (typeof value === 'undefined') {
        el = this[0];
        if (!el) return undefined; // Get value

        if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
          return el.dom7ElementDataStorage[key];
        }

        var dataKey = el.getAttribute("data-" + key);

        if (dataKey) {
          return dataKey;
        }

        return undefined;
      } // Set value


      for (var i = 0; i < this.length; i += 1) {
        el = this[i];
        if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
        el.dom7ElementDataStorage[key] = value;
      }

      return this;
    }

    function removeData(key) {
      for (var i = 0; i < this.length; i += 1) {
        var el = this[i];

        if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
          el.dom7ElementDataStorage[key] = null;
          delete el.dom7ElementDataStorage[key];
        }
      }
    }

    function dataset() {
      var el = this[0];
      if (!el) return undefined;
      var dataset = {}; // eslint-disable-line

      if (el.dataset) {
        for (var dataKey in el.dataset) {
          dataset[dataKey] = el.dataset[dataKey];
        }
      } else {
        for (var i = 0; i < el.attributes.length; i += 1) {
          var _attr = el.attributes[i];

          if (_attr.name.indexOf('data-') >= 0) {
            dataset[toCamelCase(_attr.name.split('data-')[1])] = _attr.value;
          }
        }
      }

      for (var key in dataset) {
        if (dataset[key] === 'false') dataset[key] = false;else if (dataset[key] === 'true') dataset[key] = true;else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
      }

      return dataset;
    }

    function val(value) {
      if (typeof value === 'undefined') {
        // get value
        var el = this[0];
        if (!el) return undefined;

        if (el.multiple && el.nodeName.toLowerCase() === 'select') {
          var values = [];

          for (var i = 0; i < el.selectedOptions.length; i += 1) {
            values.push(el.selectedOptions[i].value);
          }

          return values;
        }

        return el.value;
      } // set value


      for (var _i = 0; _i < this.length; _i += 1) {
        var _el = this[_i];

        if (Array.isArray(value) && _el.multiple && _el.nodeName.toLowerCase() === 'select') {
          for (var j = 0; j < _el.options.length; j += 1) {
            _el.options[j].selected = value.indexOf(_el.options[j].value) >= 0;
          }
        } else {
          _el.value = value;
        }
      }

      return this;
    }

    function value(value) {
      return this.val(value);
    }

    function transform(transform) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].style.transform = transform;
      }

      return this;
    }

    function transition$1(duration) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].style.transitionDuration = typeof duration !== 'string' ? duration + "ms" : duration;
      }

      return this;
    }

    function on() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      var eventType = args[0],
          targetSelector = args[1],
          listener = args[2],
          capture = args[3];

      if (typeof args[1] === 'function') {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = undefined;
      }

      if (!capture) capture = false;

      function handleLiveEvent(e) {
        var target = e.target;
        if (!target) return;
        var eventData = e.target.dom7EventData || [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        if ($$1(target).is(targetSelector)) listener.apply(target, eventData);else {
          var _parents = $$1(target).parents(); // eslint-disable-line


          for (var k = 0; k < _parents.length; k += 1) {
            if ($$1(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
          }
        }
      }

      function handleEvent(e) {
        var eventData = e && e.target ? e.target.dom7EventData || [] : [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        listener.apply(this, eventData);
      }

      var events = eventType.split(' ');
      var j;

      for (var i = 0; i < this.length; i += 1) {
        var el = this[i];

        if (!targetSelector) {
          for (j = 0; j < events.length; j += 1) {
            var event = events[j];
            if (!el.dom7Listeners) el.dom7Listeners = {};
            if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
            el.dom7Listeners[event].push({
              listener: listener,
              proxyListener: handleEvent
            });
            el.addEventListener(event, handleEvent, capture);
          }
        } else {
          // Live events
          for (j = 0; j < events.length; j += 1) {
            var _event = events[j];
            if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
            if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];

            el.dom7LiveListeners[_event].push({
              listener: listener,
              proxyListener: handleLiveEvent
            });

            el.addEventListener(_event, handleLiveEvent, capture);
          }
        }
      }

      return this;
    }

    function off() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      var eventType = args[0],
          targetSelector = args[1],
          listener = args[2],
          capture = args[3];

      if (typeof args[1] === 'function') {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = undefined;
      }

      if (!capture) capture = false;
      var events = eventType.split(' ');

      for (var i = 0; i < events.length; i += 1) {
        var event = events[i];

        for (var j = 0; j < this.length; j += 1) {
          var el = this[j];
          var handlers = void 0;

          if (!targetSelector && el.dom7Listeners) {
            handlers = el.dom7Listeners[event];
          } else if (targetSelector && el.dom7LiveListeners) {
            handlers = el.dom7LiveListeners[event];
          }

          if (handlers && handlers.length) {
            for (var k = handlers.length - 1; k >= 0; k -= 1) {
              var handler = handlers[k];

              if (listener && handler.listener === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (!listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              }
            }
          }
        }
      }

      return this;
    }

    function once() {
      var dom = this;

      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      var eventName = args[0],
          targetSelector = args[1],
          listener = args[2],
          capture = args[3];

      if (typeof args[1] === 'function') {
        eventName = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = undefined;
      }

      function onceHandler() {
        for (var _len8 = arguments.length, eventArgs = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
          eventArgs[_key8] = arguments[_key8];
        }

        listener.apply(this, eventArgs);
        dom.off(eventName, targetSelector, onceHandler, capture);

        if (onceHandler.dom7proxy) {
          delete onceHandler.dom7proxy;
        }
      }

      onceHandler.dom7proxy = listener;
      return dom.on(eventName, targetSelector, onceHandler, capture);
    }

    function trigger() {
      var window = getWindow();

      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }

      var events = args[0].split(' ');
      var eventData = args[1];

      for (var i = 0; i < events.length; i += 1) {
        var event = events[i];

        for (var j = 0; j < this.length; j += 1) {
          var el = this[j];

          if (window.CustomEvent) {
            var evt = new window.CustomEvent(event, {
              detail: eventData,
              bubbles: true,
              cancelable: true
            });
            el.dom7EventData = args.filter(function (data, dataIndex) {
              return dataIndex > 0;
            });
            el.dispatchEvent(evt);
            el.dom7EventData = [];
            delete el.dom7EventData;
          }
        }
      }

      return this;
    }

    function transitionEnd$1(callback) {
      var dom = this;

      function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off('transitionend', fireCallBack);
      }

      if (callback) {
        dom.on('transitionend', fireCallBack);
      }

      return this;
    }

    function animationEnd(callback) {
      var dom = this;

      function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off('animationend', fireCallBack);
      }

      if (callback) {
        dom.on('animationend', fireCallBack);
      }

      return this;
    }

    function width() {
      var window = getWindow();

      if (this[0] === window) {
        return window.innerWidth;
      }

      if (this.length > 0) {
        return parseFloat(this.css('width'));
      }

      return null;
    }

    function outerWidth(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          var _styles = this.styles();

          return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));
        }

        return this[0].offsetWidth;
      }

      return null;
    }

    function height() {
      var window = getWindow();

      if (this[0] === window) {
        return window.innerHeight;
      }

      if (this.length > 0) {
        return parseFloat(this.css('height'));
      }

      return null;
    }

    function outerHeight(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          var _styles2 = this.styles();

          return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));
        }

        return this[0].offsetHeight;
      }

      return null;
    }

    function offset() {
      if (this.length > 0) {
        var window = getWindow();
        var document = getDocument();
        var el = this[0];
        var box = el.getBoundingClientRect();
        var body = document.body;
        var clientTop = el.clientTop || body.clientTop || 0;
        var clientLeft = el.clientLeft || body.clientLeft || 0;
        var scrollTop = el === window ? window.scrollY : el.scrollTop;
        var scrollLeft = el === window ? window.scrollX : el.scrollLeft;
        return {
          top: box.top + scrollTop - clientTop,
          left: box.left + scrollLeft - clientLeft
        };
      }

      return null;
    }

    function hide() {
      for (var i = 0; i < this.length; i += 1) {
        this[i].style.display = 'none';
      }

      return this;
    }

    function show() {
      var window = getWindow();

      for (var i = 0; i < this.length; i += 1) {
        var el = this[i];

        if (el.style.display === 'none') {
          el.style.display = '';
        }

        if (window.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
          // Still not visible
          el.style.display = 'block';
        }
      }

      return this;
    }

    function styles() {
      var window = getWindow();
      if (this[0]) return window.getComputedStyle(this[0], null);
      return {};
    }

    function css(props, value) {
      var window = getWindow();
      var i;

      if (arguments.length === 1) {
        if (typeof props === 'string') {
          // .css('width')
          if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
          // .css({ width: '100px' })
          for (i = 0; i < this.length; i += 1) {
            for (var _prop in props) {
              this[i].style[_prop] = props[_prop];
            }
          }

          return this;
        }
      }

      if (arguments.length === 2 && typeof props === 'string') {
        // .css('width', '100px')
        for (i = 0; i < this.length; i += 1) {
          this[i].style[props] = value;
        }

        return this;
      }

      return this;
    }

    function each(callback) {
      if (!callback) return this;
      this.forEach(function (el, index) {
        callback.apply(el, [el, index]);
      });
      return this;
    }

    function filter(callback) {
      var result = arrayFilter(this, callback);
      return $$1(result);
    }

    function html(html) {
      if (typeof html === 'undefined') {
        return this[0] ? this[0].innerHTML : null;
      }

      for (var i = 0; i < this.length; i += 1) {
        this[i].innerHTML = html;
      }

      return this;
    }

    function text$2(text) {
      if (typeof text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      }

      for (var i = 0; i < this.length; i += 1) {
        this[i].textContent = text;
      }

      return this;
    }

    function is(selector) {
      var window = getWindow();
      var document = getDocument();
      var el = this[0];
      var compareWith;
      var i;
      if (!el || typeof selector === 'undefined') return false;

      if (typeof selector === 'string') {
        if (el.matches) return el.matches(selector);
        if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
        if (el.msMatchesSelector) return el.msMatchesSelector(selector);
        compareWith = $$1(selector);

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      if (selector === document) {
        return el === document;
      }

      if (selector === window) {
        return el === window;
      }

      if (selector.nodeType || selector instanceof Dom7) {
        compareWith = selector.nodeType ? [selector] : selector;

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      return false;
    }

    function index() {
      var child = this[0];
      var i;

      if (child) {
        i = 0; // eslint-disable-next-line

        while ((child = child.previousSibling) !== null) {
          if (child.nodeType === 1) i += 1;
        }

        return i;
      }

      return undefined;
    }

    function eq(index) {
      if (typeof index === 'undefined') return this;
      var length = this.length;

      if (index > length - 1) {
        return $$1([]);
      }

      if (index < 0) {
        var returnIndex = length + index;
        if (returnIndex < 0) return $$1([]);
        return $$1([this[returnIndex]]);
      }

      return $$1([this[index]]);
    }

    function append$1() {
      var newChild;
      var document = getDocument();

      for (var k = 0; k < arguments.length; k += 1) {
        newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];

        for (var i = 0; i < this.length; i += 1) {
          if (typeof newChild === 'string') {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;

            while (tempDiv.firstChild) {
              this[i].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom7) {
            for (var j = 0; j < newChild.length; j += 1) {
              this[i].appendChild(newChild[j]);
            }
          } else {
            this[i].appendChild(newChild);
          }
        }
      }

      return this;
    }

    function appendTo(parent) {
      $$1(parent).append(this);
      return this;
    }

    function prepend(newChild) {
      var document = getDocument();
      var i;
      var j;

      for (i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          }
        } else if (newChild instanceof Dom7) {
          for (j = 0; j < newChild.length; j += 1) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }

      return this;
    }

    function prependTo(parent) {
      $$1(parent).prepend(this);
      return this;
    }

    function insertBefore(selector) {
      var before = $$1(selector);

      for (var i = 0; i < this.length; i += 1) {
        if (before.length === 1) {
          before[0].parentNode.insertBefore(this[i], before[0]);
        } else if (before.length > 1) {
          for (var j = 0; j < before.length; j += 1) {
            before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
          }
        }
      }
    }

    function insertAfter(selector) {
      var after = $$1(selector);

      for (var i = 0; i < this.length; i += 1) {
        if (after.length === 1) {
          after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
        } else if (after.length > 1) {
          for (var j = 0; j < after.length; j += 1) {
            after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
          }
        }
      }
    }

    function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $$1(this[0].nextElementSibling).is(selector)) {
            return $$1([this[0].nextElementSibling]);
          }

          return $$1([]);
        }

        if (this[0].nextElementSibling) return $$1([this[0].nextElementSibling]);
        return $$1([]);
      }

      return $$1([]);
    }

    function nextAll(selector) {
      var nextEls = [];
      var el = this[0];
      if (!el) return $$1([]);

      while (el.nextElementSibling) {
        var _next = el.nextElementSibling; // eslint-disable-line

        if (selector) {
          if ($$1(_next).is(selector)) nextEls.push(_next);
        } else nextEls.push(_next);

        el = _next;
      }

      return $$1(nextEls);
    }

    function prev(selector) {
      if (this.length > 0) {
        var el = this[0];

        if (selector) {
          if (el.previousElementSibling && $$1(el.previousElementSibling).is(selector)) {
            return $$1([el.previousElementSibling]);
          }

          return $$1([]);
        }

        if (el.previousElementSibling) return $$1([el.previousElementSibling]);
        return $$1([]);
      }

      return $$1([]);
    }

    function prevAll(selector) {
      var prevEls = [];
      var el = this[0];
      if (!el) return $$1([]);

      while (el.previousElementSibling) {
        var _prev = el.previousElementSibling; // eslint-disable-line

        if (selector) {
          if ($$1(_prev).is(selector)) prevEls.push(_prev);
        } else prevEls.push(_prev);

        el = _prev;
      }

      return $$1(prevEls);
    }

    function siblings(selector) {
      return this.nextAll(selector).add(this.prevAll(selector));
    }

    function parent(selector) {
      var parents = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($$1(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }

      return $$1(parents);
    }

    function parents(selector) {
      var parents = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        var _parent = this[i].parentNode; // eslint-disable-line

        while (_parent) {
          if (selector) {
            if ($$1(_parent).is(selector)) parents.push(_parent);
          } else {
            parents.push(_parent);
          }

          _parent = _parent.parentNode;
        }
      }

      return $$1(parents);
    }

    function closest(selector) {
      var closest = this; // eslint-disable-line

      if (typeof selector === 'undefined') {
        return $$1([]);
      }

      if (!closest.is(selector)) {
        closest = closest.parents(selector).eq(0);
      }

      return closest;
    }

    function find(selector) {
      var foundElements = [];

      for (var i = 0; i < this.length; i += 1) {
        var found = this[i].querySelectorAll(selector);

        for (var j = 0; j < found.length; j += 1) {
          foundElements.push(found[j]);
        }
      }

      return $$1(foundElements);
    }

    function children$1(selector) {
      var children = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        var childNodes = this[i].children;

        for (var j = 0; j < childNodes.length; j += 1) {
          if (!selector || $$1(childNodes[j]).is(selector)) {
            children.push(childNodes[j]);
          }
        }
      }

      return $$1(children);
    }

    function remove() {
      for (var i = 0; i < this.length; i += 1) {
        if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
      }

      return this;
    }

    function detach$1() {
      return this.remove();
    }

    function add() {
      var dom = this;
      var i;
      var j;

      for (var _len10 = arguments.length, els = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        els[_key10] = arguments[_key10];
      }

      for (i = 0; i < els.length; i += 1) {
        var toAdd = $$1(els[i]);

        for (j = 0; j < toAdd.length; j += 1) {
          dom.push(toAdd[j]);
        }
      }

      return dom;
    }

    function empty$1() {
      for (var i = 0; i < this.length; i += 1) {
        var el = this[i];

        if (el.nodeType === 1) {
          for (var j = 0; j < el.childNodes.length; j += 1) {
            if (el.childNodes[j].parentNode) {
              el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
            }
          }

          el.textContent = '';
        }
      }

      return this;
    }

    function scrollTo() {
      var window = getWindow();

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var left = args[0],
          top = args[1],
          duration = args[2],
          easing = args[3],
          callback = args[4];

      if (args.length === 4 && typeof easing === 'function') {
        callback = easing;
        left = args[0];
        top = args[1];
        duration = args[2];
        callback = args[3];
        easing = args[4];
      }

      if (typeof easing === 'undefined') easing = 'swing';
      return this.each(function animate() {
        var el = this;
        var currentTop;
        var currentLeft;
        var maxTop;
        var maxLeft;
        var newTop;
        var newLeft;
        var scrollTop; // eslint-disable-line

        var scrollLeft; // eslint-disable-line

        var animateTop = top > 0 || top === 0;
        var animateLeft = left > 0 || left === 0;

        if (typeof easing === 'undefined') {
          easing = 'swing';
        }

        if (animateTop) {
          currentTop = el.scrollTop;

          if (!duration) {
            el.scrollTop = top;
          }
        }

        if (animateLeft) {
          currentLeft = el.scrollLeft;

          if (!duration) {
            el.scrollLeft = left;
          }
        }

        if (!duration) return;

        if (animateTop) {
          maxTop = el.scrollHeight - el.offsetHeight;
          newTop = Math.max(Math.min(top, maxTop), 0);
        }

        if (animateLeft) {
          maxLeft = el.scrollWidth - el.offsetWidth;
          newLeft = Math.max(Math.min(left, maxLeft), 0);
        }

        var startTime = null;
        if (animateTop && newTop === currentTop) animateTop = false;
        if (animateLeft && newLeft === currentLeft) animateLeft = false;

        function render(time) {
          if (time === void 0) {
            time = new Date().getTime();
          }

          if (startTime === null) {
            startTime = time;
          }

          var progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
          var easeProgress = easing === 'linear' ? progress : 0.5 - Math.cos(progress * Math.PI) / 2;
          var done;
          if (animateTop) scrollTop = currentTop + easeProgress * (newTop - currentTop);
          if (animateLeft) scrollLeft = currentLeft + easeProgress * (newLeft - currentLeft);

          if (animateTop && newTop > currentTop && scrollTop >= newTop) {
            el.scrollTop = newTop;
            done = true;
          }

          if (animateTop && newTop < currentTop && scrollTop <= newTop) {
            el.scrollTop = newTop;
            done = true;
          }

          if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
            el.scrollLeft = newLeft;
            done = true;
          }

          if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
            el.scrollLeft = newLeft;
            done = true;
          }

          if (done) {
            if (callback) callback();
            return;
          }

          if (animateTop) el.scrollTop = scrollTop;
          if (animateLeft) el.scrollLeft = scrollLeft;
          window.requestAnimationFrame(render);
        }

        window.requestAnimationFrame(render);
      });
    } // scrollTop(top, duration, easing, callback) {


    function scrollTop() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var top = args[0],
          duration = args[1],
          easing = args[2],
          callback = args[3];

      if (args.length === 3 && typeof easing === 'function') {
        top = args[0];
        duration = args[1];
        callback = args[2];
        easing = args[3];
      }

      var dom = this;

      if (typeof top === 'undefined') {
        if (dom.length > 0) return dom[0].scrollTop;
        return null;
      }

      return dom.scrollTo(undefined, top, duration, easing, callback);
    }

    function scrollLeft() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var left = args[0],
          duration = args[1],
          easing = args[2],
          callback = args[3];

      if (args.length === 3 && typeof easing === 'function') {
        left = args[0];
        duration = args[1];
        callback = args[2];
        easing = args[3];
      }

      var dom = this;

      if (typeof left === 'undefined') {
        if (dom.length > 0) return dom[0].scrollLeft;
        return null;
      }

      return dom.scrollTo(left, undefined, duration, easing, callback);
    }

    function animate(initialProps, initialParams) {
      var window = getWindow();
      var els = this;
      var a = {
        props: Object.assign({}, initialProps),
        params: Object.assign({
          duration: 300,
          easing: 'swing' // or 'linear'

          /* Callbacks
          begin(elements)
          complete(elements)
          progress(elements, complete, remaining, start, tweenValue)
          */

        }, initialParams),
        elements: els,
        animating: false,
        que: [],
        easingProgress: function easingProgress(easing, progress) {
          if (easing === 'swing') {
            return 0.5 - Math.cos(progress * Math.PI) / 2;
          }

          if (typeof easing === 'function') {
            return easing(progress);
          }

          return progress;
        },
        stop: function stop() {
          if (a.frameId) {
            window.cancelAnimationFrame(a.frameId);
          }

          a.animating = false;
          a.elements.each(function (el) {
            var element = el;
            delete element.dom7AnimateInstance;
          });
          a.que = [];
        },
        done: function done(complete) {
          a.animating = false;
          a.elements.each(function (el) {
            var element = el;
            delete element.dom7AnimateInstance;
          });
          if (complete) complete(els);

          if (a.que.length > 0) {
            var que = a.que.shift();
            a.animate(que[0], que[1]);
          }
        },
        animate: function animate(props, params) {
          if (a.animating) {
            a.que.push([props, params]);
            return a;
          }

          var elements = []; // Define & Cache Initials & Units

          a.elements.each(function (el, index) {
            var initialFullValue;
            var initialValue;
            var unit;
            var finalValue;
            var finalFullValue;
            if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;
            elements[index] = {
              container: el
            };
            Object.keys(props).forEach(function (prop) {
              initialFullValue = window.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
              initialValue = parseFloat(initialFullValue);
              unit = initialFullValue.replace(initialValue, '');
              finalValue = parseFloat(props[prop]);
              finalFullValue = props[prop] + unit;
              elements[index][prop] = {
                initialFullValue: initialFullValue,
                initialValue: initialValue,
                unit: unit,
                finalValue: finalValue,
                finalFullValue: finalFullValue,
                currentValue: initialValue
              };
            });
          });
          var startTime = null;
          var time;
          var elementsDone = 0;
          var propsDone = 0;
          var done;
          var began = false;
          a.animating = true;

          function render() {
            time = new Date().getTime();
            var progress;
            var easeProgress; // let el;

            if (!began) {
              began = true;
              if (params.begin) params.begin(els);
            }

            if (startTime === null) {
              startTime = time;
            }

            if (params.progress) {
              // eslint-disable-next-line
              params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), startTime + params.duration - time < 0 ? 0 : startTime + params.duration - time, startTime);
            }

            elements.forEach(function (element) {
              var el = element;
              if (done || el.done) return;
              Object.keys(props).forEach(function (prop) {
                if (done || el.done) return;
                progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
                easeProgress = a.easingProgress(params.easing, progress);
                var _el$prop = el[prop],
                    initialValue = _el$prop.initialValue,
                    finalValue = _el$prop.finalValue,
                    unit = _el$prop.unit;
                el[prop].currentValue = initialValue + easeProgress * (finalValue - initialValue);
                var currentValue = el[prop].currentValue;

                if (finalValue > initialValue && currentValue >= finalValue || finalValue < initialValue && currentValue <= finalValue) {
                  el.container.style[prop] = finalValue + unit;
                  propsDone += 1;

                  if (propsDone === Object.keys(props).length) {
                    el.done = true;
                    elementsDone += 1;
                  }

                  if (elementsDone === elements.length) {
                    done = true;
                  }
                }

                if (done) {
                  a.done(params.complete);
                  return;
                }

                el.container.style[prop] = currentValue + unit;
              });
            });
            if (done) return; // Then call

            a.frameId = window.requestAnimationFrame(render);
          }

          a.frameId = window.requestAnimationFrame(render);
          return a;
        }
      };

      if (a.elements.length === 0) {
        return els;
      }

      var animateInstance;

      for (var i = 0; i < a.elements.length; i += 1) {
        if (a.elements[i].dom7AnimateInstance) {
          animateInstance = a.elements[i].dom7AnimateInstance;
        } else a.elements[i].dom7AnimateInstance = a;
      }

      if (!animateInstance) {
        animateInstance = a;
      }

      if (initialProps === 'stop') {
        animateInstance.stop();
      } else {
        animateInstance.animate(a.props, a.params);
      }

      return els;
    }

    function stop() {
      var els = this;

      for (var i = 0; i < els.length; i += 1) {
        if (els[i].dom7AnimateInstance) {
          els[i].dom7AnimateInstance.stop();
        }
      }
    }

    var noTrigger = 'resize scroll'.split(' ');

    function shortcut(name) {
      function eventHandler() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (typeof args[0] === 'undefined') {
          for (var i = 0; i < this.length; i += 1) {
            if (noTrigger.indexOf(name) < 0) {
              if (name in this[i]) this[i][name]();else {
                $$1(this[i]).trigger(name);
              }
            }
          }

          return this;
        }

        return this.on.apply(this, [name].concat(args));
      }

      return eventHandler;
    }

    var click = shortcut('click');
    var blur = shortcut('blur');
    var focus = shortcut('focus');
    var focusin = shortcut('focusin');
    var focusout = shortcut('focusout');
    var keyup = shortcut('keyup');
    var keydown = shortcut('keydown');
    var keypress = shortcut('keypress');
    var submit = shortcut('submit');
    var change = shortcut('change');
    var mousedown = shortcut('mousedown');
    var mousemove = shortcut('mousemove');
    var mouseup = shortcut('mouseup');
    var mouseenter = shortcut('mouseenter');
    var mouseleave = shortcut('mouseleave');
    var mouseout = shortcut('mouseout');
    var mouseover = shortcut('mouseover');
    var touchstart = shortcut('touchstart');
    var touchend = shortcut('touchend');
    var touchmove = shortcut('touchmove');
    var resize = shortcut('resize');
    var scroll = shortcut('scroll');

    var methods = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': $$1,
        $: $$1,
        add: add,
        addClass: addClass,
        animate: animate,
        animationEnd: animationEnd,
        append: append$1,
        appendTo: appendTo,
        attr: attr$1,
        blur: blur,
        change: change,
        children: children$1,
        click: click,
        closest: closest,
        css: css,
        data: data,
        dataset: dataset,
        detach: detach$1,
        each: each,
        empty: empty$1,
        eq: eq,
        filter: filter,
        find: find,
        focus: focus,
        focusin: focusin,
        focusout: focusout,
        hasClass: hasClass,
        height: height,
        hide: hide,
        html: html,
        index: index,
        insertAfter: insertAfter,
        insertBefore: insertBefore,
        is: is,
        keydown: keydown,
        keypress: keypress,
        keyup: keyup,
        mousedown: mousedown,
        mouseenter: mouseenter,
        mouseleave: mouseleave,
        mousemove: mousemove,
        mouseout: mouseout,
        mouseover: mouseover,
        mouseup: mouseup,
        next: next,
        nextAll: nextAll,
        off: off,
        offset: offset,
        on: on,
        once: once,
        outerHeight: outerHeight,
        outerWidth: outerWidth,
        parent: parent,
        parents: parents,
        prepend: prepend,
        prependTo: prependTo,
        prev: prev,
        prevAll: prevAll,
        prop: prop,
        remove: remove,
        removeAttr: removeAttr,
        removeClass: removeClass,
        removeData: removeData,
        resize: resize,
        scroll: scroll,
        scrollLeft: scrollLeft,
        scrollTo: scrollTo,
        scrollTop: scrollTop,
        show: show,
        siblings: siblings,
        stop: stop,
        styles: styles,
        submit: submit,
        text: text$2,
        toggleClass: toggleClass,
        touchend: touchend,
        touchmove: touchmove,
        touchstart: touchstart,
        transform: transform,
        transition: transition$1,
        transitionEnd: transitionEnd$1,
        trigger: trigger,
        val: val,
        value: value,
        width: width
    });

    Object.keys(methods).forEach(function (methodName) {
      if (methodName === '$') return;
      $$1.fn[methodName] = methods[methodName];
    });
    var $ = $$1;

    var uniqueNum = 0;
    function uniqueNumber() {
      uniqueNum += 1;
      return uniqueNum;
    }
    function id(mask, map) {
      if (mask === void 0) {
        mask = 'xxxxxxxxxx';
      }

      if (map === void 0) {
        map = '0123456789abcdef';
      }

      var length = map.length;
      return mask.replace(/x/g, function () {
        return map[Math.floor(Math.random() * length)];
      });
    }
    var mdPreloaderContent = "\n  <span class=\"preloader-inner\">\n    <svg viewBox=\"0 0 36 36\">\n      <circle cx=\"18\" cy=\"18\" r=\"16\"></circle>\n    </svg>\n  </span>\n".trim();
    var iosPreloaderContent = ("\n  <span class=\"preloader-inner\">\n    " + [0, 1, 2, 3, 4, 5, 6, 7].map(function () {
      return '<span class="preloader-inner-line"></span>';
    }).join('') + "\n  </span>\n").trim();
    var auroraPreloaderContent = "\n  <span class=\"preloader-inner\">\n    <span class=\"preloader-inner-circle\"></span>\n  </span>\n";
    function eventNameToColonCase(eventName) {
      var hasColon;
      return eventName.split('').map(function (char, index) {
        if (char.match(/[A-Z]/) && index !== 0 && !hasColon) {
          hasColon = true;
          return ":" + char.toLowerCase();
        }

        return char.toLowerCase();
      }).join('');
    }
    function deleteProps$1(obj) {
      var object = obj;
      Object.keys(object).forEach(function (key) {
        try {
          object[key] = null;
        } catch (e) {// no setter for object
        }

        try {
          delete object[key];
        } catch (e) {// something got wrong
        }
      });
    }
    function requestAnimationFrame(callback) {
      var window = getWindow();
      return window.requestAnimationFrame(callback);
    }
    function cancelAnimationFrame$1(frameId) {
      var window = getWindow();
      return window.cancelAnimationFrame(frameId);
    }
    function nextTick$1(callback, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      return setTimeout(callback, delay);
    }
    function nextFrame(callback) {
      return requestAnimationFrame(function () {
        requestAnimationFrame(callback);
      });
    }
    function now$2() {
      return Date.now();
    }
    function parseUrlQuery(url) {
      var window = getWindow();
      var query = {};
      var urlToParse = url || window.location.href;
      var i;
      var params;
      var param;
      var length;

      if (typeof urlToParse === 'string' && urlToParse.length) {
        urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
        params = urlToParse.split('&').filter(function (paramsPart) {
          return paramsPart !== '';
        });
        length = params.length;

        for (i = 0; i < length; i += 1) {
          param = params[i].replace(/#\S+/g, '').split('=');
          query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param.slice(1).join('=')) || '';
        }
      }

      return query;
    }
    function getTranslate$1(el, axis) {
      if (axis === void 0) {
        axis = 'x';
      }

      var window = getWindow();
      var matrix;
      var curTransform;
      var transformMatrix;
      var curStyle = window.getComputedStyle(el, null);

      if (window.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;

        if (curTransform.split(',').length > 6) {
          curTransform = curTransform.split(', ').map(function (a) {
            return a.replace(',', '.');
          }).join(', ');
        } // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case


        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }

      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
          else curTransform = parseFloat(matrix[4]);
      }

      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
          else curTransform = parseFloat(matrix[5]);
      }

      return curTransform || 0;
    }
    function serializeObject(obj, parents) {
      if (parents === void 0) {
        parents = [];
      }

      if (typeof obj === 'string') return obj;
      var resultArray = [];
      var separator = '&';
      var newParents;

      function varName(name) {
        if (parents.length > 0) {
          var parentParts = '';

          for (var j = 0; j < parents.length; j += 1) {
            if (j === 0) parentParts += parents[j];else parentParts += "[" + encodeURIComponent(parents[j]) + "]";
          }

          return parentParts + "[" + encodeURIComponent(name) + "]";
        }

        return encodeURIComponent(name);
      }

      function varValue(value) {
        return encodeURIComponent(value);
      }

      Object.keys(obj).forEach(function (prop) {
        var toPush;

        if (Array.isArray(obj[prop])) {
          toPush = [];

          for (var i = 0; i < obj[prop].length; i += 1) {
            if (!Array.isArray(obj[prop][i]) && typeof obj[prop][i] === 'object') {
              newParents = parents.slice();
              newParents.push(prop);
              newParents.push(String(i));
              toPush.push(serializeObject(obj[prop][i], newParents));
            } else {
              toPush.push(varName(prop) + "[]=" + varValue(obj[prop][i]));
            }
          }

          if (toPush.length > 0) resultArray.push(toPush.join(separator));
        } else if (obj[prop] === null || obj[prop] === '') {
          resultArray.push(varName(prop) + "=");
        } else if (typeof obj[prop] === 'object') {
          // Object, convert to named array
          newParents = parents.slice();
          newParents.push(prop);
          toPush = serializeObject(obj[prop], newParents);
          if (toPush !== '') resultArray.push(toPush);
        } else if (typeof obj[prop] !== 'undefined' && obj[prop] !== '') {
          // Should be string or plain value
          resultArray.push(varName(prop) + "=" + varValue(obj[prop]));
        } else if (obj[prop] === '') resultArray.push(varName(prop));
      });
      return resultArray.join(separator);
    }
    function isObject$2(o) {
      return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
    }
    function merge() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var to = args[0];
      args.splice(0, 1);
      var from = args;

      for (var i = 0; i < from.length; i += 1) {
        var nextSource = args[i];

        if (nextSource !== undefined && nextSource !== null) {
          var keysArray = Object.keys(Object(nextSource));

          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }

      return to;
    }
    function extend$2() {
      var deep = true;
      var to;
      var from;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (typeof args[0] === 'boolean') {
        deep = args[0];
        to = args[1];
        args.splice(0, 2);
        from = args;
      } else {
        to = args[0];
        args.splice(0, 1);
        from = args;
      }

      for (var i = 0; i < from.length; i += 1) {
        var nextSource = args[i];

        if (nextSource !== undefined && nextSource !== null) {
          var keysArray = Object.keys(Object(nextSource));

          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              if (!deep) {
                to[nextKey] = nextSource[nextKey];
              } else if (isObject$2(to[nextKey]) && isObject$2(nextSource[nextKey])) {
                extend$2(to[nextKey], nextSource[nextKey]);
              } else if (!isObject$2(to[nextKey]) && isObject$2(nextSource[nextKey])) {
                to[nextKey] = {};
                extend$2(to[nextKey], nextSource[nextKey]);
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }

      return to;
    }
    function colorHexToRgb(hex) {
      var h = hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);
      return result ? result.slice(1).map(function (n) {
        return parseInt(n, 16);
      }) : null;
    }
    function colorRgbToHex(r, g, b) {
      var result = [r, g, b].map(function (n) {
        var hex = n.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      }).join('');
      return "#" + result;
    }
    function colorRgbToHsl(r, g, b) {
      r /= 255; // eslint-disable-line

      g /= 255; // eslint-disable-line

      b /= 255; // eslint-disable-line

      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var d = max - min;
      var h;
      if (d === 0) h = 0;else if (max === r) h = (g - b) / d % 6;else if (max === g) h = (b - r) / d + 2;else if (max === b) h = (r - g) / d + 4;
      var l = (min + max) / 2;
      var s = d === 0 ? 0 : d / (1 - Math.abs(2 * l - 1));
      if (h < 0) h = 360 / 60 + h;
      return [h * 60, s, l];
    }
    function colorHslToRgb(h, s, l) {
      var c = (1 - Math.abs(2 * l - 1)) * s;
      var hp = h / 60;
      var x = c * (1 - Math.abs(hp % 2 - 1));
      var rgb1;

      if (Number.isNaN(h) || typeof h === 'undefined') {
        rgb1 = [0, 0, 0];
      } else if (hp <= 1) rgb1 = [c, x, 0];else if (hp <= 2) rgb1 = [x, c, 0];else if (hp <= 3) rgb1 = [0, c, x];else if (hp <= 4) rgb1 = [0, x, c];else if (hp <= 5) rgb1 = [x, 0, c];else if (hp <= 6) rgb1 = [c, 0, x];

      var m = l - c / 2;
      return rgb1.map(function (n) {
        return Math.max(0, Math.min(255, Math.round(255 * (n + m))));
      });
    }
    function colorHsbToHsl(h, s, b) {
      var HSL = {
        h: h,
        s: 0,
        l: 0
      };
      var HSB = {
        h: h,
        s: s,
        b: b
      };
      HSL.l = (2 - HSB.s) * HSB.b / 2;
      HSL.s = HSL.l && HSL.l < 1 ? HSB.s * HSB.b / (HSL.l < 0.5 ? HSL.l * 2 : 2 - HSL.l * 2) : HSL.s;
      return [HSL.h, HSL.s, HSL.l];
    }
    function colorHslToHsb(h, s, l) {
      var HSB = {
        h: h,
        s: 0,
        b: 0
      };
      var HSL = {
        h: h,
        s: s,
        l: l
      };
      var t = HSL.s * (HSL.l < 0.5 ? HSL.l : 1 - HSL.l);
      HSB.b = HSL.l + t;
      HSB.s = HSL.l > 0 ? 2 * t / HSB.b : HSB.s;
      return [HSB.h, HSB.s, HSB.b];
    }
    function colorThemeCSSProperties() {
      var hex;
      var rgb;

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      if (args.length === 1) {
        hex = args[0];
        rgb = colorHexToRgb(hex);
      } else if (args.length === 3) {
        rgb = args;
        hex = colorRgbToHex.apply(void 0, rgb);
      }

      if (!rgb) return {};
      var hsl = colorRgbToHsl.apply(void 0, rgb);
      var hslShade = [hsl[0], hsl[1], Math.max(0, hsl[2] - 0.08)];
      var hslTint = [hsl[0], hsl[1], Math.max(0, hsl[2] + 0.08)];
      var shade = colorRgbToHex.apply(void 0, colorHslToRgb.apply(void 0, hslShade));
      var tint = colorRgbToHex.apply(void 0, colorHslToRgb.apply(void 0, hslTint));
      return {
        '--f7-theme-color': hex,
        '--f7-theme-color-rgb': rgb.join(', '),
        '--f7-theme-color-shade': shade,
        '--f7-theme-color-tint': tint
      };
    }
    function bindMethods(instance, obj) {
      Object.keys(obj).forEach(function (key) {
        if (isObject$2(obj[key])) {
          Object.keys(obj[key]).forEach(function (subKey) {
            if (typeof obj[key][subKey] === 'function') {
              obj[key][subKey] = obj[key][subKey].bind(instance);
            }
          });
        }

        instance[key] = obj[key];
      });
    }
    function flattenArray() {
      var arr = [];

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      args.forEach(function (arg) {
        if (Array.isArray(arg)) arr.push.apply(arr, flattenArray.apply(void 0, arg));else arr.push(arg);
      });
      return arr;
    }

    var utils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        uniqueNumber: uniqueNumber,
        id: id,
        mdPreloaderContent: mdPreloaderContent,
        iosPreloaderContent: iosPreloaderContent,
        auroraPreloaderContent: auroraPreloaderContent,
        eventNameToColonCase: eventNameToColonCase,
        deleteProps: deleteProps$1,
        requestAnimationFrame: requestAnimationFrame,
        cancelAnimationFrame: cancelAnimationFrame$1,
        nextTick: nextTick$1,
        nextFrame: nextFrame,
        now: now$2,
        parseUrlQuery: parseUrlQuery,
        getTranslate: getTranslate$1,
        serializeObject: serializeObject,
        isObject: isObject$2,
        merge: merge,
        extend: extend$2,
        colorHexToRgb: colorHexToRgb,
        colorRgbToHex: colorRgbToHex,
        colorRgbToHsl: colorRgbToHsl,
        colorHslToRgb: colorHslToRgb,
        colorHsbToHsl: colorHsbToHsl,
        colorHslToHsb: colorHslToHsb,
        colorThemeCSSProperties: colorThemeCSSProperties,
        bindMethods: bindMethods,
        flattenArray: flattenArray
    });

    var support$1;

    function calcSupport$1() {
      var window = getWindow();
      var document = getDocument();
      return {
        touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
        pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,
        passiveListener: function checkPassiveListener() {
          var supportsPassive = false;

          try {
            var opts = Object.defineProperty({}, 'passive', {
              // eslint-disable-next-line
              get: function get() {
                supportsPassive = true;
              }
            });
            window.addEventListener('testPassiveListener', null, opts);
          } catch (e) {// No support
          }

          return supportsPassive;
        }(),
        intersectionObserver: function checkObserver() {
          return 'IntersectionObserver' in window;
        }()
      };
    }

    function getSupport$1() {
      if (!support$1) {
        support$1 = calcSupport$1();
      }

      return support$1;
    }

    var deviceCalculated;

    function calcDevice$1(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          userAgent = _ref.userAgent;

      var support = getSupport$1();
      var window = getWindow();
      var platform = window.navigator.platform;
      var ua = userAgent || window.navigator.userAgent;
      var device = {
        ios: false,
        android: false,
        androidChrome: false,
        desktop: false,
        iphone: false,
        ipod: false,
        ipad: false,
        edge: false,
        ie: false,
        firefox: false,
        macos: false,
        windows: false,
        cordova: !!(window.cordova || window.phonegap),
        phonegap: !!(window.cordova || window.phonegap),
        electron: false,
        capacitor: !!window.Capacitor,
        nwjs: false
      };
      var screenWidth = window.screen.width;
      var screenHeight = window.screen.height;
      var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

      var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      var iphone = !ipad && ua.match(/(iPhone\sOS|iOS|iPhone;\sCPU\sOS)\s([\d_]+)/);
      var ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
      var edge = ua.indexOf('Edge/') >= 0;
      var firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;
      var windows = platform === 'Win32';
      var electron = ua.toLowerCase().indexOf('electron') >= 0;
      var nwjs = typeof nw !== 'undefined' && typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.nw !== 'undefined';
      var macos = platform === 'MacIntel'; // iPadOs 13 fix

      var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

      if (!ipad && macos && support.touch && iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [0, 1, '13_0_0'];
        macos = false;
      }

      device.ie = ie;
      device.edge = edge;
      device.firefox = firefox; // Android

      if (android) {
        device.os = 'android';
        device.osVersion = android[2];
        device.android = true;
        device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
      }

      if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
      } // iOS


      if (iphone && !ipod) {
        device.osVersion = iphone[2].replace(/_/g, '.');
        device.iphone = true;
      }

      if (ipad) {
        device.osVersion = ipad[2].replace(/_/g, '.');
        device.ipad = true;
      }

      if (ipod) {
        device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
        device.ipod = true;
      } // iOS 8+ changed UA


      if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
        if (device.osVersion.split('.')[0] === '10') {
          device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
        }
      } // Webview


      device.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || window.navigator.standalone)) || window.matchMedia && window.matchMedia('(display-mode: standalone)').matches;
      device.webview = device.webView;
      device.standalone = device.webView; // Desktop

      device.desktop = !(device.ios || device.android) || electron || nwjs;

      if (device.desktop) {
        device.electron = electron;
        device.nwjs = nwjs;
        device.macos = macos;
        device.windows = windows;

        if (device.macos) {
          device.os = 'macos';
        }

        if (device.windows) {
          device.os = 'windows';
        }
      } // Pixel Ratio


      device.pixelRatio = window.devicePixelRatio || 1; // Color Scheme

      var DARK = '(prefers-color-scheme: dark)';
      var LIGHT = '(prefers-color-scheme: light)';

      device.prefersColorScheme = function prefersColorTheme() {
        var theme;

        if (window.matchMedia && window.matchMedia(LIGHT).matches) {
          theme = 'light';
        }

        if (window.matchMedia && window.matchMedia(DARK).matches) {
          theme = 'dark';
        }

        return theme;
      }; // Export object


      return device;
    }

    function getDevice$1(overrides, reset) {
      if (overrides === void 0) {
        overrides = {};
      }

      if (!deviceCalculated || reset) {
        deviceCalculated = calcDevice$1(overrides);
      }

      return deviceCalculated;
    }

    var EventsClass = /*#__PURE__*/function () {
      function EventsClass(parents) {
        if (parents === void 0) {
          parents = [];
        }

        var self = this;
        self.eventsParents = parents;
        self.eventsListeners = {};
      }

      var _proto = EventsClass.prototype;

      _proto.on = function on(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;
        var method = priority ? 'unshift' : 'push';
        events.split(' ').forEach(function (event) {
          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
          self.eventsListeners[event][method](handler);
        });
        return self;
      };

      _proto.once = function once(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;

        function onceHandler() {
          self.off(events, onceHandler);

          if (onceHandler.f7proxy) {
            delete onceHandler.f7proxy;
          }

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          handler.apply(self, args);
        }

        onceHandler.f7proxy = handler;
        return self.on(events, onceHandler, priority);
      };

      _proto.off = function off(events, handler) {
        var self = this;
        if (!self.eventsListeners) return self;
        events.split(' ').forEach(function (event) {
          if (typeof handler === 'undefined') {
            self.eventsListeners[event] = [];
          } else if (self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(function (eventHandler, index) {
              if (eventHandler === handler || eventHandler.f7proxy && eventHandler.f7proxy === handler) {
                self.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self;
      };

      _proto.emit = function emit() {
        var self = this;
        if (!self.eventsListeners) return self;
        var events;
        var data;
        var context;
        var eventsParents;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          events = args[0];
          data = args.slice(1, args.length);
          context = self;
          eventsParents = self.eventsParents;
        } else {
          events = args[0].events;
          data = args[0].data;
          context = args[0].context || self;
          eventsParents = args[0].local ? [] : args[0].parents || self.eventsParents;
        }

        var eventsArray = Array.isArray(events) ? events : events.split(' ');
        var localEvents = eventsArray.map(function (eventName) {
          return eventName.replace('local::', '');
        });
        var parentEvents = eventsArray.filter(function (eventName) {
          return eventName.indexOf('local::') < 0;
        });
        localEvents.forEach(function (event) {
          if (self.eventsListeners && self.eventsListeners[event]) {
            var handlers = [];
            self.eventsListeners[event].forEach(function (eventHandler) {
              handlers.push(eventHandler);
            });
            handlers.forEach(function (eventHandler) {
              eventHandler.apply(context, data);
            });
          }
        });

        if (eventsParents && eventsParents.length > 0) {
          eventsParents.forEach(function (eventsParent) {
            eventsParent.emit.apply(eventsParent, [parentEvents].concat(data));
          });
        }

        return self;
      };

      return EventsClass;
    }();

    var EventsClass$1 = EventsClass;

    function _defineProperties$8(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass$8(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$8(Constructor.prototype, protoProps); if (staticProps) _defineProperties$8(Constructor, staticProps); return Constructor; }

    function _assertThisInitialized$x(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$x(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$z(subClass, superClass); }

    function _setPrototypeOf$z(o, p) { _setPrototypeOf$z = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$z(o, p); }

    var Framework7Class = /*#__PURE__*/function (_EventsClass) {
      _inheritsLoose$x(Framework7Class, _EventsClass);

      function Framework7Class(params, parents) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        if (parents === void 0) {
          parents = [];
        }

        _this = _EventsClass.call(this, parents) || this;

        var self = _assertThisInitialized$x(_this);

        self.params = params;

        if (self.params && self.params.on) {
          Object.keys(self.params.on).forEach(function (eventName) {
            self.on(eventName, self.params.on[eventName]);
          });
        }

        return _this;
      } // eslint-disable-next-line


      var _proto = Framework7Class.prototype;

      _proto.useModuleParams = function useModuleParams(module, instanceParams) {
        if (module.params) {
          var originalParams = {};
          Object.keys(module.params).forEach(function (paramKey) {
            if (typeof instanceParams[paramKey] === 'undefined') return;
            originalParams[paramKey] = extend$2({}, instanceParams[paramKey]);
          });
          extend$2(instanceParams, module.params);
          Object.keys(originalParams).forEach(function (paramKey) {
            extend$2(instanceParams[paramKey], originalParams[paramKey]);
          });
        }
      };

      _proto.useModulesParams = function useModulesParams(instanceParams) {
        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function (moduleName) {
          var module = instance.modules[moduleName]; // Extend params

          if (module.params) {
            extend$2(instanceParams, module.params);
          }
        });
      };

      _proto.useModule = function useModule(moduleName, moduleParams) {
        if (moduleName === void 0) {
          moduleName = '';
        }

        if (moduleParams === void 0) {
          moduleParams = {};
        }

        var instance = this;
        if (!instance.modules) return;
        var module = typeof moduleName === 'string' ? instance.modules[moduleName] : moduleName;
        if (!module) return; // Extend instance methods and props

        if (module.instance) {
          Object.keys(module.instance).forEach(function (modulePropName) {
            var moduleProp = module.instance[modulePropName];

            if (typeof moduleProp === 'function') {
              instance[modulePropName] = moduleProp.bind(instance);
            } else {
              instance[modulePropName] = moduleProp;
            }
          });
        } // Add event listeners


        if (module.on && instance.on) {
          Object.keys(module.on).forEach(function (moduleEventName) {
            instance.on(moduleEventName, module.on[moduleEventName]);
          });
        } // Add vnode hooks


        if (module.vnode) {
          if (!instance.vnodeHooks) instance.vnodeHooks = {};
          Object.keys(module.vnode).forEach(function (vnodeId) {
            Object.keys(module.vnode[vnodeId]).forEach(function (hookName) {
              var handler = module.vnode[vnodeId][hookName];
              if (!instance.vnodeHooks[hookName]) instance.vnodeHooks[hookName] = {};
              if (!instance.vnodeHooks[hookName][vnodeId]) instance.vnodeHooks[hookName][vnodeId] = [];
              instance.vnodeHooks[hookName][vnodeId].push(handler.bind(instance));
            });
          });
        } // Module create callback


        if (module.create) {
          module.create.bind(instance)(moduleParams);
        }
      };

      _proto.useModules = function useModules(modulesParams) {
        if (modulesParams === void 0) {
          modulesParams = {};
        }

        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function (moduleName) {
          var moduleParams = modulesParams[moduleName] || {};
          instance.useModule(moduleName, moduleParams);
        });
      };

      Framework7Class.installModule = function installModule(module) {
        var Class = this;
        if (!Class.prototype.modules) Class.prototype.modules = {};
        var name = module.name || Object.keys(Class.prototype.modules).length + "_" + now$2();
        Class.prototype.modules[name] = module; // Prototype

        if (module.proto) {
          Object.keys(module.proto).forEach(function (key) {
            Class.prototype[key] = module.proto[key];
          });
        } // Class


        if (module.static) {
          Object.keys(module.static).forEach(function (key) {
            Class[key] = module.static[key];
          });
        } // Callback


        if (module.install) {
          for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            params[_key - 1] = arguments[_key];
          }

          module.install.apply(Class, params);
        }

        return Class;
      };

      Framework7Class.use = function use(module) {
        var Class = this;

        if (Array.isArray(module)) {
          module.forEach(function (m) {
            return Class.installModule(m);
          });
          return Class;
        }

        for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          params[_key2 - 1] = arguments[_key2];
        }

        return Class.installModule.apply(Class, [module].concat(params));
      };

      _createClass$8(Framework7Class, null, [{
        key: "components",
        set: function set(components) {
          var Class = this;
          if (!Class.use) return;
          Class.use(components);
        }
      }]);

      return Framework7Class;
    }(EventsClass$1);

    var Framework7Class$1 = Framework7Class;

    function _construct$2(Parent, args, Class) { if (_isNativeReflectConstruct$2()) { _construct$2 = Reflect.construct; } else { _construct$2 = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf$y(instance, Class.prototype); return instance; }; } return _construct$2.apply(null, arguments); }

    function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

    function _setPrototypeOf$y(o, p) { _setPrototypeOf$y = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$y(o, p); }
    function ConstructorMethods(parameters) {
      if (parameters === void 0) {
        parameters = {};
      }

      var _parameters = parameters,
          defaultSelector = _parameters.defaultSelector,
          Constructor = _parameters.constructor,
          domProp = _parameters.domProp,
          app = _parameters.app,
          addMethods = _parameters.addMethods;
      var methods = {
        create: function create() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (app) return _construct$2(Constructor, [app].concat(args));
          return _construct$2(Constructor, args);
        },
        get: function get(el) {
          if (el === void 0) {
            el = defaultSelector;
          }

          if (el instanceof Constructor) return el;
          var $el = $(el);
          if ($el.length === 0) return undefined;
          return $el[0][domProp];
        },
        destroy: function destroy(el) {
          var instance = methods.get(el);
          if (instance && instance.destroy) return instance.destroy();
          return undefined;
        }
      };

      if (addMethods && Array.isArray(addMethods)) {
        addMethods.forEach(function (methodName) {
          methods[methodName] = function (el) {
            if (el === void 0) {
              el = defaultSelector;
            }

            var instance = methods.get(el);

            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }

            if (instance && instance[methodName]) return instance[methodName].apply(instance, args);
            return undefined;
          };
        });
      }

      return methods;
    }

    function _extends$7() { _extends$7 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$7.apply(this, arguments); }
    function ModalMethods(parameters) {
      if (parameters === void 0) {
        parameters = {};
      }

      var _parameters = parameters,
          defaultSelector = _parameters.defaultSelector,
          Constructor = _parameters.constructor,
          app = _parameters.app;
      var methods = extend$2(ConstructorMethods({
        defaultSelector: defaultSelector,
        constructor: Constructor,
        app: app,
        domProp: 'f7Modal'
      }), {
        open: function open(el, animate, targetEl) {
          var $el = $(el);

          if ($el.length > 1 && targetEl) {
            // check if same modal in other page
            var $targetPage = $(targetEl).parents('.page');

            if ($targetPage.length) {
              $el.each(function (modalEl) {
                var $modalEl = $(modalEl);

                if ($modalEl.parents($targetPage)[0] === $targetPage[0]) {
                  $el = $modalEl;
                }
              });
            }
          }

          if ($el.length > 1) {
            $el = $el.eq($el.length - 1);
          }

          if (!$el.length) return undefined;
          var instance = $el[0].f7Modal;

          if (!instance) {
            var params = $el.dataset();
            instance = new Constructor(app, _extends$7({
              el: $el
            }, params));
          }

          return instance.open(animate);
        },
        close: function close(el, animate, targetEl) {
          if (el === void 0) {
            el = defaultSelector;
          }

          var $el = $(el);
          if (!$el.length) return undefined;

          if ($el.length > 1) {
            // check if close link (targetEl) in this modal
            var $parentEl;

            if (targetEl) {
              var $targetEl = $(targetEl);

              if ($targetEl.length) {
                $parentEl = $targetEl.parents($el);
              }
            }

            if ($parentEl && $parentEl.length > 0) {
              $el = $parentEl;
            } else {
              $el = $el.eq($el.length - 1);
            }
          }

          var instance = $el[0].f7Modal;

          if (!instance) {
            var params = $el.dataset();
            instance = new Constructor(app, _extends$7({
              el: $el
            }, params));
          }

          return instance.close(animate);
        }
      });
      return methods;
    }

    var fetchedModules = [];

    function loadModule(moduleToLoad) {
      var Framework7 = this;
      var window = getWindow();
      var document = getDocument();
      return new Promise(function (resolve, reject) {
        var app = Framework7.instance;
        var modulePath;
        var moduleObj;
        var moduleFunc;

        if (!moduleToLoad) {
          reject(new Error('Framework7: Lazy module must be specified'));
          return;
        }

        function install(module) {
          Framework7.use(module);

          if (app) {
            app.useModuleParams(module, app.params);
            app.useModule(module);
          }
        }

        if (typeof moduleToLoad === 'string') {
          var matchNamePattern = moduleToLoad.match(/([a-z0-9-]*)/i);

          if (moduleToLoad.indexOf('.') < 0 && matchNamePattern && matchNamePattern[0].length === moduleToLoad.length) {
            if (!app || app && !app.params.lazyModulesPath) {
              reject(new Error('Framework7: "lazyModulesPath" app parameter must be specified to fetch module by name'));
              return;
            }

            modulePath = app.params.lazyModulesPath + "/" + moduleToLoad + "/" + moduleToLoad + ".js";
          } else {
            modulePath = moduleToLoad;
          }
        } else if (typeof moduleToLoad === 'function') {
          moduleFunc = moduleToLoad;
        } else {
          // considering F7-Plugin object
          moduleObj = moduleToLoad;
        }

        if (moduleFunc) {
          var module = moduleFunc(Framework7, false);

          if (!module) {
            reject(new Error("Framework7: Can't find Framework7 component in specified component function"));
            return;
          } // Check if it was added


          if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
            resolve();
            return;
          } // Install It


          install(module);
          resolve();
        }

        if (moduleObj) {
          var _module = moduleObj;

          if (!_module) {
            reject(new Error("Framework7: Can't find Framework7 component in specified component"));
            return;
          } // Check if it was added


          if (Framework7.prototype.modules && Framework7.prototype.modules[_module.name]) {
            resolve();
            return;
          } // Install It


          install(_module);
          resolve();
        }

        if (modulePath) {
          if (fetchedModules.indexOf(modulePath) >= 0) {
            resolve();
            return;
          }

          fetchedModules.push(modulePath);
          var scriptLoad = new Promise(function (resolveScript, rejectScript) {
            Framework7.request.get(modulePath, function (scriptContent) {
              var callbackId = id();
              var callbackLoadName = "f7_component_loader_callback_" + callbackId;
              var scriptEl = document.createElement('script');
              scriptEl.innerHTML = "window." + callbackLoadName + " = function (Framework7, Framework7AutoInstallComponent) {return " + scriptContent.trim() + "}";
              $('head').append(scriptEl);
              var componentLoader = window[callbackLoadName];
              delete window[callbackLoadName];
              $(scriptEl).remove();
              var module = componentLoader(Framework7, false);

              if (!module) {
                rejectScript(new Error("Framework7: Can't find Framework7 component in " + modulePath + " file"));
                return;
              } // Check if it was added


              if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
                resolveScript();
                return;
              } // Install It


              install(module);
              resolveScript();
            }, function (xhr, status) {
              rejectScript(xhr, status);
            });
          });
          var styleLoad = new Promise(function (resolveStyle) {
            Framework7.request.get(modulePath.replace('.js', app.rtl ? '.rtl.css' : '.css'), function (styleContent) {
              var styleEl = document.createElement('style');
              styleEl.innerHTML = styleContent;
              $('head').append(styleEl);
              resolveStyle();
            }, function () {
              resolveStyle();
            });
          });
          Promise.all([scriptLoad, styleLoad]).then(function () {
            resolve();
          }).catch(function (err) {
            reject(err);
          });
        }
      });
    }

    function _defineProperties$7(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass$7(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$7(Constructor.prototype, protoProps); if (staticProps) _defineProperties$7(Constructor, staticProps); return Constructor; }

    function _assertThisInitialized$w(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$w(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$x(subClass, superClass); }

    function _setPrototypeOf$x(o, p) { _setPrototypeOf$x = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$x(o, p); }

    var Framework7 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$w(Framework7, _Framework7Class);

      function Framework7(params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params) || this; // eslint-disable-next-line

        if (Framework7.instance && typeof window !== 'undefined') {
          throw new Error("Framework7 is already initialized and can't be initialized more than once");
        }

        var device = getDevice$1({
          userAgent: params.userAgent || undefined
        });
        var support = getSupport$1();
        var passedParams = extend$2({}, params); // App Instance

        var app = _assertThisInitialized$w(_this);

        app.device = device;
        app.support = support;
        var w = getWindow();
        var d = getDocument();
        Framework7.instance = app; // Default

        var defaults = {
          version: '1.0.0',
          id: 'io.framework7.myapp',
          el: 'body',
          theme: 'auto',
          language: w.navigator.language,
          routes: [],
          name: 'Framework7',
          lazyModulesPath: null,
          initOnDeviceReady: true,
          init: true,
          autoDarkTheme: false,
          iosTranslucentBars: true,
          iosTranslucentModals: true,
          component: undefined,
          componentUrl: undefined,
          userAgent: null,
          url: null
        }; // Extend defaults with modules params

        app.useModulesParams(defaults); // Extend defaults with passed params

        app.params = extend$2(defaults, params);
        extend$2(app, {
          // App Id
          id: app.params.id,
          // App Name
          name: app.params.name,
          // App version
          version: app.params.version,
          // Routes
          routes: app.params.routes,
          // Lang
          language: app.params.language,
          // Theme
          theme: function getTheme() {
            if (app.params.theme === 'auto') {
              if (device.ios) return 'ios';
              if (device.desktop && device.electron) return 'aurora';
              return 'md';
            }

            return app.params.theme;
          }(),
          // Initially passed parameters
          passedParams: passedParams,
          online: w.navigator.onLine
        });
        if (params.store) app.params.store = params.store; // Save Root

        if (app.$el && app.$el[0]) {
          app.$el[0].f7 = app;
        } // Install Modules


        app.useModules(); // Init Store

        app.initStore(); // Init

        if (app.params.init) {
          if (device.cordova && app.params.initOnDeviceReady) {
            $(d).on('deviceready', function () {
              app.init();
            });
          } else {
            app.init();
          }
        } // Return app instance


        return app || _assertThisInitialized$w(_this);
      }

      var _proto = Framework7.prototype;

      _proto.mount = function mount(rootEl) {
        var app = this;
        var window = getWindow();
        var document = getDocument();
        var $rootEl = $(rootEl || app.params.el).eq(0);
        app.$el = $rootEl;

        if (app.$el && app.$el[0]) {
          app.el = app.$el[0];
          app.el.f7 = app;
          app.rtl = $rootEl.css('direction') === 'rtl';
        } // Auto Dark Theme


        var DARK = '(prefers-color-scheme: dark)';
        var LIGHT = '(prefers-color-scheme: light)';
        app.mq = {};

        if (window.matchMedia) {
          app.mq.dark = window.matchMedia(DARK);
          app.mq.light = window.matchMedia(LIGHT);
        }

        app.colorSchemeListener = function colorSchemeListener(_ref) {
          var matches = _ref.matches,
              media = _ref.media;

          if (!matches) {
            return;
          }

          var html = document.querySelector('html');

          if (media === DARK) {
            html.classList.add('theme-dark');
            app.darkTheme = true;
            app.emit('darkThemeChange', true);
          } else if (media === LIGHT) {
            html.classList.remove('theme-dark');
            app.darkTheme = false;
            app.emit('darkThemeChange', false);
          }
        };

        app.emit('mount');
      };

      _proto.initStore = function initStore() {
        var app = this;

        if (typeof app.params.store !== 'undefined' && app.params.store.__store) {
          app.store = app.params.store;
        } else {
          app.store = app.createStore(app.params.store);
        }
      };

      _proto.enableAutoDarkTheme = function enableAutoDarkTheme() {
        var window = getWindow();
        var document = getDocument();
        if (!window.matchMedia) return;
        var app = this;
        var html = document.querySelector('html');

        if (app.mq.dark && app.mq.light) {
          app.mq.dark.addListener(app.colorSchemeListener);
          app.mq.light.addListener(app.colorSchemeListener);
        }

        if (app.mq.dark && app.mq.dark.matches) {
          html.classList.add('theme-dark');
          app.darkTheme = true;
          app.emit('darkThemeChange', true);
        } else if (app.mq.light && app.mq.light.matches) {
          html.classList.remove('theme-dark');
          app.darkTheme = false;
          app.emit('darkThemeChange', false);
        }
      };

      _proto.disableAutoDarkTheme = function disableAutoDarkTheme() {
        var window = getWindow();
        if (!window.matchMedia) return;
        var app = this;
        if (app.mq.dark) app.mq.dark.removeListener(app.colorSchemeListener);
        if (app.mq.light) app.mq.light.removeListener(app.colorSchemeListener);
      };

      _proto.initAppComponent = function initAppComponent(callback) {
        var app = this;
        app.router.componentLoader(app.params.component, app.params.componentUrl, {
          componentOptions: {
            el: app.$el[0]
          }
        }, function (el) {
          app.$el = $(el);
          app.$el[0].f7 = app;
          app.$elComponent = el.f7Component;
          app.el = app.$el[0];
          if (callback) callback();
        }, function () {});
      };

      _proto.init = function init(rootEl) {
        var app = this;
        app.mount(rootEl);

        var init = function init() {
          if (app.initialized) return;
          app.$el.addClass('framework7-initializing'); // RTL attr

          if (app.rtl) {
            $('html').attr('dir', 'rtl');
          } // Auto Dark Theme


          if (app.params.autoDarkTheme) {
            app.enableAutoDarkTheme();
          } // Watch for online/offline state


          var window = getWindow();
          window.addEventListener('offline', function () {
            app.online = false;
            app.emit('offline');
            app.emit('connection', false);
          });
          window.addEventListener('online', function () {
            app.online = true;
            app.emit('online');
            app.emit('connection', true);
          }); // Root class

          app.$el.addClass('framework7-root'); // Theme class

          $('html').removeClass('ios md aurora').addClass(app.theme); // iOS Translucent

          var device = app.device;

          if (app.params.iosTranslucentBars && app.theme === 'ios' && device.ios) {
            $('html').addClass('ios-translucent-bars');
          }

          if (app.params.iosTranslucentModals && app.theme === 'ios' && device.ios) {
            $('html').addClass('ios-translucent-modals');
          } // Init class


          nextFrame(function () {
            app.$el.removeClass('framework7-initializing');
          }); // Emit, init other modules

          app.initialized = true;
          app.emit('init');
        };

        if (app.params.component || app.params.componentUrl) {
          app.initAppComponent(function () {
            init();
          });
        } else {
          init();
        }

        return app;
      } // eslint-disable-next-line
      ;

      _proto.loadModule = function loadModule() {
        return Framework7.loadModule.apply(Framework7, arguments);
      } // eslint-disable-next-line
      ;

      _proto.loadModules = function loadModules() {
        return Framework7.loadModules.apply(Framework7, arguments);
      };

      _proto.getVnodeHooks = function getVnodeHooks(hook, id) {
        var app = this;
        if (!app.vnodeHooks || !app.vnodeHooks[hook]) return [];
        return app.vnodeHooks[hook][id] || [];
      } // eslint-disable-next-line
      ;

      _createClass$7(Framework7, [{
        key: "$",
        get: function get() {
          return $;
        }
      }], [{
        key: "Dom7",
        get: function get() {
          return $;
        }
      }, {
        key: "$",
        get: function get() {
          return $;
        }
      }, {
        key: "device",
        get: function get() {
          return getDevice$1();
        }
      }, {
        key: "support",
        get: function get() {
          return getSupport$1();
        }
      }, {
        key: "Class",
        get: function get() {
          return Framework7Class$1;
        }
      }, {
        key: "Events",
        get: function get() {
          return EventsClass$1;
        }
      }]);

      return Framework7;
    }(Framework7Class$1);

    Framework7.ModalMethods = ModalMethods;
    Framework7.ConstructorMethods = ConstructorMethods;
    Framework7.loadModule = loadModule;

    Framework7.loadModules = function loadModules(modules) {
      return Promise.all(modules.map(function (module) {
        return Framework7.loadModule(module);
      }));
    };

    var Framework7$1 = Framework7;

    function _assertThisInitialized$v(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$v(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$w(subClass, superClass); }

    function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct$1(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf$w(Wrapper, Class); }; return _wrapNativeSuper(Class); }

    function _construct$1(Parent, args, Class) { if (_isNativeReflectConstruct$1()) { _construct$1 = Reflect.construct; } else { _construct$1 = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf$w(instance, Class.prototype); return instance; }; } return _construct$1.apply(null, arguments); }

    function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

    function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

    function _setPrototypeOf$w(o, p) { _setPrototypeOf$w = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$w(o, p); }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
    var globals$1 = {};
    var jsonpRequests = 0;

    var RequestResponse = function RequestResponse(obj) {
      Object.assign(this, obj);
    };

    var RequestError = /*#__PURE__*/function (_Error) {
      _inheritsLoose$v(RequestError, _Error);

      function RequestError(obj) {
        var _this;

        _this = _Error.call(this) || this;
        Object.assign(_assertThisInitialized$v(_this), obj);
        return _this;
      }

      return RequestError;
    }( /*#__PURE__*/_wrapNativeSuper(Error));

    var request = function request(requestOptions) {
      return new Promise(function (resolve, reject) {
        var window = getWindow();
        var document = getDocument();
        var globalsNoCallbacks = extend$2({}, globals$1);
        'beforeCreate beforeOpen beforeSend error complete success statusCode'.split(' ').forEach(function (callbackName) {
          delete globalsNoCallbacks[callbackName];
        });
        var defaults = extend$2({
          url: window.location.toString(),
          method: 'GET',
          data: false,
          async: true,
          cache: true,
          user: '',
          password: '',
          headers: {},
          xhrFields: {},
          statusCode: {},
          processData: true,
          dataType: 'text',
          contentType: 'application/x-www-form-urlencoded',
          timeout: 0
        }, globalsNoCallbacks);
        var proceedRequest;
        var options = extend$2({}, defaults, requestOptions);

        if (requestOptions.abortController) {
          options.abortController = requestOptions.abortController;
        }

        if (options.abortController && options.abortController.canceled) {
          reject(new RequestError({
            options: options,
            status: 'canceled',
            message: 'canceled'
          }));
          return;
        } // Function to run XHR callbacks and events


        function fireCallback(callbackName) {
          /*
          Callbacks:
          beforeCreate (options),
          beforeOpen (xhr, options),
          beforeSend (xhr, options),
          error (xhr, status, message),
          complete (xhr, status),
          success (response, status, xhr),
          statusCode ()
          */
          var globalCallbackValue;
          var optionCallbackValue;

          for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            data[_key - 1] = arguments[_key];
          }

          if (globals$1[callbackName]) {
            globalCallbackValue = globals$1[callbackName].apply(globals$1, data);
          }

          if (options[callbackName]) {
            optionCallbackValue = options[callbackName].apply(options, data);
          }

          if (typeof globalCallbackValue !== 'boolean') globalCallbackValue = true;
          if (typeof optionCallbackValue !== 'boolean') optionCallbackValue = true;

          if (options.abortController && options.abortController.canceled && (callbackName === 'beforeCreate' || callbackName === 'beforeOpen' || callbackName === 'beforeSend')) {
            return false;
          }

          return globalCallbackValue && optionCallbackValue;
        } // Before create callback


        proceedRequest = fireCallback('beforeCreate', options);

        if (proceedRequest === false) {
          reject(new RequestError({
            options: options,
            status: 'canceled',
            message: 'canceled'
          }));
          return;
        } // For jQuery guys


        if (options.type) options.method = options.type; // Parameters Prefix

        var paramsPrefix = options.url.indexOf('?') >= 0 ? '&' : '?'; // UC method

        var method = options.method.toUpperCase(); // Data to modify GET URL

        if ((method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') && options.data) {
          var stringData;

          if (typeof options.data === 'string') {
            // Should be key=value string
            if (options.data.indexOf('?') >= 0) stringData = options.data.split('?')[1];else stringData = options.data;
          } else {
            // Should be key=value object
            stringData = serializeObject(options.data);
          }

          if (stringData.length) {
            options.url += paramsPrefix + stringData;
            if (paramsPrefix === '?') paramsPrefix = '&';
          }
        } // JSONP


        if (options.dataType === 'json' && options.url.indexOf('callback=') >= 0) {
          var callbackName = "f7jsonp_" + (Date.now() + (jsonpRequests += 1));
          var abortTimeout;
          var callbackSplit = options.url.split('callback=');
          var requestUrl = callbackSplit[0] + "callback=" + callbackName;

          if (callbackSplit[1].indexOf('&') >= 0) {
            var addVars = callbackSplit[1].split('&').filter(function (el) {
              return el.indexOf('=') > 0;
            }).join('&');
            if (addVars.length > 0) requestUrl += "&" + addVars;
          } // Create script


          var script = document.createElement('script');
          script.type = 'text/javascript';

          script.onerror = function onerror() {
            clearTimeout(abortTimeout);
            fireCallback('error', null, 'scripterror', 'scripterror');
            reject(new RequestError({
              options: options,
              status: 'scripterror',
              message: 'scripterror'
            }));
            fireCallback('complete', null, 'scripterror');
          };

          script.src = requestUrl; // Handler

          window[callbackName] = function jsonpCallback(data) {
            clearTimeout(abortTimeout);
            fireCallback('success', data);
            script.parentNode.removeChild(script);
            script = null;
            delete window[callbackName];
            resolve(new RequestResponse({
              options: options,
              data: data
            }));
          };

          document.querySelector('head').appendChild(script);

          if (options.timeout > 0) {
            abortTimeout = setTimeout(function () {
              script.parentNode.removeChild(script);
              script = null;
              fireCallback('error', null, 'timeout', 'timeout');
              reject(new RequestError({
                options: options,
                status: 'timeout',
                message: 'timeout'
              }));
            }, options.timeout);
          }

          return;
        } // Cache for GET/HEAD requests


        if (method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') {
          if (options.cache === false) {
            options.url += paramsPrefix + "_nocache" + Date.now();
          }
        } // Create XHR


        var xhr = new XMLHttpRequest();

        if (options.abortController) {
          var aborted = false;

          options.abortController.onAbort = function () {
            if (aborted) return;
            aborted = true;
            xhr.abort();
            reject(new RequestError({
              options: options,
              xhr: xhr,
              status: 'canceled',
              message: 'canceled'
            }));
          };
        } // Save Request URL


        xhr.requestUrl = options.url;
        xhr.requestParameters = options; // Before open callback

        proceedRequest = fireCallback('beforeOpen', xhr, options);

        if (proceedRequest === false) {
          reject(new RequestError({
            options: options,
            xhr: xhr,
            status: 'canceled',
            message: 'canceled'
          }));
          return;
        } // Open XHR


        xhr.open(method, options.url, options.async, options.user, options.password); // Create POST Data

        var postData = null;

        if ((method === 'POST' || method === 'PUT' || method === 'PATCH') && options.data) {
          if (options.processData) {
            var postDataInstances = [ArrayBuffer, Blob, Document, FormData]; // Post Data

            if (postDataInstances.indexOf(options.data.constructor) >= 0) {
              postData = options.data;
            } else {
              // POST Headers
              var boundary = "---------------------------" + Date.now().toString(16);

              if (options.contentType === 'multipart/form-data') {
                xhr.setRequestHeader('Content-Type', "multipart/form-data; boundary=" + boundary);
              } else {
                xhr.setRequestHeader('Content-Type', options.contentType);
              }

              postData = '';
              var data = serializeObject(options.data);

              if (options.contentType === 'multipart/form-data') {
                data = data.split('&');
                var newData = [];

                for (var i = 0; i < data.length; i += 1) {
                  newData.push("Content-Disposition: form-data; name=\"" + data[i].split('=')[0] + "\"\r\n\r\n" + data[i].split('=')[1] + "\r\n");
                }

                postData = "--" + boundary + "\r\n" + newData.join("--" + boundary + "\r\n") + "--" + boundary + "--\r\n";
              } else if (options.contentType === 'application/json') {
                postData = JSON.stringify(options.data);
              } else {
                postData = data;
              }
            }
          } else {
            postData = options.data;
            xhr.setRequestHeader('Content-Type', options.contentType);
          }
        }

        if (options.dataType === 'json' && (!options.headers || !options.headers.Accept)) {
          xhr.setRequestHeader('Accept', 'application/json');
        } // Additional headers


        if (options.headers) {
          Object.keys(options.headers).forEach(function (headerName) {
            if (typeof options.headers[headerName] === 'undefined') return;
            xhr.setRequestHeader(headerName, options.headers[headerName]);
          });
        } // Check for crossDomain


        if (typeof options.crossDomain === 'undefined') {
          options.crossDomain = // eslint-disable-next-line
          /^([\w-]+:)?\/\/([^\/]+)/.test(options.url) && RegExp.$2 !== window.location.host;
        }

        if (!options.crossDomain) {
          xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
        }

        if (options.xhrFields) {
          extend$2(xhr, options.xhrFields);
        } // Handle XHR


        xhr.onload = function onload() {
          if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) {
            var responseData;

            if (options.dataType === 'json') {
              var parseError;

              try {
                responseData = JSON.parse(xhr.responseText);
              } catch (err) {
                parseError = true;
              }

              if (!parseError) {
                fireCallback('success', responseData, xhr.status, xhr);
                resolve(new RequestResponse({
                  options: options,
                  data: responseData,
                  status: xhr.status,
                  xhr: xhr
                }));
              } else {
                fireCallback('error', xhr, 'parseerror', 'parseerror');
                reject(new RequestError({
                  options: options,
                  xhr: xhr,
                  status: 'parseerror',
                  message: 'parseerror'
                }));
              }
            } else {
              responseData = xhr.responseType === 'text' || xhr.responseType === '' ? xhr.responseText : xhr.response;
              fireCallback('success', responseData, xhr.status, xhr);
              resolve(new RequestResponse({
                options: options,
                data: responseData,
                status: xhr.status,
                xhr: xhr
              }));
            }
          } else {
            fireCallback('error', xhr, xhr.status, xhr.statusText);
            reject(new RequestError({
              options: options,
              xhr: xhr,
              status: xhr.status,
              message: xhr.statusText
            }));
          }

          if (options.statusCode) {
            if (globals$1.statusCode && globals$1.statusCode[xhr.status]) globals$1.statusCode[xhr.status](xhr);
            if (options.statusCode[xhr.status]) options.statusCode[xhr.status](xhr);
          }

          fireCallback('complete', xhr, xhr.status);
        };

        xhr.onerror = function onerror() {
          fireCallback('error', xhr, xhr.status, xhr.status);
          reject(new RequestError({
            options: options,
            xhr: xhr,
            status: xhr.status,
            message: xhr.statusText
          }));
          fireCallback('complete', xhr, 'error');
        }; // Timeout


        if (options.timeout > 0) {
          xhr.timeout = options.timeout;

          xhr.ontimeout = function () {
            fireCallback('error', xhr, 'timeout', 'timeout');
            reject(new RequestError({
              options: options,
              xhr: xhr,
              status: 'timeout',
              message: 'timeout'
            }));
            fireCallback('complete', xhr, 'timeout');
          };
        } // Ajax start callback


        proceedRequest = fireCallback('beforeSend', xhr, options);

        if (proceedRequest === false) {
          reject(new RequestError({
            options: options,
            xhr: xhr,
            status: 'canceled',
            message: 'canceled'
          }));
          return;
        } // Send XHR


        xhr.send(postData);
      });
    };

    function requestShortcut(method) {
      var _ref = [],
          url = _ref[0],
          data = _ref[1],
          success = _ref[2],
          error = _ref[3],
          dataType = _ref[4];

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      if (typeof args[1] === 'function') {
        url = args[0];
        success = args[1];
        error = args[2];
        dataType = args[3];
      } else {
        url = args[0];
        data = args[1];
        success = args[2];
        error = args[3];
        dataType = args[4];
      }

      [success, error].forEach(function (callback) {
        if (typeof callback === 'string') {
          dataType = callback;
          if (callback === success) success = undefined;else error = undefined;
        }
      });
      dataType = dataType || (method === 'json' || method === 'postJSON' ? 'json' : undefined);
      var requestOptions = {
        url: url,
        method: method === 'post' || method === 'postJSON' ? 'POST' : 'GET',
        data: data,
        success: success,
        error: error,
        dataType: dataType
      };

      if (method === 'postJSON') {
        extend$2(requestOptions, {
          contentType: 'application/json',
          processData: false,
          crossDomain: true,
          data: typeof data === 'string' ? data : JSON.stringify(data)
        });
      }

      return request(requestOptions);
    }

    Object.assign(request, {
      get: function get() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return requestShortcut.apply(void 0, ['get'].concat(args));
      },
      post: function post() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return requestShortcut.apply(void 0, ['post'].concat(args));
      },
      json: function json() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        return requestShortcut.apply(void 0, ['json'].concat(args));
      },
      getJSON: function getJSON() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }

        return requestShortcut.apply(void 0, ['json'].concat(args));
      },
      postJSON: function postJSON() {
        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          args[_key7] = arguments[_key7];
        }

        return requestShortcut.apply(void 0, ['postJSON'].concat(args));
      }
    });

    request.abortController = function () {
      var contoller = {
        canceled: false,
        onAbort: null,
        abort: function abort() {
          contoller.canceled = true;
          if (contoller.onAbort) contoller.onAbort();
        }
      };
      return contoller;
    };

    request.setup = function setup(options) {
      if (options.type && !options.method) {
        extend$2(options, {
          method: options.type
        });
      }

      extend$2(globals$1, options);
    };

    var request$1 = request;

    var DeviceModule = {
      name: 'device',
      static: {
        getDevice: getDevice$1
      },
      on: {
        init: function init() {
          var document = getDocument();
          var device = getDevice$1();
          var classNames = [];
          var html = document.querySelector('html');
          var metaStatusbar = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
          if (!html) return;

          if (device.standalone && device.ios && metaStatusbar && metaStatusbar.content === 'black-translucent') {
            classNames.push('device-full-viewport');
          } // Pixel Ratio


          classNames.push("device-pixel-ratio-" + Math.floor(device.pixelRatio)); // OS classes

          if (device.os && !device.desktop) {
            classNames.push("device-" + device.os);
          } else if (device.desktop) {
            classNames.push('device-desktop');

            if (device.os) {
              classNames.push("device-" + device.os);
            }
          }

          if (device.cordova || device.phonegap) {
            classNames.push('device-cordova');
          }

          if (device.capacitor) {
            classNames.push('device-capacitor');
          } // Add html classes


          classNames.forEach(function (className) {
            html.classList.add(className);
          });
        }
      }
    };

    var SupportModule = {
      name: 'support',
      static: {
        getSupport: getSupport$1
      }
    };

    var UtilsModule = {
      name: 'utils',
      proto: {
        utils: utils
      },
      static: {
        utils: utils
      }
    };

    var ResizeModule = {
      name: 'resize',
      create: function create() {
        var app = this;

        app.getSize = function () {
          if (!app.el) return {
            width: 0,
            height: 0,
            left: 0,
            top: 0
          };
          var offset = app.$el.offset();
          var _ref = [app.el.offsetWidth, app.el.offsetHeight, offset.left, offset.top],
              width = _ref[0],
              height = _ref[1],
              left = _ref[2],
              top = _ref[3];
          app.width = width;
          app.height = height;
          app.left = left;
          app.top = top;
          return {
            width: width,
            height: height,
            left: left,
            top: top
          };
        };
      },
      on: {
        init: function init() {
          var app = this;
          var window = getWindow(); // Get Size

          app.getSize(); // Emit resize

          window.addEventListener('resize', function () {
            app.emit('resize');
          }, false); // Emit orientationchange

          window.addEventListener('orientationchange', function () {
            app.emit('orientationchange');
          });
        },
        orientationchange: function orientationchange() {
          var document = getDocument();
          var device = getDevice$1(); // Fix iPad weird body scroll

          if (device.ipad) {
            document.body.scrollLeft = 0;
            setTimeout(function () {
              document.body.scrollLeft = 0;
            }, 0);
          }
        },
        resize: function resize() {
          var app = this;
          app.getSize();
        }
      }
    };

    /* eslint no-param-reassign: "off" */
    var RequestModule = {
      name: 'request',
      proto: {
        request: request$1
      },
      static: {
        request: request$1
      }
    };

    /* eslint-disable no-nested-ternary */

    function initTouch() {
      var app = this;
      var device = getDevice$1();
      var support = getSupport$1();
      var window = getWindow();
      var document = getDocument();
      var params = app.params.touch;
      var useRipple = params[app.theme + "TouchRipple"];

      if (device.ios && device.webView) {
        // Strange hack required for iOS 8 webview to work on inputs
        window.addEventListener('touchstart', function () {});
      }

      var touchStartX;
      var touchStartY;
      var targetElement;
      var isMoved;
      var tapHoldFired;
      var tapHoldTimeout;
      var preventClick;
      var activableElement;
      var activeTimeout;
      var rippleWave;
      var rippleTarget;
      var rippleTimeout;

      function findActivableElement(el) {
        var target = $(el);
        var parents = target.parents(params.activeStateElements);

        if (target.closest('.no-active-state').length) {
          return null;
        }

        var activable;

        if (target.is(params.activeStateElements)) {
          activable = target;
        }

        if (parents.length > 0) {
          activable = activable ? activable.add(parents) : parents;
        }

        if (activable && activable.length > 1) {
          var newActivable = [];
          var preventPropagation;

          for (var i = 0; i < activable.length; i += 1) {
            if (!preventPropagation) {
              newActivable.push(activable[i]);

              if (activable.eq(i).hasClass('prevent-active-state-propagation') || activable.eq(i).hasClass('no-active-state-propagation')) {
                preventPropagation = true;
              }
            }
          }

          activable = $(newActivable);
        }

        return activable || target;
      }

      function isInsideScrollableView(el) {
        var pageContent = el.parents('.page-content');
        return pageContent.length > 0;
      }

      function addActive() {
        if (!activableElement) return;
        activableElement.addClass('active-state');
      }

      function removeActive() {
        if (!activableElement) return;
        activableElement.removeClass('active-state');
        activableElement = null;
      } // Ripple handlers


      function findRippleElement(el) {
        var rippleElements = params.touchRippleElements;
        var $el = $(el);

        if ($el.is(rippleElements)) {
          if ($el.hasClass('no-ripple')) {
            return false;
          }

          return $el;
        }

        if ($el.parents(rippleElements).length > 0) {
          var rippleParent = $el.parents(rippleElements).eq(0);

          if (rippleParent.hasClass('no-ripple')) {
            return false;
          }

          return rippleParent;
        }

        return false;
      }

      function createRipple($el, x, y) {
        if (!$el) return;
        rippleWave = app.touchRipple.create(app, $el, x, y);
      }

      function removeRipple() {
        if (!rippleWave) return;
        rippleWave.remove();
        rippleWave = undefined;
        rippleTarget = undefined;
      }

      function rippleTouchStart(el) {
        rippleTarget = findRippleElement(el);

        if (!rippleTarget || rippleTarget.length === 0) {
          rippleTarget = undefined;
          return;
        }

        var inScrollable = isInsideScrollableView(rippleTarget);

        if (!inScrollable) {
          removeRipple();
          createRipple(rippleTarget, touchStartX, touchStartY);
        } else {
          clearTimeout(rippleTimeout);
          rippleTimeout = setTimeout(function () {
            removeRipple();
            createRipple(rippleTarget, touchStartX, touchStartY);
          }, 80);
        }
      }

      function rippleTouchMove() {
        clearTimeout(rippleTimeout);
        removeRipple();
      }

      function rippleTouchEnd() {
        if (!rippleWave && rippleTarget && !isMoved) {
          clearTimeout(rippleTimeout);
          createRipple(rippleTarget, touchStartX, touchStartY);
          setTimeout(removeRipple, 0);
        } else {
          removeRipple();
        }
      } // Mouse Handlers


      function handleMouseDown(e) {
        var $activableEl = findActivableElement(e.target);

        if ($activableEl) {
          $activableEl.addClass('active-state');

          if ('which' in e && e.which === 3) {
            setTimeout(function () {
              $('.active-state').removeClass('active-state');
            }, 0);
          }
        }

        if (useRipple) {
          touchStartX = e.pageX;
          touchStartY = e.pageY;
          rippleTouchStart(e.target, e.pageX, e.pageY);
        }
      }

      function handleMouseMove() {
        if (!params.activeStateOnMouseMove) {
          $('.active-state').removeClass('active-state');
        }

        if (useRipple) {
          rippleTouchMove();
        }
      }

      function handleMouseUp() {
        $('.active-state').removeClass('active-state');

        if (useRipple) {
          rippleTouchEnd();
        }
      }

      function handleTouchCancel() {
        targetElement = null; // Remove Active State

        clearTimeout(activeTimeout);
        clearTimeout(tapHoldTimeout);

        if (params.activeState) {
          removeActive();
        } // Remove Ripple


        if (useRipple) {
          rippleTouchEnd();
        }
      }

      var isScrolling;
      var isSegmentedStrong = false;
      var segmentedStrongEl = null;
      var touchMoveActivableIos = '.dialog-button, .actions-button';
      var isTouchMoveActivable = false;
      var touchmoveActivableEl = null;

      function handleTouchStart(e) {
        isMoved = false;
        tapHoldFired = false;
        preventClick = false;
        isScrolling = undefined;

        if (e.targetTouches.length > 1) {
          if (activableElement) removeActive();
          return true;
        }

        if (e.touches.length > 1 && activableElement) {
          removeActive();
        }

        if (params.tapHold) {
          if (tapHoldTimeout) clearTimeout(tapHoldTimeout);
          tapHoldTimeout = setTimeout(function () {
            if (e && e.touches && e.touches.length > 1) return;
            tapHoldFired = true;
            e.preventDefault();
            preventClick = true;
            $(e.target).trigger('taphold', e);
            app.emit('taphold', e);
          }, params.tapHoldDelay);
        }

        targetElement = e.target;
        touchStartX = e.targetTouches[0].pageX;
        touchStartY = e.targetTouches[0].pageY;
        isSegmentedStrong = e.target.closest('.segmented-strong .button-active, .segmented-strong .tab-link-active');
        isTouchMoveActivable = app.theme === 'ios' && e.target.closest(touchMoveActivableIos);

        if (isSegmentedStrong) {
          segmentedStrongEl = isSegmentedStrong.closest('.segmented-strong');
        }

        if (params.activeState) {
          activableElement = findActivableElement(targetElement);

          if (activableElement && !isInsideScrollableView(activableElement)) {
            addActive();
          } else if (activableElement) {
            activeTimeout = setTimeout(addActive, 80);
          }
        }

        if (useRipple) {
          rippleTouchStart(targetElement);
        }

        return true;
      }

      function handleTouchMove(e) {
        var touch;
        var distance;
        var shouldRemoveActive = true;

        if (e.type === 'touchmove') {
          touch = e.targetTouches[0];
          distance = params.touchClicksDistanceThreshold;
        }

        var touchCurrentX = e.targetTouches[0].pageX;
        var touchCurrentY = e.targetTouches[0].pageY;

        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
        }

        if (isTouchMoveActivable || !isScrolling && isSegmentedStrong && segmentedStrongEl) {
          if (e.cancelable) e.preventDefault();
        }

        if (!isScrolling && isSegmentedStrong && segmentedStrongEl) {
          var elementFromPoint = document.elementFromPoint(e.targetTouches[0].clientX, e.targetTouches[0].clientY);
          var buttonEl = elementFromPoint.closest('.segmented-strong .button:not(.button-active):not(.tab-link-active)');

          if (buttonEl && segmentedStrongEl.contains(buttonEl)) {
            $(buttonEl).trigger('click', 'f7Segmented');
            targetElement = buttonEl;
          }
        }

        if (distance && touch) {
          var pageX = touch.pageX;
          var pageY = touch.pageY;

          if (Math.abs(pageX - touchStartX) > distance || Math.abs(pageY - touchStartY) > distance) {
            isMoved = true;
          }
        } else {
          isMoved = true;
        }

        if (isMoved) {
          preventClick = true; // Keep active state on touchMove (for dialog and actions buttons)

          if (isTouchMoveActivable) {
            var _elementFromPoint = document.elementFromPoint(e.targetTouches[0].clientX, e.targetTouches[0].clientY);

            touchmoveActivableEl = _elementFromPoint.closest(touchMoveActivableIos);

            if (touchmoveActivableEl && activableElement && activableElement[0] === touchmoveActivableEl) {
              shouldRemoveActive = false;
            } else if (touchmoveActivableEl) {
              setTimeout(function () {
                activableElement = findActivableElement(touchmoveActivableEl);
                addActive();
              });
            }
          }

          if (params.tapHold) {
            clearTimeout(tapHoldTimeout);
          }

          if (params.activeState && shouldRemoveActive) {
            clearTimeout(activeTimeout);
            removeActive();
          }

          if (useRipple) {
            rippleTouchMove();
          }
        }
      }

      function handleTouchEnd(e) {
        isScrolling = undefined;
        isSegmentedStrong = false;
        segmentedStrongEl = null;
        isTouchMoveActivable = false;
        clearTimeout(activeTimeout);
        clearTimeout(tapHoldTimeout);

        if (touchmoveActivableEl) {
          $(touchmoveActivableEl).trigger('click', 'f7TouchMoveActivable');
          touchmoveActivableEl = null;
        }

        if (document.activeElement === e.target) {
          if (params.activeState) removeActive();

          if (useRipple) {
            rippleTouchEnd();
          }

          return true;
        }

        if (params.activeState) {
          addActive();
          setTimeout(removeActive, 0);
        }

        if (useRipple) {
          rippleTouchEnd();
        }

        if (params.tapHoldPreventClicks && tapHoldFired || preventClick) {
          if (e.cancelable) e.preventDefault();
          preventClick = true;
          return false;
        }

        return true;
      }

      function handleClick(e) {
        var isOverswipe = e && e.detail && e.detail === 'f7Overswipe';
        var isSegmented = e && e.detail && e.detail === 'f7Segmented'; // eslint-disable-next-line

        var isTouchMoveActivable = e && e.detail && e.detail === 'f7TouchMoveActivable';
        var localPreventClick = preventClick;

        if (targetElement && e.target !== targetElement) {
          if (isOverswipe || isSegmented || isTouchMoveActivable) {
            localPreventClick = false;
          } else {
            localPreventClick = true;
          }
        } else if (isTouchMoveActivable) {
          localPreventClick = false;
        }

        if (params.tapHold && params.tapHoldPreventClicks && tapHoldFired) {
          localPreventClick = true;
        }

        if (localPreventClick) {
          e.stopImmediatePropagation();
          e.stopPropagation();
          e.preventDefault();
        }

        if (params.tapHold) {
          tapHoldTimeout = setTimeout(function () {
            tapHoldFired = false;
          }, device.ios || device.androidChrome ? 100 : 400);
        }

        preventClick = false;
        targetElement = null;
        return !localPreventClick;
      }

      function emitAppTouchEvent(name, e) {
        app.emit({
          events: name,
          data: [e]
        });
      }

      function appClick(e) {
        emitAppTouchEvent('click', e);
      }

      function appTouchStartActive(e) {
        emitAppTouchEvent('touchstart touchstart:active', e);
      }

      function appTouchMoveActive(e) {
        emitAppTouchEvent('touchmove touchmove:active', e);
      }

      function appTouchEndActive(e) {
        emitAppTouchEvent('touchend touchend:active', e);
      }

      function appTouchStartPassive(e) {
        emitAppTouchEvent('touchstart:passive', e);
      }

      function appTouchMovePassive(e) {
        emitAppTouchEvent('touchmove:passive', e);
      }

      function appTouchEndPassive(e) {
        emitAppTouchEvent('touchend:passive', e);
      }

      var passiveListener = support.passiveListener ? {
        passive: true
      } : false;
      var passiveListenerCapture = support.passiveListener ? {
        passive: true,
        capture: true
      } : true;
      var activeListener = support.passiveListener ? {
        passive: false
      } : false;
      var activeListenerCapture = support.passiveListener ? {
        passive: false,
        capture: true
      } : true;
      document.addEventListener('click', appClick, true);

      if (support.passiveListener) {
        document.addEventListener(app.touchEvents.start, appTouchStartActive, activeListenerCapture);
        document.addEventListener(app.touchEvents.move, appTouchMoveActive, activeListener);
        document.addEventListener(app.touchEvents.end, appTouchEndActive, activeListener);
        document.addEventListener(app.touchEvents.start, appTouchStartPassive, passiveListenerCapture);
        document.addEventListener(app.touchEvents.move, appTouchMovePassive, passiveListener);
        document.addEventListener(app.touchEvents.end, appTouchEndPassive, passiveListener);
      } else {
        document.addEventListener(app.touchEvents.start, function (e) {
          appTouchStartActive(e);
          appTouchStartPassive(e);
        }, true);
        document.addEventListener(app.touchEvents.move, function (e) {
          appTouchMoveActive(e);
          appTouchMovePassive(e);
        }, false);
        document.addEventListener(app.touchEvents.end, function (e) {
          appTouchEndActive(e);
          appTouchEndPassive(e);
        }, false);
      }

      if (support.touch) {
        app.on('click', handleClick);
        app.on('touchstart', handleTouchStart);
        app.on('touchmove', handleTouchMove);
        app.on('touchend', handleTouchEnd);
        document.addEventListener('touchcancel', handleTouchCancel, {
          passive: true
        });
      } else if (params.activeState) {
        app.on('touchstart', handleMouseDown);
        app.on('touchmove', handleMouseMove);
        app.on('touchend', handleMouseUp);
        document.addEventListener('pointercancel', handleMouseUp, {
          passive: true
        });
      }

      document.addEventListener('contextmenu', function (e) {
        if (params.disableContextMenu && (device.ios || device.android || device.cordova || window.Capacitor && window.Capacitor.isNative)) {
          e.preventDefault();
        }

        if (useRipple) {
          if (activableElement) removeActive();
          rippleTouchEnd();
        }
      });
    }

    var TouchModule = {
      name: 'touch',
      params: {
        touch: {
          // Clicks
          touchClicksDistanceThreshold: 5,
          // ContextMenu
          disableContextMenu: false,
          // Tap Hold
          tapHold: false,
          tapHoldDelay: 750,
          tapHoldPreventClicks: true,
          // Active State
          activeState: true,
          activeStateElements: 'a, button, label, span, .actions-button, .stepper-button, .stepper-button-plus, .stepper-button-minus, .card-expandable, .menu-item, .link, .item-link, .accordion-item-toggle',
          activeStateOnMouseMove: false,
          mdTouchRipple: true,
          iosTouchRipple: false,
          auroraTouchRipple: false,
          touchRippleElements: '.ripple, .link, .item-link, .list-button, .links-list a, .button, button, .input-clear-button, .dialog-button, .tab-link, .item-radio, .item-checkbox, .actions-button, .searchbar-disable-button, .fab a, .checkbox, .radio, .data-table .sortable-cell:not(.input-cell), .notification-close-button, .stepper-button, .stepper-button-minus, .stepper-button-plus, .menu-item-content, .list.accordion-list .accordion-item-toggle',
          touchRippleInsetElements: '.ripple-inset, .icon-only, .searchbar-disable-button, .input-clear-button, .notification-close-button, .md .navbar .link.back'
        }
      },
      create: function create() {
        var app = this;
        var support = getSupport$1();
        extend$2(app, {
          touchEvents: {
            start: support.touch ? 'touchstart' : support.pointerEvents ? 'pointerdown' : 'mousedown',
            move: support.touch ? 'touchmove' : support.pointerEvents ? 'pointermove' : 'mousemove',
            end: support.touch ? 'touchend' : support.pointerEvents ? 'pointerup' : 'mouseup'
          }
        });
      },
      on: {
        init: initTouch
      }
    };

    /**
     * Tokenize input string.
     */
    function lexer(str) {
        var tokens = [];
        var i = 0;
        while (i < str.length) {
            var char = str[i];
            if (char === "*" || char === "+" || char === "?") {
                tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
                continue;
            }
            if (char === "\\") {
                tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
                continue;
            }
            if (char === "{") {
                tokens.push({ type: "OPEN", index: i, value: str[i++] });
                continue;
            }
            if (char === "}") {
                tokens.push({ type: "CLOSE", index: i, value: str[i++] });
                continue;
            }
            if (char === ":") {
                var name = "";
                var j = i + 1;
                while (j < str.length) {
                    var code = str.charCodeAt(j);
                    if (
                    // `0-9`
                    (code >= 48 && code <= 57) ||
                        // `A-Z`
                        (code >= 65 && code <= 90) ||
                        // `a-z`
                        (code >= 97 && code <= 122) ||
                        // `_`
                        code === 95) {
                        name += str[j++];
                        continue;
                    }
                    break;
                }
                if (!name)
                    throw new TypeError("Missing parameter name at " + i);
                tokens.push({ type: "NAME", index: i, value: name });
                i = j;
                continue;
            }
            if (char === "(") {
                var count = 1;
                var pattern = "";
                var j = i + 1;
                if (str[j] === "?") {
                    throw new TypeError("Pattern cannot start with \"?\" at " + j);
                }
                while (j < str.length) {
                    if (str[j] === "\\") {
                        pattern += str[j++] + str[j++];
                        continue;
                    }
                    if (str[j] === ")") {
                        count--;
                        if (count === 0) {
                            j++;
                            break;
                        }
                    }
                    else if (str[j] === "(") {
                        count++;
                        if (str[j + 1] !== "?") {
                            throw new TypeError("Capturing groups are not allowed at " + j);
                        }
                    }
                    pattern += str[j++];
                }
                if (count)
                    throw new TypeError("Unbalanced pattern at " + i);
                if (!pattern)
                    throw new TypeError("Missing pattern at " + i);
                tokens.push({ type: "PATTERN", index: i, value: pattern });
                i = j;
                continue;
            }
            tokens.push({ type: "CHAR", index: i, value: str[i++] });
        }
        tokens.push({ type: "END", index: i, value: "" });
        return tokens;
    }
    /**
     * Parse a string for the raw tokens.
     */
    function parse(str, options) {
        if (options === void 0) { options = {}; }
        var tokens = lexer(str);
        var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
        var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
        var result = [];
        var key = 0;
        var i = 0;
        var path = "";
        var tryConsume = function (type) {
            if (i < tokens.length && tokens[i].type === type)
                return tokens[i++].value;
        };
        var mustConsume = function (type) {
            var value = tryConsume(type);
            if (value !== undefined)
                return value;
            var _a = tokens[i], nextType = _a.type, index = _a.index;
            throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
        };
        var consumeText = function () {
            var result = "";
            var value;
            // tslint:disable-next-line
            while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
                result += value;
            }
            return result;
        };
        while (i < tokens.length) {
            var char = tryConsume("CHAR");
            var name = tryConsume("NAME");
            var pattern = tryConsume("PATTERN");
            if (name || pattern) {
                var prefix = char || "";
                if (prefixes.indexOf(prefix) === -1) {
                    path += prefix;
                    prefix = "";
                }
                if (path) {
                    result.push(path);
                    path = "";
                }
                result.push({
                    name: name || key++,
                    prefix: prefix,
                    suffix: "",
                    pattern: pattern || defaultPattern,
                    modifier: tryConsume("MODIFIER") || ""
                });
                continue;
            }
            var value = char || tryConsume("ESCAPED_CHAR");
            if (value) {
                path += value;
                continue;
            }
            if (path) {
                result.push(path);
                path = "";
            }
            var open = tryConsume("OPEN");
            if (open) {
                var prefix = consumeText();
                var name_1 = tryConsume("NAME") || "";
                var pattern_1 = tryConsume("PATTERN") || "";
                var suffix = consumeText();
                mustConsume("CLOSE");
                result.push({
                    name: name_1 || (pattern_1 ? key++ : ""),
                    pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                    prefix: prefix,
                    suffix: suffix,
                    modifier: tryConsume("MODIFIER") || ""
                });
                continue;
            }
            mustConsume("END");
        }
        return result;
    }
    /**
     * Compile a string to a template function for the path.
     */
    function compile(str, options) {
        return tokensToFunction(parse(str, options), options);
    }
    /**
     * Expose a method for transforming tokens into the path function.
     */
    function tokensToFunction(tokens, options) {
        if (options === void 0) { options = {}; }
        var reFlags = flags(options);
        var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
        // Compile all the tokens into regexps.
        var matches = tokens.map(function (token) {
            if (typeof token === "object") {
                return new RegExp("^(?:" + token.pattern + ")$", reFlags);
            }
        });
        return function (data) {
            var path = "";
            for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if (typeof token === "string") {
                    path += token;
                    continue;
                }
                var value = data ? data[token.name] : undefined;
                var optional = token.modifier === "?" || token.modifier === "*";
                var repeat = token.modifier === "*" || token.modifier === "+";
                if (Array.isArray(value)) {
                    if (!repeat) {
                        throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                    }
                    if (value.length === 0) {
                        if (optional)
                            continue;
                        throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                    }
                    for (var j = 0; j < value.length; j++) {
                        var segment = encode(value[j], token);
                        if (validate && !matches[i].test(segment)) {
                            throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                        }
                        path += token.prefix + segment + token.suffix;
                    }
                    continue;
                }
                if (typeof value === "string" || typeof value === "number") {
                    var segment = encode(String(value), token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                    continue;
                }
                if (optional)
                    continue;
                var typeOfMessage = repeat ? "an array" : "a string";
                throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
            }
            return path;
        };
    }
    /**
     * Escape a regular expression string.
     */
    function escapeString(str) {
        return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    }
    /**
     * Get the flags for a regexp from the options.
     */
    function flags(options) {
        return options && options.sensitive ? "" : "i";
    }
    /**
     * Pull out keys from a regexp.
     */
    function regexpToRegexp(path, keys) {
        if (!keys)
            return path;
        var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
        var index = 0;
        var execResult = groupsRegex.exec(path.source);
        while (execResult) {
            keys.push({
                // Use parenthesized substring match if available, index otherwise
                name: execResult[1] || index++,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
            execResult = groupsRegex.exec(path.source);
        }
        return path;
    }
    /**
     * Transform an array into a regexp.
     */
    function arrayToRegexp(paths, keys, options) {
        var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
        return new RegExp("(?:" + parts.join("|") + ")", flags(options));
    }
    /**
     * Create a path regexp from string input.
     */
    function stringToRegexp(path, keys, options) {
        return tokensToRegexp(parse(path, options), keys, options);
    }
    /**
     * Expose a function for taking tokens and returning a RegExp.
     */
    function tokensToRegexp(tokens, keys, options) {
        if (options === void 0) { options = {}; }
        var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
        var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
        var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
        var route = start ? "^" : "";
        // Iterate over the tokens and create our regexp string.
        for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
            var token = tokens_1[_i];
            if (typeof token === "string") {
                route += escapeString(encode(token));
            }
            else {
                var prefix = escapeString(encode(token.prefix));
                var suffix = escapeString(encode(token.suffix));
                if (token.pattern) {
                    if (keys)
                        keys.push(token);
                    if (prefix || suffix) {
                        if (token.modifier === "+" || token.modifier === "*") {
                            var mod = token.modifier === "*" ? "?" : "";
                            route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                        }
                        else {
                            route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                        }
                    }
                    else {
                        route += "(" + token.pattern + ")" + token.modifier;
                    }
                }
                else {
                    route += "(?:" + prefix + suffix + ")" + token.modifier;
                }
            }
        }
        if (end) {
            if (!strict)
                route += delimiter + "?";
            route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
        }
        else {
            var endToken = tokens[tokens.length - 1];
            var isEndDelimited = typeof endToken === "string"
                ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
                : // tslint:disable-next-line
                    endToken === undefined;
            if (!strict) {
                route += "(?:" + delimiter + "(?=" + endsWith + "))?";
            }
            if (!isEndDelimited) {
                route += "(?=" + delimiter + "|" + endsWith + ")";
            }
        }
        return new RegExp(route, flags(options));
    }
    /**
     * Normalize the given path string, returning a regular expression.
     *
     * An empty array can be passed in for the keys, which will hold the
     * placeholder key descriptions. For example, using `/user/:id`, `keys` will
     * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
     */
    function pathToRegexp(path, keys, options) {
        if (path instanceof RegExp)
            return regexpToRegexp(path, keys);
        if (Array.isArray(path))
            return arrayToRegexp(path, keys, options);
        return stringToRegexp(path, keys, options);
    }

    var History = {
      queue: [],
      clearQueue: function clearQueue() {
        if (History.queue.length === 0) return;
        var currentQueue = History.queue.shift();
        currentQueue();
      },
      routerQueue: [],
      clearRouterQueue: function clearRouterQueue() {
        if (History.routerQueue.length === 0) return;
        var currentQueue = History.routerQueue.pop();
        var router = currentQueue.router,
            stateUrl = currentQueue.stateUrl,
            action = currentQueue.action;
        var animate = router.params.animate;
        if (router.params.browserHistoryAnimate === false) animate = false;

        if (action === 'back') {
          router.back({
            animate: animate,
            browserHistory: false
          });
        }

        if (action === 'load') {
          router.navigate(stateUrl, {
            animate: animate,
            browserHistory: false
          });
        }
      },
      handle: function handle(e) {
        if (History.blockPopstate) return;
        var app = this; // const mainView = app.views.main;

        var state = e.state;
        History.previousState = History.state;
        History.state = state;
        History.allowChange = true;
        History.clearQueue();
        state = History.state;
        if (!state) state = {};
        app.views.forEach(function (view) {
          var router = view.router;
          var viewState = state[view.id];

          if (!viewState && view.params.browserHistory) {
            viewState = {
              url: view.router.history[0]
            };
          }

          if (!viewState) return;
          var stateUrl = viewState.url || undefined;
          var animate = router.params.animate;
          if (router.params.browserHistoryAnimate === false) animate = false;

          if (stateUrl !== router.url) {
            if (router.history.indexOf(stateUrl) >= 0) {
              // Go Back
              if (router.allowPageChange) {
                router.back({
                  animate: animate,
                  browserHistory: false
                });
              } else {
                History.routerQueue.push({
                  action: 'back',
                  router: router
                });
              }
            } else if (router.allowPageChange) {
              // Load page
              router.navigate(stateUrl, {
                animate: animate,
                browserHistory: false
              });
            } else {
              History.routerQueue.unshift({
                action: 'load',
                stateUrl: stateUrl,
                router: router
              });
            }
          }
        });
      },
      initViewState: function initViewState(viewId, viewState) {
        var _extend;

        var window = getWindow();
        var newState = extend$2({}, History.state || {}, (_extend = {}, _extend[viewId] = viewState, _extend));
        History.state = newState;
        window.history.replaceState(newState, '');
      },
      push: function push(viewId, viewState, url) {
        var _extend2;

        var window = getWindow();

        if (url.substr(-3) === '#!/') {
          // eslint-disable-next-line
          url = url.replace('#!/', '');
        }

        if (!History.allowChange) {
          History.queue.push(function () {
            History.push(viewId, viewState, url);
          });
          return;
        }

        History.previousState = History.state;
        var newState = extend$2({}, History.previousState || {}, (_extend2 = {}, _extend2[viewId] = viewState, _extend2));
        History.state = newState;
        window.history.pushState(newState, '', url);
      },
      replace: function replace(viewId, viewState, url) {
        var _extend3;

        var window = getWindow();

        if (url.substr(-3) === '#!/') {
          // eslint-disable-next-line
          url = url.replace('#!/', '');
        }

        if (!History.allowChange) {
          History.queue.push(function () {
            History.replace(viewId, viewState, url);
          });
          return;
        }

        History.previousState = History.state;
        var newState = extend$2({}, History.previousState || {}, (_extend3 = {}, _extend3[viewId] = viewState, _extend3));
        History.state = newState;
        window.history.replaceState(newState, '', url);
      },
      go: function go(index) {
        var window = getWindow();
        History.allowChange = false;
        window.history.go(index);
      },
      back: function back() {
        var window = getWindow();
        History.allowChange = false;
        window.history.back();
      },
      allowChange: true,
      previousState: {},
      state: {},
      blockPopstate: true,
      init: function init(app) {
        var window = getWindow();
        var document = getDocument();
        History.state = window.history.state;
        $(window).on('load', function () {
          setTimeout(function () {
            History.blockPopstate = false;
          }, 0);
        });

        if (document.readyState && document.readyState === 'complete') {
          History.blockPopstate = false;
        }

        $(window).on('popstate', History.handle.bind(app));
      }
    };
    var History$1 = History;

    function SwipeBack(r) {
      var router = r;
      var $el = router.$el,
          $navbarsEl = router.$navbarsEl,
          app = router.app,
          params = router.params;
      var support = getSupport$1();
      var device = getDevice$1();
      var isTouched = false;
      var isMoved = false;
      var touchesStart = {};
      var isScrolling;
      var $currentPageEl = [];
      var $previousPageEl = [];
      var viewContainerWidth;
      var touchesDiff;
      var allowViewTouchMove = true;
      var touchStartTime;
      var $currentNavbarEl = [];
      var $previousNavbarEl = [];
      var dynamicNavbar;
      var $pageShadowEl;
      var $pageOpacityEl;
      var animatableNavEls;
      var paramsSwipeBackAnimateShadow = params[app.theme + "SwipeBackAnimateShadow"];
      var paramsSwipeBackAnimateOpacity = params[app.theme + "SwipeBackAnimateOpacity"];
      var paramsSwipeBackActiveArea = params[app.theme + "SwipeBackActiveArea"];
      var paramsSwipeBackThreshold = params[app.theme + "SwipeBackThreshold"];
      var transformOrigin = app.rtl ? 'right center' : 'left center';
      var transformOriginTitleLarge = app.rtl ? 'calc(100% - var(--f7-navbar-large-title-padding-left) - var(--f7-safe-area-left)) center' : 'calc(var(--f7-navbar-large-title-padding-left) + var(--f7-safe-area-left)) center';

      function animatableNavElements() {
        var els = [];
        var inverter = app.rtl ? -1 : 1;
        var currentNavIsTransparent = $currentNavbarEl.hasClass('navbar-transparent') && !$currentNavbarEl.hasClass('navbar-large') && !$currentNavbarEl.hasClass('navbar-transparent-visible');
        var currentNavIsLarge = $currentNavbarEl.hasClass('navbar-large');
        var currentNavIsCollapsed = $currentNavbarEl.hasClass('navbar-large-collapsed');
        var currentNavIsLargeTransparent = $currentNavbarEl.hasClass('navbar-large-transparent') || $currentNavbarEl.hasClass('navbar-large') && $currentNavbarEl.hasClass('navbar-transparent');
        var previousNavIsTransparent = $previousNavbarEl.hasClass('navbar-transparent') && !$previousNavbarEl.hasClass('navbar-large') && !$previousNavbarEl.hasClass('navbar-transparent-visible');
        var previousNavIsLarge = $previousNavbarEl.hasClass('navbar-large');
        var previousNavIsCollapsed = $previousNavbarEl.hasClass('navbar-large-collapsed');
        var previousNavIsLargeTransparent = $previousNavbarEl.hasClass('navbar-large-transparent') || $previousNavbarEl.hasClass('navbar-large') && $previousNavbarEl.hasClass('navbar-transparent');
        var fromLarge = currentNavIsLarge && !currentNavIsCollapsed;
        var toLarge = previousNavIsLarge && !previousNavIsCollapsed;
        var $currentNavElements = $currentNavbarEl.find('.left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg');
        var $previousNavElements = $previousNavbarEl.find('.left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg');
        var activeNavBackIconText;
        var previousNavBackIconText;

        if (params.iosAnimateNavbarBackIcon) {
          if ($currentNavbarEl.hasClass('sliding') || $currentNavbarEl.find('.navbar-inner.sliding').length) {
            activeNavBackIconText = $currentNavbarEl.find('.left').find('.back .icon + span').eq(0);
          } else {
            activeNavBackIconText = $currentNavbarEl.find('.left.sliding').find('.back .icon + span').eq(0);
          }

          if ($previousNavbarEl.hasClass('sliding') || $previousNavbarEl.find('.navbar-inner.sliding').length) {
            previousNavBackIconText = $previousNavbarEl.find('.left').find('.back .icon + span').eq(0);
          } else {
            previousNavBackIconText = $previousNavbarEl.find('.left.sliding').find('.back .icon + span').eq(0);
          }

          if (activeNavBackIconText.length) {
            $previousNavElements.each(function (el) {
              if (!$(el).hasClass('title')) return;
              el.f7NavbarLeftOffset += activeNavBackIconText.prev('.icon')[0].offsetWidth;
            });
          }
        }

        $currentNavElements.each(function (navEl) {
          var $navEl = $(navEl);
          var isSubnavbar = $navEl.hasClass('subnavbar');
          var isLeft = $navEl.hasClass('left');
          var isTitle = $navEl.hasClass('title');
          var isBg = $navEl.hasClass('navbar-bg');
          if ((isTitle || isBg) && currentNavIsTransparent) return;
          if (!fromLarge && $navEl.hasClass('.title-large')) return;
          var el = {
            el: navEl
          };

          if (fromLarge) {
            if (isTitle) return;

            if ($navEl.hasClass('title-large')) {
              if (els.indexOf(el) < 0) els.push(el);
              el.overflow = 'visible';
              $navEl.find('.title-large-text').each(function (subNavEl) {
                els.push({
                  el: subNavEl,
                  transform: function transform(progress) {
                    return "translateX(" + progress * 100 * inverter + "%)";
                  }
                });
              });
              return;
            }
          }

          if (toLarge) {
            if (!fromLarge) {
              if ($navEl.hasClass('title-large')) {
                if (els.indexOf(el) < 0) els.push(el);
                el.opacity = 0;
              }
            }

            if (isLeft) {
              if (els.indexOf(el) < 0) els.push(el);

              el.opacity = function (progress) {
                return 1 - Math.pow(progress, 0.33);
              };

              $navEl.find('.back span').each(function (subNavEl) {
                els.push({
                  el: subNavEl,
                  'transform-origin': transformOrigin,
                  transform: function transform(progress) {
                    return "translateX(calc(" + progress + " * (var(--f7-navbarTitleLargeOffset) - var(--f7-navbarLeftTextOffset)))) translateY(calc(" + progress + " * (var(--f7-navbar-large-title-height) - var(--f7-navbar-large-title-padding-vertical) / 2))) scale(" + (1 + 1 * progress) + ")";
                  }
                });
              });
              return;
            }
          }

          if (isBg) {
            if (els.indexOf(el) < 0) els.push(el);

            if (!fromLarge && !toLarge) {
              if (currentNavIsCollapsed) {
                if (currentNavIsLargeTransparent) {
                  el.className = 'ios-swipeback-navbar-bg-large';
                }

                el.transform = function (progress) {
                  return "translateX(" + 100 * progress * inverter + "%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))";
                };
              } else {
                el.transform = function (progress) {
                  return "translateX(" + 100 * progress * inverter + "%)";
                };
              }
            }

            if (!fromLarge && toLarge) {
              el.className = 'ios-swipeback-navbar-bg-large';

              el.transform = function (progress) {
                return "translateX(" + 100 * progress * inverter + "%) translateY(calc(-1 * " + (1 - progress) + " * var(--f7-navbar-large-title-height)))";
              };
            }

            if (fromLarge && toLarge) {
              el.transform = function (progress) {
                return "translateX(" + 100 * progress * inverter + "%)";
              };
            }

            if (fromLarge && !toLarge) {
              el.transform = function (progress) {
                return "translateX(" + 100 * progress * inverter + "%) translateY(calc(-" + progress + " * var(--f7-navbar-large-title-height)))";
              };
            }

            return;
          }

          if ($navEl.hasClass('title-large')) return;
          var isSliding = $navEl.hasClass('sliding') || $navEl.parents('.navbar-inner.sliding').length;
          if (els.indexOf(el) < 0) els.push(el);

          if (!isSubnavbar || isSubnavbar && !isSliding) {
            el.opacity = function (progress) {
              return 1 - Math.pow(progress, 0.33);
            };
          }

          if (isSliding) {
            var transformTarget = el;

            if (isLeft && activeNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
              var textEl = {
                el: activeNavBackIconText[0]
              };
              transformTarget = textEl;
              els.push(textEl);
            }

            transformTarget.transform = function (progress) {
              var activeNavTranslate = progress * transformTarget.el.f7NavbarRightOffset;
              if (device.pixelRatio === 1) activeNavTranslate = Math.round(activeNavTranslate);

              if (isSubnavbar && currentNavIsLarge) {
                return "translate3d(" + activeNavTranslate + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)";
              }

              return "translate3d(" + activeNavTranslate + "px,0,0)";
            };
          }
        });
        $previousNavElements.each(function (navEl) {
          var $navEl = $(navEl);
          var isSubnavbar = $navEl.hasClass('subnavbar');
          var isLeft = $navEl.hasClass('left');
          var isTitle = $navEl.hasClass('title');
          var isBg = $navEl.hasClass('navbar-bg');
          if ((isTitle || isBg) && previousNavIsTransparent) return;
          var el = {
            el: navEl
          };

          if (toLarge) {
            if (isTitle) return;
            if (els.indexOf(el) < 0) els.push(el);

            if ($navEl.hasClass('title-large')) {
              el.opacity = 1;
              el.overflow = 'visible';
              $navEl.find('.title-large-text').each(function (subNavEl) {
                els.push({
                  el: subNavEl,
                  'transform-origin': transformOriginTitleLarge,
                  opacity: function opacity(progress) {
                    return Math.pow(progress, 3);
                  },
                  transform: function transform(progress) {
                    return "translateX(calc(" + (1 - progress) + " * (var(--f7-navbarLeftTextOffset) - var(--f7-navbarTitleLargeOffset)))) translateY(calc(" + (progress - 1) + " * var(--f7-navbar-large-title-height) + " + (1 - progress) + " * var(--f7-navbar-large-title-padding-vertical))) scale(" + (0.5 + progress * 0.5) + ")";
                  }
                });
              });
              return;
            }
          }

          if (isBg) {
            if (els.indexOf(el) < 0) els.push(el);

            if (!fromLarge && !toLarge) {
              if (previousNavIsCollapsed) {
                if (previousNavIsLargeTransparent) {
                  el.className = 'ios-swipeback-navbar-bg-large';
                }

                el.transform = function (progress) {
                  return "translateX(" + (-100 + 100 * progress) * inverter + "%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))";
                };
              } else {
                el.transform = function (progress) {
                  return "translateX(" + (-100 + 100 * progress) * inverter + "%)";
                };
              }
            }

            if (!fromLarge && toLarge) {
              el.transform = function (progress) {
                return "translateX(" + (-100 + 100 * progress) * inverter + "%) translateY(calc(-1 * " + (1 - progress) + " * var(--f7-navbar-large-title-height)))";
              };
            }

            if (fromLarge && !toLarge) {
              el.className = 'ios-swipeback-navbar-bg-large';

              el.transform = function (progress) {
                return "translateX(" + (-100 + 100 * progress) * inverter + "%) translateY(calc(-" + progress + " * var(--f7-navbar-large-title-height)))";
              };
            }

            if (fromLarge && toLarge) {
              el.transform = function (progress) {
                return "translateX(" + (-100 + 100 * progress) * inverter + "%)";
              };
            }

            return;
          }

          if ($navEl.hasClass('title-large')) return;
          var isSliding = $navEl.hasClass('sliding') || $previousNavbarEl.children('.navbar-inner.sliding').length;
          if (els.indexOf(el) < 0) els.push(el);

          if (!isSubnavbar || isSubnavbar && !isSliding) {
            el.opacity = function (progress) {
              return Math.pow(progress, 3);
            };
          }

          if (isSliding) {
            var transformTarget = el;

            if (isLeft && previousNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
              var textEl = {
                el: previousNavBackIconText[0]
              };
              transformTarget = textEl;
              els.push(textEl);
            }

            transformTarget.transform = function (progress) {
              var previousNavTranslate = transformTarget.el.f7NavbarLeftOffset * (1 - progress);
              if (device.pixelRatio === 1) previousNavTranslate = Math.round(previousNavTranslate);

              if (isSubnavbar && previousNavIsLarge) {
                return "translate3d(" + previousNavTranslate + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)";
              }

              return "translate3d(" + previousNavTranslate + "px,0,0)";
            };
          }
        });
        return els;
      }

      function setAnimatableNavElements(_temp) {
        var _ref = _temp === void 0 ? {} : _temp,
            progress = _ref.progress,
            reset = _ref.reset,
            transition = _ref.transition,
            reflow = _ref.reflow;

        var styles = ['overflow', 'transform', 'transform-origin', 'opacity'];

        if (transition === true || transition === false) {
          for (var i = 0; i < animatableNavEls.length; i += 1) {
            var el = animatableNavEls[i];

            if (el && el.el) {
              if (transition === true) el.el.classList.add('navbar-page-transitioning');
              if (transition === false) el.el.classList.remove('navbar-page-transitioning');
            }
          }
        }

        if (reflow && animatableNavEls.length && animatableNavEls[0] && animatableNavEls[0].el) {
          // eslint-disable-next-line
          animatableNavEls[0].el._clientLeft = animatableNavEls[0].el.clientLeft;
        }

        for (var _i = 0; _i < animatableNavEls.length; _i += 1) {
          var _el = animatableNavEls[_i];

          if (_el && _el.el) {
            if (_el.className && !_el.classNameSet && !reset) {
              _el.el.classList.add(_el.className);

              _el.classNameSet = true;
            }

            if (_el.className && reset) {
              _el.el.classList.remove(_el.className);
            }

            for (var j = 0; j < styles.length; j += 1) {
              var styleProp = styles[j];

              if (_el[styleProp]) {
                if (reset) {
                  _el.el.style[styleProp] = '';
                } else if (typeof _el[styleProp] === 'function') {
                  _el.el.style[styleProp] = _el[styleProp](progress);
                } else {
                  _el.el.style[styleProp] = _el[styleProp];
                }
              }
            }
          }
        }
      }

      function handleTouchStart(e) {
        var swipeBackEnabled = params[app.theme + "SwipeBack"];
        if (!allowViewTouchMove || !swipeBackEnabled || isTouched || app.swipeout && app.swipeout.el || !router.allowPageChange) return;
        if ($(e.target).closest('.range-slider, .calendar-months').length > 0) return;
        if ($(e.target).closest('.page-master, .page-master-detail').length > 0 && params.masterDetailBreakpoint > 0 && app.width >= params.masterDetailBreakpoint) return;
        isMoved = false;
        isTouched = true;
        isScrolling = undefined;
        touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        touchStartTime = now$2();
        dynamicNavbar = router.dynamicNavbar;
      }

      function handleTouchMove(e) {
        if (!isTouched) return;
        var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x)) || pageX < touchesStart.x && !app.rtl || pageX > touchesStart.x && app.rtl;
        }

        if (isScrolling || e.f7PreventSwipeBack || app.preventSwipeBack) {
          isTouched = false;
          return;
        }

        if (!isMoved) {
          // Calc values during first move fired
          var cancel = false;
          var target = $(e.target);
          var swipeout = target.closest('.swipeout');

          if (swipeout.length > 0) {
            if (!app.rtl && swipeout.find('.swipeout-actions-left').length > 0) cancel = true;
            if (app.rtl && swipeout.find('.swipeout-actions-right').length > 0) cancel = true;
          }

          $currentPageEl = target.closest('.page');
          if ($currentPageEl.hasClass('no-swipeback') || target.closest('.no-swipeback, .card-opened').length > 0) cancel = true;
          $previousPageEl = $el.find('.page-previous:not(.stacked)');

          if ($previousPageEl.length > 1) {
            $previousPageEl = $previousPageEl.eq($previousPageEl.length - 1);
          }

          var notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
          viewContainerWidth = $el.width();

          if (app.rtl) {
            notFromBorder = touchesStart.x < $el.offset().left - $el[0].scrollLeft + (viewContainerWidth - paramsSwipeBackActiveArea);
          } else {
            notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
          }

          if (notFromBorder) cancel = true;
          if ($previousPageEl.length === 0 || $currentPageEl.length === 0) cancel = true;

          if (cancel) {
            isTouched = false;
            return;
          }

          if (paramsSwipeBackAnimateShadow) {
            $pageShadowEl = $currentPageEl.find('.page-shadow-effect');

            if ($pageShadowEl.length === 0) {
              $pageShadowEl = $('<div class="page-shadow-effect"></div>');
              $currentPageEl.append($pageShadowEl);
            }
          }

          if (paramsSwipeBackAnimateOpacity) {
            $pageOpacityEl = $previousPageEl.find('.page-opacity-effect');

            if ($pageOpacityEl.length === 0) {
              $pageOpacityEl = $('<div class="page-opacity-effect"></div>');
              $previousPageEl.append($pageOpacityEl);
            }
          }

          if (dynamicNavbar) {
            $currentNavbarEl = $navbarsEl.find('.navbar-current:not(.stacked)');
            $previousNavbarEl = $navbarsEl.find('.navbar-previous:not(.stacked)');

            if ($previousNavbarEl.length > 1) {
              $previousNavbarEl = $previousNavbarEl.eq($previousNavbarEl.length - 1);
            }

            animatableNavEls = animatableNavElements();
          } // Close/Hide Any Picker


          if ($('.sheet.modal-in').length > 0 && app.sheet) {
            app.sheet.close($('.sheet.modal-in'));
          }
        }

        e.f7PreventSwipePanel = true;
        isMoved = true;
        app.preventSwipePanelBySwipeBack = true;
        e.preventDefault(); // RTL inverter

        var inverter = app.rtl ? -1 : 1; // Touches diff

        touchesDiff = (pageX - touchesStart.x - paramsSwipeBackThreshold) * inverter;
        if (touchesDiff < 0) touchesDiff = 0;
        var percentage = Math.min(Math.max(touchesDiff / viewContainerWidth, 0), 1); // Swipe Back Callback

        var callbackData = {
          percentage: percentage,
          progress: percentage,
          currentPageEl: $currentPageEl[0],
          previousPageEl: $previousPageEl[0],
          currentNavbarEl: $currentNavbarEl[0],
          previousNavbarEl: $previousNavbarEl[0]
        };
        $el.trigger('swipeback:move', callbackData);
        router.emit('swipebackMove', callbackData); // Transform pages

        var currentPageTranslate = touchesDiff * inverter;
        var previousPageTranslate = (touchesDiff / 5 - viewContainerWidth / 5) * inverter;

        if (!app.rtl) {
          currentPageTranslate = Math.min(currentPageTranslate, viewContainerWidth);
          previousPageTranslate = Math.min(previousPageTranslate, 0);
        } else {
          currentPageTranslate = Math.max(currentPageTranslate, -viewContainerWidth);
          previousPageTranslate = Math.max(previousPageTranslate, 0);
        }

        if (device.pixelRatio === 1) {
          currentPageTranslate = Math.round(currentPageTranslate);
          previousPageTranslate = Math.round(previousPageTranslate);
        }

        router.swipeBackActive = true;
        $([$currentPageEl[0], $previousPageEl[0]]).addClass('page-swipeback-active');
        $currentPageEl.transform("translate3d(" + currentPageTranslate + "px,0,0)");
        if (paramsSwipeBackAnimateShadow) $pageShadowEl[0].style.opacity = 1 - 1 * percentage;

        if (app.theme === 'ios') {
          $previousPageEl.transform("translate3d(" + previousPageTranslate + "px,0,0)");
        }

        if (paramsSwipeBackAnimateOpacity) $pageOpacityEl[0].style.opacity = 1 - 1 * percentage; // Dynamic Navbars Animation

        if (!dynamicNavbar) return;
        setAnimatableNavElements({
          progress: percentage
        });
      }

      function handleTouchEnd() {
        app.preventSwipePanelBySwipeBack = false;

        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }

        isTouched = false;
        isMoved = false;
        router.swipeBackActive = false;
        var $pages = $([$currentPageEl[0], $previousPageEl[0]]);
        $pages.removeClass('page-swipeback-active');

        if (touchesDiff === 0) {
          $pages.transform('');
          if ($pageShadowEl && $pageShadowEl.length > 0) $pageShadowEl.remove();
          if ($pageOpacityEl && $pageOpacityEl.length > 0) $pageOpacityEl.remove();

          if (dynamicNavbar) {
            setAnimatableNavElements({
              reset: true
            });
          }

          return;
        }

        var timeDiff = now$2() - touchStartTime;
        var pageChanged = false; // Swipe back to previous page

        if (timeDiff < 300 && touchesDiff > 10 || timeDiff >= 300 && touchesDiff > viewContainerWidth / 2) {
          $currentPageEl.removeClass('page-current').addClass("page-next" + (app.theme !== 'ios' ? ' page-next-on-right' : ''));
          $previousPageEl.removeClass('page-previous').addClass('page-current').removeAttr('aria-hidden');
          if ($pageShadowEl) $pageShadowEl[0].style.opacity = '';
          if ($pageOpacityEl) $pageOpacityEl[0].style.opacity = '';

          if (dynamicNavbar) {
            router.setNavbarPosition($currentNavbarEl, 'next');
            router.setNavbarPosition($previousNavbarEl, 'current', false);
          }

          pageChanged = true;
        } // Reset custom styles
        // Add transitioning class for transition-duration


        $pages.addClass('page-transitioning page-transitioning-swipeback');

        if (device.ios) {
          // eslint-disable-next-line
          $currentPageEl[0]._clientLeft = $currentPageEl[0].clientLeft;
        }

        $pages.transform('');

        if (dynamicNavbar) {
          setAnimatableNavElements({
            progress: pageChanged ? 1 : 0,
            transition: true,
            reflow: !!device.ios
          });
        }

        allowViewTouchMove = false;
        router.allowPageChange = false; // Swipe Back Callback

        var callbackData = {
          currentPageEl: $currentPageEl[0],
          previousPageEl: $previousPageEl[0],
          currentNavbarEl: $currentNavbarEl[0],
          previousNavbarEl: $previousNavbarEl[0]
        };

        if (pageChanged) {
          // Update Route
          router.currentRoute = $previousPageEl[0].f7Page.route;
          router.currentPage = $previousPageEl[0]; // Page before animation callback

          router.pageCallback('beforeOut', $currentPageEl, $currentNavbarEl, 'current', 'next', {
            route: $currentPageEl[0].f7Page.route,
            swipeBack: true
          });
          router.pageCallback('beforeIn', $previousPageEl, $previousNavbarEl, 'previous', 'current', {
            route: $previousPageEl[0].f7Page.route,
            swipeBack: true
          }, $currentPageEl[0]);
          $el.trigger('swipeback:beforechange', callbackData);
          router.emit('swipebackBeforeChange', callbackData);
        } else {
          $el.trigger('swipeback:beforereset', callbackData);
          router.emit('swipebackBeforeReset', callbackData);
        }

        $currentPageEl.transitionEnd(function () {
          $pages.removeClass('page-transitioning page-transitioning-swipeback');

          if (dynamicNavbar) {
            setAnimatableNavElements({
              reset: true,
              transition: false
            });
          }

          allowViewTouchMove = true;
          router.allowPageChange = true;

          if (pageChanged) {
            // Update History
            if (router.history.length === 1) {
              router.history.unshift(router.url);
            }

            router.history.pop();
            router.saveHistory(); // Update push state

            if (params.browserHistory) {
              History$1.back();
            } // Page after animation callback


            router.pageCallback('afterOut', $currentPageEl, $currentNavbarEl, 'current', 'next', {
              route: $currentPageEl[0].f7Page.route,
              swipeBack: true
            });
            router.pageCallback('afterIn', $previousPageEl, $previousNavbarEl, 'previous', 'current', {
              route: $previousPageEl[0].f7Page.route,
              swipeBack: true
            }); // Remove Old Page

            if (params.stackPages && router.initialPages.indexOf($currentPageEl[0]) >= 0) {
              $currentPageEl.addClass('stacked');

              if (dynamicNavbar) {
                $currentNavbarEl.addClass('stacked');
              }
            } else {
              router.pageCallback('beforeRemove', $currentPageEl, $currentNavbarEl, 'next', {
                swipeBack: true
              });
              router.removePage($currentPageEl);

              if (dynamicNavbar) {
                router.removeNavbar($currentNavbarEl);
              }
            }

            $el.trigger('swipeback:afterchange', callbackData);
            router.emit('swipebackAfterChange', callbackData);
            router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

            if (params.preloadPreviousPage) {
              router.back(router.history[router.history.length - 2], {
                preload: true
              });
            }
          } else {
            $el.trigger('swipeback:afterreset', callbackData);
            router.emit('swipebackAfterReset', callbackData);
          }

          if ($pageShadowEl && $pageShadowEl.length > 0) $pageShadowEl.remove();
          if ($pageOpacityEl && $pageOpacityEl.length > 0) $pageOpacityEl.remove();
        });
      }

      function attachEvents() {
        var passiveListener = app.touchEvents.start === 'touchstart' && support.passiveListener ? {
          passive: true,
          capture: false
        } : false;
        $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
        app.on('touchmove:active', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
      }

      function detachEvents() {
        var passiveListener = app.touchEvents.start === 'touchstart' && support.passiveListener ? {
          passive: true,
          capture: false
        } : false;
        $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
        app.off('touchmove:active', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
      }

      attachEvents();
      router.on('routerDestroy', detachEvents);
    }

    function redirect(direction, route, options) {
      var router = this;
      var r = route.route.redirect;
      var method = direction === 'forward' ? 'navigate' : 'back';

      if (options.initial && router.params.browserHistory) {
        options.replaceState = true; // eslint-disable-line

        options.history = true; // eslint-disable-line
      }

      function redirectResolve(redirectUrl, redirectOptions) {
        if (redirectOptions === void 0) {
          redirectOptions = {};
        }

        router.allowPageChange = true;
        router[method](redirectUrl, extend$2({}, options, redirectOptions));
      }

      function redirectReject() {
        router.allowPageChange = true;
      }

      if (typeof r === 'function') {
        router.allowPageChange = false;
        var redirectUrl = r.call(router, {
          router: router,
          to: route,
          resolve: redirectResolve,
          reject: redirectReject,
          direction: direction,
          app: router.app
        });

        if (redirectUrl && typeof redirectUrl === 'string') {
          router.allowPageChange = true;
          return router[method](redirectUrl, options);
        }

        return router;
      }

      return router[method](r, options);
    }

    function processQueue(router, routerQueue, routeQueue, to, from, resolve, _reject, direction) {
      var queue = [];

      if (Array.isArray(routeQueue)) {
        queue.push.apply(queue, routeQueue);
      } else if (routeQueue && typeof routeQueue === 'function') {
        queue.push(routeQueue);
      }

      if (routerQueue) {
        if (Array.isArray(routerQueue)) {
          queue.push.apply(queue, routerQueue);
        } else {
          queue.push(routerQueue);
        }
      }

      function next() {
        if (queue.length === 0) {
          resolve();
          return;
        }

        var queueItem = queue.shift();
        queueItem.call(router, {
          router: router,
          to: to,
          from: from,
          resolve: function resolve() {
            next();
          },
          reject: function reject() {
            _reject();
          },
          direction: direction,
          app: router.app
        });
      }

      next();
    }

    function processRouteQueue(to, from, resolve, reject, direction) {
      var router = this;

      function enterNextRoute() {
        if (to && to.route && (router.params.routesBeforeEnter || to.route.beforeEnter)) {
          router.allowPageChange = false;
          processQueue(router, router.params.routesBeforeEnter, to.route.beforeEnter, to, from, function () {
            router.allowPageChange = true;
            resolve();
          }, function () {
            reject();
          }, direction);
        } else {
          resolve();
        }
      }

      function leaveCurrentRoute() {
        if (from && from.route && (router.params.routesBeforeLeave || from.route.beforeLeave)) {
          router.allowPageChange = false;
          processQueue(router, router.params.routesBeforeLeave, from.route.beforeLeave, to, from, function () {
            router.allowPageChange = true;
            enterNextRoute();
          }, function () {
            reject();
          }, direction);
        } else {
          enterNextRoute();
        }
      }

      leaveCurrentRoute();
    }

    function appRouterCheck(router, method) {
      if (!router.view) {
        throw new Error("Framework7: it is not allowed to use router methods on global app router. Use router methods only on related View, e.g. app.views.main.router." + method + "(...)");
      }
    }

    function asyncComponent(router, component, resolve, reject) {
      function resolvePromise(componentPromise) {
        componentPromise.then(function (c) {
          // eslint-disable-next-line
          resolve({
            component: c.default || c._default || c
          });
        }).catch(function (err) {
          reject();
          throw new Error(err);
        });
      }

      if (component instanceof Promise) {
        resolvePromise(component);
        return;
      }

      var asyncComponentResult = component.call(router);

      if (asyncComponentResult instanceof Promise) {
        resolvePromise(asyncComponentResult);
      } else {
        resolve({
          component: asyncComponentResult
        });
      }
    }

    function _extends$6() { _extends$6 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$6.apply(this, arguments); }

    function refreshPage() {
      var router = this;
      appRouterCheck(router, 'refreshPage');
      return router.navigate(router.currentRoute.url, {
        ignoreCache: true,
        reloadCurrent: true
      });
    }

    function forward(router, el, forwardOptions) {
      if (forwardOptions === void 0) {
        forwardOptions = {};
      }

      var document = getDocument();
      var $el = $(el);
      var app = router.app;
      var view = router.view;
      var options = extend$2(false, {
        animate: router.params.animate,
        browserHistory: true,
        replaceState: false,
        history: true,
        reloadCurrent: router.params.reloadPages,
        reloadPrevious: false,
        reloadAll: false,
        clearPreviousHistory: false,
        reloadDetail: router.params.reloadDetail,
        on: {}
      }, forwardOptions);
      var masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
      var isMaster = masterDetailEnabled && options.route && options.route.route && (options.route.route.master === true || typeof options.route.route.master === 'function' && options.route.route.master(app, router));
      var masterPageEl;
      var otherDetailPageEl;
      var detailsInBetweenRemoved = 0;
      var currentRouteIsModal = router.currentRoute.modal;
      var modalType;

      if (!currentRouteIsModal) {
        'popup popover sheet loginScreen actions customModal panel'.split(' ').forEach(function (modalLoadProp) {
          if (router.currentRoute && router.currentRoute.route && router.currentRoute.route[modalLoadProp]) {
            currentRouteIsModal = true;
            modalType = modalLoadProp;
          }
        });
      }

      if (currentRouteIsModal) {
        var modalToClose = router.currentRoute.modal || router.currentRoute.route.modalInstance || app[modalType].get();
        var previousUrl = router.history[router.history.length - 2];
        var previousRoute = router.findMatchingRoute(previousUrl);

        if (!previousRoute && previousUrl) {
          previousRoute = {
            url: previousUrl,
            path: previousUrl.split('?')[0],
            query: parseUrlQuery(previousUrl),
            route: {
              path: previousUrl.split('?')[0],
              url: previousUrl
            }
          };
        }

        router.modalRemove(modalToClose);
      }

      var dynamicNavbar = router.dynamicNavbar;
      var $viewEl = router.$el;
      var $newPage = $el;
      var reload = options.reloadPrevious || options.reloadCurrent || options.reloadAll;
      var $oldPage;
      var $navbarsEl;
      var $newNavbarEl;
      var $oldNavbarEl;
      router.allowPageChange = false;

      if ($newPage.length === 0) {
        router.allowPageChange = true;
        return router;
      }

      if ($newPage.length) {
        // Remove theme elements
        router.removeThemeElements($newPage);
      }

      if (dynamicNavbar) {
        $newNavbarEl = $newPage.children('.navbar');
        $navbarsEl = router.$navbarsEl;

        if ($newNavbarEl.length === 0 && $newPage[0] && $newPage[0].f7Page) {
          // Try from pageData
          $newNavbarEl = $newPage[0].f7Page.$navbarEl;
        }
      } // Save Keep Alive Cache


      if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
        options.route.route.keepAliveData = {
          pageEl: $el[0]
        };
      } // Pages In View


      var $pagesInView = $viewEl.children('.page:not(.stacked)').filter(function (pageInView) {
        return pageInView !== $newPage[0];
      }); // Navbars In View

      var $navbarsInView;

      if (dynamicNavbar) {
        $navbarsInView = $navbarsEl.children('.navbar:not(.stacked)').filter(function (navbarInView) {
          return navbarInView !== $newNavbarEl[0];
        });
      } // Exit when reload previous and only 1 page in view so nothing ro reload


      if (options.reloadPrevious && $pagesInView.length < 2) {
        router.allowPageChange = true;
        return router;
      } // Find Detail' master page


      var isDetail;
      var reloadDetail;
      var isDetailRoot;

      if (masterDetailEnabled && !options.reloadAll) {
        for (var i = 0; i < $pagesInView.length; i += 1) {
          if (!masterPageEl && $pagesInView[i].classList.contains('page-master')) {
            masterPageEl = $pagesInView[i];
            continue; // eslint-disable-line
          }
        }

        isDetail = !isMaster && masterPageEl;

        if (isDetail) {
          // Find Other Detail
          if (masterPageEl) {
            for (var _i = 0; _i < $pagesInView.length; _i += 1) {
              if ($pagesInView[_i].classList.contains('page-master-detail')) {
                otherDetailPageEl = $pagesInView[_i];
                continue; // eslint-disable-line
              }
            }
          }
        }

        reloadDetail = isDetail && options.reloadDetail && app.width >= router.params.masterDetailBreakpoint && masterPageEl;
      }

      if (isDetail) {
        isDetailRoot = !otherDetailPageEl || reloadDetail || options.reloadAll || options.reloadCurrent;
      } // New Page


      var newPagePosition = 'next';

      if (options.reloadCurrent || options.reloadAll || reloadDetail) {
        newPagePosition = 'current';
      } else if (options.reloadPrevious) {
        newPagePosition = 'previous';
      }

      $newPage.removeClass('page-previous page-current page-next').addClass("page-" + newPagePosition + (isMaster ? ' page-master' : '') + (isDetail ? ' page-master-detail' : '') + (isDetailRoot ? ' page-master-detail-root' : '')).removeClass('stacked').trigger('page:unstack').trigger('page:position', {
        position: newPagePosition
      });
      router.emit('pageUnstack', $newPage[0]);
      router.emit('pagePosition', $newPage[0], newPagePosition);

      if (isMaster || isDetail) {
        $newPage.trigger('page:role', {
          role: isMaster ? 'master' : 'detail',
          root: !!isDetailRoot
        });
        router.emit('pageRole', $newPage[0], {
          role: isMaster ? 'master' : 'detail',
          detailRoot: !!isDetailRoot
        });
      }

      if (dynamicNavbar && $newNavbarEl.length) {
        $newNavbarEl.removeClass('navbar-previous navbar-current navbar-next').addClass("navbar-" + newPagePosition + (isMaster ? ' navbar-master' : '') + (isDetail ? ' navbar-master-detail' : '') + (isDetailRoot ? ' navbar-master-detail-root' : '')).removeClass('stacked');
        $newNavbarEl.trigger('navbar:position', {
          position: newPagePosition
        });
        router.emit('navbarPosition', $newNavbarEl[0], newPagePosition);

        if (isMaster || isDetail) {
          router.emit('navbarRole', $newNavbarEl[0], {
            role: isMaster ? 'master' : 'detail',
            detailRoot: !!isDetailRoot
          });
        }
      } // Find Old Page


      if (options.reloadCurrent || reloadDetail) {
        if (reloadDetail) {
          $oldPage = $pagesInView.filter(function (pageEl) {
            return !pageEl.classList.contains('page-master');
          });

          if (dynamicNavbar) {
            $oldNavbarEl = $($oldPage.map(function (pageEl) {
              return app.navbar.getElByPage(pageEl);
            }));
          }

          if ($oldPage.length > 1 && masterPageEl) {
            detailsInBetweenRemoved = $oldPage.length - 1;
            $(masterPageEl).removeClass('page-master-stacked').trigger('page:masterunstack');
            router.emit('pageMasterUnstack', masterPageEl);

            if (dynamicNavbar) {
              $(app.navbar.getElByPage(masterPageEl)).removeClass('navbar-master-stacked');
              router.emit('navbarMasterUnstack', app.navbar.getElByPage(masterPageEl));
            }
          }
        } else {
          $oldPage = $pagesInView.eq($pagesInView.length - 1);

          if (dynamicNavbar) {
            $oldNavbarEl = $(app.navbar.getElByPage($oldPage));
          }
        }
      } else if (options.reloadPrevious) {
        $oldPage = $pagesInView.eq($pagesInView.length - 2);

        if (dynamicNavbar) {
          // $oldNavbarEl = $navbarsInView.eq($pagesInView.length - 2);
          $oldNavbarEl = $(app.navbar.getElByPage($oldPage));
        }
      } else if (options.reloadAll) {
        $oldPage = $pagesInView.filter(function (pageEl) {
          return pageEl !== $newPage[0];
        });

        if (dynamicNavbar) {
          $oldNavbarEl = $navbarsInView.filter(function (navbarEl) {
            return navbarEl !== $newNavbarEl[0];
          });
        }
      } else {
        var removedPageEls = [];
        var removedNavbarEls = [];

        if ($pagesInView.length > 1) {
          var _i2 = 0;

          for (_i2 = 0; _i2 < $pagesInView.length - 1; _i2 += 1) {
            if (masterPageEl && $pagesInView[_i2] === masterPageEl) {
              $pagesInView.eq(_i2).addClass('page-master-stacked');
              $pagesInView.eq(_i2).trigger('page:masterstack');
              router.emit('pageMasterStack', $pagesInView[_i2]);

              if (dynamicNavbar) {
                $(app.navbar.getElByPage(masterPageEl)).addClass('navbar-master-stacked');
                router.emit('navbarMasterStack', app.navbar.getElByPage(masterPageEl));
              }

              continue; // eslint-disable-line
            }

            var oldNavbarEl = app.navbar.getElByPage($pagesInView.eq(_i2));

            if (router.params.stackPages) {
              $pagesInView.eq(_i2).addClass('stacked');
              $pagesInView.eq(_i2).trigger('page:stack');
              router.emit('pageStack', $pagesInView[_i2]);

              if (dynamicNavbar) {
                $(oldNavbarEl).addClass('stacked');
              }
            } else {
              // Page remove event
              removedPageEls.push($pagesInView[_i2]);
              router.pageCallback('beforeRemove', $pagesInView[_i2], $navbarsInView && $navbarsInView[_i2], 'previous', undefined, options);
              router.removePage($pagesInView[_i2]);

              if (dynamicNavbar && oldNavbarEl) {
                removedNavbarEls.push(oldNavbarEl);
                router.removeNavbar(oldNavbarEl);
              }
            }
          }
        }

        $oldPage = $viewEl.children('.page:not(.stacked)').filter(function (pageEl) {
          return pageEl !== $newPage[0] && removedPageEls.indexOf(pageEl) < 0;
        });

        if (dynamicNavbar) {
          $oldNavbarEl = $navbarsEl.children('.navbar:not(.stacked)').filter(function (navbarEl) {
            return navbarEl !== $newNavbarEl[0] && removedNavbarEls.indexOf(removedNavbarEls) < 0;
          });
        }

        removedPageEls = [];
        removedNavbarEls = [];
      }

      if (isDetail && !options.reloadAll) {
        if ($oldPage.length > 1 || reloadDetail) {
          $oldPage = $oldPage.filter(function (pageEl) {
            return !pageEl.classList.contains('page-master');
          });
        }

        if ($oldNavbarEl && ($oldNavbarEl.length > 1 || reloadDetail)) {
          $oldNavbarEl = $oldNavbarEl.filter(function (navbarEl) {
            return !navbarEl.classList.contains('navbar-master');
          });
        }
      } // Push State


      if (router.params.browserHistory && (options.browserHistory || options.replaceState) && !options.reloadPrevious) {
        var browserHistoryRoot = router.params.browserHistoryRoot || '';
        History$1[options.reloadCurrent || reloadDetail && otherDetailPageEl || options.reloadAll || options.replaceState ? 'replace' : 'push'](view.id, {
          url: options.route.url
        }, browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
      }

      if (!options.reloadPrevious) {
        // Current Page & Navbar
        router.currentPageEl = $newPage[0];

        if (dynamicNavbar && $newNavbarEl.length) {
          router.currentNavbarEl = $newNavbarEl[0];
        } else {
          delete router.currentNavbarEl;
        } // Current Route


        router.currentRoute = options.route;
      } // Update router history


      var url = options.route.url;

      if (options.history) {
        if (((options.reloadCurrent || reloadDetail && otherDetailPageEl) && router.history.length) > 0 || options.replaceState) {
          if (reloadDetail && detailsInBetweenRemoved > 0) {
            router.history = router.history.slice(0, router.history.length - detailsInBetweenRemoved);
          }

          router.history[router.history.length - (options.reloadPrevious ? 2 : 1)] = url;
        } else if (options.reloadPrevious) {
          router.history[router.history.length - 2] = url;
        } else if (options.reloadAll) {
          router.history = [url];
        } else {
          router.history.push(url);
        }
      }

      router.saveHistory(); // Insert new page and navbar

      var newPageInDom = $newPage.parents(document).length > 0;
      var f7Component = $newPage[0].f7Component;

      if (options.reloadPrevious) {
        if (f7Component && !newPageInDom) {
          f7Component.mount(function (componentEl) {
            $(componentEl).insertBefore($oldPage);
          });
        } else {
          $newPage.insertBefore($oldPage);
        }

        if (dynamicNavbar && $newNavbarEl.length) {
          if ($newNavbarEl.find('.title-large').length) {
            $newNavbarEl.addClass('navbar-large');
          }

          if ($oldNavbarEl.length) {
            $newNavbarEl.insertBefore($oldNavbarEl);
          } else {
            if (!router.$navbarsEl.parents(document).length) {
              router.$el.prepend(router.$navbarsEl);
            }

            $navbarsEl.append($newNavbarEl);
          }
        }
      } else {
        if ($oldPage.next('.page')[0] !== $newPage[0]) {
          if (f7Component && !newPageInDom) {
            f7Component.mount(function (componentEl) {
              $viewEl.append(componentEl);
            });
          } else {
            $viewEl.append($newPage[0]);
          }
        }

        if (dynamicNavbar && $newNavbarEl.length) {
          if ($newNavbarEl.find('.title-large').length) {
            $newNavbarEl.addClass('navbar-large');
          }

          if (!router.$navbarsEl.parents(document).length) {
            router.$el.prepend(router.$navbarsEl);
          }

          $navbarsEl.append($newNavbarEl[0]);
        }
      }

      if (!newPageInDom) {
        router.pageCallback('mounted', $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);
      } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
        $newPage[0].f7PageMounted = true;
        router.pageCallback('mounted', $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);
      } // Remove old page


      if ((options.reloadCurrent || reloadDetail) && $oldPage.length > 0) {
        if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
          $oldPage.addClass('stacked');
          $oldPage.trigger('page:stack');
          router.emit('pageStack', $oldPage[0]);

          if (dynamicNavbar) {
            $oldNavbarEl.addClass('stacked');
          }
        } else {
          // Page remove event
          router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
          router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
          router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'current', undefined, options);
          router.removePage($oldPage);

          if (dynamicNavbar && $oldNavbarEl && $oldNavbarEl.length) {
            router.removeNavbar($oldNavbarEl);
          }
        }
      } else if (options.reloadAll) {
        $oldPage.each(function (pageEl, index) {
          var $oldPageEl = $(pageEl);
          var $oldNavbarElEl = $(app.navbar.getElByPage($oldPageEl));

          if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
            $oldPageEl.addClass('stacked');
            $oldPageEl.trigger('page:stack');
            router.emit('pageStack', $oldPageEl[0]);

            if (dynamicNavbar) {
              $oldNavbarElEl.addClass('stacked');
            }
          } else {
            // Page remove event
            if ($oldPageEl.hasClass('page-current')) {
              router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
              router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
            }

            router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarEl && $oldNavbarEl.eq(index), 'previous', undefined, options);
            router.removePage($oldPageEl);

            if (dynamicNavbar && $oldNavbarElEl.length) {
              router.removeNavbar($oldNavbarElEl);
            }
          }
        });
      } else if (options.reloadPrevious) {
        if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
          $oldPage.addClass('stacked');
          $oldPage.trigger('page:stack');
          router.emit('pageStack', $oldPage[0]);

          if (dynamicNavbar) {
            $oldNavbarEl.addClass('stacked');
          }
        } else {
          // Page remove event
          router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'previous', undefined, options);
          router.removePage($oldPage);

          if (dynamicNavbar && $oldNavbarEl && $oldNavbarEl.length) {
            router.removeNavbar($oldNavbarEl);
          }
        }
      } // Load Tab


      if (options.route.route.tab) {
        router.tabLoad(options.route.route.tab, extend$2({}, options, {
          history: false,
          browserHistory: false
        }));
      } // Check master detail


      if (masterDetailEnabled) {
        view.checkMasterDetailBreakpoint();
      } // Page init and before init events


      router.pageCallback('init', $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);

      if (options.reloadCurrent || options.reloadAll || reloadDetail) {
        router.allowPageChange = true;
        router.pageCallback('beforeIn', $newPage, $newNavbarEl, newPagePosition, 'current', options);
        $newPage.removeAttr('aria-hidden');

        if (dynamicNavbar && $newNavbarEl) {
          $newNavbarEl.removeAttr('aria-hidden');
        }

        router.pageCallback('afterIn', $newPage, $newNavbarEl, newPagePosition, 'current', options);
        if (options.reloadCurrent && options.clearPreviousHistory) router.clearPreviousHistory();

        if (reloadDetail) {
          router.setPagePosition($(masterPageEl), 'previous');

          if (masterPageEl.f7Page && masterPageEl.f7Page.navbarEl) {
            router.setNavbarPosition($(masterPageEl.f7Page.navbarEl), 'previous');
          }
        }

        return router;
      }

      if (options.reloadPrevious) {
        router.allowPageChange = true;
        return router;
      } // Before animation event


      router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', 'previous', options);
      router.pageCallback('beforeIn', $newPage, $newNavbarEl, 'next', 'current', options); // Animation

      function afterAnimation() {
        router.setPagePosition($newPage, 'current', false);
        router.setPagePosition($oldPage, 'previous', !$oldPage.hasClass('page-master'));

        if (dynamicNavbar) {
          router.setNavbarPosition($newNavbarEl, 'current', false);
          router.setNavbarPosition($oldNavbarEl, 'previous', !$oldNavbarEl.hasClass('navbar-master'));
        } // After animation event


        router.allowPageChange = true;
        router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', 'previous', options);
        router.pageCallback('afterIn', $newPage, $newNavbarEl, 'next', 'current', options);
        var keepOldPage = (router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"]) && !isMaster;

        if (!keepOldPage) {
          if ($newPage.hasClass('smart-select-page') || $newPage.hasClass('photo-browser-page') || $newPage.hasClass('autocomplete-page') || $newPage.hasClass('color-picker-page')) {
            keepOldPage = true;
          }
        }

        if (!keepOldPage) {
          if (router.params.stackPages) {
            $oldPage.addClass('stacked');
            $oldPage.trigger('page:stack');
            router.emit('pageStack', $oldPage[0]);

            if (dynamicNavbar) {
              $oldNavbarEl.addClass('stacked');
            }
          } else if (!($newPage.attr('data-name') && $newPage.attr('data-name') === 'smart-select-page')) {
            // Remove event
            router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'previous', undefined, options);
            router.removePage($oldPage);

            if (dynamicNavbar && $oldNavbarEl.length) {
              router.removeNavbar($oldNavbarEl);
            }
          }
        }

        if (options.clearPreviousHistory) router.clearPreviousHistory();
        router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

        if (router.params.browserHistory) {
          History$1.clearRouterQueue();
        }
      }

      function setPositionClasses() {
        router.setPagePosition($oldPage, 'current', false);
        router.setPagePosition($newPage, 'next', false);

        if (dynamicNavbar) {
          router.setNavbarPosition($oldNavbarEl, 'current', false);
          router.setNavbarPosition($newNavbarEl, 'next', false);
        }
      }

      if (options.animate && !(isMaster && app.width >= router.params.masterDetailBreakpoint)) {
        var delay = router.params[router.app.theme + "PageLoadDelay"];
        var transition = router.params.transition;
        if (options.transition) transition = options.transition;

        if (!transition && router.currentRoute && router.currentRoute.route) {
          transition = router.currentRoute.route.transition;
        }

        if (!transition && router.currentRoute && router.currentRoute.route.options) {
          transition = router.currentRoute.route.options.transition;
        }

        if (transition) {
          $newPage[0].f7PageTransition = transition;
        }

        if (delay) {
          setTimeout(function () {
            setPositionClasses();
            router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'forward', transition, function () {
              afterAnimation();
            });
          }, delay);
        } else {
          setPositionClasses();
          router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'forward', transition, function () {
            afterAnimation();
          });
        }
      } else {
        afterAnimation();
      }

      return router;
    }

    function load(router, loadParams, loadOptions, ignorePageChange) {
      if (loadParams === void 0) {
        loadParams = {};
      }

      if (loadOptions === void 0) {
        loadOptions = {};
      }

      if (!router.allowPageChange && !ignorePageChange) return router;
      var params = loadParams;
      var options = loadOptions;
      var url = params.url,
          content = params.content,
          el = params.el,
          pageName = params.pageName,
          component = params.component,
          componentUrl = params.componentUrl;

      if (!options.reloadCurrent && options.route && options.route.route && options.route.route.parentPath && router.currentRoute.route && router.currentRoute.route.parentPath === options.route.route.parentPath) {
        // Do something nested
        if (options.route.url === router.url) {
          router.allowPageChange = true;
          return false;
        } // Check for same params


        var sameParams = Object.keys(options.route.params).length === Object.keys(router.currentRoute.params).length;

        if (sameParams) {
          // Check for equal params name
          Object.keys(options.route.params).forEach(function (paramName) {
            if (!(paramName in router.currentRoute.params) || router.currentRoute.params[paramName] !== options.route.params[paramName]) {
              sameParams = false;
            }
          });
        }

        if (sameParams) {
          if (options.route.route.tab) {
            return router.tabLoad(options.route.route.tab, options);
          }

          return false;
        }

        if (!sameParams && options.route.route.tab && router.currentRoute.route.tab && router.currentRoute.parentPath === options.route.parentPath) {
          return router.tabLoad(options.route.route.tab, options);
        }
      }

      if (options.route && options.route.url && router.url === options.route.url && !(options.reloadCurrent || options.reloadPrevious) && !router.params.allowDuplicateUrls) {
        router.allowPageChange = true;
        return false;
      }

      if (!options.route && url) {
        options.route = router.parseRouteUrl(url);
        extend$2(options.route, {
          route: {
            url: url,
            path: url
          }
        });
      } // Component Callbacks


      function resolve(pageEl, newOptions) {
        return forward(router, pageEl, extend$2(options, newOptions));
      }

      function reject() {
        router.allowPageChange = true;
        return router;
      }

      if (url || componentUrl || component) {
        router.allowPageChange = false;
      } // Proceed


      if (content) {
        forward(router, router.getPageEl(content), options);
      } else if (el) {
        // Load page from specified HTMLElement or by page name in pages container
        forward(router, router.getPageEl(el), options);
      } else if (pageName) {
        // Load page by page name in pages container
        forward(router, router.$el.children(".page[data-name=\"" + pageName + "\"]").eq(0), options);
      } else if (component || componentUrl) {
        // Load from component (F7/Vue/React/...)
        try {
          router.pageComponentLoader({
            routerEl: router.el,
            component: component,
            componentUrl: componentUrl,
            options: options,
            resolve: resolve,
            reject: reject
          });
        } catch (err) {
          router.allowPageChange = true;
          throw err;
        }
      } else if (url) {
        // Load using XHR
        if (router.xhrAbortController) {
          router.xhrAbortController.abort();
          router.xhrAbortController = false;
        }

        router.xhrRequest(url, options).then(function (pageContent) {
          forward(router, router.getPageEl(pageContent), options);
        }).catch(function () {
          router.allowPageChange = true;
        });
      }

      return router;
    }

    function openIn(router, url, options) {
      var navigateOptions = {
        url: url,
        route: {
          path: url,
          options: _extends$6({}, options, {
            openIn: undefined
          })
        }
      };

      var params = _extends$6({}, options);

      if (options.openIn === 'popup') {
        params.content = "<div class=\"popup popup-router-open-in\" data-url=\"" + url + "\"><div class=\"view view-init\" data-links-view=\"" + router.view.selector + "\" data-url=\"" + url + "\" data-ignore-open-in=\"true\"></div></div>";
        navigateOptions.route.popup = params;
      }

      if (options.openIn === 'loginScreen') {
        params.content = "<div class=\"login-screen login-screen-router-open-in\" data-url=\"" + url + "\"><div class=\"view view-init\" data-links-view=\"" + router.view.selector + "\" data-url=\"" + url + "\" data-ignore-open-in=\"true\"></div></div>";
        navigateOptions.route.loginScreen = params;
      }

      if (options.openIn === 'sheet') {
        params.content = "<div class=\"sheet-modal sheet-modal-router-open-in\" data-url=\"" + url + "\"><div class=\"sheet-modal-inner\"><div class=\"view view-init\" data-links-view=\"" + router.view.selector + "\" data-url=\"" + url + "\" data-ignore-open-in=\"true\"></div></div></div>";
        navigateOptions.route.sheet = params;
      }

      if (options.openIn === 'popover') {
        params.targetEl = options.clickedEl || options.targetEl;
        params.content = "<div class=\"popover popover-router-open-in\" data-url=\"" + url + "\"><div class=\"popover-inner\"><div class=\"view view-init\" data-links-view=\"" + router.view.selector + "\" data-url=\"" + url + "\" data-ignore-open-in=\"true\"></div></div></div>";
        navigateOptions.route.popover = params;
      }

      if (options.openIn.indexOf('panel') >= 0) {
        var parts = options.openIn.split(':');
        var side = parts[1] || 'left';
        var effect = parts[2] || 'cover';
        params.targetEl = options.clickedEl || options.targetEl;
        params.content = "<div class=\"panel panel-router-open-in panel-" + side + " panel-" + effect + "\" data-url=\"" + url + "\"><div class=\"view view-init\" data-links-view=\"" + router.view.selector + "\" data-url=\"" + url + "\" data-ignore-open-in=\"true\"></div></div>";
        navigateOptions.route.panel = params;
      }

      return router.navigate(navigateOptions);
    }

    function navigate(navigateParams, navigateOptions) {
      if (navigateOptions === void 0) {
        navigateOptions = {};
      }

      var router = this;
      if (router.swipeBackActive) return router;
      var url;
      var createRoute;
      var name;
      var path;
      var query;
      var params;
      var route;

      if (typeof navigateParams === 'string') {
        url = navigateParams;
      } else {
        url = navigateParams.url;
        createRoute = navigateParams.route;
        name = navigateParams.name;
        path = navigateParams.path;
        query = navigateParams.query;
        params = navigateParams.params;
      }

      if (name || path) {
        url = router.generateUrl({
          path: path,
          name: name,
          params: params,
          query: query
        });

        if (url) {
          return router.navigate(url, navigateOptions);
        }

        return router;
      }

      var app = router.app;
      appRouterCheck(router, 'navigate');

      if (url === '#' || url === '') {
        return router;
      }

      var navigateUrl = url.replace('./', '');

      if (navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
        var currentPath = router.currentRoute.parentPath || router.currentRoute.path;
        navigateUrl = ((currentPath ? currentPath + "/" : '/') + navigateUrl).replace('///', '/').replace('//', '/');
      }

      if (createRoute) {
        route = extend$2(router.parseRouteUrl(navigateUrl), {
          route: extend$2({}, createRoute)
        });
      } else {
        route = router.findMatchingRoute(navigateUrl);
      }

      if (!route) {
        return router;
      }

      if (route.route && route.route.viewName) {
        var anotherViewName = route.route.viewName;
        var anotherView = app.views[anotherViewName];

        if (!anotherView) {
          throw new Error("Framework7: There is no View with \"" + anotherViewName + "\" name that was specified in this route");
        }

        if (anotherView !== router.view) {
          return anotherView.router.navigate(navigateParams, navigateOptions);
        }
      }

      if (route.route.redirect) {
        return redirect.call(router, 'forward', route, navigateOptions);
      }

      var options = {};

      if (route.route.options) {
        extend$2(options, route.route.options, navigateOptions);
      } else {
        extend$2(options, navigateOptions);
      }

      if (options.openIn && (!router.params.ignoreOpenIn || router.params.ignoreOpenIn && router.history.length > 0)) {
        return openIn(router, navigateUrl, options);
      }

      options.route = route;

      function resolve() {
        var routerLoaded = false;
        'popup popover sheet loginScreen actions customModal panel'.split(' ').forEach(function (modalLoadProp) {
          if (route.route[modalLoadProp] && !routerLoaded) {
            routerLoaded = true;
            router.modalLoad(modalLoadProp, route, options, 'forward');
          }
        });

        if (route.route.keepAlive && route.route.keepAliveData) {
          load(router, {
            el: route.route.keepAliveData.pageEl
          }, options, false);
          routerLoaded = true;
        }

        'url content component pageName el componentUrl'.split(' ').forEach(function (pageLoadProp) {
          if (route.route[pageLoadProp] && !routerLoaded) {
            var _load;

            routerLoaded = true;
            load(router, (_load = {}, _load[pageLoadProp] = route.route[pageLoadProp], _load), options, false);
          }
        });
        if (routerLoaded) return; // Async

        function asyncResolve(resolveParams, resolveOptions) {
          router.allowPageChange = false;
          var resolvedAsModal = false;
          'popup popover sheet loginScreen actions customModal panel'.split(' ').forEach(function (modalLoadProp) {
            if (resolveParams[modalLoadProp]) {
              resolvedAsModal = true;
              var modalRoute = extend$2({}, route, {
                route: resolveParams
              });
              router.allowPageChange = true;
              router.modalLoad(modalLoadProp, modalRoute, extend$2(options, resolveOptions), 'forward');
            }
          });
          if (resolvedAsModal) return;
          load(router, resolveParams, extend$2(options, resolveOptions), true);
        }

        function asyncReject() {
          router.allowPageChange = true;
        }

        if (route.route.async) {
          router.allowPageChange = false;
          route.route.async.call(router, {
            router: router,
            to: options.route,
            from: router.currentRoute,
            resolve: asyncResolve,
            reject: asyncReject,
            direction: 'forward',
            app: app
          });
        }

        if (route.route.asyncComponent) {
          asyncComponent(router, route.route.asyncComponent, asyncResolve, asyncReject);
        }
      }

      function reject() {
        router.allowPageChange = true;
      }

      if (router.params.masterDetailBreakpoint > 0 && route.route.masterRoute) {
        // load detail route
        var preloadMaster = true;
        var masterLoaded = false;

        if (router.currentRoute && router.currentRoute.route) {
          if ((router.currentRoute.route.master === true || typeof router.currentRoute.route.master === 'function' && router.currentRoute.route.master(app, router)) && (router.currentRoute.route === route.route.masterRoute || router.currentRoute.route.path === route.route.masterRoute.path)) {
            preloadMaster = false;
          }

          if (router.currentRoute.route.masterRoute && (router.currentRoute.route.masterRoute === route.route.masterRoute || router.currentRoute.route.masterRoute.path === route.route.masterRoute.path)) {
            preloadMaster = false;
            masterLoaded = true;
          }
        }

        if (preloadMaster || masterLoaded && navigateOptions.reloadAll) {
          router.navigate({
            path: route.route.masterRoute.path,
            params: route.params || {}
          }, {
            animate: false,
            reloadAll: navigateOptions.reloadAll,
            reloadCurrent: navigateOptions.reloadCurrent,
            reloadPrevious: navigateOptions.reloadPrevious,
            browserHistory: !navigateOptions.initial,
            history: !navigateOptions.initial,
            once: {
              pageAfterIn: function pageAfterIn() {
                router.navigate(navigateParams, extend$2({}, navigateOptions, {
                  animate: false,
                  reloadAll: false,
                  reloadCurrent: false,
                  reloadPrevious: false,
                  history: !navigateOptions.initial,
                  browserHistory: !navigateOptions.initial
                }));
              }
            }
          });
          return router;
        }
      }

      processRouteQueue.call(router, route, router.currentRoute, function () {
        if (route.route.modules) {
          app.loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules]).then(function () {
            resolve();
          }).catch(function () {
            reject();
          });
        } else {
          resolve();
        }
      }, function () {
        reject();
      }, 'forward'); // Return Router

      return router;
    }

    function tabLoad(tabRoute, loadOptions) {
      if (loadOptions === void 0) {
        loadOptions = {};
      }

      var router = this;
      var options = extend$2({
        animate: router.params.animate,
        browserHistory: true,
        history: true,
        parentPageEl: null,
        preload: false,
        on: {}
      }, loadOptions);
      var currentRoute;
      var previousRoute;

      if (options.route) {
        // Set Route
        if (!options.preload && options.route !== router.currentRoute) {
          previousRoute = router.previousRoute;
          router.currentRoute = options.route;
        }

        if (options.preload) {
          currentRoute = options.route;
          previousRoute = router.currentRoute;
        } else {
          currentRoute = router.currentRoute;
          if (!previousRoute) previousRoute = router.previousRoute;
        } // Update Browser History


        if (router.params.browserHistory && options.browserHistory && !options.reloadPrevious) {
          History$1.replace(router.view.id, {
            url: options.route.url
          }, (router.params.browserHistoryRoot || '') + router.params.browserHistorySeparator + options.route.url);
        } // Update Router History


        if (options.history) {
          router.history[Math.max(router.history.length - 1, 0)] = options.route.url;
          router.saveHistory();
        }
      } // Show Tab


      var $parentPageEl = $(options.parentPageEl || router.currentPageEl);
      var tabEl;

      if ($parentPageEl.length && $parentPageEl.find("#" + tabRoute.id).length) {
        tabEl = $parentPageEl.find("#" + tabRoute.id).eq(0);
      } else if (router.view.selector) {
        tabEl = router.view.selector + " #" + tabRoute.id;
      } else {
        tabEl = "#" + tabRoute.id;
      }

      var tabShowResult = router.app.tab.show({
        tabEl: tabEl,
        animate: options.animate,
        tabRoute: options.route
      });
      var $newTabEl = tabShowResult.$newTabEl,
          $oldTabEl = tabShowResult.$oldTabEl,
          animated = tabShowResult.animated,
          onTabsChanged = tabShowResult.onTabsChanged;

      if ($newTabEl && $newTabEl.parents('.page').length > 0 && options.route) {
        var tabParentPageData = $newTabEl.parents('.page')[0].f7Page;

        if (tabParentPageData && options.route) {
          tabParentPageData.route = options.route;
        }
      } // Tab Content Loaded


      function onTabLoaded(contentEl) {
        // Remove theme elements
        router.removeThemeElements($newTabEl);
        var tabEventTarget = $newTabEl;
        if (typeof contentEl !== 'string') tabEventTarget = $(contentEl);
        tabEventTarget.trigger('tab:init tab:mounted', tabRoute);
        router.emit('tabInit tabMounted', $newTabEl[0], tabRoute);

        if ($oldTabEl && $oldTabEl.length) {
          if (animated) {
            onTabsChanged(function () {
              router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

              if (router.params.unloadTabContent) {
                router.tabRemove($oldTabEl, $newTabEl, tabRoute);
              }
            });
          } else {
            router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

            if (router.params.unloadTabContent) {
              router.tabRemove($oldTabEl, $newTabEl, tabRoute);
            }
          }
        }
      }

      if ($newTabEl[0].f7RouterTabLoaded) {
        if (!$oldTabEl || !$oldTabEl.length) return router;

        if (animated) {
          onTabsChanged(function () {
            router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
          });
        } else {
          router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
        }

        return router;
      } // Load Tab Content


      function loadTab(loadTabParams, loadTabOptions) {
        // Load Tab Props
        var url = loadTabParams.url,
            content = loadTabParams.content,
            el = loadTabParams.el,
            component = loadTabParams.component,
            componentUrl = loadTabParams.componentUrl; // Component/Template Callbacks

        function resolve(contentEl) {
          router.allowPageChange = true;
          if (!contentEl) return;

          if (typeof contentEl === 'string') {
            $newTabEl.html(contentEl);
          } else {
            $newTabEl.html('');

            if (contentEl.f7Component) {
              contentEl.f7Component.mount(function (componentEl) {
                $newTabEl.append(componentEl);
              });
            } else {
              $newTabEl.append(contentEl);
            }
          }

          $newTabEl[0].f7RouterTabLoaded = true;
          onTabLoaded(contentEl);
        }

        function reject() {
          router.allowPageChange = true;
          return router;
        }

        if (content) {
          resolve(content);
        } else if (el) {
          resolve(el);
        } else if (component || componentUrl) {
          // Load from component (F7/Vue/React/...)
          try {
            router.tabComponentLoader({
              tabEl: $newTabEl[0],
              component: component,
              componentUrl: componentUrl,
              options: loadTabOptions,
              resolve: resolve,
              reject: reject
            });
          } catch (err) {
            router.allowPageChange = true;
            throw err;
          }
        } else if (url) {
          // Load using XHR
          if (router.xhrAbortController) {
            router.xhrAbortController.abort();
            router.xhrAbortController = false;
          }

          router.xhrRequest(url, loadTabOptions).then(function (tabContent) {
            resolve(tabContent);
          }).catch(function () {
            router.allowPageChange = true;
          });
        }
      }

      var hasContentLoadProp;
      'url content component el componentUrl'.split(' ').forEach(function (tabLoadProp) {
        if (tabRoute[tabLoadProp]) {
          var _loadTab;

          hasContentLoadProp = true;
          loadTab((_loadTab = {}, _loadTab[tabLoadProp] = tabRoute[tabLoadProp], _loadTab), options);
        }
      }); // Async

      function asyncResolve(resolveParams, resolveOptions) {
        loadTab(resolveParams, extend$2(options, resolveOptions));
      }

      function asyncReject() {
        router.allowPageChange = true;
      }

      if (tabRoute.async) {
        tabRoute.async.call(router, {
          router: router,
          to: currentRoute,
          from: previousRoute,
          resolve: asyncResolve,
          reject: asyncReject,
          app: router.app
        });
      } else if (tabRoute.asyncComponent) {
        asyncComponent(router, tabRoute.asyncComponent, asyncResolve, asyncReject);
      } else if (!hasContentLoadProp) {
        router.allowPageChange = true;
      }

      return router;
    }

    function tabRemove($oldTabEl, $newTabEl, tabRoute) {
      var router = this;
      var hasTabComponentChild;

      if ($oldTabEl[0]) {
        $oldTabEl[0].f7RouterTabLoaded = false;
        delete $oldTabEl[0].f7RouterTabLoaded;
      }

      $oldTabEl.children().each(function (tabChild) {
        if (tabChild.f7Component) {
          hasTabComponentChild = true;
          $(tabChild).trigger('tab:beforeremove', tabRoute);
          tabChild.f7Component.destroy();
        }
      });

      if (!hasTabComponentChild) {
        $oldTabEl.trigger('tab:beforeremove', tabRoute);
      }

      router.emit('tabBeforeRemove', $oldTabEl[0], $newTabEl[0], tabRoute);
      router.removeTabContent($oldTabEl[0], tabRoute);
    }

    function modalLoad(modalType, route, loadOptions, direction) {
      if (loadOptions === void 0) {
        loadOptions = {};
      }

      var router = this;
      var app = router.app;
      var isPanel = modalType === 'panel';
      var modalOrPanel = isPanel ? 'panel' : 'modal';
      var options = extend$2({
        animate: router.params.animate,
        browserHistory: true,
        history: true,
        on: {},
        once: {}
      }, loadOptions);
      var modalParams = extend$2({}, route.route[modalType]);
      var modalRoute = route.route;

      var routeCallback = function routeCallback(modal, name) {
        var on = options.on,
            once = options.once;
        var callback;

        if (name === 'open') {
          callback = on.modalOpen || once.modalOpen || on.panelOpen || once.panelOpen;
        }

        if (name === 'close') {
          callback = on.modalClose || once.modalClose || on.panelClose || once.panelClose;
        }

        if (name === 'closed') {
          callback = on.modalClosed || once.modalClosed || on.panelClosed || once.panelClosed;
        }

        if (callback) callback(modal);
      };

      function onModalLoaded() {
        // Create Modal
        var modal = app[modalType].create(modalParams);
        modalRoute.modalInstance = modal;
        var hasEl = modal.el;

        function closeOnSwipeBack() {
          modal.close();
        }

        modal.on(modalOrPanel + "Open", function () {
          if (!hasEl) {
            // Remove theme elements
            router.removeThemeElements(modal.el); // Emit events

            modal.$el.trigger(modalType.toLowerCase() + ":init " + modalType.toLowerCase() + ":mounted", route, modal);
            router.emit((!isPanel ? 'modalInit' : '') + " " + modalType + "Init " + modalType + "Mounted", modal.el, route, modal);
          }

          router.once('swipeBackMove', closeOnSwipeBack);
          routeCallback(modal, 'open');
        });
        modal.on(modalOrPanel + "Close", function () {
          router.off('swipeBackMove', closeOnSwipeBack);

          if (!modal.closeByRouter) {
            router.back();
          }

          routeCallback(modal, 'close');
        });
        modal.on(modalOrPanel + "Closed", function () {
          modal.$el.trigger(modalType.toLowerCase() + ":beforeremove", route, modal);
          modal.emit("" + (!isPanel ? 'modalBeforeRemove ' : '') + modalType + "BeforeRemove", modal.el, route, modal);
          var modalComponent = modal.el.f7Component;
          routeCallback(modal, 'closed');

          if (modalComponent) {
            modalComponent.destroy();
          }

          nextTick$1(function () {
            if (modalComponent || modalParams.component || modalParams.asyncComponent) {
              router.removeModal(modal.el);
            }

            modal.destroy();
            delete modal.route;
            delete modalRoute.modalInstance;
          });
        });

        if (options.route) {
          // Update Browser History
          if (router.params.browserHistory && options.browserHistory) {
            History$1.push(router.view.id, {
              url: options.route.url,
              modal: modalType
            }, (router.params.browserHistoryRoot || '') + router.params.browserHistorySeparator + options.route.url);
          } // Set Route


          if (options.route !== router.currentRoute) {
            modal.route = extend$2(options.route, {
              modal: modal
            });
            router.currentRoute = modal.route;
          } // Update Router History


          if (options.history && !options.reloadCurrent) {
            router.history.push(options.route.url);
            router.saveHistory();
          }
        }

        if (hasEl) {
          // Remove theme elements
          router.removeThemeElements(modal.el); // Emit events

          modal.$el.trigger(modalType.toLowerCase() + ":init " + modalType.toLowerCase() + ":mounted", route, modal);
          router.emit(modalOrPanel + "Init " + modalType + "Init " + modalType + "Mounted", modal.el, route, modal);
        } // Open


        modal.open(options.animate === false || options.animate === true ? options.animate : undefined);
      } // Load Modal Content


      function loadModal(loadModalParams, loadModalOptions) {
        // Load Modal Props
        var url = loadModalParams.url,
            content = loadModalParams.content,
            component = loadModalParams.component,
            componentUrl = loadModalParams.componentUrl; // Component/Template Callbacks

        function resolve(contentEl) {
          if (contentEl) {
            if (typeof contentEl === 'string') {
              modalParams.content = contentEl;
            } else if (contentEl.f7Component) {
              contentEl.f7Component.mount(function (componentEl) {
                modalParams.el = componentEl;
                app.$el.append(componentEl);
              });
            } else {
              modalParams.el = contentEl;
            }

            onModalLoaded();
          }
        }

        function reject() {
          router.allowPageChange = true;
          return router;
        }

        if (content) {
          resolve(content);
        } else if (component || componentUrl) {
          // Load from component (F7/Vue/React/...)
          try {
            router.modalComponentLoader({
              rootEl: app.el,
              component: component,
              componentUrl: componentUrl,
              options: loadModalOptions,
              resolve: resolve,
              reject: reject
            });
          } catch (err) {
            router.allowPageChange = true;
            throw err;
          }
        } else if (url) {
          // Load using XHR
          if (router.xhrAbortController) {
            router.xhrAbortController.abort();
            router.xhrAbortController = false;
          }

          router.xhrRequest(url, loadModalOptions).then(function (modalContent) {
            modalParams.content = modalContent;
            onModalLoaded();
          }).catch(function () {
            router.allowPageChange = true;
          });
        } else {
          onModalLoaded();
        }
      }

      var foundLoadProp;
      'url content component el componentUrl template'.split(' ').forEach(function (modalLoadProp) {
        if (modalParams[modalLoadProp] && !foundLoadProp) {
          var _loadModal;

          foundLoadProp = true;
          loadModal((_loadModal = {}, _loadModal[modalLoadProp] = modalParams[modalLoadProp], _loadModal), options);
        }
      });

      if (!foundLoadProp && modalType === 'actions') {
        onModalLoaded();
      } // Async


      function asyncResolve(resolveParams, resolveOptions) {
        loadModal(resolveParams, extend$2(options, resolveOptions));
      }

      function asyncReject() {
        router.allowPageChange = true;
      }

      if (modalParams.async) {
        modalParams.async.call(router, {
          router: router,
          to: options.route,
          from: router.currentRoute,
          resolve: asyncResolve,
          reject: asyncReject,
          direction: direction,
          app: app
        });
      }

      if (modalParams.asyncComponent) {
        asyncComponent(router, modalParams.asyncComponent, asyncResolve, asyncReject);
      }

      return router;
    }

    function modalRemove(modal) {
      extend$2(modal, {
        closeByRouter: true
      });
      modal.close();
    }

    function backward(router, el, backwardOptions) {
      var device = getDevice$1();
      var document = getDocument();
      var $el = $(el);
      var app = router.app;
      var view = router.view;
      var options = extend$2({
        animate: router.params.animate,
        browserHistory: true,
        replaceState: false
      }, backwardOptions);
      var masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
      var isMaster = masterDetailEnabled && options.route && options.route.route && (options.route.route.master === true || typeof options.route.route.master === 'function' && options.route.route.master(app, router));
      var masterPageEl;
      var masterPageRemoved;
      var dynamicNavbar = router.dynamicNavbar;
      var $newPage = $el;
      var $oldPage = router.$el.children('.page-current');
      var initialPreload = $oldPage.length === 0 && options.preload;
      var currentIsMaster = masterDetailEnabled && $oldPage.hasClass('page-master');

      if ($newPage.length) {
        // Remove theme elements
        router.removeThemeElements($newPage);
      }

      var $navbarsEl;
      var $newNavbarEl;
      var $oldNavbarEl;

      if (dynamicNavbar) {
        $newNavbarEl = $newPage.children('.navbar');
        $navbarsEl = router.$navbarsEl;

        if ($newNavbarEl.length === 0 && $newPage[0] && $newPage[0].f7Page) {
          // Try from pageData
          $newNavbarEl = $newPage[0].f7Page.$navbarEl;
        }

        $oldNavbarEl = $navbarsEl.find('.navbar-current');
      }

      router.allowPageChange = false;

      if ($newPage.length === 0 || $oldPage.length === 0 && !options.preload) {
        router.allowPageChange = true;
        return router;
      } // Remove theme elements


      router.removeThemeElements($newPage); // Save Keep Alive Cache

      if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
        options.route.route.keepAliveData = {
          pageEl: $el[0]
        };
      } // Pages In View


      var isDetail;
      var isDetailRoot;

      if (masterDetailEnabled) {
        var $pagesInView = router.$el.children('.page:not(.stacked)').filter(function (pageInView) {
          return pageInView !== $newPage[0];
        }); // Find Detail' master page

        for (var i = 0; i < $pagesInView.length; i += 1) {
          if (!masterPageEl && $pagesInView[i].classList.contains('page-master')) {
            masterPageEl = $pagesInView[i];
            continue; // eslint-disable-line
          }
        }

        isDetail = !isMaster && masterPageEl && router.history.indexOf(options.route.url) > router.history.indexOf(masterPageEl.f7Page.route.url);

        if (!isDetail && !isMaster && masterPageEl && masterPageEl.f7Page && options.route.route.masterRoute) {
          isDetail = options.route.route.masterRoute.path === masterPageEl.f7Page.route.route.path;
        }
      }

      if (isDetail && masterPageEl && masterPageEl.f7Page) {
        isDetailRoot = router.history.indexOf(options.route.url) - router.history.indexOf(masterPageEl.f7Page.route.url) === 1;
      } // New Page


      $newPage.addClass("page-" + (initialPreload ? 'current' : 'previous') + (isMaster ? ' page-master' : '') + (isDetail ? ' page-master-detail' : '') + (isDetailRoot ? ' page-master-detail-root' : '')).removeClass('stacked').removeAttr('aria-hidden').trigger('page:unstack').trigger('page:position', {
        position: initialPreload ? 'current' : 'previous'
      });
      router.emit('pageUnstack', $newPage[0]);
      router.emit('pagePosition', $newPage[0], initialPreload ? 'current' : 'previous');

      if (isMaster || isDetail) {
        $newPage.trigger('page:role', {
          role: isMaster ? 'master' : 'detail',
          root: !!isDetailRoot
        });
        router.emit('pageRole', $newPage[0], {
          role: isMaster ? 'master' : 'detail',
          detailRoot: !!isDetailRoot
        });
      }

      if (dynamicNavbar && $newNavbarEl.length > 0) {
        $newNavbarEl.addClass("navbar-" + (initialPreload ? 'current' : 'previous') + (isMaster ? ' navbar-master' : '') + (isDetail ? ' navbar-master-detail' : '') + (isDetailRoot ? ' navbar-master-detail-root' : '')).removeClass('stacked').removeAttr('aria-hidden');
        $newNavbarEl.trigger('navbar:position', {
          position: initialPreload ? 'current' : 'previous'
        });
        router.emit('navbarPosition', $newNavbarEl[0], initialPreload ? 'current' : 'previous');

        if (isMaster || isDetailRoot) {
          router.emit('navbarRole', $newNavbarEl[0], {
            role: isMaster ? 'master' : 'detail',
            detailRoot: !!isDetailRoot
          });
        }
      } // Remove previous page in case of "forced"


      var backIndex;

      if (options.force) {
        if ($oldPage.prev('.page-previous:not(.stacked)').length > 0 || $oldPage.prev('.page-previous').length === 0) {
          if (router.history.indexOf(options.route.url) >= 0) {
            backIndex = router.history.length - router.history.indexOf(options.route.url) - 1;
            router.history = router.history.slice(0, router.history.indexOf(options.route.url) + 2);
            view.history = router.history;
          } else if (router.history[[router.history.length - 2]]) {
            router.history[router.history.length - 2] = options.route.url;
          } else {
            router.history.unshift(router.url);
          }

          if (backIndex && router.params.stackPages) {
            $oldPage.prevAll('.page-previous').each(function (pageToRemove) {
              var $pageToRemove = $(pageToRemove);
              var $navbarToRemove;

              if (dynamicNavbar) {
                // $navbarToRemove = $oldNavbarEl.prevAll('.navbar-previous').eq(index);
                $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
              }

              if ($pageToRemove[0] !== $newPage[0] && $pageToRemove.index() > $newPage.index()) {
                if (router.initialPages.indexOf($pageToRemove[0]) >= 0) {
                  $pageToRemove.addClass('stacked');
                  $pageToRemove.trigger('page:stack');
                  router.emit('pageStack', $pageToRemove[0]);

                  if (dynamicNavbar) {
                    $navbarToRemove.addClass('stacked');
                  }
                } else {
                  router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);

                  if ($pageToRemove[0] === masterPageEl) {
                    masterPageRemoved = true;
                  }

                  router.removePage($pageToRemove);

                  if (dynamicNavbar && $navbarToRemove.length > 0) {
                    router.removeNavbar($navbarToRemove);
                  }
                }
              }
            });
          } else {
            var $pageToRemove = $oldPage.prev('.page-previous:not(.stacked)');
            var $navbarToRemove;

            if (dynamicNavbar) {
              // $navbarToRemove = $oldNavbarEl.prev('.navbar-inner:not(.stacked)');
              $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
            }

            if (router.params.stackPages && router.initialPages.indexOf($pageToRemove[0]) >= 0) {
              $pageToRemove.addClass('stacked');
              $pageToRemove.trigger('page:stack');
              router.emit('pageStack', $pageToRemove[0]);
              $navbarToRemove.addClass('stacked');
            } else if ($pageToRemove.length > 0) {
              router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);

              if ($pageToRemove[0] === masterPageEl) {
                masterPageRemoved = true;
              }

              router.removePage($pageToRemove);

              if (dynamicNavbar && $navbarToRemove.length) {
                router.removeNavbar($navbarToRemove);
              }
            }
          }
        }
      } // Insert new page


      var newPageInDom = $newPage.parents(document).length > 0;
      var f7Component = $newPage[0].f7Component;

      function insertPage() {
        if (initialPreload) {
          if (!newPageInDom && f7Component) {
            f7Component.mount(function (componentEl) {
              router.$el.append(componentEl);
            });
          } else {
            router.$el.append($newPage);
          }
        }

        if ($newPage.next($oldPage).length === 0) {
          if (!newPageInDom && f7Component) {
            f7Component.mount(function (componentEl) {
              $(componentEl).insertBefore($oldPage);
            });
          } else {
            $newPage.insertBefore($oldPage);
          }
        }

        if (dynamicNavbar && $newNavbarEl.length) {
          if ($newNavbarEl.find('.title-large').length) {
            $newNavbarEl.addClass('navbar-large');
          }

          $newNavbarEl.insertBefore($oldNavbarEl);

          if ($oldNavbarEl.length > 0) {
            $newNavbarEl.insertBefore($oldNavbarEl);
          } else {
            if (!router.$navbarsEl.parents(document).length) {
              router.$el.prepend(router.$navbarsEl);
            }

            $navbarsEl.append($newNavbarEl);
          }
        }

        if (!newPageInDom) {
          router.pageCallback('mounted', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);
        } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
          $newPage[0].f7PageMounted = true;
          router.pageCallback('mounted', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);
        }
      }

      if (options.preload) {
        // Insert Page
        insertPage(); // Tab route

        if (options.route.route.tab) {
          router.tabLoad(options.route.route.tab, extend$2({}, options, {
            history: false,
            browserHistory: false,
            preload: true
          }));
        }

        if (isMaster) {
          $newPage.removeClass('page-master-stacked').trigger('page:masterunstack');
          router.emit('pageMasterUnstack', $newPage[0]);

          if (dynamicNavbar) {
            $(app.navbar.getElByPage($newPage)).removeClass('navbar-master-stacked');
            router.emit('navbarMasterUnstack', app.navbar.getElByPage($newPage));
          }
        } // Page init and before init events


        router.pageCallback('init', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);

        if (initialPreload) {
          router.pageCallback('beforeIn', $newPage, $newNavbarEl, 'current', undefined, options);
          router.pageCallback('afterIn', $newPage, $newNavbarEl, 'current', undefined, options);
        }

        var $previousPages = $newPage.prevAll('.page-previous:not(.stacked):not(.page-master)');

        if ($previousPages.length > 0) {
          $previousPages.each(function (pageToRemove) {
            var $pageToRemove = $(pageToRemove);
            var $navbarToRemove;

            if (dynamicNavbar) {
              // $navbarToRemove = $newNavbarEl.prevAll('.navbar-previous:not(.stacked)').eq(index);
              $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
            }

            if (router.params.stackPages && router.initialPages.indexOf(pageToRemove) >= 0) {
              $pageToRemove.addClass('stacked');
              $pageToRemove.trigger('page:stack');
              router.emit('pageStack', $pageToRemove[0]);

              if (dynamicNavbar) {
                $navbarToRemove.addClass('stacked');
              }
            } else {
              router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined);
              router.removePage($pageToRemove);

              if (dynamicNavbar && $navbarToRemove.length) {
                router.removeNavbar($navbarToRemove);
              }
            }
          });
        }

        router.allowPageChange = true;
        return router;
      } // History State


      if (!(device.ie || device.edge || device.firefox && !device.ios)) {
        if (router.params.browserHistory && options.browserHistory) {
          if (options.replaceState) {
            var browserHistoryRoot = router.params.browserHistoryRoot || '';
            History$1.replace(view.id, {
              url: options.route.url
            }, browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
          } else if (backIndex) {
            History$1.go(-backIndex);
          } else {
            History$1.back();
          }
        }
      } // Update History


      if (options.replaceState) {
        router.history[router.history.length - 1] = options.route.url;
      } else {
        if (router.history.length === 1) {
          router.history.unshift(router.url);
        }

        router.history.pop();
      }

      router.saveHistory(); // Current Page & Navbar

      router.currentPageEl = $newPage[0];

      if (dynamicNavbar && $newNavbarEl.length) {
        router.currentNavbarEl = $newNavbarEl[0];
      } else {
        delete router.currentNavbarEl;
      } // Current Route


      router.currentRoute = options.route; // History State

      if (device.ie || device.edge || device.firefox && !device.ios) {
        if (router.params.browserHistory && options.browserHistory) {
          if (options.replaceState) {
            var _browserHistoryRoot = router.params.browserHistoryRoot || '';

            History$1.replace(view.id, {
              url: options.route.url
            }, _browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
          } else if (backIndex) {
            History$1.go(-backIndex);
          } else {
            History$1.back();
          }
        }
      } // Insert Page


      insertPage(); // Load Tab

      if (options.route.route.tab) {
        router.tabLoad(options.route.route.tab, extend$2({}, options, {
          history: false,
          browserHistory: false
        }));
      } // Check master detail


      if (masterDetailEnabled && (currentIsMaster || masterPageRemoved)) {
        view.checkMasterDetailBreakpoint(false);
      } // Page init and before init events


      router.pageCallback('init', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage); // Before animation callback

      router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', 'next', options);
      router.pageCallback('beforeIn', $newPage, $newNavbarEl, 'previous', 'current', options); // Animation

      function afterAnimation() {
        // Set classes
        router.setPagePosition($newPage, 'current', false);
        router.setPagePosition($oldPage, 'next', true);

        if (dynamicNavbar) {
          router.setNavbarPosition($newNavbarEl, 'current', false);
          router.setNavbarPosition($oldNavbarEl, 'next', true);
        } // After animation event


        router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', 'next', options);
        router.pageCallback('afterIn', $newPage, $newNavbarEl, 'previous', 'current', options); // Remove Old Page

        if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
          $oldPage.addClass('stacked');
          $oldPage.trigger('page:stack');
          router.emit('pageStack', $oldPage[0]);

          if (dynamicNavbar) {
            $oldNavbarEl.addClass('stacked');
          }
        } else {
          router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'next', undefined, options);
          router.removePage($oldPage);

          if (dynamicNavbar && $oldNavbarEl.length) {
            router.removeNavbar($oldNavbarEl);
          }
        }

        router.allowPageChange = true;
        router.emit('routeChanged', router.currentRoute, router.previousRoute, router); // Preload previous page

        var preloadPreviousPage = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];

        if (preloadPreviousPage && router.history[router.history.length - 2] && !isMaster) {
          router.back(router.history[router.history.length - 2], {
            preload: true
          });
        }

        if (router.params.browserHistory) {
          History$1.clearRouterQueue();
        }
      }

      function setPositionClasses() {
        router.setPagePosition($oldPage, 'current');
        router.setPagePosition($newPage, 'previous', false);

        if (dynamicNavbar) {
          router.setNavbarPosition($oldNavbarEl, 'current');
          router.setNavbarPosition($newNavbarEl, 'previous', false);
        }
      }

      if (options.animate && !(currentIsMaster && app.width >= router.params.masterDetailBreakpoint)) {
        var transition = router.params.transition;

        if ($oldPage[0] && $oldPage[0].f7PageTransition) {
          transition = $oldPage[0].f7PageTransition;
          delete $oldPage[0].f7PageTransition;
        }

        if (options.transition) transition = options.transition;

        if (!transition && router.previousRoute && router.previousRoute.route) {
          transition = router.previousRoute.route.transition;
        }

        if (!transition && router.previousRoute && router.previousRoute.route && router.previousRoute.route.options) {
          transition = router.previousRoute.route.options.transition;
        }

        setPositionClasses();
        router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'backward', transition, function () {
          afterAnimation();
        });
      } else {
        afterAnimation();
      }

      return router;
    }

    function loadBack(router, backParams, backOptions, ignorePageChange) {
      if (!router.allowPageChange && !ignorePageChange) return router;
      var params = backParams;
      var options = backOptions;
      var url = params.url,
          content = params.content,
          el = params.el,
          pageName = params.pageName,
          component = params.component,
          componentUrl = params.componentUrl;

      if (options.route.url && router.url === options.route.url && !(options.reloadCurrent || options.reloadPrevious) && !router.params.allowDuplicateUrls) {
        return false;
      }

      if (!options.route && url) {
        options.route = router.parseRouteUrl(url);
      } // Component Callbacks


      function resolve(pageEl, newOptions) {
        return backward(router, pageEl, extend$2(options, newOptions));
      }

      function reject() {
        router.allowPageChange = true;
        return router;
      }

      if (url || componentUrl || component) {
        router.allowPageChange = false;
      } // Proceed


      if (content) {
        backward(router, router.getPageEl(content), options);
      } else if (el) {
        // Load page from specified HTMLElement or by page name in pages container
        backward(router, router.getPageEl(el), options);
      } else if (pageName) {
        // Load page by page name in pages container
        backward(router, router.$el.children(".page[data-name=\"" + pageName + "\"]").eq(0), options);
      } else if (component || componentUrl) {
        // Load from component (F7/Vue/React/...)
        try {
          router.pageComponentLoader({
            routerEl: router.el,
            component: component,
            componentUrl: componentUrl,
            options: options,
            resolve: resolve,
            reject: reject
          });
        } catch (err) {
          router.allowPageChange = true;
          throw err;
        }
      } else if (url) {
        // Load using XHR
        if (router.xhrAbortController) {
          router.xhrAbortController.abort();
          router.xhrAbortController = false;
        }

        router.xhrRequest(url, options).then(function (pageContent) {
          backward(router, router.getPageEl(pageContent), options);
        }).catch(function () {
          router.allowPageChange = true;
        });
      }

      return router;
    }

    function back() {
      var router = this;
      var device = getDevice$1();
      if (router.swipeBackActive) return router;
      var navigateUrl;
      var navigateOptions;
      var route;

      if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'object') {
        navigateOptions = (arguments.length <= 0 ? undefined : arguments[0]) || {};
      } else {
        navigateUrl = arguments.length <= 0 ? undefined : arguments[0];
        navigateOptions = (arguments.length <= 1 ? undefined : arguments[1]) || {};
      }

      var _navigateOptions = navigateOptions,
          name = _navigateOptions.name,
          params = _navigateOptions.params,
          query = _navigateOptions.query;

      if (name) {
        navigateUrl = router.generateUrl({
          name: name,
          params: params,
          query: query
        });

        if (navigateUrl) {
          return router.back(navigateUrl, extend$2({}, navigateOptions, {
            name: null,
            params: null,
            query: null
          }));
        }

        return router;
      }

      var app = router.app;
      appRouterCheck(router, 'back');
      var currentRouteIsModal = router.currentRoute.modal;
      var modalType;

      if (!currentRouteIsModal) {
        'popup popover sheet loginScreen actions customModal panel'.split(' ').forEach(function (modalLoadProp) {
          if (router.currentRoute.route[modalLoadProp]) {
            currentRouteIsModal = true;
            modalType = modalLoadProp;
          }
        });
      }

      if (currentRouteIsModal && !navigateOptions.preload) {
        var modalToClose = router.currentRoute.modal || router.currentRoute.route.modalInstance || app[modalType].get();
        var previousUrl = router.history[router.history.length - 2];
        var previousRoute; // check if previous route is modal too

        if (modalToClose && modalToClose.$el) {
          var prevOpenedModals = modalToClose.$el.prevAll('.modal-in');

          if (prevOpenedModals.length && prevOpenedModals[0].f7Modal) {
            var modalEl = prevOpenedModals[0]; // check if current router not inside of the modalEl

            if (!router.$el.parents(modalEl).length) {
              previousRoute = modalEl.f7Modal.route;
            }
          }
        }

        if (!previousRoute) {
          previousRoute = router.findMatchingRoute(previousUrl);
        }

        if (!previousRoute && previousUrl) {
          previousRoute = {
            url: previousUrl,
            path: previousUrl.split('?')[0],
            query: parseUrlQuery(previousUrl),
            route: {
              path: previousUrl.split('?')[0],
              url: previousUrl
            }
          };
        }

        if (!navigateUrl || navigateUrl.replace(/[# ]/g, '').trim().length === 0) {
          if (!previousRoute || !modalToClose) {
            return router;
          }
        }

        var forceOtherUrl = navigateOptions.force && previousRoute && navigateUrl;

        if (previousRoute && modalToClose) {
          var isBrokenBrowserHistory = device.ie || device.edge || device.firefox && !device.ios;
          var needHistoryBack = router.params.browserHistory && navigateOptions.browserHistory !== false;
          var currentRouteWithoutBrowserHistory = router.currentRoute && router.currentRoute.route && router.currentRoute.route.options && router.currentRoute.route.options.browserHistory === false;

          if (needHistoryBack && !isBrokenBrowserHistory && !currentRouteWithoutBrowserHistory) {
            History$1.back();
          }

          router.currentRoute = previousRoute;
          router.history.pop();
          router.saveHistory();

          if (needHistoryBack && isBrokenBrowserHistory && !currentRouteWithoutBrowserHistory) {
            History$1.back();
          }

          router.modalRemove(modalToClose);

          if (forceOtherUrl) {
            router.navigate(navigateUrl, {
              reloadCurrent: true
            });
          }
        } else if (modalToClose) {
          router.modalRemove(modalToClose);

          if (navigateUrl) {
            router.navigate(navigateUrl, {
              reloadCurrent: true
            });
          }
        }

        return router;
      }

      var $previousPage = router.$el.children('.page-current').prevAll('.page-previous:not(.page-master)').eq(0);
      var skipMaster;

      if (router.params.masterDetailBreakpoint > 0) {
        var classes = [];
        router.$el.children('.page').each(function (pageEl) {
          classes.push(pageEl.className);
        });
        var $previousMaster = router.$el.children('.page-current').prevAll('.page-master').eq(0);

        if ($previousMaster.length) {
          var expectedPreviousPageUrl = router.history[router.history.length - 2];
          var expectedPreviousPageRoute = router.findMatchingRoute(expectedPreviousPageUrl);

          if (expectedPreviousPageRoute && $previousMaster[0].f7Page && expectedPreviousPageRoute.route === $previousMaster[0].f7Page.route.route) {
            $previousPage = $previousMaster;

            if (!navigateOptions.preload) {
              skipMaster = app.width >= router.params.masterDetailBreakpoint;
            }
          }
        }
      }

      if (!navigateOptions.force && $previousPage.length && !skipMaster) {
        if (router.params.browserHistory && $previousPage[0].f7Page && router.history[router.history.length - 2] !== $previousPage[0].f7Page.route.url) {
          router.back(router.history[router.history.length - 2], extend$2(navigateOptions, {
            force: true
          }));
          return router;
        }

        var previousPageRoute = $previousPage[0].f7Page.route;
        processRouteQueue.call(router, previousPageRoute, router.currentRoute, function () {
          loadBack(router, {
            el: $previousPage
          }, extend$2(navigateOptions, {
            route: previousPageRoute
          }));
        }, function () {}, 'backward');
        return router;
      } // Navigate URL


      if (navigateUrl === '#') {
        navigateUrl = undefined;
      }

      if (navigateUrl && navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
        navigateUrl = ((router.path || '/') + navigateUrl).replace('//', '/');
      }

      if (!navigateUrl && router.history.length > 1) {
        navigateUrl = router.history[router.history.length - 2];
      }

      if (skipMaster && !navigateOptions.force && router.history[router.history.length - 3]) {
        return router.back(router.history[router.history.length - 3], extend$2({}, navigateOptions || {}, {
          force: true,
          animate: false
        }));
      }

      if (skipMaster && !navigateOptions.force) {
        return router;
      } // Find route to load


      route = router.findMatchingRoute(navigateUrl);

      if (!route) {
        if (navigateUrl) {
          route = {
            url: navigateUrl,
            path: navigateUrl.split('?')[0],
            query: parseUrlQuery(navigateUrl),
            route: {
              path: navigateUrl.split('?')[0],
              url: navigateUrl
            }
          };
        }
      }

      if (!route) {
        return router;
      }

      if (route.route.redirect) {
        return redirect.call(router, 'backward', route, navigateOptions);
      }

      var options = {};

      if (route.route.options) {
        extend$2(options, route.route.options, navigateOptions);
      } else {
        extend$2(options, navigateOptions);
      }

      options.route = route;
      var backForceLoaded;

      if (options.force && router.params.stackPages) {
        router.$el.children('.page-previous.stacked').each(function (pageEl) {
          if (pageEl.f7Page && pageEl.f7Page.route && pageEl.f7Page.route.url === route.url) {
            backForceLoaded = true;
            loadBack(router, {
              el: pageEl
            }, options);
          }
        });

        if (backForceLoaded) {
          return router;
        }
      }

      function resolve() {
        var routerLoaded = false;

        if (route.route.keepAlive && route.route.keepAliveData) {
          loadBack(router, {
            el: route.route.keepAliveData.pageEl
          }, options);
          routerLoaded = true;
        }

        'url content component pageName el componentUrl'.split(' ').forEach(function (pageLoadProp) {
          if (route.route[pageLoadProp] && !routerLoaded) {
            var _loadBack;

            routerLoaded = true;
            loadBack(router, (_loadBack = {}, _loadBack[pageLoadProp] = route.route[pageLoadProp], _loadBack), options);
          }
        });
        if (routerLoaded) return; // Async

        function asyncResolve(resolveParams, resolveOptions) {
          router.allowPageChange = false;
          loadBack(router, resolveParams, extend$2(options, resolveOptions), true);
        }

        function asyncReject() {
          router.allowPageChange = true;
        }

        if (route.route.async) {
          router.allowPageChange = false;
          route.route.async.call(router, {
            router: router,
            to: route,
            from: router.currentRoute,
            resolve: asyncResolve,
            reject: asyncReject,
            direction: 'backward',
            app: app
          });
        }

        if (route.route.asyncComponent) {
          asyncComponent(router, route.route.asyncComponent, asyncResolve, asyncReject);
        }
      }

      function reject() {
        router.allowPageChange = true;
      }

      if (options.preload) {
        resolve();
      } else {
        processRouteQueue.call(router, route, router.currentRoute, function () {
          if (route.route.modules) {
            app.loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules]).then(function () {
              resolve();
            }).catch(function () {
              reject();
            });
          } else {
            resolve();
          }
        }, function () {
          reject();
        }, 'backward');
      } // Return Router


      return router;
    }

    function clearPreviousPages(router) {
      appRouterCheck(router, 'clearPreviousPages');
      var app = router.app;
      var dynamicNavbar = router.dynamicNavbar;
      var $pagesToRemove = router.$el.children('.page').filter(function (pageInView) {
        if (router.currentRoute && (router.currentRoute.modal || router.currentRoute.panel)) return true;
        return pageInView !== router.currentPageEl;
      });
      $pagesToRemove.each(function (pageEl) {
        var $oldPageEl = $(pageEl);
        var $oldNavbarEl = $(app.navbar.getElByPage($oldPageEl));

        if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
          $oldPageEl.addClass('stacked');

          if (dynamicNavbar) {
            $oldNavbarEl.addClass('stacked');
          }
        } else {
          // Page remove event
          router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarEl, 'previous', undefined, {});
          router.removePage($oldPageEl);

          if (dynamicNavbar && $oldNavbarEl.length) {
            router.removeNavbar($oldNavbarEl);
          }
        }
      });
    }

    function clearPreviousHistory() {
      var router = this;
      appRouterCheck(router, 'clearPreviousHistory');
      var url = router.history[router.history.length - 1];
      clearPreviousPages(router);
      router.history = [url];
      router.view.history = [url];
      router.saveHistory();
    }
     // eslint-disable-line

    function _assertThisInitialized$u(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$u(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$v(subClass, superClass); }

    function _setPrototypeOf$v(o, p) { _setPrototypeOf$v = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$v(o, p); }

    var Router = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$u(Router, _Framework7Class);

      function Router(app, view) {
        var _this;

        _this = _Framework7Class.call(this, {}, [typeof view === 'undefined' ? app : view]) || this;

        var router = _assertThisInitialized$u(_this); // Is App Router


        router.isAppRouter = typeof view === 'undefined';

        if (router.isAppRouter) {
          // App Router
          extend$2(false, router, {
            app: app,
            params: app.params.view,
            routes: app.routes || [],
            cache: app.cache
          });
        } else {
          // View Router
          extend$2(false, router, {
            app: app,
            view: view,
            viewId: view.id,
            id: view.params.routerId,
            params: view.params,
            routes: view.routes,
            history: view.history,
            scrollHistory: view.scrollHistory,
            cache: app.cache,
            dynamicNavbar: app.theme === 'ios' && view.params.iosDynamicNavbar,
            initialPages: [],
            initialNavbars: []
          });
        } // Install Modules


        router.useModules(); // AllowPageChage

        router.allowPageChange = true; // Current Route

        var currentRoute = {};
        var previousRoute = {};
        Object.defineProperty(router, 'currentRoute', {
          enumerable: true,
          configurable: true,
          set: function set(newRoute) {
            if (newRoute === void 0) {
              newRoute = {};
            }

            previousRoute = extend$2({}, currentRoute);
            currentRoute = newRoute;
            if (!currentRoute) return;
            router.url = currentRoute.url;
            router.emit('routeChange', newRoute, previousRoute, router);
          },
          get: function get() {
            return currentRoute;
          }
        });
        Object.defineProperty(router, 'previousRoute', {
          enumerable: true,
          configurable: true,
          get: function get() {
            return previousRoute;
          },
          set: function set(newRoute) {
            previousRoute = newRoute;
          }
        });
        return router || _assertThisInitialized$u(_this);
      }

      var _proto = Router.prototype;

      _proto.mount = function mount() {
        var router = this;
        var view = router.view;
        var document = getDocument();
        extend$2(false, router, {
          tempDom: document.createElement('div'),
          $el: view.$el,
          el: view.el,
          $navbarsEl: view.$navbarsEl,
          navbarsEl: view.navbarsEl
        });
        router.emit('local::mount routerMount', router);
      };

      _proto.animatableNavElements = function animatableNavElements($newNavbarEl, $oldNavbarEl, toLarge, fromLarge, direction) {
        var router = this;
        var dynamicNavbar = router.dynamicNavbar;
        var animateIcon = router.params.iosAnimateNavbarBackIcon;
        var newNavEls;
        var oldNavEls;

        function animatableNavEl($el, $navbarInner) {
          var isSliding = $el.hasClass('sliding') || $navbarInner.hasClass('sliding');
          var isSubnavbar = $el.hasClass('subnavbar');
          var needsOpacityTransition = isSliding ? !isSubnavbar : true;
          var $iconEl = $el.find('.back .icon');
          var isIconLabel;

          if (isSliding && animateIcon && $el.hasClass('left') && $iconEl.length > 0 && $iconEl.next('span').length) {
            $el = $iconEl.next('span'); // eslint-disable-line

            isIconLabel = true;
          }

          return {
            $el: $el,
            isIconLabel: isIconLabel,
            leftOffset: $el[0].f7NavbarLeftOffset,
            rightOffset: $el[0].f7NavbarRightOffset,
            isSliding: isSliding,
            isSubnavbar: isSubnavbar,
            needsOpacityTransition: needsOpacityTransition
          };
        }

        if (dynamicNavbar) {
          newNavEls = [];
          oldNavEls = [];
          $newNavbarEl.children('.navbar-inner').children('.left, .right, .title, .subnavbar').each(function (navEl) {
            var $navEl = $(navEl);
            if ($navEl.hasClass('left') && fromLarge && direction === 'forward') return;
            if ($navEl.hasClass('title') && toLarge) return;
            newNavEls.push(animatableNavEl($navEl, $newNavbarEl.children('.navbar-inner')));
          });

          if (!($oldNavbarEl.hasClass('navbar-master') && router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint)) {
            $oldNavbarEl.children('.navbar-inner').children('.left, .right, .title, .subnavbar').each(function (navEl) {
              var $navEl = $(navEl);
              if ($navEl.hasClass('left') && toLarge && !fromLarge && direction === 'forward') return;
              if ($navEl.hasClass('left') && toLarge && direction === 'backward') return;

              if ($navEl.hasClass('title') && fromLarge) {
                return;
              }

              oldNavEls.push(animatableNavEl($navEl, $oldNavbarEl.children('.navbar-inner')));
            });
          }

          [oldNavEls, newNavEls].forEach(function (navEls) {
            navEls.forEach(function (navEl) {
              var n = navEl;
              var isSliding = navEl.isSliding,
                  $el = navEl.$el;
              var otherEls = navEls === oldNavEls ? newNavEls : oldNavEls;
              if (!(isSliding && $el.hasClass('title') && otherEls)) return;
              otherEls.forEach(function (otherNavEl) {
                if (otherNavEl.isIconLabel) {
                  var iconTextEl = otherNavEl.$el[0];
                  n.leftOffset += iconTextEl ? iconTextEl.offsetLeft || 0 : 0;
                }
              });
            });
          });
        }

        return {
          newNavEls: newNavEls,
          oldNavEls: oldNavEls
        };
      };

      _proto.animate = function animate($oldPageEl, $newPageEl, $oldNavbarEl, $newNavbarEl, direction, transition, callback) {
        var router = this;

        if (router.params.animateCustom) {
          router.params.animateCustom.apply(router, [$oldPageEl, $newPageEl, $oldNavbarEl, $newNavbarEl, direction, callback]);
          return;
        }

        var dynamicNavbar = router.dynamicNavbar;
        var ios = router.app.theme === 'ios';

        if (transition) {
          var routerCustomTransitionClass = "router-transition-custom router-transition-" + transition + "-" + direction; // Animate

          var onCustomTransitionDone = function onCustomTransitionDone() {
            router.$el.removeClass(routerCustomTransitionClass);

            if (dynamicNavbar && router.$navbarsEl.length) {
              if ($newNavbarEl) {
                router.$navbarsEl.prepend($newNavbarEl);
              }

              if ($oldNavbarEl) {
                router.$navbarsEl.prepend($oldNavbarEl);
              }
            }

            if (callback) callback();
          };

          (direction === 'forward' ? $newPageEl : $oldPageEl).animationEnd(onCustomTransitionDone);

          if (dynamicNavbar) {
            if ($newNavbarEl && $newPageEl) {
              router.setNavbarPosition($newNavbarEl, '');
              $newNavbarEl.removeClass('navbar-next navbar-previous navbar-current');
              $newPageEl.prepend($newNavbarEl);
            }

            if ($oldNavbarEl && $oldPageEl) {
              router.setNavbarPosition($oldNavbarEl, '');
              $oldNavbarEl.removeClass('navbar-next navbar-previous navbar-current');
              $oldPageEl.prepend($oldNavbarEl);
            }
          }

          router.$el.addClass(routerCustomTransitionClass);
          return;
        } // Router Animation class


        var routerTransitionClass = "router-transition-" + direction + " router-transition";
        var newNavEls;
        var oldNavEls;
        var fromLarge;
        var toLarge;
        var toDifferent;
        var oldIsLarge;
        var newIsLarge;

        if (ios && dynamicNavbar) {
          var betweenMasterAndDetail = router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint && ($oldNavbarEl.hasClass('navbar-master') && $newNavbarEl.hasClass('navbar-master-detail') || $oldNavbarEl.hasClass('navbar-master-detail') && $newNavbarEl.hasClass('navbar-master'));

          if (!betweenMasterAndDetail) {
            oldIsLarge = $oldNavbarEl && $oldNavbarEl.hasClass('navbar-large');
            newIsLarge = $newNavbarEl && $newNavbarEl.hasClass('navbar-large');
            fromLarge = oldIsLarge && !$oldNavbarEl.hasClass('navbar-large-collapsed');
            toLarge = newIsLarge && !$newNavbarEl.hasClass('navbar-large-collapsed');
            toDifferent = fromLarge && !toLarge || toLarge && !fromLarge;
          }

          var navEls = router.animatableNavElements($newNavbarEl, $oldNavbarEl, toLarge, fromLarge, direction);
          newNavEls = navEls.newNavEls;
          oldNavEls = navEls.oldNavEls;
        }

        function animateNavbars(progress) {
          if (!(ios && dynamicNavbar)) return;

          if (progress === 1) {
            if (toLarge) {
              $newNavbarEl.addClass('router-navbar-transition-to-large');
              $oldNavbarEl.addClass('router-navbar-transition-to-large');
            }

            if (fromLarge) {
              $newNavbarEl.addClass('router-navbar-transition-from-large');
              $oldNavbarEl.addClass('router-navbar-transition-from-large');
            }
          }

          newNavEls.forEach(function (navEl) {
            var $el = navEl.$el;
            var offset = direction === 'forward' ? navEl.rightOffset : navEl.leftOffset;

            if (navEl.isSliding) {
              if (navEl.isSubnavbar && newIsLarge) {
                // prettier-ignore
                $el[0].style.setProperty('transform', "translate3d(" + offset * (1 - progress) + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)", 'important');
              } else {
                $el.transform("translate3d(" + offset * (1 - progress) + "px,0,0)");
              }
            }
          });
          oldNavEls.forEach(function (navEl) {
            var $el = navEl.$el;
            var offset = direction === 'forward' ? navEl.leftOffset : navEl.rightOffset;

            if (navEl.isSliding) {
              if (navEl.isSubnavbar && oldIsLarge) {
                $el.transform("translate3d(" + offset * progress + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)");
              } else {
                $el.transform("translate3d(" + offset * progress + "px,0,0)");
              }
            }
          });
        } // AnimationEnd Callback


        function onDone() {
          if (router.dynamicNavbar) {
            if ($newNavbarEl) {
              $newNavbarEl.removeClass('router-navbar-transition-to-large router-navbar-transition-from-large');
              $newNavbarEl.addClass('navbar-no-title-large-transition');
              nextFrame(function () {
                $newNavbarEl.removeClass('navbar-no-title-large-transition');
              });
            }

            if ($oldNavbarEl) {
              $oldNavbarEl.removeClass('router-navbar-transition-to-large router-navbar-transition-from-large');
            }

            if ($newNavbarEl.hasClass('sliding') || $newNavbarEl.children('.navbar-inner.sliding').length) {
              $newNavbarEl.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
            } else {
              $newNavbarEl.find('.sliding').transform('');
            }

            if ($oldNavbarEl.hasClass('sliding') || $oldNavbarEl.children('.navbar-inner.sliding').length) {
              $oldNavbarEl.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
            } else {
              $oldNavbarEl.find('.sliding').transform('');
            }
          }

          router.$el.removeClass(routerTransitionClass);
          if (callback) callback();
        }

        (direction === 'forward' ? $newPageEl : $oldPageEl).animationEnd(function () {
          onDone();
        }); // Animate

        if (dynamicNavbar) {
          // Prepare Navbars
          animateNavbars(0);
          nextFrame(function () {
            // Add class, start animation
            router.$el.addClass(routerTransitionClass);

            if (toDifferent) {
              // eslint-disable-next-line
              router.el._clientLeft = router.el.clientLeft;
            }

            animateNavbars(1);
          });
        } else {
          // Add class, start animation
          router.$el.addClass(routerTransitionClass);
        }
      };

      _proto.removeModal = function removeModal(modalEl) {
        var router = this;
        router.removeEl(modalEl);
      } // eslint-disable-next-line
      ;

      _proto.removeTabContent = function removeTabContent(tabEl) {
        var $tabEl = $(tabEl);
        $tabEl.html('');
      };

      _proto.removeNavbar = function removeNavbar(el) {
        var router = this;
        router.removeEl(el);
      };

      _proto.removePage = function removePage(el) {
        var $el = $(el);
        var f7Page = $el && $el[0] && $el[0].f7Page;
        var router = this;

        if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
          $el.remove();
          return;
        }

        router.removeEl(el);
      };

      _proto.removeEl = function removeEl(el) {
        if (!el) return;
        var router = this;
        var $el = $(el);
        if ($el.length === 0) return;
        $el.find('.tab').each(function (tabEl) {
          $(tabEl).children().each(function (tabChild) {
            if (tabChild.f7Component) {
              $(tabChild).trigger('tab:beforeremove');
              tabChild.f7Component.destroy();
            }
          });
        });

        if ($el[0].f7Component && $el[0].f7Component.destroy) {
          $el[0].f7Component.destroy();
        }

        if (!router.params.removeElements) {
          return;
        }

        if (router.params.removeElementsWithTimeout) {
          setTimeout(function () {
            $el.remove();
          }, router.params.removeElementsTimeout);
        } else {
          $el.remove();
        }
      };

      _proto.getPageEl = function getPageEl(content) {
        var router = this;

        if (typeof content === 'string') {
          router.tempDom.innerHTML = content;
        } else {
          if ($(content).hasClass('page')) {
            return content;
          }

          router.tempDom.innerHTML = '';
          $(router.tempDom).append(content);
        }

        return router.findElement('.page', router.tempDom);
      };

      _proto.findElement = function findElement(stringSelector, container, notStacked) {
        var router = this;
        var view = router.view;
        var app = router.app; // Modals Selector

        var modalsSelector = '.popup, .dialog, .popover, .actions-modal, .sheet-modal, .login-screen, .page';
        var $container = $(container);
        var selector = stringSelector;
        if (notStacked) selector += ':not(.stacked)';
        var found = $container.find(selector).filter(function (el) {
          return $(el).parents(modalsSelector).length === 0;
        });

        if (found.length > 1) {
          if (typeof view.selector === 'string') {
            // Search in related view
            found = $container.find(view.selector + " " + selector);
          }

          if (found.length > 1) {
            // Search in main view
            found = $container.find("." + app.params.viewMainClass + " " + selector);
          }
        }

        if (found.length === 1) return found; // Try to find not stacked

        if (!notStacked) found = router.findElement(selector, $container, true);
        if (found && found.length === 1) return found;
        if (found && found.length > 1) return $(found[0]);
        return undefined;
      };

      _proto.flattenRoutes = function flattenRoutes(routes) {
        if (routes === void 0) {
          routes = this.routes;
        }

        var router = this;
        var flattenedRoutes = [];
        routes.forEach(function (route) {
          var hasTabRoutes = false;

          if ('tabs' in route && route.tabs) {
            var mergedPathsRoutes = route.tabs.map(function (tabRoute) {
              var tRoute = extend$2({}, route, {
                path: (route.path + "/" + tabRoute.path).replace('///', '/').replace('//', '/'),
                parentPath: route.path,
                tab: tabRoute
              });
              delete tRoute.tabs;
              delete tRoute.routes;
              return tRoute;
            });
            hasTabRoutes = true;
            flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(mergedPathsRoutes));
          }

          if ('detailRoutes' in route) {
            var _mergedPathsRoutes = route.detailRoutes.map(function (detailRoute) {
              var dRoute = extend$2({}, detailRoute);
              dRoute.masterRoute = route;
              dRoute.masterRoutePath = route.path;
              return dRoute;
            });

            flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(_mergedPathsRoutes));
          }

          if ('routes' in route) {
            var _mergedPathsRoutes2 = route.routes.map(function (childRoute) {
              var cRoute = extend$2({}, childRoute);
              cRoute.path = (route.path + "/" + cRoute.path).replace('///', '/').replace('//', '/');
              return cRoute;
            });

            if (hasTabRoutes) {
              flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(_mergedPathsRoutes2));
            } else {
              flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(_mergedPathsRoutes2));
            }
          }

          if (!('routes' in route) && !('tabs' in route && route.tabs) && !('detailRoutes' in route)) {
            flattenedRoutes.push(route);
          }
        });
        return flattenedRoutes;
      } // eslint-disable-next-line
      ;

      _proto.parseRouteUrl = function parseRouteUrl(url) {
        if (!url) return {};
        var query = parseUrlQuery(url);
        var hash = url.split('#')[1];
        var params = {};
        var path = url.split('#')[0].split('?')[0];
        return {
          query: query,
          hash: hash,
          params: params,
          url: url,
          path: path
        };
      };

      _proto.generateUrl = function generateUrl(parameters) {
        if (parameters === void 0) {
          parameters = {};
        }

        if (typeof parameters === 'string') {
          return parameters;
        }

        var _parameters = parameters,
            name = _parameters.name,
            path = _parameters.path,
            params = _parameters.params,
            query = _parameters.query;

        if (!name && !path) {
          throw new Error('Framework7: "name" or "path" parameter is required');
        }

        var router = this;
        var route = name ? router.findRouteByKey('name', name) : router.findRouteByKey('path', path);

        if (!route) {
          if (name) {
            throw new Error("Framework7: route with name \"" + name + "\" not found");
          } else {
            throw new Error("Framework7: route with path \"" + path + "\" not found");
          }
        }

        var url = router.constructRouteUrl(route, {
          params: params,
          query: query
        });

        if (!url) {
          throw new Error("Framework7: can't construct URL for route with name \"" + name + "\"");
        }

        return url;
      } // eslint-disable-next-line
      ;

      _proto.constructRouteUrl = function constructRouteUrl(route, _temp) {
        var _ref = _temp === void 0 ? {} : _temp,
            params = _ref.params,
            query = _ref.query;

        var path = route.path;
        var toUrl = compile(path);
        var url;

        try {
          url = toUrl(params || {});
        } catch (error) {
          throw new Error("Framework7: error constructing route URL from passed params:\nRoute: " + path + "\n" + error.toString());
        }

        if (query) {
          if (typeof query === 'string') url += "?" + query;else if (Object.keys(query).length) url += "?" + serializeObject(query);
        }

        return url;
      };

      _proto.findTabRouteUrl = function findTabRouteUrl(tabEl) {
        var router = this;
        var $tabEl = $(tabEl);
        var parentPath = router.currentRoute.route.parentPath;
        var tabId = $tabEl.attr('id');
        var flattenedRoutes = router.flattenRoutes(router.routes);
        var foundTabRouteUrl;
        flattenedRoutes.forEach(function (route) {
          if (route.parentPath === parentPath && route.tab && route.tab.id === tabId) {
            if (router.currentRoute.params && Object.keys(router.currentRoute.params).length > 0) {
              foundTabRouteUrl = router.constructRouteUrl(route, {
                params: router.currentRoute.params,
                query: router.currentRoute.query
              });
            } else {
              foundTabRouteUrl = route.path;
            }
          }
        });
        return foundTabRouteUrl;
      };

      _proto.findRouteByKey = function findRouteByKey(key, value) {
        var router = this;
        var routes = router.routes;
        var flattenedRoutes = router.flattenRoutes(routes);
        var matchingRoute;
        flattenedRoutes.forEach(function (route) {
          if (matchingRoute) return;

          if (route[key] === value) {
            matchingRoute = route;
          }
        });
        return matchingRoute;
      };

      _proto.findMatchingRoute = function findMatchingRoute(url) {
        if (!url) return undefined;
        var router = this;
        var routes = router.routes;
        var flattenedRoutes = router.flattenRoutes(routes);

        var _router$parseRouteUrl = router.parseRouteUrl(url),
            path = _router$parseRouteUrl.path,
            query = _router$parseRouteUrl.query,
            hash = _router$parseRouteUrl.hash,
            params = _router$parseRouteUrl.params;

        var matchingRoute;
        flattenedRoutes.forEach(function (route) {
          if (matchingRoute) return;
          var keys = [];
          var pathsToMatch = [route.path];

          if (route.alias) {
            if (typeof route.alias === 'string') pathsToMatch.push(route.alias);else if (Array.isArray(route.alias)) {
              route.alias.forEach(function (aliasPath) {
                pathsToMatch.push(aliasPath);
              });
            }
          }

          var matched;
          pathsToMatch.forEach(function (pathToMatch) {
            if (matched) return;
            matched = pathToRegexp(pathToMatch, keys).exec(path);
          });

          if (matched) {
            keys.forEach(function (keyObj, index) {
              if (typeof keyObj.name === 'number') return;
              var paramValue = matched[index + 1];

              if (typeof paramValue === 'undefined' || paramValue === null) {
                params[keyObj.name] = paramValue;
              } else {
                params[keyObj.name] = decodeURIComponent(paramValue);
              }
            });
            var parentPath;

            if (route.parentPath) {
              parentPath = path.split('/').slice(0, route.parentPath.split('/').length - 1).join('/');
            }

            matchingRoute = {
              query: query,
              hash: hash,
              params: params,
              url: url,
              path: path,
              parentPath: parentPath,
              route: route,
              name: route.name
            };
          }
        });
        return matchingRoute;
      } // eslint-disable-next-line
      ;

      _proto.replaceRequestUrlParams = function replaceRequestUrlParams(url, options) {
        if (url === void 0) {
          url = '';
        }

        if (options === void 0) {
          options = {};
        }

        var compiledUrl = url;

        if (typeof compiledUrl === 'string' && compiledUrl.indexOf('{{') >= 0 && options && options.route && options.route.params && Object.keys(options.route.params).length) {
          Object.keys(options.route.params).forEach(function (paramName) {
            var regExp = new RegExp("{{" + paramName + "}}", 'g');
            compiledUrl = compiledUrl.replace(regExp, options.route.params[paramName] || '');
          });
        }

        return compiledUrl;
      };

      _proto.removeFromXhrCache = function removeFromXhrCache(url) {
        var router = this;
        var xhrCache = router.cache.xhr;
        var index = false;

        for (var i = 0; i < xhrCache.length; i += 1) {
          if (xhrCache[i].url === url) index = i;
        }

        if (index !== false) xhrCache.splice(index, 1);
      };

      _proto.xhrRequest = function xhrRequest(requestUrl, options) {
        var router = this;
        var params = router.params;
        var ignoreCache = options.ignoreCache;
        var url = requestUrl;
        var hasQuery = url.indexOf('?') >= 0;

        if (params.passRouteQueryToRequest && options && options.route && options.route.query && Object.keys(options.route.query).length) {
          url += "" + (hasQuery ? '&' : '?') + serializeObject(options.route.query);
          hasQuery = true;
        }

        if (params.passRouteParamsToRequest && options && options.route && options.route.params && Object.keys(options.route.params).length) {
          url += "" + (hasQuery ? '&' : '?') + serializeObject(options.route.params);
          hasQuery = true;
        }

        if (url.indexOf('{{') >= 0) {
          url = router.replaceRequestUrlParams(url, options);
        } // should we ignore get params or not


        if (params.xhrCacheIgnoreGetParameters && url.indexOf('?') >= 0) {
          url = url.split('?')[0];
        }

        return new Promise(function (resolve, reject) {
          if (params.xhrCache && !ignoreCache && url.indexOf('nocache') < 0 && params.xhrCacheIgnore.indexOf(url) < 0) {
            for (var i = 0; i < router.cache.xhr.length; i += 1) {
              var cachedUrl = router.cache.xhr[i];

              if (cachedUrl.url === url) {
                // Check expiration
                if (now$2() - cachedUrl.time < params.xhrCacheDuration) {
                  // Load from cache
                  resolve(cachedUrl.content);
                  return;
                }
              }
            }
          }

          router.xhrAbortController = router.app.request.abortController();
          router.app.request({
            abortController: router.xhrAbortController,
            url: url,
            method: 'GET',
            beforeSend: function beforeSend(xhr) {
              router.emit('routerAjaxStart', xhr, options);
            },
            complete: function complete(xhr, status) {
              router.emit('routerAjaxComplete', xhr);

              if (status !== 'error' && status !== 'timeout' && xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) {
                if (params.xhrCache && xhr.responseText !== '') {
                  router.removeFromXhrCache(url);
                  router.cache.xhr.push({
                    url: url,
                    time: now$2(),
                    content: xhr.responseText
                  });
                }

                router.emit('routerAjaxSuccess', xhr, options);
                resolve(xhr.responseText);
              } else {
                router.emit('routerAjaxError', xhr, options);
                reject(xhr);
              }
            },
            error: function error(xhr) {
              router.emit('routerAjaxError', xhr, options);
              reject(xhr);
            }
          });
        });
      };

      _proto.setNavbarPosition = function setNavbarPosition($el, position, ariaHidden) {
        var router = this;
        $el.removeClass('navbar-previous navbar-current navbar-next');

        if (position) {
          $el.addClass("navbar-" + position);
        }

        if (ariaHidden === false) {
          $el.removeAttr('aria-hidden');
        } else if (ariaHidden === true) {
          $el.attr('aria-hidden', 'true');
        }

        $el.trigger('navbar:position', {
          position: position
        });
        router.emit('navbarPosition', $el[0], position);
      };

      _proto.setPagePosition = function setPagePosition($el, position, ariaHidden) {
        var router = this;
        $el.removeClass('page-previous page-current page-next');
        $el.addClass("page-" + position);

        if (ariaHidden === false) {
          $el.removeAttr('aria-hidden');
        } else if (ariaHidden === true) {
          $el.attr('aria-hidden', 'true');
        }

        $el.trigger('page:position', {
          position: position
        });
        router.emit('pagePosition', $el[0], position);
      } // Remove theme elements
      ;

      _proto.removeThemeElements = function removeThemeElements(el) {
        var router = this;
        var theme = router.app.theme;
        var toRemove;

        if (theme === 'ios') {
          toRemove = '.md-only, .aurora-only, .if-md, .if-aurora, .if-not-ios, .not-ios';
        } else if (theme === 'md') {
          toRemove = '.ios-only, .aurora-only, .if-ios, .if-aurora, .if-not-md, .not-md';
        } else if (theme === 'aurora') {
          toRemove = '.ios-only, .md-only, .if-ios, .if-md, .if-not-aurora, .not-aurora';
        }

        $(el).find(toRemove).remove();
      };

      _proto.getPageData = function getPageData(pageEl, navbarEl, from, to, route, pageFromEl) {
        if (route === void 0) {
          route = {};
        }

        var router = this;
        var $pageEl = $(pageEl).eq(0);
        var $navbarEl = $(navbarEl).eq(0);
        var currentPage = $pageEl[0].f7Page || {};
        var direction;
        var pageFrom;
        if (from === 'next' && to === 'current' || from === 'current' && to === 'previous') direction = 'forward';
        if (from === 'current' && to === 'next' || from === 'previous' && to === 'current') direction = 'backward';

        if (currentPage && !currentPage.fromPage) {
          var $pageFromEl = $(pageFromEl);

          if ($pageFromEl.length) {
            pageFrom = $pageFromEl[0].f7Page;
          }
        }

        pageFrom = currentPage.pageFrom || pageFrom;

        if (pageFrom && pageFrom.pageFrom) {
          pageFrom.pageFrom = null;
        }

        var page = {
          app: router.app,
          view: router.view,
          router: router,
          $el: $pageEl,
          el: $pageEl[0],
          $pageEl: $pageEl,
          pageEl: $pageEl[0],
          $navbarEl: $navbarEl,
          navbarEl: $navbarEl[0],
          name: $pageEl.attr('data-name'),
          position: from,
          from: from,
          to: to,
          direction: direction,
          route: currentPage.route ? currentPage.route : route,
          pageFrom: pageFrom
        };
        $pageEl[0].f7Page = page;
        return page;
      } // Callbacks
      ;

      _proto.pageCallback = function pageCallback(callback, pageEl, navbarEl, from, to, options, pageFromEl) {
        if (options === void 0) {
          options = {};
        }

        if (!pageEl) return;
        var router = this;
        var $pageEl = $(pageEl);
        if (!$pageEl.length) return;
        var $navbarEl = $(navbarEl);
        var _options = options,
            route = _options.route;
        var restoreScrollTopOnBack = router.params.restoreScrollTopOnBack && !(router.params.masterDetailBreakpoint > 0 && $pageEl.hasClass('page-master') && router.app.width >= router.params.masterDetailBreakpoint);
        var keepAlive = $pageEl[0].f7Page && $pageEl[0].f7Page.route && $pageEl[0].f7Page.route.route && $pageEl[0].f7Page.route.route.keepAlive;

        if (callback === 'beforeRemove' && keepAlive) {
          callback = 'beforeUnmount'; // eslint-disable-line
        }

        var camelName = "page" + (callback[0].toUpperCase() + callback.slice(1, callback.length));
        var colonName = "page:" + callback.toLowerCase();
        var page = {};

        if (callback === 'beforeRemove' && $pageEl[0].f7Page) {
          page = extend$2($pageEl[0].f7Page, {
            from: from,
            to: to,
            position: from
          });
        } else {
          page = router.getPageData($pageEl[0], $navbarEl[0], from, to, route, pageFromEl);
        }

        page.swipeBack = !!options.swipeBack;

        var _ref2 = options.route ? options.route.route : {},
            _ref2$on = _ref2.on,
            on = _ref2$on === void 0 ? {} : _ref2$on,
            _ref2$once = _ref2.once,
            once = _ref2$once === void 0 ? {} : _ref2$once;

        if (options.on) {
          extend$2(on, options.on);
        }

        if (options.once) {
          extend$2(once, options.once);
        }

        function attachEvents() {
          if ($pageEl[0].f7RouteEventsAttached) return;
          $pageEl[0].f7RouteEventsAttached = true;

          if (on && Object.keys(on).length > 0) {
            $pageEl[0].f7RouteEventsOn = on;
            Object.keys(on).forEach(function (eventName) {
              on[eventName] = on[eventName].bind(router);
              $pageEl.on(eventNameToColonCase(eventName), on[eventName]);
            });
          }

          if (once && Object.keys(once).length > 0) {
            $pageEl[0].f7RouteEventsOnce = once;
            Object.keys(once).forEach(function (eventName) {
              once[eventName] = once[eventName].bind(router);
              $pageEl.once(eventNameToColonCase(eventName), once[eventName]);
            });
          }
        }

        function detachEvents() {
          if (!$pageEl[0].f7RouteEventsAttached) return;

          if ($pageEl[0].f7RouteEventsOn) {
            Object.keys($pageEl[0].f7RouteEventsOn).forEach(function (eventName) {
              $pageEl.off(eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOn[eventName]);
            });
          }

          if ($pageEl[0].f7RouteEventsOnce) {
            Object.keys($pageEl[0].f7RouteEventsOnce).forEach(function (eventName) {
              $pageEl.off(eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOnce[eventName]);
            });
          }

          $pageEl[0].f7RouteEventsAttached = null;
          $pageEl[0].f7RouteEventsOn = null;
          $pageEl[0].f7RouteEventsOnce = null;
          delete $pageEl[0].f7RouteEventsAttached;
          delete $pageEl[0].f7RouteEventsOn;
          delete $pageEl[0].f7RouteEventsOnce;
        }

        if (callback === 'mounted') {
          attachEvents();
        }

        if (callback === 'init') {
          if (restoreScrollTopOnBack && (from === 'previous' || !from) && to === 'current' && router.scrollHistory[page.route.url] && !$pageEl.hasClass('no-restore-scroll')) {
            var $pageContent = $pageEl.find('.page-content');

            if ($pageContent.length > 0) {
              // eslint-disable-next-line
              $pageContent = $pageContent.filter(function (pageContentEl) {
                return $(pageContentEl).parents('.tab:not(.tab-active)').length === 0 && !$(pageContentEl).is('.tab:not(.tab-active)');
              });
            }

            $pageContent.scrollTop(router.scrollHistory[page.route.url]);
          }

          attachEvents();

          if ($pageEl[0].f7PageInitialized) {
            $pageEl.trigger('page:reinit', page);
            router.emit('pageReinit', page);
            return;
          }

          $pageEl[0].f7PageInitialized = true;
        }

        if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'previous') {
          // Save scroll position
          var _$pageContent = $pageEl.find('.page-content');

          if (_$pageContent.length > 0) {
            // eslint-disable-next-line
            _$pageContent = _$pageContent.filter(function (pageContentEl) {
              return $(pageContentEl).parents('.tab:not(.tab-active)').length === 0 && !$(pageContentEl).is('.tab:not(.tab-active)');
            });
          }

          router.scrollHistory[page.route.url] = _$pageContent.scrollTop();
        }

        if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'next') {
          // Delete scroll position
          delete router.scrollHistory[page.route.url];
        }

        $pageEl.trigger(colonName, page);
        router.emit(camelName, page);

        if (callback === 'beforeRemove' || callback === 'beforeUnmount') {
          detachEvents();

          if (!keepAlive) {
            if ($pageEl[0].f7Page && $pageEl[0].f7Page.navbarEl) {
              delete $pageEl[0].f7Page.navbarEl.f7Page;
            }

            $pageEl[0].f7Page = null;
          }
        }
      };

      _proto.saveHistory = function saveHistory() {
        var router = this;
        var window = getWindow();
        router.view.history = router.history;

        if (router.params.browserHistory && router.params.browserHistoryStoreHistory && window.localStorage) {
          window.localStorage["f7router-" + router.view.id + "-history"] = JSON.stringify(router.history);
        }
      };

      _proto.restoreHistory = function restoreHistory() {
        var router = this;
        var window = getWindow();

        if (router.params.browserHistory && router.params.browserHistoryStoreHistory && window.localStorage && window.localStorage["f7router-" + router.view.id + "-history"]) {
          router.history = JSON.parse(window.localStorage["f7router-" + router.view.id + "-history"]);
          router.view.history = router.history;
        }
      };

      _proto.clearHistory = function clearHistory() {
        var router = this;
        router.history = [];
        if (router.view) router.view.history = [];
        router.saveHistory();
      };

      _proto.updateCurrentUrl = function updateCurrentUrl(newUrl) {
        var router = this;
        appRouterCheck(router, 'updateCurrentUrl'); // Update history

        if (router.history.length) {
          router.history[router.history.length - 1] = newUrl;
        } else {
          router.history.push(newUrl);
        } // Update current route params


        var _router$parseRouteUrl2 = router.parseRouteUrl(newUrl),
            query = _router$parseRouteUrl2.query,
            hash = _router$parseRouteUrl2.hash,
            params = _router$parseRouteUrl2.params,
            url = _router$parseRouteUrl2.url,
            path = _router$parseRouteUrl2.path;

        if (router.currentRoute) {
          extend$2(router.currentRoute, {
            query: query,
            hash: hash,
            params: params,
            url: url,
            path: path
          });
        }

        if (router.params.browserHistory) {
          var browserHistoryRoot = router.params.browserHistoryRoot || '';
          History$1.replace(router.view.id, {
            url: newUrl
          }, browserHistoryRoot + router.params.browserHistorySeparator + newUrl);
        } // Save History


        router.saveHistory();
        router.emit('routeUrlUpdate', router.currentRoute, router);
      };

      _proto.getInitialUrl = function getInitialUrl() {
        var router = this;

        if (router.initialUrl) {
          return {
            initialUrl: router.initialUrl,
            historyRestored: router.historyRestored
          };
        }

        var app = router.app,
            view = router.view;
        var document = getDocument();
        var window = getWindow();
        var location = app.params.url && typeof app.params.url === 'string' && typeof URL !== 'undefined' ? new URL(app.params.url) : document.location;
        var initialUrl = router.params.url;
        var documentUrl = location.href.split(location.origin)[1];
        var historyRestored;
        var _router$params = router.params,
            browserHistory = _router$params.browserHistory,
            browserHistoryOnLoad = _router$params.browserHistoryOnLoad,
            browserHistorySeparator = _router$params.browserHistorySeparator;
        var browserHistoryRoot = router.params.browserHistoryRoot;

        if ((window.cordova || window.Capacitor && window.Capacitor.isNative) && browserHistory && !browserHistorySeparator && !browserHistoryRoot && location.pathname.indexOf('index.html')) {
          // eslint-disable-next-line
          console.warn('Framework7: wrong or not complete browserHistory configuration, trying to guess browserHistoryRoot');
          browserHistoryRoot = location.pathname.split('index.html')[0];
        }

        if (!browserHistory || !browserHistoryOnLoad) {
          if (!initialUrl) {
            initialUrl = documentUrl;
          }

          if (location.search && initialUrl.indexOf('?') < 0) {
            initialUrl += location.search;
          }

          if (location.hash && initialUrl.indexOf('#') < 0) {
            initialUrl += location.hash;
          }
        } else {
          if (browserHistoryRoot && documentUrl.indexOf(browserHistoryRoot) >= 0) {
            documentUrl = documentUrl.split(browserHistoryRoot)[1];
            if (documentUrl === '') documentUrl = '/';
          }

          if (browserHistorySeparator.length > 0 && documentUrl.indexOf(browserHistorySeparator) >= 0) {
            initialUrl = documentUrl.split(browserHistorySeparator)[1];
          } else {
            initialUrl = documentUrl;
          }

          router.restoreHistory();

          if (router.history.indexOf(initialUrl) >= 0) {
            router.history = router.history.slice(0, router.history.indexOf(initialUrl) + 1);
          } else if (router.params.url === initialUrl) {
            router.history = [initialUrl];
          } else if (History$1.state && History$1.state[view.id] && History$1.state[view.id].url === router.history[router.history.length - 1]) {
            initialUrl = router.history[router.history.length - 1];
          } else {
            router.history = [documentUrl.split(browserHistorySeparator)[0] || '/', initialUrl];
          }

          if (router.history.length > 1) {
            historyRestored = true;
          } else {
            router.history = [];
          }

          router.saveHistory();
        }

        router.initialUrl = initialUrl;
        router.historyRestored = historyRestored;
        return {
          initialUrl: initialUrl,
          historyRestored: historyRestored
        };
      };

      _proto.init = function init() {
        var router = this;
        var app = router.app,
            view = router.view;
        var document = getDocument();
        router.mount();

        var _router$getInitialUrl = router.getInitialUrl(),
            initialUrl = _router$getInitialUrl.initialUrl,
            historyRestored = _router$getInitialUrl.historyRestored; // Init Swipeback


        if (view && router.params.iosSwipeBack && app.theme === 'ios' || view && router.params.mdSwipeBack && app.theme === 'md' || view && router.params.auroraSwipeBack && app.theme === 'aurora') {
          SwipeBack(router);
        }

        var _router$params2 = router.params,
            browserHistory = _router$params2.browserHistory,
            browserHistoryOnLoad = _router$params2.browserHistoryOnLoad,
            browserHistoryAnimateOnLoad = _router$params2.browserHistoryAnimateOnLoad,
            browserHistoryInitialMatch = _router$params2.browserHistoryInitialMatch;
        var currentRoute;

        if (router.history.length > 1) {
          // Will load page
          var initUrl = browserHistoryInitialMatch ? initialUrl : router.history[0];
          currentRoute = router.findMatchingRoute(initUrl);

          if (!currentRoute) {
            currentRoute = extend$2(router.parseRouteUrl(initUrl), {
              route: {
                url: initUrl,
                path: initUrl.split('?')[0]
              }
            });
          }
        } else {
          // Don't load page
          currentRoute = router.findMatchingRoute(initialUrl);

          if (!currentRoute) {
            currentRoute = extend$2(router.parseRouteUrl(initialUrl), {
              route: {
                url: initialUrl,
                path: initialUrl.split('?')[0]
              }
            });
          }
        }

        if (router.params.stackPages) {
          router.$el.children('.page').each(function (pageEl) {
            var $pageEl = $(pageEl);
            router.initialPages.push($pageEl[0]);

            if (router.dynamicNavbar && $pageEl.children('.navbar').length > 0) {
              router.initialNavbars.push($pageEl.children('.navbar')[0]);
            }
          });
        }

        if (router.$el.children('.page:not(.stacked)').length === 0 && initialUrl && router.params.loadInitialPage) {
          // No pages presented in DOM, reload new page
          router.navigate(initialUrl, {
            initial: true,
            reloadCurrent: true,
            browserHistory: false,
            animate: false,
            once: {
              modalOpen: function modalOpen() {
                if (!historyRestored) return;
                var preloadPreviousPage = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];

                if (preloadPreviousPage && router.history.length > 1) {
                  router.back({
                    preload: true
                  });
                }
              },
              pageAfterIn: function pageAfterIn() {
                if (!historyRestored) return;
                var preloadPreviousPage = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];

                if (preloadPreviousPage && router.history.length > 1) {
                  router.back({
                    preload: true
                  });
                }
              }
            }
          });
        } else if (router.$el.children('.page:not(.stacked)').length) {
          // Init current DOM page
          var hasTabRoute;
          router.currentRoute = currentRoute;
          router.$el.children('.page:not(.stacked)').each(function (pageEl) {
            var $pageEl = $(pageEl);
            var $navbarEl;
            router.setPagePosition($pageEl, 'current');

            if (router.dynamicNavbar) {
              $navbarEl = $pageEl.children('.navbar');

              if ($navbarEl.length > 0) {
                if (!router.$navbarsEl.parents(document).length) {
                  router.$el.prepend(router.$navbarsEl);
                }

                router.setNavbarPosition($navbarEl, 'current');
                router.$navbarsEl.append($navbarEl);

                if ($navbarEl.children('.title-large').length) {
                  $navbarEl.addClass('navbar-large');
                }

                $pageEl.children('.navbar').remove();
              } else {
                router.$navbarsEl.addClass('navbar-hidden');

                if ($navbarEl.children('.title-large').length) {
                  router.$navbarsEl.addClass('navbar-hidden navbar-large-hidden');
                }
              }
            }

            if (router.currentRoute && router.currentRoute.route && (router.currentRoute.route.master === true || typeof router.currentRoute.route.master === 'function' && router.currentRoute.route.master(app, router)) && router.params.masterDetailBreakpoint > 0) {
              $pageEl.addClass('page-master');
              $pageEl.trigger('page:role', {
                role: 'master'
              });

              if ($navbarEl && $navbarEl.length) {
                $navbarEl.addClass('navbar-master');
              }

              view.checkMasterDetailBreakpoint();
            }

            var initOptions = {
              route: router.currentRoute
            };

            if (router.currentRoute && router.currentRoute.route && router.currentRoute.route.options) {
              extend$2(initOptions, router.currentRoute.route.options);
            }

            router.currentPageEl = $pageEl[0];

            if (router.dynamicNavbar && $navbarEl.length) {
              router.currentNavbarEl = $navbarEl[0];
            }

            router.removeThemeElements($pageEl);

            if (router.dynamicNavbar && $navbarEl.length) {
              router.removeThemeElements($navbarEl);
            }

            if (initOptions.route.route.tab) {
              hasTabRoute = true;
              router.tabLoad(initOptions.route.route.tab, extend$2({}, initOptions));
            }

            router.pageCallback('init', $pageEl, $navbarEl, 'current', undefined, initOptions);
            router.pageCallback('beforeIn', $pageEl, $navbarEl, 'current', undefined, initOptions);
            router.pageCallback('afterIn', $pageEl, $navbarEl, 'current', undefined, initOptions);
          });

          if (historyRestored) {
            if (browserHistoryInitialMatch) {
              var preloadPreviousPage = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];

              if (preloadPreviousPage && router.history.length > 1) {
                router.back({
                  preload: true
                });
              }
            } else {
              router.navigate(initialUrl, {
                initial: true,
                browserHistory: false,
                history: false,
                animate: browserHistoryAnimateOnLoad,
                once: {
                  pageAfterIn: function pageAfterIn() {
                    var preloadPreviousPage = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];

                    if (preloadPreviousPage && router.history.length > 2) {
                      router.back({
                        preload: true
                      });
                    }
                  }
                }
              });
            }
          }

          if (!historyRestored && !hasTabRoute) {
            router.history.push(initialUrl);
            router.saveHistory();
          }
        }

        if (initialUrl && browserHistory && browserHistoryOnLoad && (!History$1.state || !History$1.state[view.id])) {
          History$1.initViewState(view.id, {
            url: initialUrl
          });
        }

        router.emit('local::init routerInit', router);
      };

      _proto.destroy = function destroy() {
        var router = this;
        router.emit('local::destroy routerDestroy', router); // Delete props & methods

        Object.keys(router).forEach(function (routerProp) {
          router[routerProp] = null;
          delete router[routerProp];
        });
        router = null;
      };

      return Router;
    }(Framework7Class$1); // Load


    Router.prototype.navigate = navigate;
    Router.prototype.refreshPage = refreshPage; // Tab

    Router.prototype.tabLoad = tabLoad;
    Router.prototype.tabRemove = tabRemove; // Modal

    Router.prototype.modalLoad = modalLoad;
    Router.prototype.modalRemove = modalRemove; // Back

    Router.prototype.back = back; // Clear history

    Router.prototype.clearPreviousHistory = clearPreviousHistory;
    var Router$1 = Router;

    var RouterModule = {
      name: 'router',
      static: {
        Router: Router$1
      },
      instance: {
        cache: {
          xhr: [],
          templates: [],
          components: []
        }
      },
      create: function create() {
        var instance = this;

        if (instance.app) {
          // View Router
          if (instance.params.router) {
            instance.router = new Router$1(instance.app, instance);
          }
        } else {
          // App Router
          instance.router = new Router$1(instance);
        }
      }
    };

    function resizableView(view) {
      var app = view.app;
      var support = getSupport$1();
      if (view.resizableInitialized) return;
      extend$2(view, {
        resizable: true,
        resizableWidth: null,
        resizableInitialized: true
      });
      var $htmlEl = $('html');
      var $el = view.$el;
      if (!$el) return;
      var $resizeHandlerEl;
      var isTouched;
      var isMoved;
      var touchesStart = {};
      var touchesDiff;
      var width;
      var minWidth;
      var maxWidth;

      function transformCSSWidth(v) {
        if (!v) return null;

        if (v.indexOf('%') >= 0 || v.indexOf('vw') >= 0) {
          return parseInt(v, 10) / 100 * app.width;
        }

        var newV = parseInt(v, 10);
        if (Number.isNaN(newV)) return null;
        return newV;
      }

      function isResizable() {
        return view.resizable && $el.hasClass('view-resizable') && $el.hasClass('view-master-detail');
      }

      function handleTouchStart(e) {
        if (!isResizable()) return;
        touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        isMoved = false;
        isTouched = true;
        var $pageMasterEl = $el.children('.page-master');
        minWidth = transformCSSWidth($pageMasterEl.css('min-width'));
        maxWidth = transformCSSWidth($pageMasterEl.css('max-width'));
      }

      function handleTouchMove(e) {
        if (!isTouched) return;
        e.f7PreventSwipePanel = true;
        var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;

        if (!isMoved) {
          width = $resizeHandlerEl[0].offsetLeft + $resizeHandlerEl[0].offsetWidth;
          $el.addClass('view-resizing');
          $htmlEl.css('cursor', 'col-resize');
        }

        isMoved = true;
        e.preventDefault();
        touchesDiff = pageX - touchesStart.x;
        var newWidth = width + touchesDiff;

        if (minWidth && !Number.isNaN(minWidth)) {
          newWidth = Math.max(newWidth, minWidth);
        }

        if (maxWidth && !Number.isNaN(maxWidth)) {
          newWidth = Math.min(newWidth, maxWidth);
        }

        newWidth = Math.min(Math.max(newWidth, 0), app.width);
        view.resizableWidth = newWidth;
        $htmlEl[0].style.setProperty('--f7-page-master-width', newWidth + "px");
        $el.trigger('view:resize', newWidth);
        view.emit('local::resize viewResize', view, newWidth);
      }

      function handleTouchEnd() {
        $('html').css('cursor', '');

        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }

        isTouched = false;
        isMoved = false;
        $htmlEl[0].style.setProperty('--f7-page-master-width', view.resizableWidth + "px");
        $el.removeClass('view-resizing');
      }

      function handleResize() {
        if (!view.resizableWidth) return;
        minWidth = transformCSSWidth($resizeHandlerEl.css('min-width'));
        maxWidth = transformCSSWidth($resizeHandlerEl.css('max-width'));

        if (minWidth && !Number.isNaN(minWidth) && view.resizableWidth < minWidth) {
          view.resizableWidth = Math.max(view.resizableWidth, minWidth);
        }

        if (maxWidth && !Number.isNaN(maxWidth) && view.resizableWidth > maxWidth) {
          view.resizableWidth = Math.min(view.resizableWidth, maxWidth);
        }

        view.resizableWidth = Math.min(Math.max(view.resizableWidth, 0), app.width);
        $htmlEl[0].style.setProperty('--f7-page-master-width', view.resizableWidth + "px");
      }

      $resizeHandlerEl = view.$el.children('.view-resize-handler');

      if (!$resizeHandlerEl.length) {
        view.$el.append('<div class="view-resize-handler"></div>');
        $resizeHandlerEl = view.$el.children('.view-resize-handler');
      }

      view.$resizeHandlerEl = $resizeHandlerEl;
      $el.addClass('view-resizable'); // Add Events

      var passive = support.passiveListener ? {
        passive: true
      } : false;
      view.$el.on(app.touchEvents.start, '.view-resize-handler', handleTouchStart, passive);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      app.on('resize', handleResize);
      view.on('beforeOpen', handleResize);
      view.once('viewDestroy', function () {
        $el.removeClass('view-resizable');
        view.$resizeHandlerEl.remove();
        view.$el.off(app.touchEvents.start, '.view-resize-handler', handleTouchStart, passive);
        app.off('touchmove:active', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
        app.off('resize', handleResize);
        view.off('beforeOpen', handleResize);
      });
    }

    function _assertThisInitialized$t(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$t(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$u(subClass, superClass); }

    function _setPrototypeOf$u(o, p) { _setPrototypeOf$u = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$u(o, p); }

    var View$2 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$t(View, _Framework7Class);

      function View(app, el, viewParams) {
        var _this;

        if (viewParams === void 0) {
          viewParams = {};
        }

        _this = _Framework7Class.call(this, viewParams, [app]) || this;

        var view = _assertThisInitialized$t(_this);

        var ssr = view.params.routerId;
        var defaults = {
          routes: [],
          routesAdd: []
        };

        if (!ssr) {
          var $el = $(el);

          if (!$el.length) {
            var message = "Framework7: can't create a View instance because ";
            message += typeof el === 'string' ? "the selector \"" + el + "\" didn't match any element" : 'el must be an HTMLElement or Dom7 object';
            throw new Error(message);
          }
        } // Default View params


        view.params = extend$2({
          el: el
        }, defaults, app.params.view, viewParams); // Routes

        if (view.params.routes.length > 0) {
          view.routes = view.params.routes;
        } else {
          view.routes = [].concat(app.routes, view.params.routesAdd);
        } // View Props


        extend$2(false, view, {
          app: app,
          name: view.params.name,
          main: view.params.main,
          history: [],
          scrollHistory: {}
        }); // Install Modules

        view.useModules(); // Add to app

        app.views.push(view);

        if (view.main) {
          app.views.main = view;
        }

        if (view.name) {
          app.views[view.name] = view;
        } // Index


        view.index = app.views.indexOf(view); // View ID

        var viewId;

        if (view.name) {
          viewId = "view_" + view.name;
        } else if (view.main) {
          viewId = 'view_main';
        } else {
          viewId = "view_" + view.index;
        }

        view.id = viewId;

        if (!view.params.init) {
          return view || _assertThisInitialized$t(_this);
        } // Init View


        if (app.initialized) {
          view.init();
        } else {
          app.on('init', function () {
            view.init();
          });
        }

        return view || _assertThisInitialized$t(_this);
      }

      var _proto = View.prototype;

      _proto.destroy = function destroy() {
        var view = this;
        var app = view.app;
        view.$el.trigger('view:beforedestroy');
        view.emit('local::beforeDestroy viewBeforeDestroy', view);
        app.off('resize', view.checkMasterDetailBreakpoint);

        if (view.main) {
          app.views.main = null;
          delete app.views.main;
        } else if (view.name) {
          app.views[view.name] = null;
          delete app.views[view.name];
        }

        view.$el[0].f7View = null;
        delete view.$el[0].f7View;
        app.views.splice(app.views.indexOf(view), 1); // Destroy Router

        if (view.params.router && view.router) {
          view.router.destroy();
        }

        view.emit('local::destroy viewDestroy', view); // Delete props & methods

        Object.keys(view).forEach(function (viewProp) {
          view[viewProp] = null;
          delete view[viewProp];
        });
        view = null;
      };

      _proto.checkMasterDetailBreakpoint = function checkMasterDetailBreakpoint(force) {
        var view = this;
        var app = view.app;
        var wasMasterDetail = view.$el.hasClass('view-master-detail');
        var isMasterDetail = app.width >= view.params.masterDetailBreakpoint && view.$el.children('.page-master').length;

        if (typeof force === 'undefined' && isMasterDetail || force === true) {
          view.$el.addClass('view-master-detail');

          if (!wasMasterDetail) {
            view.emit('local::masterDetailBreakpoint viewMasterDetailBreakpoint', view);
            view.$el.trigger('view:masterDetailBreakpoint');
          }
        } else {
          view.$el.removeClass('view-master-detail');

          if (wasMasterDetail) {
            view.emit('local::masterDetailBreakpoint viewMasterDetailBreakpoint', view);
            view.$el.trigger('view:masterDetailBreakpoint');
          }
        }
      };

      _proto.initMasterDetail = function initMasterDetail() {
        var view = this;
        var app = view.app;
        view.checkMasterDetailBreakpoint = view.checkMasterDetailBreakpoint.bind(view);
        view.checkMasterDetailBreakpoint();

        if (view.params.masterDetailResizable) {
          resizableView(view);
        }

        app.on('resize', view.checkMasterDetailBreakpoint);
      };

      _proto.mount = function mount(viewEl) {
        var view = this;
        var app = view.app;
        var el = view.params.el || viewEl;
        var $el = $(el); // Selector

        var selector;
        if (typeof el === 'string') selector = el;else {
          // Supposed to be HTMLElement or Dom7
          selector = ($el.attr('id') ? "#" + $el.attr('id') : '') + ($el.attr('class') ? "." + $el.attr('class').replace(/ /g, '.').replace('.active', '') : '');
        } // DynamicNavbar

        var $navbarsEl;

        if (app.theme === 'ios' && view.params.iosDynamicNavbar) {
          $navbarsEl = $el.children('.navbars').eq(0);

          if ($navbarsEl.length === 0) {
            $navbarsEl = $('<div class="navbars"></div>');
          }
        }

        extend$2(view, {
          $el: $el,
          el: $el[0],
          main: view.main || $el.hasClass('view-main'),
          $navbarsEl: $navbarsEl,
          navbarsEl: $navbarsEl ? $navbarsEl[0] : undefined,
          selector: selector
        });

        if (view.main) {
          app.views.main = view;
        } // Save in DOM


        if ($el && $el[0]) {
          $el[0].f7View = view;
        }

        view.emit('local::mount viewMount', view);
      };

      _proto.init = function init(viewEl) {
        var view = this;
        view.mount(viewEl);

        if (view.params.router) {
          if (view.params.masterDetailBreakpoint > 0) {
            view.initMasterDetail();
          }

          view.router.init();
          view.$el.trigger('view:init');
          view.emit('local::init viewInit', view);
        }
      };

      return View;
    }(Framework7Class$1); // Use Router


    View$2.use(RouterModule);
    var View$3 = View$2;

    function initClicks(app) {
      function handleClicks(e) {
        var window = getWindow();
        var $clickedEl = $(e.target);
        var $clickedLinkEl = $clickedEl.closest('a');
        var isLink = $clickedLinkEl.length > 0;
        var url = isLink && $clickedLinkEl.attr('href'); // Check if link is external

        if (isLink) {
          if ($clickedLinkEl.is(app.params.clicks.externalLinks) || // eslint-disable-next-line
          url && url.indexOf('javascript:') >= 0) {
            var target = $clickedLinkEl.attr('target');

            if (url && window.cordova && window.cordova.InAppBrowser && (target === '_system' || target === '_blank')) {
              e.preventDefault();
              window.cordova.InAppBrowser.open(url, target);
            } else if (url && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Browser && (target === '_system' || target === '_blank')) {
              e.preventDefault();
              window.Capacitor.Plugins.Browser.open({
                url: url
              });
            }

            return;
          }
        } // Modules Clicks


        Object.keys(app.modules).forEach(function (moduleName) {
          var moduleClicks = app.modules[moduleName].clicks;
          if (!moduleClicks) return;
          if (e.preventF7Router) return;
          Object.keys(moduleClicks).forEach(function (clickSelector) {
            var matchingClickedElement = $clickedEl.closest(clickSelector).eq(0);

            if (matchingClickedElement.length > 0) {
              moduleClicks[clickSelector].call(app, matchingClickedElement, matchingClickedElement.dataset(), e);
            }
          });
        }); // Load Page

        var clickedLinkData = {};

        if (isLink) {
          e.preventDefault();
          clickedLinkData = $clickedLinkEl.dataset();
        }

        clickedLinkData.clickedEl = $clickedLinkEl[0]; // Prevent Router

        if (e.preventF7Router) return;
        if ($clickedLinkEl.hasClass('prevent-router') || $clickedLinkEl.hasClass('router-prevent')) return;
        var validUrl = url && url.length > 0 && url[0] !== '#';

        if (validUrl || $clickedLinkEl.hasClass('back')) {
          var view;

          if (clickedLinkData.view && clickedLinkData.view === 'current') {
            view = app.views.current;
          } else if (clickedLinkData.view) {
            view = $(clickedLinkData.view)[0].f7View;
          } else {
            view = $clickedEl.parents('.view')[0] && $clickedEl.parents('.view')[0].f7View;

            if (!$clickedLinkEl.hasClass('back') && view && view.params.linksView) {
              if (typeof view.params.linksView === 'string') view = $(view.params.linksView)[0].f7View;else if (view.params.linksView instanceof View$3) view = view.params.linksView;
            }
          }

          if (!view) {
            if (app.views.main) view = app.views.main;
          }

          if (!view || !view.router) return;

          if ($clickedLinkEl[0].f7RouteProps) {
            clickedLinkData.props = $clickedLinkEl[0].f7RouteProps;
          }

          if ($clickedLinkEl.hasClass('back')) view.router.back(url, clickedLinkData);else view.router.navigate(url, clickedLinkData);
        }
      }

      app.on('click', handleClicks);
    }

    var ClicksModule = {
      name: 'clicks',
      params: {
        clicks: {
          // External Links
          externalLinks: '.external'
        }
      },
      on: {
        init: function init() {
          var app = this;
          initClicks(app);
        }
      }
    };

    var HistoryModule = {
      name: 'history',
      static: {
        history: History$1
      },
      on: {
        init: function init() {
          History$1.init(this);
        }
      }
    };

    var SW = {
      registrations: [],
      register: function register(path, scope) {
        var app = this;
        var window = getWindow();

        if (!('serviceWorker' in window.navigator) || !app.serviceWorker.container) {
          return new Promise(function (resolve, reject) {
            reject(new Error('Service worker is not supported'));
          });
        }

        return new Promise(function (resolve, reject) {
          app.serviceWorker.container.register(path, scope ? {
            scope: scope
          } : {}).then(function (reg) {
            SW.registrations.push(reg);
            app.emit('serviceWorkerRegisterSuccess', reg);
            resolve(reg);
          }).catch(function (error) {
            app.emit('serviceWorkerRegisterError', error);
            reject(error);
          });
        });
      },
      unregister: function unregister(registration) {
        var app = this;
        var window = getWindow();

        if (!('serviceWorker' in window.navigator) || !app.serviceWorker.container) {
          return new Promise(function (resolve, reject) {
            reject(new Error('Service worker is not supported'));
          });
        }

        var registrations;
        if (!registration) registrations = SW.registrations;else if (Array.isArray(registration)) registrations = registration;else registrations = [registration];
        return Promise.all(registrations.map(function (reg) {
          return new Promise(function (resolve, reject) {
            reg.unregister().then(function () {
              if (SW.registrations.indexOf(reg) >= 0) {
                SW.registrations.splice(SW.registrations.indexOf(reg), 1);
              }

              app.emit('serviceWorkerUnregisterSuccess', reg);
              resolve();
            }).catch(function (error) {
              app.emit('serviceWorkerUnregisterError', reg, error);
              reject(error);
            });
          });
        }));
      }
    };
    var ServiceWorkerModule = {
      name: 'sw',
      params: {
        serviceWorker: {
          path: undefined,
          scope: undefined
        }
      },
      create: function create() {
        var app = this;
        var window = getWindow();
        extend$2(app, {
          serviceWorker: {
            container: 'serviceWorker' in window.navigator ? window.navigator.serviceWorker : undefined,
            registrations: SW.registrations,
            register: SW.register.bind(app),
            unregister: SW.unregister.bind(app)
          }
        });
      },
      on: {
        init: function init() {
          var window = getWindow();
          if (!('serviceWorker' in window.navigator)) return;
          var app = this;
          if (app.device.cordova || window.Capacitor && window.Capacitor.isNative) return;
          if (!app.serviceWorker.container) return;
          var paths = app.params.serviceWorker.path;
          var scope = app.params.serviceWorker.scope;
          if (!paths || Array.isArray(paths) && !paths.length) return;
          var toRegister = Array.isArray(paths) ? paths : [paths];
          toRegister.forEach(function (path) {
            app.serviceWorker.register(path, scope);
          });
        }
      }
    };

    function _extends$5() { _extends$5 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$5.apply(this, arguments); }

    function createStore(storeParams) {
      if (storeParams === void 0) {
        storeParams = {};
      }

      var store = {
        __store: true
      };

      var originalState = _extends$5({}, storeParams.state || {});

      var actions = _extends$5({}, storeParams.actions || {});

      var getters = _extends$5({}, storeParams.getters || {});

      var state = extend$2({}, originalState);
      var propsQueue = [];
      var gettersDependencies = {};
      var gettersCallbacks = {};
      Object.keys(getters).forEach(function (getterKey) {
        gettersDependencies[getterKey] = [];
        gettersCallbacks[getterKey] = [];
      });

      var getGetterValue = function getGetterValue(getterKey) {
        return getters[getterKey]({
          state: store.state
        });
      };

      var addGetterDependencies = function addGetterDependencies(getterKey, deps) {
        if (!gettersDependencies[getterKey]) gettersDependencies[getterKey] = [];
        deps.forEach(function (dep) {
          if (gettersDependencies[getterKey].indexOf(dep) < 0) {
            gettersDependencies[getterKey].push(dep);
          }
        });
      };

      var addGetterCallback = function addGetterCallback(getterKey, callback) {
        if (!gettersCallbacks[getterKey]) gettersCallbacks[getterKey] = [];
        gettersCallbacks[getterKey].push(callback);
      };

      var runGetterCallbacks = function runGetterCallbacks(stateKey) {
        var keys = Object.keys(gettersDependencies).filter(function (getterKey) {
          return gettersDependencies[getterKey].indexOf(stateKey) >= 0;
        });
        keys.forEach(function (getterKey) {
          if (!gettersCallbacks[getterKey] || !gettersCallbacks[getterKey].length) return;
          gettersCallbacks[getterKey].forEach(function (callback) {
            callback(getGetterValue(getterKey));
          });
        });
      };

      var removeGetterCallback = function removeGetterCallback(callback) {
        Object.keys(gettersCallbacks).forEach(function (stateKey) {
          var callbacks = gettersCallbacks[stateKey];

          if (callbacks.indexOf(callback) >= 0) {
            callbacks.splice(callbacks.indexOf(callback), 1);
          }
        });
      }; // eslint-disable-next-line


      store.__removeCallback = function (callback) {
        removeGetterCallback(callback);
      };

      var getterValue = function getterValue(getterKey, addCallback) {
        if (addCallback === void 0) {
          addCallback = true;
        }

        if (getterKey === 'constructor') return undefined;
        propsQueue = [];
        var value = getGetterValue(getterKey);
        addGetterDependencies(getterKey, propsQueue);

        var onUpdated = function onUpdated(callback) {
          addGetterCallback(getterKey, callback);
        };

        var obj = {
          value: value,
          onUpdated: onUpdated
        };

        if (!addCallback) {
          return obj;
        }

        var callback = function callback(v) {
          obj.value = v;
        };

        obj.__callback = callback;
        addGetterCallback(getterKey, callback); // eslint-disable-next-line

        return obj;
      };

      store.state = new Proxy(state, {
        set: function set(target, prop, value) {
          target[prop] = value;
          runGetterCallbacks(prop);
          return true;
        },
        get: function get(target, prop) {
          propsQueue.push(prop);
          return target[prop];
        }
      });
      store.getters = new Proxy(getters, {
        set: function set() {
          return false;
        },
        get: function get(target, prop) {
          if (!target[prop]) {
            return undefined;
          }

          return getterValue(prop, true);
        }
      });
      store._gettersPlain = new Proxy(getters, {
        set: function set() {
          return false;
        },
        get: function get(target, prop) {
          if (!target[prop]) {
            return undefined;
          }

          return getterValue(prop, false);
        }
      });

      store.dispatch = function (actionName, data) {
        return new Promise(function (resolve, reject) {
          if (!actions[actionName]) {
            reject();
            throw new Error("Framework7: Store action \"" + actionName + "\" is not found");
          }

          var result = actions[actionName]({
            state: store.state,
            dispatch: store.dispatch
          }, data);
          resolve(result);
        });
      };

      return store;
    }

    var StoreModule = {
      name: 'store',
      static: {
        createStore: createStore
      },
      proto: {
        createStore: createStore
      }
    };

    var isCapacitor = function isCapacitor() {
      var window = getWindow();
      return window.Capacitor && window.Capacitor.isNative && window.Capacitor.Plugins && window.Capacitor.Plugins.StatusBar;
    };

    var Statusbar = {
      hide: function hide() {
        var window = getWindow();
        var device = getDevice$1();

        if (device.cordova && window.StatusBar) {
          window.StatusBar.hide();
        }

        if (isCapacitor()) {
          window.Capacitor.Plugins.StatusBar.hide();
        }
      },
      show: function show() {
        var window = getWindow();
        var device = getDevice$1();

        if (device.cordova && window.StatusBar) {
          window.StatusBar.show();
        }

        if (isCapacitor()) {
          window.Capacitor.Plugins.StatusBar.show();
        }
      },
      onClick: function onClick() {
        var app = this;
        var pageContent;

        if ($('.popup.modal-in').length > 0) {
          // Check for opened popup
          pageContent = $('.popup.modal-in').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
        } else if ($('.panel.panel-in').length > 0) {
          // Check for opened panel
          pageContent = $('.panel.panel-in').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
        } else if ($('.views > .view.tab-active').length > 0) {
          // View in tab bar app layout
          pageContent = $('.views > .view.tab-active').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
        } else if ($('.views').length > 0) {
          pageContent = $('.views').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
        } else {
          pageContent = app.$el.children('.view').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
        }

        if (pageContent && pageContent.length > 0) {
          // Check for tab
          if (pageContent.hasClass('tab')) {
            pageContent = pageContent.parent('.tabs').children('.page-content.tab-active');
          }

          if (pageContent.length > 0) pageContent.scrollTop(0, 300);
        }
      },
      setTextColor: function setTextColor(color) {
        var window = getWindow();
        var device = getDevice$1();

        if (device.cordova && window.StatusBar) {
          if (color === 'white') {
            window.StatusBar.styleLightContent();
          } else {
            window.StatusBar.styleDefault();
          }
        }

        if (isCapacitor()) {
          if (color === 'white') {
            window.Capacitor.Plugins.StatusBar.setStyle({
              style: 'DARK'
            });
          } else {
            window.Capacitor.Plugins.StatusBar.setStyle({
              style: 'LIGHT'
            });
          }
        }
      },
      setBackgroundColor: function setBackgroundColor(color) {
        var window = getWindow();
        var device = getDevice$1();

        if (device.cordova && window.StatusBar) {
          window.StatusBar.backgroundColorByHexString(color);
        }

        if (isCapacitor()) {
          window.Capacitor.Plugins.StatusBar.setBackgroundColor({
            color: color
          });
        }
      },
      isVisible: function isVisible() {
        var window = getWindow();
        var device = getDevice$1();
        return new Promise(function (resolve) {
          if (device.cordova && window.StatusBar) {
            resolve(window.StatusBar.isVisible);
          }

          if (isCapacitor()) {
            window.Capacitor.Plugins.StatusBar.getInfo().then(function (info) {
              resolve(info.visible);
            });
          }

          resolve(false);
        });
      },
      overlaysWebView: function overlaysWebView(overlays) {
        if (overlays === void 0) {
          overlays = true;
        }

        var window = getWindow();
        var device = getDevice$1();

        if (device.cordova && window.StatusBar) {
          window.StatusBar.overlaysWebView(overlays);
        }

        if (isCapacitor()) {
          window.Capacitor.Plugins.StatusBar.setOverlaysWebView({
            overlay: overlays
          });
        }
      },
      init: function init() {
        var app = this;
        var window = getWindow();
        var device = getDevice$1();
        var params = app.params.statusbar;
        if (!params.enabled) return;
        var isCordova = device.cordova && window.StatusBar;
        var isCap = isCapacitor();

        if (isCordova || isCap) {
          if (params.scrollTopOnClick) {
            $(window).on('statusTap', Statusbar.onClick.bind(app));
          }

          if (device.ios) {
            if (params.iosOverlaysWebView) {
              Statusbar.overlaysWebView(true);
            } else {
              Statusbar.overlaysWebView(false);
            }

            if (params.iosTextColor === 'white') {
              Statusbar.setTextColor('white');
            } else {
              Statusbar.setTextColor('black');
            }
          }

          if (device.android) {
            if (params.androidOverlaysWebView) {
              Statusbar.overlaysWebView(true);
            } else {
              Statusbar.overlaysWebView(false);
            }

            if (params.androidTextColor === 'white') {
              Statusbar.setTextColor('white');
            } else {
              Statusbar.setTextColor('black');
            }
          }
        }

        if (params.iosBackgroundColor && device.ios) {
          Statusbar.setBackgroundColor(params.iosBackgroundColor);
        }

        if (params.androidBackgroundColor && device.android) {
          Statusbar.setBackgroundColor(params.androidBackgroundColor);
        }
      }
    };
    var Statusbar$1 = {
      name: 'statusbar',
      params: {
        statusbar: {
          enabled: true,
          scrollTopOnClick: true,
          iosOverlaysWebView: true,
          iosTextColor: 'black',
          iosBackgroundColor: null,
          androidOverlaysWebView: false,
          androidTextColor: 'black',
          androidBackgroundColor: null
        }
      },
      create: function create() {
        var app = this;
        bindMethods(app, {
          statusbar: Statusbar
        });
      },
      on: {
        init: function init() {
          var app = this;
          Statusbar.init.call(app);
        }
      }
    };

    function getCurrentView(app) {
      var $popoverView = $('.popover.modal-in .view');
      var $popupView = $('.popup.modal-in .view');
      var $panelView = $('.panel.panel-in .view');
      var $viewsEl = $('.views');
      if ($viewsEl.length === 0) $viewsEl = app.$el; // Find active view as tab

      var $viewEl = $viewsEl.children('.view');

      if ($viewEl.length === 0) {
        $viewEl = $viewsEl.children('.tabs').children('.view');
      } // Propably in tabs or split view


      if ($viewEl.length > 1) {
        if ($viewEl.hasClass('tab')) {
          // Tabs
          $viewEl = $viewsEl.children('.view.tab-active');

          if ($viewEl.length === 0) {
            $viewEl = $viewsEl.children('.tabs').children('.view.tab-active');
          }
        }
      }

      if ($popoverView.length > 0 && $popoverView[0].f7View) return $popoverView[0].f7View;
      if ($popupView.length > 0 && $popupView[0].f7View) return $popupView[0].f7View;
      if ($panelView.length > 0 && $panelView[0].f7View) return $panelView[0].f7View;

      if ($viewEl.length > 0) {
        if ($viewEl.length === 1 && $viewEl[0].f7View) return $viewEl[0].f7View;

        if ($viewEl.length > 1) {
          return app.views.main;
        }
      }

      return undefined;
    }

    var View$1 = {
      name: 'view',
      params: {
        view: {
          init: true,
          name: undefined,
          main: false,
          router: true,
          linksView: null,
          stackPages: false,
          xhrCache: true,
          xhrCacheIgnore: [],
          xhrCacheIgnoreGetParameters: false,
          xhrCacheDuration: 1000 * 60 * 10,
          // Ten minutes
          componentCache: true,
          preloadPreviousPage: true,
          allowDuplicateUrls: false,
          reloadPages: false,
          reloadDetail: false,
          masterDetailBreakpoint: 0,
          masterDetailResizable: false,
          removeElements: true,
          removeElementsWithTimeout: false,
          removeElementsTimeout: 0,
          restoreScrollTopOnBack: true,
          unloadTabContent: true,
          passRouteQueryToRequest: true,
          passRouteParamsToRequest: false,
          loadInitialPage: true,
          // Swipe Back
          iosSwipeBack: true,
          iosSwipeBackAnimateShadow: true,
          iosSwipeBackAnimateOpacity: true,
          iosSwipeBackActiveArea: 30,
          iosSwipeBackThreshold: 0,
          mdSwipeBack: false,
          mdSwipeBackAnimateShadow: true,
          mdSwipeBackAnimateOpacity: false,
          mdSwipeBackActiveArea: 30,
          mdSwipeBackThreshold: 0,
          auroraSwipeBack: false,
          auroraSwipeBackAnimateShadow: false,
          auroraSwipeBackAnimateOpacity: true,
          auroraSwipeBackActiveArea: 30,
          auroraSwipeBackThreshold: 0,
          // Push State
          browserHistory: false,
          browserHistoryRoot: undefined,
          browserHistoryAnimate: true,
          browserHistoryAnimateOnLoad: false,
          browserHistorySeparator: '#!',
          browserHistoryOnLoad: true,
          browserHistoryInitialMatch: false,
          browserHistoryStoreHistory: true,
          // Animate Pages
          animate: true,
          // iOS Dynamic Navbar
          iosDynamicNavbar: true,
          // Animate iOS Navbar Back Icon
          iosAnimateNavbarBackIcon: true,
          // Delays
          iosPageLoadDelay: 0,
          mdPageLoadDelay: 0,
          auroraPageLoadDelay: 0,
          // Routes hooks
          routesBeforeEnter: null,
          routesBeforeLeave: null
        }
      },
      static: {
        View: View$3
      },
      create: function create() {
        var app = this;
        extend$2(app, {
          views: extend$2([], {
            create: function create(el, params) {
              return new View$3(app, el, params);
            },
            get: function get(viewEl) {
              var $viewEl = $(viewEl);
              if ($viewEl.length && $viewEl[0].f7View) return $viewEl[0].f7View;
              return undefined;
            }
          })
        });
        Object.defineProperty(app.views, 'current', {
          enumerable: true,
          configurable: true,
          get: function get() {
            return getCurrentView(app);
          }
        }); // Alias

        app.view = app.views;
      },
      on: {
        init: function init() {
          var app = this;
          $('.view-init').each(function (viewEl) {
            if (viewEl.f7View) return;
            var viewParams = $(viewEl).dataset();
            app.views.create(viewEl, viewParams);
          });
        },
        'modalOpen panelOpen': function onOpen(instance) {
          var app = this;
          instance.$el.find('.view-init').each(function (viewEl) {
            if (viewEl.f7View) return;
            var viewParams = $(viewEl).dataset();
            app.views.create(viewEl, viewParams);
          });
        },
        'modalBeforeDestroy panelBeforeDestroy': function onClose(instance) {
          if (!instance || !instance.$el) return;
          instance.$el.find('.view-init').each(function (viewEl) {
            var view = viewEl.f7View;
            if (!view) return;
            view.destroy();
          });
        }
      },
      vnode: {
        'view-init': {
          insert: function insert(vnode) {
            var app = this;
            var viewEl = vnode.elm;
            if (viewEl.f7View) return;
            var viewParams = $(viewEl).dataset();
            app.views.create(viewEl, viewParams);
          },
          destroy: function destroy(vnode) {
            var viewEl = vnode.elm;
            var view = viewEl.f7View;
            if (!view) return;
            view.destroy();
          }
        }
      }
    };

    var Navbar$1 = {
      size: function size(el) {
        var app = this;
        var $el = $(el);

        if ($el.hasClass('navbars')) {
          $el = $el.children('.navbar').each(function (navbarEl) {
            app.navbar.size(navbarEl);
          });
          return;
        }

        var $innerEl = $el.children('.navbar-inner');
        if (!$innerEl.length) return;
        var needCenterTitle = $innerEl.hasClass('navbar-inner-centered-title') || app.params.navbar[app.theme + "CenterTitle"];
        var needLeftTitle = app.theme === 'ios' && !app.params.navbar[app.theme + "CenterTitle"];
        if (!needCenterTitle && !needLeftTitle) return;

        if ($el.hasClass('stacked') || $el.parents('.stacked').length > 0 || $el.parents('.tab:not(.tab-active)').length > 0 || $el.parents('.popup:not(.modal-in)').length > 0) {
          return;
        }

        if (app.theme !== 'ios' && app.params.navbar[app.theme + "CenterTitle"]) {
          $innerEl.addClass('navbar-inner-centered-title');
        }

        if (app.theme === 'ios' && !app.params.navbar.iosCenterTitle) {
          $innerEl.addClass('navbar-inner-left-title');
        }

        var $viewEl = $el.parents('.view').eq(0);
        var left = app.rtl ? $innerEl.children('.right') : $innerEl.children('.left');
        var right = app.rtl ? $innerEl.children('.left') : $innerEl.children('.right');
        var title = $innerEl.children('.title');
        var subnavbar = $innerEl.children('.subnavbar');
        var noLeft = left.length === 0;
        var noRight = right.length === 0;
        var leftWidth = noLeft ? 0 : left.outerWidth(true);
        var rightWidth = noRight ? 0 : right.outerWidth(true);
        var titleWidth = title.outerWidth(true);
        var navbarStyles = $innerEl.styles();
        var navbarWidth = $innerEl[0].offsetWidth;
        var navbarInnerWidth = navbarWidth - parseInt(navbarStyles.paddingLeft, 10) - parseInt(navbarStyles.paddingRight, 10);
        var isPrevious = $el.hasClass('navbar-previous');
        var sliding = $innerEl.hasClass('sliding');
        var router;
        var dynamicNavbar;

        if ($viewEl.length > 0 && $viewEl[0].f7View) {
          router = $viewEl[0].f7View.router;
          dynamicNavbar = router && router.dynamicNavbar;
        }

        var currLeft;
        var diff;

        if (noRight) {
          currLeft = navbarInnerWidth - titleWidth;
        }

        if (noLeft) {
          currLeft = 0;
        }

        if (!noLeft && !noRight) {
          currLeft = (navbarInnerWidth - rightWidth - titleWidth + leftWidth) / 2;
        }

        var requiredLeft = (navbarInnerWidth - titleWidth) / 2;

        if (navbarInnerWidth - leftWidth - rightWidth > titleWidth) {
          if (requiredLeft < leftWidth) {
            requiredLeft = leftWidth;
          }

          if (requiredLeft + titleWidth > navbarInnerWidth - rightWidth) {
            requiredLeft = navbarInnerWidth - rightWidth - titleWidth;
          }

          diff = requiredLeft - currLeft;
        } else {
          diff = 0;
        } // RTL inverter


        var inverter = app.rtl ? -1 : 1;

        if (dynamicNavbar && app.theme === 'ios') {
          if (title.hasClass('sliding') || title.length > 0 && sliding) {
            var titleLeftOffset = -(currLeft + diff) * inverter;
            var titleRightOffset = (navbarInnerWidth - currLeft - diff - titleWidth) * inverter;

            if (isPrevious) {
              if (router && router.params.iosAnimateNavbarBackIcon) {
                var activeNavbarBackLink = $el.parent().find('.navbar-current').children('.left.sliding').find('.back .icon ~ span');

                if (activeNavbarBackLink.length > 0) {
                  titleLeftOffset += activeNavbarBackLink[0].offsetLeft;
                }
              }
            }

            title[0].f7NavbarLeftOffset = titleLeftOffset;
            title[0].f7NavbarRightOffset = titleRightOffset;
          }

          if (!noLeft && (left.hasClass('sliding') || sliding)) {
            if (app.rtl) {
              left[0].f7NavbarLeftOffset = -(navbarInnerWidth - left[0].offsetWidth) / 2 * inverter;
              left[0].f7NavbarRightOffset = leftWidth * inverter;
            } else {
              left[0].f7NavbarLeftOffset = -leftWidth;
              left[0].f7NavbarRightOffset = (navbarInnerWidth - left[0].offsetWidth) / 2;

              if (router && router.params.iosAnimateNavbarBackIcon && left.find('.back .icon').length > 0) {
                if (left.find('.back .icon ~ span').length) {
                  var leftOffset = left[0].f7NavbarLeftOffset;
                  var rightOffset = left[0].f7NavbarRightOffset;
                  left[0].f7NavbarLeftOffset = 0;
                  left[0].f7NavbarRightOffset = 0;
                  left.find('.back .icon ~ span')[0].f7NavbarLeftOffset = leftOffset;
                  left.find('.back .icon ~ span')[0].f7NavbarRightOffset = rightOffset - left.find('.back .icon')[0].offsetWidth;
                }
              }
            }
          }

          if (!noRight && (right.hasClass('sliding') || sliding)) {
            if (app.rtl) {
              right[0].f7NavbarLeftOffset = -rightWidth * inverter;
              right[0].f7NavbarRightOffset = (navbarInnerWidth - right[0].offsetWidth) / 2 * inverter;
            } else {
              right[0].f7NavbarLeftOffset = -(navbarInnerWidth - right[0].offsetWidth) / 2;
              right[0].f7NavbarRightOffset = rightWidth;
            }
          }

          if (subnavbar.length && (subnavbar.hasClass('sliding') || sliding)) {
            subnavbar[0].f7NavbarLeftOffset = app.rtl ? subnavbar[0].offsetWidth : -subnavbar[0].offsetWidth;
            subnavbar[0].f7NavbarRightOffset = -subnavbar[0].f7NavbarLeftOffset;
          }
        } // Center title


        if (needCenterTitle) {
          var titleLeft = diff;
          if (app.rtl && noLeft && noRight && title.length > 0) titleLeft = -titleLeft;
          title.css({
            left: titleLeft + "px"
          });
        }
      },
      hide: function hide(el, animate, hideStatusbar, hideOnlyCurrent) {
        if (animate === void 0) {
          animate = true;
        }

        if (hideStatusbar === void 0) {
          hideStatusbar = false;
        }

        if (hideOnlyCurrent === void 0) {
          hideOnlyCurrent = false;
        }

        var app = this;
        var $el = $(el);
        var isDynamic = $el.hasClass('navbar') && $el.parent('.navbars').length && !hideOnlyCurrent;
        if (isDynamic) $el = $el.parents('.navbars');
        if (!$el.length) return;
        if ($el.hasClass('navbar-hidden')) return;
        var className = "navbar-hidden" + (animate ? ' navbar-transitioning' : '');
        var currentIsLarge = isDynamic ? $el.find('.navbar-current .title-large').length : $el.find('.title-large').length;

        if (currentIsLarge) {
          className += ' navbar-large-hidden';
        }

        if (hideStatusbar) {
          className += ' navbar-hidden-statusbar';
        }

        $el.transitionEnd(function () {
          $el.removeClass('navbar-transitioning');
        });
        $el.addClass(className);

        if (isDynamic) {
          $el.children('.navbar').each(function (subEl) {
            $(subEl).trigger('navbar:hide');
            app.emit('navbarHide', subEl);
          });
        } else {
          $el.trigger('navbar:hide');
          app.emit('navbarHide', $el[0]);
        }
      },
      show: function show(el, animate, hideOnlyCurrent) {
        if (el === void 0) {
          el = '.navbar-hidden';
        }

        if (animate === void 0) {
          animate = true;
        }

        if (hideOnlyCurrent === void 0) {
          hideOnlyCurrent = false;
        }

        var app = this;
        var $el = $(el);
        var isDynamic = $el.hasClass('navbar') && $el.parent('.navbars').length && !hideOnlyCurrent;
        if (isDynamic) $el = $el.parents('.navbars');
        if (!$el.length) return;
        if (!$el.hasClass('navbar-hidden')) return;

        if (animate) {
          $el.addClass('navbar-transitioning');
          $el.transitionEnd(function () {
            $el.removeClass('navbar-transitioning');
          });
        }

        $el.removeClass('navbar-hidden navbar-large-hidden navbar-hidden-statusbar');

        if (isDynamic) {
          $el.children('.navbar').each(function (subEl) {
            $(subEl).trigger('navbar:show');
            app.emit('navbarShow', subEl);
          });
        } else {
          $el.trigger('navbar:show');
          app.emit('navbarShow', $el[0]);
        }
      },
      getElByPage: function getElByPage(page) {
        var $pageEl;
        var $navbarEl;
        var pageData;

        if (page.$navbarEl || page.$el) {
          pageData = page;
          $pageEl = page.$el;
        } else {
          $pageEl = $(page);
          if ($pageEl.length > 0) pageData = $pageEl[0].f7Page;
        }

        if (pageData && pageData.$navbarEl && pageData.$navbarEl.length > 0) {
          $navbarEl = pageData.$navbarEl;
        } else if ($pageEl) {
          $navbarEl = $pageEl.children('.navbar');
        }

        if (!$navbarEl || $navbarEl && $navbarEl.length === 0) return undefined;
        return $navbarEl[0];
      },
      getPageByEl: function getPageByEl(navbarEl) {
        var $navbarEl = $(navbarEl);

        if ($navbarEl.parents('.page').length) {
          return $navbarEl.parents('.page')[0];
        }

        var pageEl;
        $navbarEl.parents('.view').find('.page').each(function (el) {
          if (el && el.f7Page && el.f7Page.navbarEl && $navbarEl[0] === el.f7Page.navbarEl) {
            pageEl = el;
          }
        });
        return pageEl;
      },
      collapseLargeTitle: function collapseLargeTitle(navbarEl) {
        var app = this;
        var $navbarEl = $(navbarEl);

        if ($navbarEl.hasClass('navbars')) {
          $navbarEl = $navbarEl.find('.navbar');

          if ($navbarEl.length > 1) {
            $navbarEl = $(navbarEl).find('.navbar-large.navbar-current');
          }

          if ($navbarEl.length > 1 || !$navbarEl.length) {
            return;
          }
        }

        var $pageEl = $(app.navbar.getPageByEl($navbarEl));
        $navbarEl.addClass('navbar-large-collapsed');
        $pageEl.eq(0).addClass('page-with-navbar-large-collapsed').trigger('page:navbarlargecollapsed');
        app.emit('pageNavbarLargeCollapsed', $pageEl[0]);
        $navbarEl.trigger('navbar:collapse');
        app.emit('navbarCollapse', $navbarEl[0]);
      },
      expandLargeTitle: function expandLargeTitle(navbarEl) {
        var app = this;
        var $navbarEl = $(navbarEl);

        if ($navbarEl.hasClass('navbars')) {
          $navbarEl = $navbarEl.find('.navbar-large');

          if ($navbarEl.length > 1) {
            $navbarEl = $(navbarEl).find('.navbar-large.navbar-current');
          }

          if ($navbarEl.length > 1 || !$navbarEl.length) {
            return;
          }
        }

        var $pageEl = $(app.navbar.getPageByEl($navbarEl));
        $navbarEl.removeClass('navbar-large-collapsed');
        $pageEl.eq(0).removeClass('page-with-navbar-large-collapsed').trigger('page:navbarlargeexpanded');
        app.emit('pageNavbarLargeExpanded', $pageEl[0]);
        $navbarEl.trigger('navbar:expand');
        app.emit('navbarExpand', $navbarEl[0]);
      },
      toggleLargeTitle: function toggleLargeTitle(navbarEl) {
        var app = this;
        var $navbarEl = $(navbarEl);

        if ($navbarEl.hasClass('navbars')) {
          $navbarEl = $navbarEl.find('.navbar-large');

          if ($navbarEl.length > 1) {
            $navbarEl = $(navbarEl).find('.navbar-large.navbar-current');
          }

          if ($navbarEl.length > 1 || !$navbarEl.length) {
            return;
          }
        }

        if ($navbarEl.hasClass('navbar-large-collapsed')) {
          app.navbar.expandLargeTitle($navbarEl);
        } else {
          app.navbar.collapseLargeTitle($navbarEl);
        }
      },
      initNavbarOnScroll: function initNavbarOnScroll(pageEl, navbarEl, needHide, needCollapse, needTransparent) {
        var app = this;
        var support = getSupport$1();
        var $pageEl = $(pageEl);
        var $navbarEl = $(navbarEl);
        var $titleLargeEl = $navbarEl.find('.title-large');
        var isLarge = $titleLargeEl.length || $navbarEl.hasClass('.navbar-large');
        var navbarHideHeight = 44;
        var snapPageScrollToLargeTitle = app.params.navbar.snapPageScrollToLargeTitle;
        var snapPageScrollToTransparentNavbar = app.params.navbar.snapPageScrollToTransparentNavbar;
        var previousScrollTop;
        var currentScrollTop;
        var scrollHeight;
        var offsetHeight;
        var reachEnd;
        var action;
        var navbarHidden;
        var navbarCollapsed;
        var navbarTitleLargeHeight;
        var navbarOffsetHeight;

        if (needCollapse || needHide && isLarge) {
          navbarTitleLargeHeight = $navbarEl.css('--f7-navbar-large-title-height');

          if (navbarTitleLargeHeight && navbarTitleLargeHeight.indexOf('px') >= 0) {
            navbarTitleLargeHeight = parseInt(navbarTitleLargeHeight, 10);

            if (Number.isNaN(navbarTitleLargeHeight) && $titleLargeEl.length) {
              navbarTitleLargeHeight = $titleLargeEl[0].offsetHeight;
            } else if (Number.isNaN(navbarTitleLargeHeight)) {
              if (app.theme === 'ios') navbarTitleLargeHeight = 52;else if (app.theme === 'md') navbarTitleLargeHeight = 48;else if (app.theme === 'aurora') navbarTitleLargeHeight = 38;
            }
          } else if ($titleLargeEl.length) {
            navbarTitleLargeHeight = $titleLargeEl[0].offsetHeight;
          } else {
            // eslint-disable-next-line
            if (app.theme === 'ios') navbarTitleLargeHeight = 52;else if (app.theme === 'md') navbarTitleLargeHeight = 48;else if (app.theme === 'aurora') navbarTitleLargeHeight = 38;
          }
        }

        if (needHide && isLarge) {
          navbarHideHeight += navbarTitleLargeHeight;
        }

        var scrollChanged;
        var scrollContent;
        var scrollTimeoutId;
        var touchEndTimeoutId;
        var touchSnapTimeout = 70;
        var desktopSnapTimeout = 300;

        function calcScrollableDistance() {
          $pageEl.find('.page-content').each(function (pageContentEl) {
            pageContentEl.f7ScrollableDistance = pageContentEl.scrollHeight - pageContentEl.offsetHeight;
          });
        }

        function snapLargeNavbar() {
          var inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
          if (inSearchbarExpanded) return;
          if (!scrollContent || currentScrollTop < 0) return;

          if (currentScrollTop >= navbarTitleLargeHeight / 2 && currentScrollTop < navbarTitleLargeHeight) {
            $(scrollContent).scrollTop(navbarTitleLargeHeight, 100);
          } else if (currentScrollTop < navbarTitleLargeHeight) {
            $(scrollContent).scrollTop(0, 200);
          }
        }

        function snapTransparentNavbar() {
          var inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
          if (inSearchbarExpanded) return;
          if (!scrollContent || currentScrollTop < 0) return;

          if (currentScrollTop >= navbarOffsetHeight / 2 && currentScrollTop < navbarOffsetHeight) {
            $(scrollContent).scrollTop(navbarOffsetHeight, 100);
          } else if (currentScrollTop < navbarOffsetHeight) {
            $(scrollContent).scrollTop(0, 200);
          }
        }

        function handleNavbarTransparent() {
          var isHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');
          var inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
          if (inSearchbarExpanded || isHidden) return;

          if (!navbarOffsetHeight) {
            navbarOffsetHeight = navbarEl.offsetHeight;
          }

          var opacity = currentScrollTop / navbarOffsetHeight;
          var notTransparent = $navbarEl.hasClass('navbar-transparent-visible');
          opacity = Math.max(Math.min(opacity, 1), 0);

          if (notTransparent && opacity === 1 || !notTransparent && opacity === 0) {
            $navbarEl.find('.navbar-bg, .title').css('opacity', '');
            return;
          }

          if (notTransparent && opacity === 0) {
            $navbarEl.trigger('navbar:transparenthide');
            app.emit('navbarTransparentHide', $navbarEl[0]);
            $navbarEl.removeClass('navbar-transparent-visible');
            $navbarEl.find('.navbar-bg, .title').css('opacity', '');
            return;
          }

          if (!notTransparent && opacity === 1) {
            $navbarEl.trigger('navbar:transparentshow');
            app.emit('navbarTransparentShow', $navbarEl[0]);
            $navbarEl.addClass('navbar-transparent-visible');
            $navbarEl.find('.navbar-bg, .title').css('opacity', '');
            return;
          }

          $navbarEl.find('.navbar-bg, .title').css('opacity', opacity);

          if (snapPageScrollToTransparentNavbar) {
            if (!support.touch) {
              clearTimeout(scrollTimeoutId);
              scrollTimeoutId = setTimeout(function () {
                snapTransparentNavbar();
              }, desktopSnapTimeout);
            } else if (touchEndTimeoutId) {
              clearTimeout(touchEndTimeoutId);
              touchEndTimeoutId = null;
              touchEndTimeoutId = setTimeout(function () {
                snapTransparentNavbar();
                clearTimeout(touchEndTimeoutId);
                touchEndTimeoutId = null;
              }, touchSnapTimeout);
            }
          }
        }

        var previousCollapseProgress = null;
        var collapseProgress = null;

        function handleLargeNavbarCollapse(pageContentEl) {
          var isHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');
          if (isHidden) return;
          var isLargeTransparent = $navbarEl.hasClass('navbar-large-transparent') || $navbarEl.hasClass('navbar-large') && $navbarEl.hasClass('navbar-transparent');
          previousCollapseProgress = collapseProgress;
          var scrollableDistance = Math.min(navbarTitleLargeHeight, pageContentEl.f7ScrollableDistance || navbarTitleLargeHeight);
          collapseProgress = Math.min(Math.max(currentScrollTop / scrollableDistance, 0), 1);
          var previousCollapseWasInMiddle = previousCollapseProgress > 0 && previousCollapseProgress < 1;
          var inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
          if (inSearchbarExpanded) return;
          navbarCollapsed = $navbarEl.hasClass('navbar-large-collapsed');

          if (collapseProgress === 0 && navbarCollapsed) {
            app.navbar.expandLargeTitle($navbarEl[0]);
          } else if (collapseProgress === 1 && !navbarCollapsed) {
            app.navbar.collapseLargeTitle($navbarEl[0]);
          }

          if (collapseProgress === 0 && navbarCollapsed || collapseProgress === 0 && previousCollapseWasInMiddle || collapseProgress === 1 && !navbarCollapsed || collapseProgress === 1 && previousCollapseWasInMiddle) {
            if (app.theme === 'md') {
              $navbarEl.find('.navbar-inner').css('overflow', '');
            }

            $navbarEl.find('.title').css('opacity', '');
            $navbarEl.find('.title-large-text, .subnavbar').css('transform', '');

            if (isLargeTransparent) {
              $navbarEl.find('.navbar-bg').css('opacity', '');
            } else {
              $navbarEl.find('.navbar-bg').css('transform', '');
            }
          } else if (collapseProgress > 0 && collapseProgress < 1) {
            if (app.theme === 'md') {
              $navbarEl.find('.navbar-inner').css('overflow', 'visible');
            }

            $navbarEl.find('.title').css('opacity', collapseProgress);
            $navbarEl.find('.title-large-text, .subnavbar').css('transform', "translate3d(0px, " + -1 * collapseProgress * navbarTitleLargeHeight + "px, 0)");

            if (isLargeTransparent) {
              $navbarEl.find('.navbar-bg').css('opacity', collapseProgress);
            } else {
              $navbarEl.find('.navbar-bg').css('transform', "translate3d(0px, " + -1 * collapseProgress * navbarTitleLargeHeight + "px, 0)");
            }
          }

          if (snapPageScrollToLargeTitle) {
            if (!support.touch) {
              clearTimeout(scrollTimeoutId);
              scrollTimeoutId = setTimeout(function () {
                snapLargeNavbar();
              }, desktopSnapTimeout);
            } else if (touchEndTimeoutId) {
              clearTimeout(touchEndTimeoutId);
              touchEndTimeoutId = null;
              touchEndTimeoutId = setTimeout(function () {
                snapLargeNavbar();
                clearTimeout(touchEndTimeoutId);
                touchEndTimeoutId = null;
              }, touchSnapTimeout);
            }
          }
        }

        function handleTitleHideShow() {
          if ($pageEl.hasClass('page-with-card-opened')) return;
          scrollHeight = scrollContent.scrollHeight;
          offsetHeight = scrollContent.offsetHeight;
          reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
          navbarHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');

          if (reachEnd) {
            if (app.params.navbar.showOnPageScrollEnd) {
              action = 'show';
            }
          } else if (previousScrollTop > currentScrollTop) {
            if (app.params.navbar.showOnPageScrollTop || currentScrollTop <= navbarHideHeight) {
              action = 'show';
            } else {
              action = 'hide';
            }
          } else if (currentScrollTop > navbarHideHeight) {
            action = 'hide';
          } else {
            action = 'show';
          }

          if (action === 'show' && navbarHidden) {
            app.navbar.show($navbarEl, true, true);
            navbarHidden = false;
          } else if (action === 'hide' && !navbarHidden) {
            app.navbar.hide($navbarEl, true, false, true);
            navbarHidden = true;
          }

          previousScrollTop = currentScrollTop;
        }

        function handleScroll(e) {
          scrollContent = this;

          if (e && e.target && e.target !== scrollContent) {
            return;
          }

          currentScrollTop = scrollContent.scrollTop;
          scrollChanged = currentScrollTop;

          if (needCollapse) {
            handleLargeNavbarCollapse(scrollContent);
          } else if (needTransparent) {
            handleNavbarTransparent();
          }

          if ($pageEl.hasClass('page-previous')) return;

          if (needHide) {
            handleTitleHideShow();
          }
        }

        function handeTouchStart() {
          scrollChanged = false;
        }

        function handleTouchEnd() {
          clearTimeout(touchEndTimeoutId);
          touchEndTimeoutId = null;
          touchEndTimeoutId = setTimeout(function () {
            if (scrollChanged !== false) {
              if (needTransparent && !needCollapse) {
                snapTransparentNavbar();
              } else {
                snapLargeNavbar();
              }

              clearTimeout(touchEndTimeoutId);
              touchEndTimeoutId = null;
            }
          }, touchSnapTimeout);
        }

        $pageEl.on('scroll', '.page-content', handleScroll, true);

        if (support.touch && (needCollapse && snapPageScrollToLargeTitle || needTransparent && snapPageScrollToTransparentNavbar)) {
          app.on('touchstart:passive', handeTouchStart);
          app.on('touchend:passive', handleTouchEnd);
        }

        calcScrollableDistance();

        if (needCollapse || needTransparent) {
          $pageEl.find('.page-content').each(function (pageContentEl) {
            if (pageContentEl.scrollTop > 0) handleScroll.call(pageContentEl);
          });
        }

        app.on('resize', calcScrollableDistance);

        $pageEl[0].f7DetachNavbarScrollHandlers = function f7DetachNavbarScrollHandlers() {
          app.off('resize', calcScrollableDistance);
          delete $pageEl[0].f7DetachNavbarScrollHandlers;
          $pageEl.off('scroll', '.page-content', handleScroll, true);

          if (support.touch && (needCollapse && snapPageScrollToLargeTitle || needTransparent && snapPageScrollToTransparentNavbar)) {
            app.off('touchstart:passive', handeTouchStart);
            app.off('touchend:passive', handleTouchEnd);
          }
        };
      }
    };
    var Navbar$2 = {
      name: 'navbar',
      create: function create() {
        var app = this;
        bindMethods(app, {
          navbar: Navbar$1
        });
      },
      params: {
        navbar: {
          scrollTopOnTitleClick: true,
          iosCenterTitle: true,
          mdCenterTitle: false,
          auroraCenterTitle: true,
          hideOnPageScroll: false,
          showOnPageScrollEnd: true,
          showOnPageScrollTop: true,
          collapseLargeTitleOnScroll: true,
          snapPageScrollToLargeTitle: true,
          snapPageScrollToTransparentNavbar: true
        }
      },
      on: {
        'panelBreakpoint panelCollapsedBreakpoint panelResize viewResize resize viewMasterDetailBreakpoint': function onPanelResize() {
          var app = this;
          $('.navbar').each(function (navbarEl) {
            app.navbar.size(navbarEl);
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          if (page.$el[0].f7DetachNavbarScrollHandlers) {
            page.$el[0].f7DetachNavbarScrollHandlers();
          }
        },
        pageBeforeIn: function pageBeforeIn(page) {
          var app = this;
          if (app.theme !== 'ios') return;
          var $navbarsEl;
          var view = page.$el.parents('.view')[0].f7View;
          var navbarEl = app.navbar.getElByPage(page);

          if (!navbarEl) {
            $navbarsEl = page.$el.parents('.view').children('.navbars');
          } else {
            $navbarsEl = $(navbarEl).parents('.navbars');
          }

          if (page.$el.hasClass('no-navbar') || view.router.dynamicNavbar && !navbarEl) {
            var animate = !!(page.pageFrom && page.router.history.length > 0);
            app.navbar.hide($navbarsEl, animate);
          } else {
            app.navbar.show($navbarsEl);
          }
        },
        pageReinit: function pageReinit(page) {
          var app = this;
          var $navbarEl = $(app.navbar.getElByPage(page));
          if (!$navbarEl || $navbarEl.length === 0) return;
          app.navbar.size($navbarEl);
        },
        pageInit: function pageInit(page) {
          var app = this;
          var $navbarEl = $(app.navbar.getElByPage(page));
          if (!$navbarEl || $navbarEl.length === 0) return; // Size

          app.navbar.size($navbarEl); // Need Collapse On Scroll

          var needCollapseOnScrollHandler;

          if ($navbarEl.find('.title-large').length > 0) {
            $navbarEl.addClass('navbar-large');
          }

          if ($navbarEl.hasClass('navbar-large')) {
            if (app.params.navbar.collapseLargeTitleOnScroll) needCollapseOnScrollHandler = true;
            page.$el.addClass('page-with-navbar-large');
          } // Need transparent on scroll


          var needTransparentOnScroll;

          if (!needCollapseOnScrollHandler && $navbarEl.hasClass('navbar-transparent')) {
            needTransparentOnScroll = true;
          } // Need Hide On Scroll


          var needHideOnScrollHandler;

          if (app.params.navbar.hideOnPageScroll || page.$el.find('.hide-navbar-on-scroll').length || page.$el.hasClass('hide-navbar-on-scroll') || page.$el.find('.hide-bars-on-scroll').length || page.$el.hasClass('hide-bars-on-scroll')) {
            if (page.$el.find('.keep-navbar-on-scroll').length || page.$el.hasClass('keep-navbar-on-scroll') || page.$el.find('.keep-bars-on-scroll').length || page.$el.hasClass('keep-bars-on-scroll')) {
              needHideOnScrollHandler = false;
            } else {
              needHideOnScrollHandler = true;
            }
          }

          if (needCollapseOnScrollHandler || needHideOnScrollHandler || needTransparentOnScroll) {
            app.navbar.initNavbarOnScroll(page.el, $navbarEl[0], needHideOnScrollHandler, needCollapseOnScrollHandler, needTransparentOnScroll);
          }
        },
        'panelOpen panelSwipeOpen modalOpen': function onPanelModalOpen(instance) {
          var app = this;
          instance.$el.find('.navbar:not(.navbar-previous):not(.stacked)').each(function (navbarEl) {
            app.navbar.size(navbarEl);
          });
        },
        tabShow: function tabShow(tabEl) {
          var app = this;
          $(tabEl).find('.navbar:not(.navbar-previous):not(.stacked)').each(function (navbarEl) {
            app.navbar.size(navbarEl);
          });
        }
      },
      clicks: {
        '.navbar .title': function onTitleClick($clickedEl, clickedData, e) {
          var app = this;
          if (!app.params.navbar.scrollTopOnTitleClick) return;

          if ($(e.target).closest('a, button').length > 0) {
            return;
          }

          var $pageContentEl; // Find active page

          var $navbarEl = $clickedEl.parents('.navbar');
          var $navbarsEl = $navbarEl.parents('.navbars'); // Static Layout

          $pageContentEl = $navbarEl.parents('.page-content');

          if ($pageContentEl.length === 0) {
            // Fixed Layout
            if ($navbarEl.parents('.page').length > 0) {
              $pageContentEl = $navbarEl.parents('.page').find('.page-content');
            } // Through Layout iOS


            if ($pageContentEl.length === 0 && $navbarsEl.length) {
              if ($navbarsEl.nextAll('.page-current:not(.stacked)').length > 0) {
                $pageContentEl = $navbarsEl.nextAll('.page-current:not(.stacked)').find('.page-content');
              }
            } // Through Layout


            if ($pageContentEl.length === 0) {
              if ($navbarEl.nextAll('.page-current:not(.stacked)').length > 0) {
                $pageContentEl = $navbarEl.nextAll('.page-current:not(.stacked)').find('.page-content');
              }
            }
          }

          if ($pageContentEl && $pageContentEl.length > 0) {
            // Check for tab
            if ($pageContentEl.hasClass('tab')) {
              $pageContentEl = $pageContentEl.parent('.tabs').children('.page-content.tab-active');
            }

            if ($pageContentEl.length > 0) $pageContentEl.scrollTop(0, 300);
          }
        }
      },
      vnode: {
        navbar: {
          postpatch: function postpatch(vnode) {
            var app = this;
            app.navbar.size(vnode.elm);
          }
        }
      }
    };

    var Toolbar$1 = {
      setHighlight: function setHighlight(tabbarEl) {
        var app = this;
        if (app.theme === 'ios') return;
        var $tabbarEl = $(tabbarEl);
        if ($tabbarEl.length === 0 || !($tabbarEl.hasClass('tabbar') || $tabbarEl.hasClass('tabbar-labels'))) return;
        var $highlightEl = $tabbarEl.find('.tab-link-highlight');
        var tabLinksCount = $tabbarEl.find('.tab-link').length;

        if (tabLinksCount === 0) {
          $highlightEl.remove();
          return;
        }

        if ($highlightEl.length === 0) {
          $tabbarEl.children('.toolbar-inner').append('<span class="tab-link-highlight"></span>');
          $highlightEl = $tabbarEl.find('.tab-link-highlight');
        } else if ($highlightEl.next().length) {
          $tabbarEl.children('.toolbar-inner').append($highlightEl);
        }

        var $activeLink = $tabbarEl.find('.tab-link-active');
        var highlightWidth;
        var highlightTranslate;

        if ($tabbarEl.hasClass('tabbar-scrollable') && $activeLink && $activeLink[0]) {
          highlightWidth = $activeLink[0].offsetWidth + "px";
          highlightTranslate = $activeLink[0].offsetLeft + "px";
        } else {
          var activeIndex = $activeLink.index();
          highlightWidth = 100 / tabLinksCount + "%";
          highlightTranslate = (app.rtl ? -activeIndex : activeIndex) * 100 + "%";
        }

        nextFrame(function () {
          $highlightEl.css('width', highlightWidth).transform("translate3d(" + highlightTranslate + ",0,0)");
        });
      },
      init: function init(tabbarEl) {
        var app = this;
        app.toolbar.setHighlight(tabbarEl);
      },
      hide: function hide(el, animate) {
        if (animate === void 0) {
          animate = true;
        }

        var app = this;
        var $el = $(el);
        if ($el.hasClass('toolbar-hidden')) return;
        var className = "toolbar-hidden" + (animate ? ' toolbar-transitioning' : '');
        $el.transitionEnd(function () {
          $el.removeClass('toolbar-transitioning');
        });
        $el.addClass(className);
        $el.trigger('toolbar:hide');
        app.emit('toolbarHide', $el[0]);
      },
      show: function show(el, animate) {
        if (animate === void 0) {
          animate = true;
        }

        var app = this;
        var $el = $(el);
        if (!$el.hasClass('toolbar-hidden')) return;

        if (animate) {
          $el.addClass('toolbar-transitioning');
          $el.transitionEnd(function () {
            $el.removeClass('toolbar-transitioning');
          });
        }

        $el.removeClass('toolbar-hidden');
        $el.trigger('toolbar:show');
        app.emit('toolbarShow', $el[0]);
      },
      initToolbarOnScroll: function initToolbarOnScroll(pageEl) {
        var app = this;
        var $pageEl = $(pageEl);
        var $toolbarEl = $pageEl.parents('.view').children('.toolbar');

        if ($toolbarEl.length === 0) {
          $toolbarEl = $pageEl.find('.toolbar');
        }

        if ($toolbarEl.length === 0) {
          $toolbarEl = $pageEl.parents('.views').children('.tabbar, .tabbar-labels');
        }

        if ($toolbarEl.length === 0) {
          return;
        }

        var previousScrollTop;
        var currentScrollTop;
        var scrollHeight;
        var offsetHeight;
        var reachEnd;
        var action;
        var toolbarHidden;

        function handleScroll(e) {
          if ($pageEl.hasClass('page-with-card-opened')) return;
          if ($pageEl.hasClass('page-previous')) return;
          var scrollContent = this;

          if (e && e.target && e.target !== scrollContent) {
            return;
          }

          currentScrollTop = scrollContent.scrollTop;
          scrollHeight = scrollContent.scrollHeight;
          offsetHeight = scrollContent.offsetHeight;
          reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
          toolbarHidden = $toolbarEl.hasClass('toolbar-hidden');

          if (reachEnd) {
            if (app.params.toolbar.showOnPageScrollEnd) {
              action = 'show';
            }
          } else if (previousScrollTop > currentScrollTop) {
            if (app.params.toolbar.showOnPageScrollTop || currentScrollTop <= 44) {
              action = 'show';
            } else {
              action = 'hide';
            }
          } else if (currentScrollTop > 44) {
            action = 'hide';
          } else {
            action = 'show';
          }

          if (action === 'show' && toolbarHidden) {
            app.toolbar.show($toolbarEl);
            toolbarHidden = false;
          } else if (action === 'hide' && !toolbarHidden) {
            app.toolbar.hide($toolbarEl);
            toolbarHidden = true;
          }

          previousScrollTop = currentScrollTop;
        }

        $pageEl.on('scroll', '.page-content', handleScroll, true);
        $pageEl[0].f7ScrollToolbarHandler = handleScroll;
      }
    };
    var Toolbar$2 = {
      name: 'toolbar',
      create: function create() {
        var app = this;
        bindMethods(app, {
          toolbar: Toolbar$1
        });
      },
      params: {
        toolbar: {
          hideOnPageScroll: false,
          showOnPageScrollEnd: true,
          showOnPageScrollTop: true
        }
      },
      on: {
        pageBeforeRemove: function pageBeforeRemove(page) {
          if (page.$el[0].f7ScrollToolbarHandler) {
            page.$el.off('scroll', '.page-content', page.$el[0].f7ScrollToolbarHandler, true);
          }
        },
        pageBeforeIn: function pageBeforeIn(page) {
          var app = this;
          var $toolbarEl = page.$el.parents('.view').children('.toolbar');

          if ($toolbarEl.length === 0) {
            $toolbarEl = page.$el.parents('.views').children('.tabbar, .tabbar-labels');
          }

          if ($toolbarEl.length === 0) {
            $toolbarEl = page.$el.find('.toolbar');
          }

          if ($toolbarEl.length === 0) {
            return;
          }

          if (page.$el.hasClass('no-toolbar')) {
            app.toolbar.hide($toolbarEl);
          } else {
            app.toolbar.show($toolbarEl);
          }
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.tabbar, .tabbar-labels').each(function (tabbarEl) {
            app.toolbar.init(tabbarEl);
          });

          if (app.params.toolbar.hideOnPageScroll || page.$el.find('.hide-toolbar-on-scroll').length || page.$el.hasClass('hide-toolbar-on-scroll') || page.$el.find('.hide-bars-on-scroll').length || page.$el.hasClass('hide-bars-on-scroll')) {
            if (page.$el.find('.keep-toolbar-on-scroll').length || page.$el.hasClass('keep-toolbar-on-scroll') || page.$el.find('.keep-bars-on-scroll').length || page.$el.hasClass('keep-bars-on-scroll')) {
              return;
            }

            app.toolbar.initToolbarOnScroll(page.el);
          }
        },
        init: function init() {
          var app = this;
          app.$el.find('.tabbar, .tabbar-labels').each(function (tabbarEl) {
            app.toolbar.init(tabbarEl);
          });
        }
      },
      vnode: {
        tabbar: {
          insert: function insert(vnode) {
            var app = this;
            app.toolbar.init(vnode.elm);
          }
        }
      }
    };

    var Subnavbar = {
      name: 'subnavbar',
      on: {
        pageInit: function pageInit(page) {
          if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find('.subnavbar').length) {
            page.$el.addClass('page-with-subnavbar');
          }

          var $innerSubnavbars = page.$el.find('.subnavbar').filter(function (subnavbarEl) {
            return $(subnavbarEl).parents('.page')[0] === page.$el[0];
          });

          if ($innerSubnavbars.length) {
            page.$el.addClass('page-with-subnavbar');
          }
        }
      }
    };

    var TouchRipple$1 = /*#__PURE__*/function () {
      function TouchRipple(app, $el, x, y) {
        var ripple = this;
        if (!$el) return undefined;

        var _$el$0$getBoundingCli = $el[0].getBoundingClientRect(),
            left = _$el$0$getBoundingCli.left,
            top = _$el$0$getBoundingCli.top,
            width = _$el$0$getBoundingCli.width,
            height = _$el$0$getBoundingCli.height;

        var center = {
          x: x - left,
          y: y - top
        };
        var diameter = Math.max(Math.pow(Math.pow(height, 2) + Math.pow(width, 2), 0.5), 48);
        var isInset = false;
        var insetElements = app.params.touch.touchRippleInsetElements || '';

        if (insetElements && $el.is(insetElements)) {
          isInset = true;
        }

        if (isInset) {
          diameter = Math.max(Math.min(width, height), 48);
        }

        if (!isInset && $el.css('overflow') === 'hidden') {
          var distanceFromCenter = Math.pow(Math.pow(center.x - width / 2, 2) + Math.pow(center.y - height / 2, 2), 0.5);
          var scale = (diameter / 2 + distanceFromCenter) / (diameter / 2);
          ripple.rippleTransform = "translate3d(0px, 0px, 0) scale(" + scale + ")";
        } else {
          // prettier-ignore
          ripple.rippleTransform = "translate3d(" + (-center.x + width / 2) + "px, " + (-center.y + height / 2) + "px, 0) scale(1)";
        }

        if (isInset) {
          $el.addClass('ripple-inset');
        }

        ripple.$rippleWaveEl = $("<div class=\"ripple-wave\" style=\"width: " + diameter + "px; height: " + diameter + "px; margin-top:-" + diameter / 2 + "px; margin-left:-" + diameter / 2 + "px; left:" + center.x + "px; top:" + center.y + "px; --f7-ripple-transform: " + ripple.rippleTransform + "\"></div>");
        $el.prepend(ripple.$rippleWaveEl);
        ripple.$rippleWaveEl.animationEnd(function () {
          if (!ripple.$rippleWaveEl) return;
          if (ripple.$rippleWaveEl.hasClass('ripple-wave-out')) return;
          ripple.$rippleWaveEl.addClass('ripple-wave-in');

          if (ripple.shouldBeRemoved) {
            ripple.out();
          }
        });
        return ripple;
      }

      var _proto = TouchRipple.prototype;

      _proto.destroy = function destroy() {
        var ripple = this;

        if (ripple.$rippleWaveEl) {
          ripple.$rippleWaveEl.remove();
        }

        Object.keys(ripple).forEach(function (key) {
          ripple[key] = null;
          delete ripple[key];
        });
        ripple = null;
      };

      _proto.out = function out() {
        var ripple = this;
        var $rippleWaveEl = this.$rippleWaveEl;
        clearTimeout(ripple.removeTimeout);
        $rippleWaveEl.addClass('ripple-wave-out');
        ripple.removeTimeout = setTimeout(function () {
          ripple.destroy();
        }, 300);
        $rippleWaveEl.animationEnd(function () {
          clearTimeout(ripple.removeTimeout);
          ripple.destroy();
        });
      };

      _proto.remove = function remove() {
        var ripple = this;
        if (ripple.shouldBeRemoved) return;
        ripple.removeTimeout = setTimeout(function () {
          ripple.destroy();
        }, 400);
        ripple.shouldBeRemoved = true;

        if (ripple.$rippleWaveEl.hasClass('ripple-wave-in')) {
          ripple.out();
        }
      };

      return TouchRipple;
    }();

    function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf$t(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

    function _setPrototypeOf$t(o, p) { _setPrototypeOf$t = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$t(o, p); }
    var TouchRipple = {
      name: 'touch-ripple',
      static: {
        TouchRipple: TouchRipple$1
      },
      create: function create() {
        var app = this;
        app.touchRipple = {
          create: function create() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            return _construct(TouchRipple$1, args);
          }
        };
      }
    };

    function _assertThisInitialized$s(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$s(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$s(subClass, superClass); }

    function _setPrototypeOf$s(o, p) { _setPrototypeOf$s = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$s(o, p); }
    var openedModals = [];
    var dialogsQueue = [];

    function clearDialogsQueue() {
      if (dialogsQueue.length === 0) return;
      var dialog = dialogsQueue.shift();
      dialog.open();
    }

    var Modal$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$s(Modal, _Framework7Class);

      function Modal(app, params) {
        var _this;

        _this = _Framework7Class.call(this, params, [app]) || this;

        var modal = _assertThisInitialized$s(_this);

        var defaults = {}; // Extend defaults with modules params

        modal.useModulesParams(defaults);
        modal.params = extend$2(defaults, params);
        modal.opened = false;
        var $containerEl = modal.params.containerEl ? $(modal.params.containerEl).eq(0) : app.$el;
        if (!$containerEl.length) $containerEl = app.$el;
        modal.$containerEl = $containerEl;
        modal.containerEl = $containerEl[0]; // Install Modules

        modal.useModules();
        return _assertThisInitialized$s(_this) || _assertThisInitialized$s(_this);
      }

      var _proto = Modal.prototype;

      _proto.onOpen = function onOpen() {
        var modal = this;
        modal.opened = true;
        openedModals.push(modal);
        $('html').addClass("with-modal-" + modal.type.toLowerCase());
        modal.$el.trigger("modal:open " + modal.type.toLowerCase() + ":open");
        modal.emit("local::open modalOpen " + modal.type + "Open", modal);
      };

      _proto.onOpened = function onOpened() {
        var modal = this;
        modal.$el.trigger("modal:opened " + modal.type.toLowerCase() + ":opened");
        modal.emit("local::opened modalOpened " + modal.type + "Opened", modal);
      };

      _proto.onClose = function onClose() {
        var modal = this;
        modal.opened = false;
        if (!modal.type || !modal.$el) return;
        openedModals.splice(openedModals.indexOf(modal), 1);
        $('html').removeClass("with-modal-" + modal.type.toLowerCase());
        modal.$el.trigger("modal:close " + modal.type.toLowerCase() + ":close");
        modal.emit("local::close modalClose " + modal.type + "Close", modal);
      };

      _proto.onClosed = function onClosed() {
        var modal = this;
        if (!modal.type || !modal.$el) return;
        modal.$el.removeClass('modal-out');
        modal.$el.hide();
        modal.$el.trigger("modal:closed " + modal.type.toLowerCase() + ":closed");
        modal.emit("local::closed modalClosed " + modal.type + "Closed", modal);
      };

      _proto.open = function open(animateModal) {
        var modal = this;
        var document = getDocument();
        var app = modal.app;
        var $el = modal.$el;
        var $backdropEl = modal.$backdropEl;
        var type = modal.type;
        var animate = true;
        if (typeof animateModal !== 'undefined') animate = animateModal;else if (typeof modal.params.animate !== 'undefined') {
          animate = modal.params.animate;
        }

        if (!$el || $el.hasClass('modal-in')) {
          if (animateModal === false && $el[0] && type !== 'dialog') {
            $el[0].style.display = 'block';
          }

          return modal;
        }

        if (type === 'dialog' && app.params.modal.queueDialogs) {
          var pushToQueue;

          if ($('.dialog.modal-in').length > 0) {
            pushToQueue = true;
          } else if (openedModals.length > 0) {
            openedModals.forEach(function (openedModal) {
              if (openedModal.type === 'dialog') pushToQueue = true;
            });
          }

          if (pushToQueue) {
            dialogsQueue.push(modal);
            return modal;
          }
        }

        var $modalParentEl = $el.parent();
        var wasInDom = $el.parents(document).length > 0;

        if (!$modalParentEl.is(modal.$containerEl)) {
          modal.$containerEl.append($el);
          modal.once(type + "Closed", function () {
            if (wasInDom) {
              $modalParentEl.append($el);
            } else {
              $el.remove();
            }
          });
        } // Show Modal


        $el.show();
        /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */

        modal._clientLeft = $el[0].clientLeft; // Modal

        function transitionEnd() {
          if ($el.hasClass('modal-out')) {
            modal.onClosed();
          } else if ($el.hasClass('modal-in')) {
            modal.onOpened();
          }
        }

        if (animate) {
          if ($backdropEl) {
            $backdropEl.removeClass('not-animated');
            $backdropEl.addClass('backdrop-in');
          }

          $el.animationEnd(function () {
            transitionEnd();
          });
          $el.transitionEnd(function () {
            transitionEnd();
          });
          $el.removeClass('modal-out not-animated').addClass('modal-in');
          modal.onOpen();
        } else {
          if ($backdropEl) {
            $backdropEl.addClass('backdrop-in not-animated');
          }

          $el.removeClass('modal-out').addClass('modal-in not-animated');
          modal.onOpen();
          modal.onOpened();
        }

        return modal;
      };

      _proto.close = function close(animateModal) {
        var modal = this;
        var $el = modal.$el;
        var $backdropEl = modal.$backdropEl;
        var animate = true;
        if (typeof animateModal !== 'undefined') animate = animateModal;else if (typeof modal.params.animate !== 'undefined') {
          animate = modal.params.animate;
        }

        if (!$el || !$el.hasClass('modal-in')) {
          if (dialogsQueue.indexOf(modal) >= 0) {
            dialogsQueue.splice(dialogsQueue.indexOf(modal), 1);
          }

          return modal;
        } // backdrop


        if ($backdropEl) {
          var needToHideBackdrop = true;

          if (modal.type === 'popup') {
            modal.$el.prevAll('.popup.modal-in').add(modal.$el.nextAll('.popup.modal-in')).each(function (popupEl) {
              var popupInstance = popupEl.f7Modal;
              if (!popupInstance) return;

              if (popupInstance.params.closeByBackdropClick && popupInstance.params.backdrop && popupInstance.backdropEl === modal.backdropEl) {
                needToHideBackdrop = false;
              }
            });
          }

          if (needToHideBackdrop) {
            $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
            $backdropEl.removeClass('backdrop-in');
          }
        } // Modal


        $el[animate ? 'removeClass' : 'addClass']('not-animated');

        function transitionEnd() {
          if ($el.hasClass('modal-out')) {
            modal.onClosed();
          } else if ($el.hasClass('modal-in')) {
            modal.onOpened();
          }
        }

        if (animate) {
          $el.animationEnd(function () {
            transitionEnd();
          });
          $el.transitionEnd(function () {
            transitionEnd();
          });
          $el.removeClass('modal-in').addClass('modal-out'); // Emit close

          modal.onClose();
        } else {
          $el.addClass('not-animated').removeClass('modal-in').addClass('modal-out'); // Emit close

          modal.onClose();
          modal.onClosed();
        }

        if (modal.type === 'dialog') {
          clearDialogsQueue();
        }

        return modal;
      };

      _proto.destroy = function destroy() {
        var modal = this;
        if (modal.destroyed) return;
        modal.emit("local::beforeDestroy modalBeforeDestroy " + modal.type + "BeforeDestroy", modal);

        if (modal.$el) {
          modal.$el.trigger("modal:beforedestroy " + modal.type.toLowerCase() + ":beforedestroy");

          if (modal.$el.length && modal.$el[0].f7Modal) {
            delete modal.$el[0].f7Modal;
          }
        }

        deleteProps$1(modal);
        modal.destroyed = true;
      };

      return Modal;
    }(Framework7Class$1);

    var Modal$2 = Modal$1;

    function _assertThisInitialized$r(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$r(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$r(subClass, superClass); }

    function _setPrototypeOf$r(o, p) { _setPrototypeOf$r = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$r(o, p); }

    var CustomModal = /*#__PURE__*/function (_Modal) {
      _inheritsLoose$r(CustomModal, _Modal);

      function CustomModal(app, params) {
        var _this;

        var extendedParams = extend$2({
          backdrop: true,
          closeByBackdropClick: true,
          on: {}
        }, params); // Extends with open/close Modal methods;

        _this = _Modal.call(this, app, extendedParams) || this;

        var customModal = _assertThisInitialized$r(_this);

        customModal.params = extendedParams; // Find Element

        var $el;

        if (!customModal.params.el) {
          $el = $(customModal.params.content);
        } else {
          $el = $(customModal.params.el);
        }

        if ($el && $el.length > 0 && $el[0].f7Modal) {
          return $el[0].f7Modal || _assertThisInitialized$r(_this);
        }

        if ($el.length === 0) {
          return customModal.destroy() || _assertThisInitialized$r(_this);
        }

        var $backdropEl;

        if (customModal.params.backdrop) {
          $backdropEl = app.$el.children('.custom-modal-backdrop');

          if ($backdropEl.length === 0) {
            $backdropEl = $('<div class="custom-modal-backdrop"></div>');
            app.$el.append($backdropEl);
          }
        }

        function handleClick(e) {
          if (!customModal || customModal.destroyed) return;

          if ($backdropEl && e.target === $backdropEl[0]) {
            customModal.close();
          }
        }

        customModal.on('customModalOpened', function () {
          if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
            app.on('click', handleClick);
          }
        });
        customModal.on('customModalClose', function () {
          if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
            app.off('click', handleClick);
          }
        });
        extend$2(customModal, {
          app: app,
          $el: $el,
          el: $el[0],
          $backdropEl: $backdropEl,
          backdropEl: $backdropEl && $backdropEl[0],
          type: 'customModal'
        });
        $el[0].f7Modal = customModal;
        return customModal || _assertThisInitialized$r(_this);
      }

      return CustomModal;
    }(Modal$2);

    var CustomModal$1 = CustomModal;

    var Modal = {
      name: 'modal',
      static: {
        Modal: Modal$2,
        CustomModal: CustomModal$1
      },
      create: function create() {
        var app = this;
        app.customModal = {
          create: function create(params) {
            return new CustomModal$1(app, params);
          }
        };
      },
      params: {
        modal: {
          queueDialogs: true
        }
      }
    };

    var Appbar = {
      name: 'appbar'
    };

    /* eslint-disable prefer-rest-params */
    var $jsx = function $jsx(tag, props) {
      var attrs = props || {};

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      var children = args || [];
      var attrsString = Object.keys(attrs).map(function (attr) {
        if (attr[0] === '_') {
          if (attrs[attr]) return attr.replace('_', '');
          return '';
        }

        return attr + "=\"" + attrs[attr] + "\"";
      }).filter(function (attr) {
        return !!attr;
      }).join(' ');

      if (['path', 'img', 'circle', 'polygon', 'line', 'input'].indexOf(tag) >= 0) {
        return ("<" + tag + " " + attrsString + " />").trim();
      }

      var childrenContent = children.filter(function (c) {
        return !!c;
      }).map(function (c) {
        return Array.isArray(c) ? c.join('') : c;
      }).join('');
      return ("<" + tag + " " + attrsString + ">" + childrenContent + "</" + tag + ">").trim();
    };

    var $jsx$1 = $jsx;

    function _assertThisInitialized$q(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$q(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$q(subClass, superClass); }

    function _setPrototypeOf$q(o, p) { _setPrototypeOf$q = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$q(o, p); }

    var Dialog$1 = /*#__PURE__*/function (_Modal) {
      _inheritsLoose$q(Dialog, _Modal);

      function Dialog(app, params) {
        var _this;

        var extendedParams = extend$2({
          title: app.params.dialog.title,
          text: undefined,
          content: '',
          buttons: [],
          verticalButtons: false,
          onClick: undefined,
          cssClass: undefined,
          destroyOnClose: false,
          on: {}
        }, params);

        if (typeof extendedParams.closeByBackdropClick === 'undefined') {
          extendedParams.closeByBackdropClick = app.params.dialog.closeByBackdropClick;
        }

        if (typeof extendedParams.backdrop === 'undefined') {
          extendedParams.backdrop = app.params.dialog.backdrop;
        } // Extends with open/close Modal methods;


        _this = _Modal.call(this, app, extendedParams) || this;

        var dialog = _assertThisInitialized$q(_this);

        var device = getDevice$1();
        var document = getDocument();
        var title = extendedParams.title,
            text = extendedParams.text,
            content = extendedParams.content,
            buttons = extendedParams.buttons,
            verticalButtons = extendedParams.verticalButtons,
            cssClass = extendedParams.cssClass,
            backdrop = extendedParams.backdrop;
        dialog.params = extendedParams; // Find Element

        var $el;

        if (!dialog.params.el) {
          var dialogClasses = ['dialog'];
          if (buttons.length === 0) dialogClasses.push('dialog-no-buttons');
          if (buttons.length > 0) dialogClasses.push("dialog-buttons-" + buttons.length);
          if (verticalButtons) dialogClasses.push('dialog-buttons-vertical');
          if (cssClass) dialogClasses.push(cssClass);
          var buttonsHTML = '';

          if (buttons.length > 0) {
            buttonsHTML = $jsx$1("div", {
              class: "dialog-buttons"
            }, buttons.map(function (button) {
              return $jsx$1("span", {
                class: "dialog-button" + (button.bold ? ' dialog-button-bold' : '') + (button.color ? " color-" + button.color : '') + (button.cssClass ? " " + button.cssClass : '')
              }, button.text);
            }));
          }

          var dialogHtml = $jsx$1("div", {
            class: dialogClasses.join(' ')
          }, $jsx$1("div", {
            class: "dialog-inner"
          }, title && $jsx$1("div", {
            class: "dialog-title"
          }, title), text && $jsx$1("div", {
            class: "dialog-text"
          }, text), content), buttonsHTML);
          $el = $(dialogHtml);
        } else {
          $el = $(dialog.params.el);
        }

        if ($el && $el.length > 0 && $el[0].f7Modal) {
          return $el[0].f7Modal || _assertThisInitialized$q(_this);
        }

        if ($el.length === 0) {
          return dialog.destroy() || _assertThisInitialized$q(_this);
        }

        var $backdropEl;

        if (backdrop) {
          $backdropEl = app.$el.children('.dialog-backdrop');

          if ($backdropEl.length === 0) {
            $backdropEl = $('<div class="dialog-backdrop"></div>');
            app.$el.append($backdropEl);
          }
        } // Assign events


        function buttonOnClick(e) {
          var buttonEl = this;
          var index = $(buttonEl).index();
          var button = buttons[index];
          if (button.onClick) button.onClick(dialog, e);
          if (dialog.params.onClick) dialog.params.onClick(dialog, index);
          if (button.close !== false) dialog.close();
        }

        var addKeyboardHander;

        function onKeyDown(e) {
          var keyCode = e.keyCode;
          buttons.forEach(function (button, index) {
            if (button.keyCodes && button.keyCodes.indexOf(keyCode) >= 0) {
              if (document.activeElement) document.activeElement.blur();
              if (button.onClick) button.onClick(dialog, e);
              if (dialog.params.onClick) dialog.params.onClick(dialog, index);
              if (button.close !== false) dialog.close();
            }
          });
        }

        if (buttons && buttons.length > 0) {
          dialog.on('open', function () {
            $el.find('.dialog-button').each(function (buttonEl, index) {
              var button = buttons[index];
              if (button.keyCodes) addKeyboardHander = true;
              $(buttonEl).on('click', buttonOnClick);
            });

            if (addKeyboardHander && !device.ios && !device.android && !device.cordova && !device.capacitor) {
              $(document).on('keydown', onKeyDown);
            }
          });
          dialog.on('close', function () {
            $el.find('.dialog-button').each(function (buttonEl) {
              $(buttonEl).off('click', buttonOnClick);
            });

            if (addKeyboardHander && !device.ios && !device.android && !device.cordova && !device.capacitor) {
              $(document).off('keydown', onKeyDown);
            }

            addKeyboardHander = false;
          });
        }

        extend$2(dialog, {
          app: app,
          $el: $el,
          el: $el[0],
          $backdropEl: $backdropEl,
          backdropEl: $backdropEl && $backdropEl[0],
          type: 'dialog',
          setProgress: function setProgress(progress, duration) {
            app.progressbar.set($el.find('.progressbar'), progress, duration);
            return dialog;
          },
          setText: function setText(newText) {
            var $textEl = $el.find('.dialog-text');

            if ($textEl.length === 0) {
              $textEl = $('<div class="dialog-text"></div>');

              if (typeof title !== 'undefined') {
                $textEl.insertAfter($el.find('.dialog-title'));
              } else {
                $el.find('.dialog-inner').prepend($textEl);
              }
            }

            $textEl.html(newText);
            dialog.params.text = newText;
            return dialog;
          },
          setTitle: function setTitle(newTitle) {
            var $titleEl = $el.find('.dialog-title');

            if ($titleEl.length === 0) {
              $titleEl = $('<div class="dialog-title"></div>');
              $el.find('.dialog-inner').prepend($titleEl);
            }

            $titleEl.html(newTitle);
            dialog.params.title = newTitle;
            return dialog;
          }
        });

        function handleClick(e) {
          var target = e.target;
          var $target = $(target);

          if ($target.closest(dialog.el).length === 0) {
            if (dialog.params.closeByBackdropClick && dialog.backdropEl && dialog.backdropEl === target) {
              dialog.close();
            }
          }
        }

        dialog.on('opened', function () {
          if (dialog.params.closeByBackdropClick) {
            app.on('click', handleClick);
          }
        });
        dialog.on('close', function () {
          if (dialog.params.closeByBackdropClick) {
            app.off('click', handleClick);
          }
        });
        $el[0].f7Modal = dialog;

        if (dialog.params.destroyOnClose) {
          dialog.once('closed', function () {
            setTimeout(function () {
              dialog.destroy();
            }, 0);
          });
        }

        return dialog || _assertThisInitialized$q(_this);
      }

      return Dialog;
    }(Modal$2);

    var Dialog$2 = Dialog$1;

    function _extends$4() { _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }
    var Dialog = {
      name: 'dialog',
      params: {
        dialog: {
          title: undefined,
          buttonOk: 'OK',
          buttonCancel: 'Cancel',
          usernamePlaceholder: 'Username',
          passwordPlaceholder: 'Password',
          preloaderTitle: 'Loading... ',
          progressTitle: 'Loading... ',
          backdrop: true,
          closeByBackdropClick: false,
          destroyPredefinedDialogs: true,
          keyboardActions: true,
          autoFocus: true
        }
      },
      static: {
        Dialog: Dialog$2
      },
      create: function create() {
        var app = this;

        function defaultDialogTitle() {
          return app.params.dialog.title || app.name;
        }

        var destroyOnClose = app.params.dialog.destroyPredefinedDialogs;
        var keyboardActions = app.params.dialog.keyboardActions;
        var autoFocus = app.params.dialog.autoFocus;
        var autoFocusHandler = autoFocus ? {
          on: {
            opened: function opened(dialog) {
              dialog.$el.find('input').eq(0).focus();
            }
          }
        } : {};
        app.dialog = extend$2(ModalMethods({
          app: app,
          constructor: Dialog$2,
          defaultSelector: '.dialog.modal-in'
        }), {
          // Shortcuts
          alert: function alert() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            var text = args[0],
                title = args[1],
                callbackOk = args[2];

            if (args.length === 2 && typeof args[1] === 'function') {
              text = args[0];
              callbackOk = args[1];
              title = args[2];
            }

            return new Dialog$2(app, {
              title: typeof title === 'undefined' ? defaultDialogTitle() : title,
              text: text,
              buttons: [{
                text: app.params.dialog.buttonOk,
                bold: true,
                onClick: callbackOk,
                keyCodes: keyboardActions ? [13, 27] : null
              }],
              destroyOnClose: destroyOnClose
            }).open();
          },
          prompt: function prompt() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            var text = args[0],
                title = args[1],
                callbackOk = args[2],
                callbackCancel = args[3],
                defaultValue = args[4];

            if (typeof args[1] === 'function') {
              text = args[0];
              callbackOk = args[1];
              callbackCancel = args[2];
              defaultValue = args[3];
              title = args[4];
            }

            defaultValue = typeof defaultValue === 'undefined' || defaultValue === null ? '' : defaultValue;
            return new Dialog$2(app, _extends$4({
              title: typeof title === 'undefined' ? defaultDialogTitle() : title,
              text: text,
              content: "<div class=\"dialog-input-field input\"><input type=\"text\" class=\"dialog-input\" value=\"" + defaultValue + "\"></div>",
              buttons: [{
                text: app.params.dialog.buttonCancel,
                keyCodes: keyboardActions ? [27] : null,
                color: app.theme === 'aurora' ? 'gray' : null
              }, {
                text: app.params.dialog.buttonOk,
                bold: true,
                keyCodes: keyboardActions ? [13] : null
              }],
              onClick: function onClick(dialog, index) {
                var inputValue = dialog.$el.find('.dialog-input').val();
                if (index === 0 && callbackCancel) callbackCancel(inputValue);
                if (index === 1 && callbackOk) callbackOk(inputValue);
              },
              destroyOnClose: destroyOnClose
            }, autoFocusHandler)).open();
          },
          confirm: function confirm() {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }

            var text = args[0],
                title = args[1],
                callbackOk = args[2],
                callbackCancel = args[3];

            if (typeof args[1] === 'function') {
              text = args[0];
              callbackOk = args[1];
              callbackCancel = args[2];
              title = args[3];
            }

            return new Dialog$2(app, {
              title: typeof title === 'undefined' ? defaultDialogTitle() : title,
              text: text,
              buttons: [{
                text: app.params.dialog.buttonCancel,
                onClick: callbackCancel,
                keyCodes: keyboardActions ? [27] : null,
                color: app.theme === 'aurora' ? 'gray' : null
              }, {
                text: app.params.dialog.buttonOk,
                bold: true,
                onClick: callbackOk,
                keyCodes: keyboardActions ? [13] : null
              }],
              destroyOnClose: destroyOnClose
            }).open();
          },
          login: function login() {
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }

            var text = args[0],
                title = args[1],
                callbackOk = args[2],
                callbackCancel = args[3];

            if (typeof args[1] === 'function') {
              text = args[0];
              callbackOk = args[1];
              callbackCancel = args[2];
              title = args[3];
            }

            return new Dialog$2(app, _extends$4({
              title: typeof title === 'undefined' ? defaultDialogTitle() : title,
              text: text,
              // prettier-ignore
              content: "\n              <div class=\"dialog-input-field dialog-input-double input\">\n                <input type=\"text\" name=\"dialog-username\" placeholder=\"" + app.params.dialog.usernamePlaceholder + "\" class=\"dialog-input\">\n              </div>\n              <div class=\"dialog-input-field dialog-input-double input\">\n                <input type=\"password\" name=\"dialog-password\" placeholder=\"" + app.params.dialog.passwordPlaceholder + "\" class=\"dialog-input\">\n              </div>",
              buttons: [{
                text: app.params.dialog.buttonCancel,
                keyCodes: keyboardActions ? [27] : null,
                color: app.theme === 'aurora' ? 'gray' : null
              }, {
                text: app.params.dialog.buttonOk,
                bold: true,
                keyCodes: keyboardActions ? [13] : null
              }],
              onClick: function onClick(dialog, index) {
                var username = dialog.$el.find('[name="dialog-username"]').val();
                var password = dialog.$el.find('[name="dialog-password"]').val();
                if (index === 0 && callbackCancel) callbackCancel(username, password);
                if (index === 1 && callbackOk) callbackOk(username, password);
              },
              destroyOnClose: destroyOnClose
            }, autoFocusHandler)).open();
          },
          password: function password() {
            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              args[_key5] = arguments[_key5];
            }

            var text = args[0],
                title = args[1],
                callbackOk = args[2],
                callbackCancel = args[3];

            if (typeof args[1] === 'function') {
              text = args[0];
              callbackOk = args[1];
              callbackCancel = args[2];
              title = args[3];
            }

            return new Dialog$2(app, _extends$4({
              title: typeof title === 'undefined' ? defaultDialogTitle() : title,
              text: text,
              // prettier-ignore
              content: "\n              <div class=\"dialog-input-field input\">\n                <input type=\"password\" name=\"dialog-password\" placeholder=\"" + app.params.dialog.passwordPlaceholder + "\" class=\"dialog-input\">\n              </div>",
              buttons: [{
                text: app.params.dialog.buttonCancel,
                keyCodes: keyboardActions ? [27] : null,
                color: app.theme === 'aurora' ? 'gray' : null
              }, {
                text: app.params.dialog.buttonOk,
                bold: true,
                keyCodes: keyboardActions ? [13] : null
              }],
              onClick: function onClick(dialog, index) {
                var password = dialog.$el.find('[name="dialog-password"]').val();
                if (index === 0 && callbackCancel) callbackCancel(password);
                if (index === 1 && callbackOk) callbackOk(password);
              },
              destroyOnClose: destroyOnClose
            }, autoFocusHandler)).open();
          },
          preloader: function preloader(title, color) {
            var preloaders = {
              iosPreloaderContent: iosPreloaderContent,
              mdPreloaderContent: mdPreloaderContent,
              auroraPreloaderContent: auroraPreloaderContent
            };
            var preloaderInner = preloaders[app.theme + "PreloaderContent"] || '';
            return new Dialog$2(app, {
              title: typeof title === 'undefined' || title === null ? app.params.dialog.preloaderTitle : title,
              // prettier-ignore
              content: "<div class=\"preloader" + (color ? " color-" + color : '') + "\">" + preloaderInner + "</div>",
              cssClass: 'dialog-preloader',
              destroyOnClose: destroyOnClose
            }).open();
          },
          progress: function progress() {
            for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
              args[_key6] = arguments[_key6];
            }

            var title = args[0],
                progress = args[1],
                color = args[2];

            if (args.length === 2) {
              if (typeof args[0] === 'number') {
                progress = args[0];
                color = args[1];
                title = args[2];
              } else if (typeof args[0] === 'string' && typeof args[1] === 'string') {
                title = args[0];
                color = args[1];
                progress = args[2];
              }
            } else if (args.length === 1) {
              if (typeof args[0] === 'number') {
                progress = args[0];
                title = args[1];
                color = args[2];
              }
            }

            var infinite = typeof progress === 'undefined';
            var dialog = new Dialog$2(app, {
              title: typeof title === 'undefined' ? app.params.dialog.progressTitle : title,
              cssClass: 'dialog-progress',
              // prettier-ignore
              content: "\n              <div class=\"progressbar" + (infinite ? '-infinite' : '') + (color ? " color-" + color : '') + "\">\n                " + (!infinite ? '<span></span>' : '') + "\n              </div>\n            ",
              destroyOnClose: destroyOnClose
            });
            if (!infinite) dialog.setProgress(progress);
            return dialog.open();
          }
        });
      }
    };

    function _assertThisInitialized$p(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$p(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$p(subClass, superClass); }

    function _setPrototypeOf$p(o, p) { _setPrototypeOf$p = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$p(o, p); }

    var Popup$2 = /*#__PURE__*/function (_Modal) {
      _inheritsLoose$p(Popup, _Modal);

      function Popup(app, params) {
        var _this;

        var extendedParams = extend$2({
          on: {}
        }, app.params.popup, params); // Extends with open/close Modal methods;

        _this = _Modal.call(this, app, extendedParams) || this;

        var popup = _assertThisInitialized$p(_this);

        var window = getWindow();
        var document = getDocument();
        var support = getSupport$1();
        var device = getDevice$1();
        popup.params = extendedParams; // Find Element

        var $el;

        if (!popup.params.el) {
          $el = $(popup.params.content).filter(function (node) {
            return node.nodeType === 1;
          }).eq(0);
        } else {
          $el = $(popup.params.el).eq(0);
        }

        if ($el && $el.length > 0 && $el[0].f7Modal) {
          return $el[0].f7Modal || _assertThisInitialized$p(_this);
        }

        if ($el.length === 0) {
          return popup.destroy() || _assertThisInitialized$p(_this);
        }

        var $backdropEl;

        if (popup.params.backdrop && popup.params.backdropEl) {
          $backdropEl = $(popup.params.backdropEl);
        } else if (popup.params.backdrop) {
          $backdropEl = popup.$containerEl.children('.popup-backdrop');

          if ($backdropEl.length === 0) {
            $backdropEl = $('<div class="popup-backdrop"></div>');
            popup.$containerEl.append($backdropEl);
          }
        }

        extend$2(popup, {
          app: app,
          push: $el.hasClass('popup-push') || popup.params.push,
          $el: $el,
          el: $el[0],
          $backdropEl: $backdropEl,
          backdropEl: $backdropEl && $backdropEl[0],
          type: 'popup',
          $htmlEl: $('html')
        });

        if (popup.params.push) {
          $el.addClass('popup-push');
        }

        function handleClick(e) {
          var target = e.target;
          var $target = $(target);
          var keyboardOpened = !device.desktop && device.cordova && (window.Keyboard && window.Keyboard.isVisible || window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible);
          if (keyboardOpened) return;

          if ($target.closest(popup.el).length === 0) {
            if (popup.params && popup.params.closeByBackdropClick && popup.params.backdrop && popup.backdropEl && popup.backdropEl === target) {
              var needToClose = true;
              popup.$el.nextAll('.popup.modal-in').each(function (popupEl) {
                var popupInstance = popupEl.f7Modal;
                if (!popupInstance) return;

                if (popupInstance.params.closeByBackdropClick && popupInstance.params.backdrop && popupInstance.backdropEl === popup.backdropEl) {
                  needToClose = false;
                }
              });

              if (needToClose) {
                popup.close();
              }
            }
          }
        }

        function onKeyDown(e) {
          var keyCode = e.keyCode;

          if (keyCode === 27 && popup.params.closeOnEscape) {
            popup.close();
          }
        }

        var pushOffset;
        var isPush;

        function pushViewScale(offset) {
          return (app.height - offset * 2) / app.height;
        }

        var allowSwipeToClose = true;
        var isTouched = false;
        var startTouch;
        var currentTouch;
        var isScrolling;
        var touchStartTime;
        var touchesDiff;
        var isMoved = false;
        var pageContentEl;
        var pageContentScrollTop;
        var pageContentOffsetHeight;
        var pageContentScrollHeight;
        var popupHeight;
        var $pushEl;

        function handleTouchStart(e) {
          if (isTouched || !allowSwipeToClose || !popup.params.swipeToClose) return;

          if (popup.params.swipeHandler && $(e.target).closest(popup.params.swipeHandler).length === 0) {
            return;
          }

          isTouched = true;
          isMoved = false;
          startTouch = {
            x: e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX,
            y: e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY
          };
          touchStartTime = now$2();
          isScrolling = undefined;

          if (!popup.params.swipeHandler && e.type === 'touchstart') {
            pageContentEl = $(e.target).closest('.page-content')[0];
          }
        }

        function handleTouchMove(e) {
          if (!isTouched) return;
          currentTouch = {
            x: e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX,
            y: e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY
          };

          if (typeof isScrolling === 'undefined') {
            isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
          }

          if (isScrolling) {
            isTouched = false;
            isMoved = false;
            return;
          }

          touchesDiff = startTouch.y - currentTouch.y;

          if (isPush && pushOffset && touchesDiff > 0) {
            touchesDiff = 0;
          }

          var direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';
          $el.transition(0);

          if (typeof popup.params.swipeToClose === 'string' && direction !== popup.params.swipeToClose) {
            $el.transform('');
            $el.transition('');
            return;
          }

          if (!isMoved) {
            if (isPush && pushOffset) {
              popupHeight = $el[0].offsetHeight;
              $pushEl = $el.prevAll('.popup.modal-in').eq(0);

              if ($pushEl.length === 0) {
                $pushEl = app.$el.children('.view, .views');
              }
            }

            if (pageContentEl) {
              pageContentScrollTop = pageContentEl.scrollTop;
              pageContentScrollHeight = pageContentEl.scrollHeight;
              pageContentOffsetHeight = pageContentEl.offsetHeight;

              if (!(pageContentScrollHeight === pageContentOffsetHeight) && !(direction === 'to-bottom' && pageContentScrollTop === 0) && !(direction === 'to-top' && pageContentScrollTop === pageContentScrollHeight - pageContentOffsetHeight)) {
                $el.transform('');
                $el.transition('');
                isTouched = false;
                isMoved = false;
                return;
              }
            }

            isMoved = true;
            popup.emit('local::swipeStart popupSwipeStart', popup);
            popup.$el.trigger('popup:swipestart');
          } else {
            popup.emit('local::swipeMove popupSwipeMove', popup);
            popup.$el.trigger('popup:swipemove');
          }

          e.preventDefault();

          if (isPush && pushOffset) {
            var pushProgress = 1 - Math.abs(touchesDiff / popupHeight);
            var scale = 1 - (1 - pushViewScale(pushOffset)) * pushProgress;

            if ($pushEl.hasClass('popup')) {
              if ($pushEl.hasClass('popup-push')) {
                $pushEl.transition(0).forEach(function (el) {
                  el.style.setProperty('transform', "translate3d(0, calc(-1 * " + pushProgress + " * (var(--f7-popup-push-offset) + 10px)) , 0px) scale(" + scale + ")", 'important');
                });
              } else {
                $pushEl.transition(0).forEach(function (el) {
                  el.style.setProperty('transform', "translate3d(0, 0px , 0px) scale(" + scale + ")", 'important');
                });
              }
            } else {
              $pushEl.transition(0).forEach(function (el) {
                el.style.setProperty('transform', "translate3d(0,0,0) scale(" + scale + ")", 'important');
              });
            }
          }

          $el.transition(0).transform("translate3d(0," + -touchesDiff + "px,0)");
        }

        function handleTouchEnd() {
          isTouched = false;

          if (!isMoved) {
            return;
          }

          popup.emit('local::swipeEnd popupSwipeEnd', popup);
          popup.$el.trigger('popup:swipeend');
          isMoved = false;
          allowSwipeToClose = false;
          $el.transition('');

          if (isPush && pushOffset) {
            $pushEl.transition('').transform('');
          }

          var direction = touchesDiff <= 0 ? 'to-bottom' : 'to-top';

          if (typeof popup.params.swipeToClose === 'string' && direction !== popup.params.swipeToClose) {
            $el.transform('');
            allowSwipeToClose = true;
            return;
          }

          var diff = Math.abs(touchesDiff);
          var timeDiff = new Date().getTime() - touchStartTime;

          if (timeDiff < 300 && diff > 20 || timeDiff >= 300 && diff > 100) {
            nextTick$1(function () {
              if (direction === 'to-bottom') {
                $el.addClass('swipe-close-to-bottom');
              } else {
                $el.addClass('swipe-close-to-top');
              }

              $el.transform('');
              popup.emit('local::swipeclose popupSwipeClose', popup);
              popup.$el.trigger('popup:swipeclose');
              popup.close();
              allowSwipeToClose = true;
            });
            return;
          }

          allowSwipeToClose = true;
          $el.transform('');
        }

        var passive = support.passiveListener ? {
          passive: true
        } : false;

        if (popup.params.swipeToClose) {
          $el.on(app.touchEvents.start, handleTouchStart, passive);
          app.on('touchmove', handleTouchMove);
          app.on('touchend:passive', handleTouchEnd);
          popup.once('popupDestroy', function () {
            $el.off(app.touchEvents.start, handleTouchStart, passive);
            app.off('touchmove', handleTouchMove);
            app.off('touchend:passive', handleTouchEnd);
          });
        }

        var hasPreviousPushPopup;

        var updatePushOffset = function updatePushOffset() {
          var wasPush = isPush;

          if (popup.push) {
            isPush = popup.push && (app.width < 630 || app.height < 630 || $el.hasClass('popup-tablet-fullscreen'));
          }

          if (isPush && !wasPush) {
            // eslint-disable-next-line
            setPushOffset();
          } else if (isPush && wasPush) {
            popup.$htmlEl[0].style.setProperty('--f7-popup-push-scale', pushViewScale(pushOffset));
          } else if (!isPush && wasPush) {
            popup.$htmlEl.removeClass('with-modal-popup-push');
            popup.$htmlEl[0].style.removeProperty('--f7-popup-push-scale');
          }
        };

        var setPushOffset = function setPushOffset() {
          app.off('resize', updatePushOffset);

          if (popup.push) {
            isPush = popup.push && (app.width < 630 || app.height < 630 || $el.hasClass('popup-tablet-fullscreen'));
          }

          if (isPush) {
            pushOffset = parseInt($el.css('--f7-popup-push-offset'), 10);
            if (Number.isNaN(pushOffset)) pushOffset = 0;

            if (pushOffset) {
              $el.addClass('popup-push');
              popup.$htmlEl.addClass('with-modal-popup-push');
              popup.$htmlEl[0].style.setProperty('--f7-popup-push-scale', pushViewScale(pushOffset));
            }
          }

          app.on('resize', updatePushOffset);
        };

        popup.on('open', function () {
          hasPreviousPushPopup = false;

          if (popup.params.closeOnEscape) {
            $(document).on('keydown', onKeyDown);
          }

          $el.prevAll('.popup.modal-in').addClass('popup-behind');
          setPushOffset();
        });
        popup.on('opened', function () {
          $el.removeClass('swipe-close-to-bottom swipe-close-to-top');

          if (popup.params.closeByBackdropClick) {
            app.on('click', handleClick);
          }
        });
        popup.on('close', function () {
          hasPreviousPushPopup = popup.$el.prevAll('.popup-push.modal-in').length > 0;

          if (popup.params.closeOnEscape) {
            $(document).off('keydown', onKeyDown);
          }

          if (popup.params.closeByBackdropClick) {
            app.off('click', handleClick);
          }

          $el.prevAll('.popup.modal-in').eq(0).removeClass('popup-behind');

          if (isPush && pushOffset && !hasPreviousPushPopup) {
            popup.$htmlEl.removeClass('with-modal-popup-push');
            popup.$htmlEl.addClass('with-modal-popup-push-closing');
          }

          app.off('resize', updatePushOffset);
        });
        popup.on('closed', function () {
          $el.removeClass('popup-behind');

          if (isPush && pushOffset && !hasPreviousPushPopup) {
            popup.$htmlEl.removeClass('with-modal-popup-push-closing');
            popup.$htmlEl[0].style.removeProperty('--f7-popup-push-scale');
          }
        });
        $el[0].f7Modal = popup;
        return popup || _assertThisInitialized$p(_this);
      }

      return Popup;
    }(Modal$2);

    var Popup$3 = Popup$2;

    var Popup$1 = {
      name: 'popup',
      params: {
        popup: {
          backdrop: true,
          backdropEl: undefined,
          closeByBackdropClick: true,
          closeOnEscape: false,
          swipeToClose: false,
          swipeHandler: null,
          push: false,
          containerEl: null
        }
      },
      static: {
        Popup: Popup$3
      },
      create: function create() {
        var app = this;
        app.popup = ModalMethods({
          app: app,
          constructor: Popup$3,
          defaultSelector: '.popup.modal-in',
          parentSelector: '.popup'
        });
      },
      clicks: {
        '.popup-open': function openPopup($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.popup.open(data.popup, data.animate, $clickedEl);
        },
        '.popup-close': function closePopup($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.popup.close(data.popup, data.animate, $clickedEl);
        }
      }
    };

    function _assertThisInitialized$o(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$o(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$o(subClass, superClass); }

    function _setPrototypeOf$o(o, p) { _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$o(o, p); }

    var LoginScreen$1 = /*#__PURE__*/function (_Modal) {
      _inheritsLoose$o(LoginScreen, _Modal);

      function LoginScreen(app, params) {
        var _this;

        var extendedParams = extend$2({
          on: {}
        }, params); // Extends with open/close Modal methods;

        _this = _Modal.call(this, app, extendedParams) || this;

        var loginScreen = _assertThisInitialized$o(_this);

        loginScreen.params = extendedParams; // Find Element

        var $el;

        if (!loginScreen.params.el) {
          $el = $(loginScreen.params.content).filter(function (node) {
            return node.nodeType === 1;
          }).eq(0);
        } else {
          $el = $(loginScreen.params.el).eq(0);
        }

        if ($el && $el.length > 0 && $el[0].f7Modal) {
          return $el[0].f7Modal || _assertThisInitialized$o(_this);
        }

        if ($el.length === 0) {
          return loginScreen.destroy() || _assertThisInitialized$o(_this);
        }

        extend$2(loginScreen, {
          app: app,
          $el: $el,
          el: $el[0],
          type: 'loginScreen'
        });
        $el[0].f7Modal = loginScreen;
        return loginScreen || _assertThisInitialized$o(_this);
      }

      return LoginScreen;
    }(Modal$2);

    var LoginScreen$2 = LoginScreen$1;

    var LoginScreen = {
      name: 'loginScreen',
      static: {
        LoginScreen: LoginScreen$2
      },
      create: function create() {
        var app = this;
        app.loginScreen = ModalMethods({
          app: app,
          constructor: LoginScreen$2,
          defaultSelector: '.login-screen.modal-in'
        });
      },
      clicks: {
        '.login-screen-open': function openLoginScreen($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.loginScreen.open(data.loginScreen, data.animate, $clickedEl);
        },
        '.login-screen-close': function closeLoginScreen($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.loginScreen.close(data.loginScreen, data.animate, $clickedEl);
        }
      }
    };

    function _assertThisInitialized$n(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$n(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$n(subClass, superClass); }

    function _setPrototypeOf$n(o, p) { _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$n(o, p); }

    var Popover$1 = /*#__PURE__*/function (_Modal) {
      _inheritsLoose$n(Popover, _Modal);

      function Popover(app, params) {
        var _this;

        var extendedParams = extend$2({
          on: {}
        }, app.params.popover, params); // Extends with open/close Modal methods;

        _this = _Modal.call(this, app, extendedParams) || this;

        var popover = _assertThisInitialized$n(_this);

        var device = getDevice$1();
        var window = getWindow();
        var document = getDocument();
        popover.params = extendedParams; // Find Element

        var $el;

        if (!popover.params.el) {
          $el = $(popover.params.content).filter(function (node) {
            return node.nodeType === 1;
          }).eq(0);
        } else {
          $el = $(popover.params.el).eq(0);
        }

        if ($el && $el.length > 0 && $el[0].f7Modal) {
          return $el[0].f7Modal || _assertThisInitialized$n(_this);
        } // Find Target


        var $targetEl = $(popover.params.targetEl).eq(0);

        if ($el.length === 0) {
          return popover.destroy() || _assertThisInitialized$n(_this);
        } // Backdrop


        var $backdropEl;

        if (popover.params.backdrop && popover.params.backdropEl) {
          $backdropEl = $(popover.params.backdropEl);
        } else if (popover.params.backdrop) {
          $backdropEl = popover.$containerEl.children('.popover-backdrop');

          if ($backdropEl.length === 0) {
            $backdropEl = $('<div class="popover-backdrop"></div>');
            popover.$containerEl.append($backdropEl);
          }
        } // Find Angle


        var $angleEl;

        if ($el.find('.popover-angle').length === 0) {
          $angleEl = $('<div class="popover-angle"></div>');
          $el.prepend($angleEl);
        } else {
          $angleEl = $el.find('.popover-angle');
        } // Open


        var originalOpen = popover.open;
        extend$2(popover, {
          app: app,
          $el: $el,
          el: $el[0],
          $targetEl: $targetEl,
          targetEl: $targetEl[0],
          $angleEl: $angleEl,
          angleEl: $angleEl[0],
          $backdropEl: $backdropEl,
          backdropEl: $backdropEl && $backdropEl[0],
          type: 'popover',
          open: function open() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            var targetEl = args[0],
                animate = args[1];

            if (typeof args[0] === 'boolean') {
              animate = args[0];
              targetEl = args[1];
            }

            if (targetEl) {
              popover.$targetEl = $(targetEl);
              popover.targetEl = popover.$targetEl[0];
            }

            return originalOpen.call(popover, animate);
          }
        });

        function handleResize() {
          popover.resize();
        }

        popover.on('popoverOpen', function () {
          popover.resize();
          app.on('resize', handleResize);
          $(window).on('keyboardDidShow keyboardDidHide', handleResize);
          popover.on('popoverClose popoverBeforeDestroy', function () {
            app.off('resize', handleResize);
            $(window).off('keyboardDidShow keyboardDidHide', handleResize);
          });
        });
        var touchStartTarget = null;

        function handleTouchStart(e) {
          touchStartTarget = e.target;
        }

        function handleClick(e) {
          var target = e.target;
          var $target = $(target);
          var keyboardOpened = !device.desktop && device.cordova && (window.Keyboard && window.Keyboard.isVisible || window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible);
          if (keyboardOpened) return;

          if ($target.closest(popover.el).length === 0) {
            if (popover.params.closeByBackdropClick && popover.params.backdrop && popover.backdropEl && popover.backdropEl === target && touchStartTarget === target) {
              popover.close();
            } else if (popover.params.closeByOutsideClick && touchStartTarget === target) {
              popover.close();
            }
          }
        }

        function onKeyDown(e) {
          var keyCode = e.keyCode;

          if (keyCode === 27 && popover.params.closeOnEscape) {
            popover.close();
          }
        }

        if (popover.params.closeOnEscape) {
          popover.on('popoverOpen', function () {
            $(document).on('keydown', onKeyDown);
          });
          popover.on('popoverClose', function () {
            $(document).off('keydown', onKeyDown);
          });
        }

        popover.on('popoverOpened', function () {
          if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
            app.on('touchstart', handleTouchStart);
            app.on('click', handleClick);
          }
        });
        popover.on('popoverClose', function () {
          if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
            app.off('touchstart', handleTouchStart);
            app.off('click', handleClick);
          }
        });
        $el[0].f7Modal = popover;
        return popover || _assertThisInitialized$n(_this);
      }

      var _proto = Popover.prototype;

      _proto.resize = function resize() {
        var popover = this;
        var app = popover.app,
            $el = popover.$el,
            $targetEl = popover.$targetEl,
            $angleEl = popover.$angleEl;
        var _popover$params = popover.params,
            targetX = _popover$params.targetX,
            targetY = _popover$params.targetY;
        $el.css({
          left: '',
          top: ''
        });
        var _ref = [$el.width(), $el.height()],
            width = _ref[0],
            height = _ref[1];
        var angleSize = 0;
        var angleLeft;
        var angleTop;

        if (app.theme === 'ios' || app.theme === 'aurora') {
          $angleEl.removeClass('on-left on-right on-top on-bottom').css({
            left: '',
            top: ''
          });
          angleSize = $angleEl.width() / 2;
        } else {
          $el.removeClass('popover-on-left popover-on-right popover-on-top popover-on-bottom popover-on-middle').css({
            left: '',
            top: ''
          });
        }

        var targetWidth;
        var targetHeight;
        var targetOffsetLeft;
        var targetOffsetTop;
        var safeAreaTop = parseInt($('html').css('--f7-safe-area-top'), 10);
        var safeAreaLeft = parseInt($('html').css('--f7-safe-area-left'), 10);
        var safeAreaRight = parseInt($('html').css('--f7-safe-area-right'), 10);
        if (Number.isNaN(safeAreaTop)) safeAreaTop = 0;
        if (Number.isNaN(safeAreaLeft)) safeAreaLeft = 0;
        if (Number.isNaN(safeAreaRight)) safeAreaRight = 0;

        if ($targetEl && $targetEl.length > 0) {
          targetWidth = $targetEl.outerWidth();
          targetHeight = $targetEl.outerHeight();
          var targetOffset = $targetEl.offset();
          targetOffsetLeft = targetOffset.left - app.left;
          targetOffsetTop = targetOffset.top - app.top;
          var targetParentPage = $targetEl.parents('.page');

          if (targetParentPage.length > 0) {
            targetOffsetTop -= targetParentPage[0].scrollTop;
          }
        } else if (typeof targetX !== 'undefined' && targetY !== 'undefined') {
          targetOffsetLeft = targetX;
          targetOffsetTop = targetY;
          targetWidth = popover.params.targetWidth || 0;
          targetHeight = popover.params.targetHeight || 0;
        }

        var left = 0,
            top = 0,
            diff = 0; // Top Position

        var position = app.theme === 'md' ? 'bottom' : 'top';

        if (app.theme === 'md') {
          if (height < app.height - targetOffsetTop - targetHeight) {
            // On bottom
            position = 'bottom';
            top = targetOffsetTop + targetHeight;
          } else if (height < targetOffsetTop - safeAreaTop) {
            // On top
            top = targetOffsetTop - height;
            position = 'top';
          } else {
            // On middle
            position = 'middle';
            top = targetHeight / 2 + targetOffsetTop - height / 2;
          }

          top = Math.max(8, Math.min(top, app.height - height - 8)); // Horizontal Position

          var hPosition;

          if (targetOffsetLeft < app.width / 2) {
            hPosition = 'right';
            left = position === 'middle' ? targetOffsetLeft + targetWidth : targetOffsetLeft;
          } else {
            hPosition = 'left';
            left = position === 'middle' ? targetOffsetLeft - width : targetOffsetLeft + targetWidth - width;
          }

          left = Math.max(8, Math.min(left, app.width - width - 8 - safeAreaRight), safeAreaLeft);
          $el.addClass("popover-on-" + position + " popover-on-" + hPosition);
        } else {
          // ios and aurora
          if (height + angleSize < targetOffsetTop - safeAreaTop) {
            // On top
            top = targetOffsetTop - height - angleSize;
          } else if (height + angleSize < app.height - targetOffsetTop - targetHeight) {
            // On bottom
            position = 'bottom';
            top = targetOffsetTop + targetHeight + angleSize;
          } else {
            // On middle
            position = 'middle';
            top = targetHeight / 2 + targetOffsetTop - height / 2;
            diff = top;
            top = Math.max(5, Math.min(top, app.height - height - 5));
            diff -= top;
          } // Horizontal Position


          if (position === 'top' || position === 'bottom') {
            left = targetWidth / 2 + targetOffsetLeft - width / 2;
            diff = left;
            left = Math.max(5, Math.min(left, app.width - width - 5));

            if (safeAreaLeft) {
              left = Math.max(left, safeAreaLeft);
            }

            if (safeAreaRight && left + width > app.width - 5 - safeAreaRight) {
              left = app.width - 5 - safeAreaRight - width;
            }

            if (position === 'top') {
              $angleEl.addClass('on-bottom');
            }

            if (position === 'bottom') {
              $angleEl.addClass('on-top');
            }

            diff -= left;
            angleLeft = width / 2 - angleSize + diff;
            angleLeft = Math.max(Math.min(angleLeft, width - angleSize * 2 - 13), 13);
            $angleEl.css({
              left: angleLeft + "px"
            });
          } else if (position === 'middle') {
            left = targetOffsetLeft - width - angleSize;
            $angleEl.addClass('on-right');

            if (left < 5 || left + width + safeAreaRight > app.width || left < safeAreaLeft) {
              if (left < 5) left = targetOffsetLeft + targetWidth + angleSize;
              if (left + width + safeAreaRight > app.width) left = app.width - width - 5 - safeAreaRight;
              if (left < safeAreaLeft) left = safeAreaLeft;
              $angleEl.removeClass('on-right').addClass('on-left');
            }

            angleTop = height / 2 - angleSize + diff;
            angleTop = Math.max(Math.min(angleTop, height - angleSize * 2 - 13), 13);
            $angleEl.css({
              top: angleTop + "px"
            });
          }
        } // Apply Styles


        $el.css({
          top: top + "px",
          left: left + "px"
        });
      };

      return Popover;
    }(Modal$2);

    var Popover$2 = Popover$1;

    var Popover = {
      name: 'popover',
      params: {
        popover: {
          backdrop: true,
          backdropEl: undefined,
          closeByBackdropClick: true,
          closeByOutsideClick: true,
          closeOnEscape: false,
          containerEl: null
        }
      },
      static: {
        Popover: Popover$2
      },
      create: function create() {
        var app = this;
        app.popover = extend$2(ModalMethods({
          app: app,
          constructor: Popover$2,
          defaultSelector: '.popover.modal-in'
        }), {
          open: function open(popoverEl, targetEl, animate) {
            var $popoverEl = $(popoverEl);

            if ($popoverEl.length > 1) {
              // check if same popover in other page
              var $targetPage = $(targetEl).parents('.page');

              if ($targetPage.length) {
                $popoverEl.each(function (el) {
                  var $el = $(el);

                  if ($el.parents($targetPage)[0] === $targetPage[0]) {
                    $popoverEl = $el;
                  }
                });
              }
            }

            if ($popoverEl.length > 1) {
              $popoverEl = $popoverEl.eq($popoverEl.length - 1);
            }

            var popover = $popoverEl[0].f7Modal;
            var data = $popoverEl.dataset();

            if (!popover) {
              popover = new Popover$2(app, Object.assign({
                el: $popoverEl,
                targetEl: targetEl
              }, data));
            }

            return popover.open(targetEl, animate);
          }
        });
      },
      clicks: {
        '.popover-open': function openPopover($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.popover.open(data.popover, $clickedEl, data.animate);
        },
        '.popover-close': function closePopover($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.popover.close(data.popover, data.animate, $clickedEl);
        }
      }
    };

    function _assertThisInitialized$m(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$m(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$m(subClass, superClass); }

    function _setPrototypeOf$m(o, p) { _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$m(o, p); }

    var Actions$1 = /*#__PURE__*/function (_Modal) {
      _inheritsLoose$m(Actions, _Modal);

      function Actions(app, params) {
        var _this;

        var extendedParams = extend$2({
          on: {}
        }, app.params.actions, params); // Extends with open/close Modal methods;

        _this = _Modal.call(this, app, extendedParams) || this;

        var actions = _assertThisInitialized$m(_this);

        var device = getDevice$1();
        var window = getWindow();
        var document = getDocument();
        actions.params = extendedParams; // Buttons

        var groups;

        if (actions.params.buttons) {
          groups = actions.params.buttons;
          if (!Array.isArray(groups[0])) groups = [groups];
        }

        actions.groups = groups; // Find Element

        var $el;

        if (actions.params.el) {
          $el = $(actions.params.el).eq(0);
        } else if (actions.params.content) {
          $el = $(actions.params.content).filter(function (node) {
            return node.nodeType === 1;
          }).eq(0);
        } else if (actions.params.buttons) {
          if (actions.params.convertToPopover) {
            actions.popoverHtml = actions.renderPopover();
          }

          actions.actionsHtml = actions.render();
        }

        if ($el && $el.length > 0 && $el[0].f7Modal) {
          return $el[0].f7Modal || _assertThisInitialized$m(_this);
        }

        if ($el && $el.length === 0 && !(actions.actionsHtml || actions.popoverHtml)) {
          return actions.destroy() || _assertThisInitialized$m(_this);
        } // Backdrop


        var $backdropEl;

        if (actions.params.backdrop && actions.params.backdropEl) {
          $backdropEl = $(actions.params.backdropEl);
        } else if (actions.params.backdrop) {
          $backdropEl = actions.$containerEl.children('.actions-backdrop');

          if ($backdropEl.length === 0) {
            $backdropEl = $('<div class="actions-backdrop"></div>');
            actions.$containerEl.append($backdropEl);
          }
        }

        var originalOpen = actions.open;
        var originalClose = actions.close;
        var popover;

        function buttonOnClick(e) {
          var $buttonEl = $(this);
          var buttonIndex;
          var groupIndex;

          if ($buttonEl.hasClass('list-button') || $buttonEl.hasClass('item-link')) {
            buttonIndex = $buttonEl.parents('li').index();
            groupIndex = $buttonEl.parents('.list').index();
          } else {
            buttonIndex = $buttonEl.index();
            groupIndex = $buttonEl.parents('.actions-group').index();
          }

          if (typeof groups !== 'undefined') {
            var button = groups[groupIndex][buttonIndex];
            if (button.onClick) button.onClick(actions, e);
            if (actions.params.onClick) actions.params.onClick(actions, e);
            if (button.close !== false) actions.close();
          }
        }

        actions.open = function open(animate) {
          var convertToPopover = false;
          var _actions$params = actions.params,
              targetEl = _actions$params.targetEl,
              targetX = _actions$params.targetX,
              targetY = _actions$params.targetY,
              targetWidth = _actions$params.targetWidth,
              targetHeight = _actions$params.targetHeight;

          if (actions.params.convertToPopover && (targetEl || targetX !== undefined && targetY !== undefined)) {
            // Popover
            if (actions.params.forceToPopover || device.ios && device.ipad || app.width >= 768 || device.desktop && app.theme === 'aurora') {
              convertToPopover = true;
            }
          }

          if (convertToPopover && actions.popoverHtml) {
            popover = app.popover.create({
              containerEl: actions.params.containerEl,
              content: actions.popoverHtml,
              backdrop: actions.params.backdrop,
              targetEl: targetEl,
              targetX: targetX,
              targetY: targetY,
              targetWidth: targetWidth,
              targetHeight: targetHeight,
              on: {
                open: function open() {
                  if (!actions.$el) {
                    actions.$el = popover.$el;
                  }

                  actions.$el.trigger("modal:open " + actions.type.toLowerCase() + ":open");
                  actions.emit("local::open modalOpen " + actions.type + "Open", actions);
                },
                opened: function opened() {
                  if (!actions.$el) {
                    actions.$el = popover.$el;
                  }

                  actions.$el.trigger("modal:opened " + actions.type.toLowerCase() + ":opened");
                  actions.emit("local::opened modalOpened " + actions.type + "Opened", actions);
                },
                close: function close() {
                  if (!actions.$el) {
                    actions.$el = popover.$el;
                  }

                  actions.$el.trigger("modal:close " + actions.type.toLowerCase() + ":close");
                  actions.emit("local::close modalClose " + actions.type + "Close", actions);
                },
                closed: function closed() {
                  if (!actions.$el) {
                    actions.$el = popover.$el;
                  }

                  actions.$el.trigger("modal:closed " + actions.type.toLowerCase() + ":closed");
                  actions.emit("local::closed modalClosed " + actions.type + "Closed", actions);
                }
              }
            });
            popover.open(animate);
            popover.once('popoverOpened', function () {
              popover.$el.find('.list-button, .item-link').each(function (buttonEl) {
                $(buttonEl).on('click', buttonOnClick);
              });
            });
            popover.once('popoverClosed', function () {
              popover.$el.find('.list-button, .item-link').each(function (buttonEl) {
                $(buttonEl).off('click', buttonOnClick);
              });
              nextTick$1(function () {
                popover.destroy();
                popover = undefined;
              });
            });
          } else {
            actions.$el = actions.actionsHtml ? $(actions.actionsHtml) : actions.$el;
            actions.$el[0].f7Modal = actions;

            if (actions.groups) {
              actions.$el.find('.actions-button').each(function (buttonEl) {
                $(buttonEl).on('click', buttonOnClick);
              });
              actions.once('actionsClosed', function () {
                actions.$el.find('.actions-button').each(function (buttonEl) {
                  $(buttonEl).off('click', buttonOnClick);
                });
              });
            }

            actions.el = actions.$el[0];
            originalOpen.call(actions, animate);
          }

          return actions;
        };

        actions.close = function close(animate) {
          if (popover) {
            popover.close(animate);
          } else {
            originalClose.call(actions, animate);
          }

          return actions;
        };

        extend$2(actions, {
          app: app,
          $el: $el,
          el: $el ? $el[0] : undefined,
          $backdropEl: $backdropEl,
          backdropEl: $backdropEl && $backdropEl[0],
          type: 'actions'
        });

        function handleClick(e) {
          var target = e.target;
          var $target = $(target);
          var keyboardOpened = !device.desktop && device.cordova && (window.Keyboard && window.Keyboard.isVisible || window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible);
          if (keyboardOpened) return;

          if ($target.closest(actions.el).length === 0) {
            if (actions.params.closeByBackdropClick && actions.params.backdrop && actions.backdropEl && actions.backdropEl === target) {
              actions.close();
            } else if (actions.params.closeByOutsideClick) {
              actions.close();
            }
          }
        }

        function onKeyDown(e) {
          var keyCode = e.keyCode;

          if (keyCode === 27 && actions.params.closeOnEscape) {
            actions.close();
          }
        }

        if (actions.params.closeOnEscape) {
          actions.on('open', function () {
            $(document).on('keydown', onKeyDown);
          });
          actions.on('close', function () {
            $(document).off('keydown', onKeyDown);
          });
        }

        actions.on('opened', function () {
          if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
            app.on('click', handleClick);
          }
        });
        actions.on('close', function () {
          if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
            app.off('click', handleClick);
          }
        });

        if ($el) {
          $el[0].f7Modal = actions;
        }

        return actions || _assertThisInitialized$m(_this);
      }

      var _proto = Actions.prototype;

      _proto.render = function render() {
        var actions = this;
        if (actions.params.render) return actions.params.render.call(actions, actions);
        var groups = actions.groups;
        var cssClass = actions.params.cssClass;
        return $jsx$1("div", {
          class: "actions-modal" + (actions.params.grid ? ' actions-grid' : '') + " " + (cssClass || '')
        }, groups.map(function (group) {
          return $jsx$1("div", {
            class: "actions-group"
          }, group.map(function (button) {
            var buttonClasses = ["actions-" + (button.label ? 'label' : 'button')];
            var color = button.color,
                bg = button.bg,
                bold = button.bold,
                disabled = button.disabled,
                label = button.label,
                text = button.text,
                icon = button.icon;
            if (color) buttonClasses.push("color-" + color);
            if (bg) buttonClasses.push("bg-color-" + bg);
            if (bold) buttonClasses.push('actions-button-bold');
            if (disabled) buttonClasses.push('disabled');

            if (label) {
              return $jsx$1("div", {
                class: buttonClasses.join(' ')
              }, text);
            }

            return $jsx$1("div", {
              class: buttonClasses.join(' ')
            }, icon && $jsx$1("div", {
              class: "actions-button-media"
            }, icon), $jsx$1("div", {
              class: "actions-button-text"
            }, text));
          }));
        }));
      };

      _proto.renderPopover = function renderPopover() {
        var actions = this;
        if (actions.params.renderPopover) return actions.params.renderPopover.call(actions, actions);
        var groups = actions.groups;
        var cssClass = actions.params.cssClass;
        return $jsx$1("div", {
          class: "popover popover-from-actions " + (cssClass || '')
        }, $jsx$1("div", {
          class: "popover-inner"
        }, groups.map(function (group) {
          return $jsx$1("div", {
            class: "list"
          }, $jsx$1("ul", null, group.map(function (button) {
            var itemClasses = [];
            var color = button.color,
                bg = button.bg,
                bold = button.bold,
                disabled = button.disabled,
                label = button.label,
                text = button.text,
                icon = button.icon;
            if (color) itemClasses.push("color-" + color);
            if (bg) itemClasses.push("bg-color-" + bg);
            if (bold) itemClasses.push('popover-from-actions-bold');
            if (disabled) itemClasses.push('disabled');

            if (label) {
              itemClasses.push('popover-from-actions-label');
              return "<li class=\"" + itemClasses.join(' ') + "\">" + text + "</li>";
            }

            if (icon) {
              itemClasses.push('item-link item-content');
              return $jsx$1("li", null, $jsx$1("a", {
                class: itemClasses.join(' ')
              }, $jsx$1("div", {
                class: "item-media"
              }, icon), $jsx$1("div", {
                class: "item-inner"
              }, $jsx$1("div", {
                class: "item-title"
              }, text))));
            }

            itemClasses.push('list-button');
            return $jsx$1("li", null, $jsx$1("a", {
              class: itemClasses.join(' ')
            }, text));
          })));
        })));
      };

      return Actions;
    }(Modal$2);

    var Actions$2 = Actions$1;

    var Actions = {
      name: 'actions',
      params: {
        actions: {
          convertToPopover: true,
          forceToPopover: false,
          backdrop: true,
          backdropEl: undefined,
          cssClass: null,
          closeByBackdropClick: true,
          closeOnEscape: false,
          render: null,
          renderPopover: null,
          containerEl: null
        }
      },
      static: {
        Actions: Actions$2
      },
      create: function create() {
        var app = this;
        app.actions = ModalMethods({
          app: app,
          constructor: Actions$2,
          defaultSelector: '.actions-modal.modal-in'
        });
      },
      clicks: {
        '.actions-open': function openActions($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.actions.open(data.actions, data.animate, $clickedEl);
        },
        '.actions-close': function closeActions($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.actions.close(data.actions, data.animate, $clickedEl);
        }
      }
    };

    function _assertThisInitialized$l(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$l(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$l(subClass, superClass); }

    function _setPrototypeOf$l(o, p) { _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$l(o, p); }

    var Sheet$1 = /*#__PURE__*/function (_Modal) {
      _inheritsLoose$l(Sheet, _Modal);

      function Sheet(app, params) {
        var _this;

        var extendedParams = extend$2({
          on: {}
        }, app.params.sheet, params); // Extends with open/close Modal methods;

        _this = _Modal.call(this, app, extendedParams) || this;

        var sheet = _assertThisInitialized$l(_this);

        var window = getWindow();
        var document = getDocument();
        var support = getSupport$1();
        var device = getDevice$1();
        sheet.params = extendedParams;

        if (typeof sheet.params.backdrop === 'undefined') {
          sheet.params.backdrop = app.theme !== 'ios';
        } // Find Element


        var $el;

        if (!sheet.params.el) {
          $el = $(sheet.params.content).filter(function (node) {
            return node.nodeType === 1;
          }).eq(0);
        } else {
          $el = $(sheet.params.el).eq(0);
        }

        if ($el && $el.length > 0 && $el[0].f7Modal) {
          return $el[0].f7Modal || _assertThisInitialized$l(_this);
        }

        if ($el.length === 0) {
          return sheet.destroy() || _assertThisInitialized$l(_this);
        }

        var $backdropEl;

        if (sheet.params.backdrop && sheet.params.backdropEl) {
          $backdropEl = $(sheet.params.backdropEl);
        } else if (sheet.params.backdrop) {
          $backdropEl = sheet.$containerEl.children('.sheet-backdrop');

          if ($backdropEl.length === 0) {
            $backdropEl = $('<div class="sheet-backdrop"></div>');
            sheet.$containerEl.append($backdropEl);
          }
        }

        extend$2(sheet, {
          app: app,
          push: $el.hasClass('sheet-modal-push') || sheet.params.push,
          $el: $el,
          el: $el[0],
          $backdropEl: $backdropEl,
          backdropEl: $backdropEl && $backdropEl[0],
          type: 'sheet',
          $htmlEl: $('html')
        });

        if (sheet.params.push) {
          $el.addClass('sheet-modal-push');
        }

        var $pageContentEl;

        function scrollToElementOnOpen() {
          var $scrollEl = $(sheet.params.scrollToEl).eq(0);
          if ($scrollEl.length === 0) return;
          $pageContentEl = $scrollEl.parents('.page-content');
          if ($pageContentEl.length === 0) return;
          var paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
          var paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
          var pageHeight = $pageContentEl[0].offsetHeight - paddingTop - $el.height();
          var pageScrollHeight = $pageContentEl[0].scrollHeight - paddingTop - $el.height();
          var pageScroll = $pageContentEl.scrollTop();
          var newPaddingBottom;
          var scrollElTop = $scrollEl.offset().top - paddingTop + $scrollEl[0].offsetHeight;

          if (scrollElTop > pageHeight) {
            var scrollTop = pageScroll + scrollElTop - pageHeight;

            if (scrollTop + pageHeight > pageScrollHeight) {
              newPaddingBottom = scrollTop + pageHeight - pageScrollHeight + paddingBottom;

              if (pageHeight === pageScrollHeight) {
                newPaddingBottom = $el.height();
              }

              $pageContentEl.css({
                'padding-bottom': newPaddingBottom + "px"
              });
            }

            $pageContentEl.scrollTop(scrollTop, 300);
          }
        }

        function scrollToElementOnClose() {
          if ($pageContentEl && $pageContentEl.length > 0) {
            $pageContentEl.css({
              'padding-bottom': ''
            });
          }
        }

        function handleClick(e) {
          var target = e.target;
          var $target = $(target);
          var keyboardOpened = !device.desktop && device.cordova && (window.Keyboard && window.Keyboard.isVisible || window.cordova.plugins && window.cordova.plugins.Keyboard && window.cordova.plugins.Keyboard.isVisible);
          if (keyboardOpened) return;

          if ($target.closest(sheet.el).length === 0) {
            if (sheet.params.closeByBackdropClick && sheet.params.backdrop && sheet.backdropEl && sheet.backdropEl === target) {
              sheet.close();
            } else if (sheet.params.closeByOutsideClick) {
              sheet.close();
            }
          }
        }

        function onKeyDown(e) {
          var keyCode = e.keyCode;

          if (keyCode === 27 && sheet.params.closeOnEscape) {
            sheet.close();
          }
        }

        var pushOffset;

        function pushViewScale(offset) {
          return (app.height - offset * 2) / app.height;
        }

        var isTouched = false;
        var startTouch;
        var currentTouch;
        var isScrolling;
        var touchStartTime;
        var touchesDiff;
        var isMoved = false;
        var isTopSheetModal;
        var swipeStepTranslate;
        var startTranslate;
        var currentTranslate;
        var sheetElOffsetHeight;
        var minTranslate;
        var maxTranslate;
        var $pushViewEl;
        var pushBorderRadius;
        var sheetPageContentEl;
        var sheetPageContentScrollTop;
        var sheetPageContentScrollHeight;
        var sheetPageContentOffsetHeight;

        function handleTouchStart(e) {
          if (isTouched || !(sheet.params.swipeToClose || sheet.params.swipeToStep)) return;

          if (sheet.params.swipeHandler && $(e.target).closest(sheet.params.swipeHandler).length === 0) {
            return;
          }

          isTouched = true;
          isMoved = false;
          startTouch = {
            x: e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX,
            y: e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY
          };
          touchStartTime = now$2();
          isScrolling = undefined;
          isTopSheetModal = $el.hasClass('sheet-modal-top');

          if (!sheet.params.swipeHandler && e.type === 'touchstart') {
            sheetPageContentEl = $(e.target).closest('.page-content')[0];
          }
        }

        function handleTouchMove(e) {
          if (!isTouched) return;
          currentTouch = {
            x: e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX,
            y: e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY
          };

          if (typeof isScrolling === 'undefined') {
            isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
          }

          if (isScrolling) {
            isTouched = false;
            isMoved = false;
            return;
          }

          touchesDiff = startTouch.y - currentTouch.y;
          var direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';

          if (!isMoved) {
            if (sheetPageContentEl && !$el.hasClass('modal-in-swipe-step')) {
              sheetPageContentScrollTop = sheetPageContentEl.scrollTop;
              sheetPageContentScrollHeight = sheetPageContentEl.scrollHeight;
              sheetPageContentOffsetHeight = sheetPageContentEl.offsetHeight;

              if (!(sheetPageContentScrollHeight === sheetPageContentOffsetHeight) && !(direction === 'to-bottom' && sheetPageContentScrollTop === 0) && !(direction === 'to-top' && sheetPageContentScrollTop === sheetPageContentScrollHeight - sheetPageContentOffsetHeight)) {
                $el.transform('');
                isTouched = false;
                isMoved = false;
                return;
              }
            }

            if (sheet.push && pushOffset) {
              $pushViewEl = app.$el.children('.view, .views');
            }

            sheetElOffsetHeight = $el[0].offsetHeight;
            startTranslate = getTranslate$1($el[0], 'y');

            if (isTopSheetModal) {
              minTranslate = sheet.params.swipeToClose ? -sheetElOffsetHeight : -swipeStepTranslate;
              maxTranslate = 0;
            } else {
              minTranslate = 0;
              maxTranslate = sheet.params.swipeToClose ? sheetElOffsetHeight : swipeStepTranslate;
            }

            isMoved = true;
          }

          currentTranslate = startTranslate - touchesDiff;
          currentTranslate = Math.min(Math.max(currentTranslate, minTranslate), maxTranslate);
          e.preventDefault();

          if (sheet.push && pushOffset) {
            var progress = (currentTranslate - startTranslate) / sheetElOffsetHeight;

            if (sheet.params.swipeToStep) {
              if (isTopSheetModal) {
                progress = currentTranslate / swipeStepTranslate;
              } else {
                progress = 1 - (swipeStepTranslate - currentTranslate) / swipeStepTranslate;
              }
            }

            progress = Math.abs(progress);
            progress = Math.min(Math.max(progress, 0), 1);
            var pushProgress = 1 - progress;
            var scale = 1 - (1 - pushViewScale(pushOffset)) * pushProgress;
            $pushViewEl.transition(0).forEach(function (el) {
              el.style.setProperty('transform', "translate3d(0,0,0) scale(" + scale + ")", 'important');
            });

            if (sheet.params.swipeToStep) {
              $pushViewEl.css('border-radius', pushBorderRadius * pushProgress + "px");
            }
          }

          $el.transition(0).transform("translate3d(0," + currentTranslate + "px,0)");

          if (sheet.params.swipeToStep) {
            var _progress;

            if (isTopSheetModal) {
              _progress = 1 - currentTranslate / swipeStepTranslate;
            } else {
              _progress = (swipeStepTranslate - currentTranslate) / swipeStepTranslate;
            }

            _progress = Math.min(Math.max(_progress, 0), 1);
            $el.trigger('sheet:stepprogress', _progress);
            sheet.emit('local::stepProgress sheetStepProgress', sheet, _progress);
          }
        }

        function handleTouchEnd() {
          isTouched = false;

          if (!isMoved) {
            return;
          }

          isMoved = false;
          $el.transform('').transition('');

          if (sheet.push && pushOffset) {
            $pushViewEl.transition('').transform('');
            $pushViewEl.css('border-radius', '');
          }

          var direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';
          var diff = Math.abs(touchesDiff);
          if (diff === 0 || currentTranslate === startTranslate) return;
          var timeDiff = new Date().getTime() - touchStartTime;

          if (!sheet.params.swipeToStep) {
            if (direction !== (isTopSheetModal ? 'to-top' : 'to-bottom')) {
              return;
            }

            if (timeDiff < 300 && diff > 20 || timeDiff >= 300 && diff > sheetElOffsetHeight / 2) {
              sheet.close();
            }

            return;
          }

          var openDirection = isTopSheetModal ? 'to-bottom' : 'to-top';
          var closeDirection = isTopSheetModal ? 'to-top' : 'to-bottom';
          var absCurrentTranslate = Math.abs(currentTranslate);
          var absSwipeStepTranslate = Math.abs(swipeStepTranslate);

          if (timeDiff < 300 && diff > 10) {
            if (direction === openDirection && absCurrentTranslate < absSwipeStepTranslate) {
              // open step
              $el.removeClass('modal-in-swipe-step');
              $el.trigger('sheet:stepprogress', 1);
              sheet.emit('local::stepProgress sheetStepProgress', sheet, 1);
              $el.trigger('sheet:stepopen');
              sheet.emit('local::stepOpen sheetStepOpen', sheet);

              if (sheet.push && pushOffset) {
                sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
                $pushViewEl.css('border-radius', '');
              }
            }

            if (direction === closeDirection && absCurrentTranslate > absSwipeStepTranslate) {
              // close sheet
              if (sheet.params.swipeToClose) {
                sheet.close();
              } else {
                // close step
                $el.addClass('modal-in-swipe-step');
                $el.trigger('sheet:stepprogress', 0);
                sheet.emit('local::stepProgress sheetStepProgress', sheet, 0);
                $el.trigger('sheet:stepclose');
                sheet.emit('local::stepClose sheetStepClose', sheet);

                if (sheet.push && pushOffset) {
                  sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
                  $pushViewEl.css('border-radius', '0px');
                }
              }
            }

            if (direction === closeDirection && absCurrentTranslate <= absSwipeStepTranslate) {
              // close step
              $el.addClass('modal-in-swipe-step');
              $el.trigger('sheet:stepprogress', 0);
              sheet.emit('local::stepProgress sheetStepProgress', sheet, 0);
              $el.trigger('sheet:stepclose');
              sheet.emit('local::stepClose sheetStepClose', sheet);

              if (sheet.push && pushOffset) {
                sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
                $pushViewEl.css('border-radius', '0px');
              }
            }

            return;
          }

          if (timeDiff >= 300) {
            var stepOpened = !$el.hasClass('modal-in-swipe-step');

            if (!stepOpened) {
              if (absCurrentTranslate < absSwipeStepTranslate / 2) {
                // open step
                $el.removeClass('modal-in-swipe-step');
                $el.trigger('sheet:stepprogress', 1);
                sheet.emit('local::stepProgress sheetStepProgress', sheet, 1);
                $el.trigger('sheet:stepopen');
                sheet.emit('local::stepOpen sheetStepOpen', sheet);

                if (sheet.push && pushOffset) {
                  sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
                  $pushViewEl.css('border-radius', '');
                }
              } else if (absCurrentTranslate - absSwipeStepTranslate > (sheetElOffsetHeight - absSwipeStepTranslate) / 2) {
                // close sheet
                if (sheet.params.swipeToClose) sheet.close();
              }
            } else if (stepOpened) {
              if (absCurrentTranslate > absSwipeStepTranslate + (sheetElOffsetHeight - absSwipeStepTranslate) / 2) {
                // close sheet
                if (sheet.params.swipeToClose) sheet.close();
              } else if (absCurrentTranslate > absSwipeStepTranslate / 2) {
                // close step
                $el.addClass('modal-in-swipe-step');
                $el.trigger('sheet:stepprogress', 0);
                sheet.emit('local::stepProgress sheetStepProgress', sheet, 0);
                $el.trigger('sheet:stepclose');
                sheet.emit('local::stepClose sheetStepClose', sheet);

                if (sheet.push && pushOffset) {
                  sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
                  $pushViewEl.css('border-radius', '0px');
                }
              }
            }
          }
        }

        sheet.setSwipeStep = function setSwipeStep(byResize) {
          if (byResize === void 0) {
            byResize = true;
          }

          var $swipeStepEl = $el.find('.sheet-modal-swipe-step').eq(0);
          if (!$swipeStepEl.length) return;

          if ($el.hasClass('sheet-modal-top')) {
            swipeStepTranslate = -($swipeStepEl.offset().top - $el.offset().top + $swipeStepEl[0].offsetHeight);
          } else {
            swipeStepTranslate = $el[0].offsetHeight - ($swipeStepEl.offset().top - $el.offset().top + $swipeStepEl[0].offsetHeight);
          }

          $el[0].style.setProperty('--f7-sheet-swipe-step', swipeStepTranslate + "px");

          if (!byResize) {
            $el.addClass('modal-in-swipe-step');
          }
        };

        function onResize() {
          sheet.setSwipeStep(true);
        }

        var passive = support.passiveListener ? {
          passive: true
        } : false;

        if (sheet.params.swipeToClose || sheet.params.swipeToStep) {
          $el.on(app.touchEvents.start, handleTouchStart, passive);
          app.on('touchmove', handleTouchMove);
          app.on('touchend:passive', handleTouchEnd);
          sheet.once('sheetDestroy', function () {
            $el.off(app.touchEvents.start, handleTouchStart, passive);
            app.off('touchmove', handleTouchMove);
            app.off('touchend:passive', handleTouchEnd);
          });
        }

        sheet.on('open', function () {
          if (sheet.params.closeOnEscape) {
            $(document).on('keydown', onKeyDown);
          }

          $el.prevAll('.popup.modal-in').addClass('popup-behind');

          if (sheet.params.swipeToStep) {
            sheet.setSwipeStep(false);
            app.on('resize', onResize);
          }

          if (sheet.params.scrollToEl) {
            scrollToElementOnOpen();
          }

          if (sheet.push) {
            pushOffset = parseInt($el.css('--f7-sheet-push-offset'), 10);
            if (Number.isNaN(pushOffset)) pushOffset = 0;

            if (pushOffset) {
              $el.addClass('sheet-modal-push');
              sheet.$htmlEl.addClass('with-modal-sheet-push');

              if (!sheet.params.swipeToStep) {
                sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
              } else {
                $pushViewEl = app.$el.children('.view, .views');
                pushBorderRadius = parseFloat($el.css("border-" + (isTopSheetModal ? 'bottom' : 'top') + "-left-radius"));
                $pushViewEl.css('border-radius', '0px');
              }
            }
          }
        });
        sheet.on('opened', function () {
          if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
            app.on('click', handleClick);
          }
        });
        sheet.on('close', function () {
          if (sheet.params.swipeToStep) {
            $el.removeClass('modal-in-swipe-step');
            app.off('resize', onResize);
          }

          if (sheet.params.closeOnEscape) {
            $(document).off('keydown', onKeyDown);
          }

          if (sheet.params.scrollToEl) {
            scrollToElementOnClose();
          }

          if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
            app.off('click', handleClick);
          }

          $el.prevAll('.popup.modal-in').eq(0).removeClass('popup-behind');

          if (sheet.push && pushOffset) {
            sheet.$htmlEl.removeClass('with-modal-sheet-push');
            sheet.$htmlEl.addClass('with-modal-sheet-push-closing');
          }
        });
        sheet.on('closed', function () {
          if (sheet.push && pushOffset) {
            sheet.$htmlEl.removeClass('with-modal-sheet-push-closing');
            sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
          }
        });

        sheet.stepOpen = function stepOpen() {
          $el.removeClass('modal-in-swipe-step');

          if (sheet.push) {
            if (!pushOffset) {
              pushOffset = parseInt($el.css('--f7-sheet-push-offset'), 10);
              if (Number.isNaN(pushOffset)) pushOffset = 0;
            }

            if (pushOffset) {
              sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
            }
          }
        };

        sheet.stepClose = function stepClose() {
          $el.addClass('modal-in-swipe-step');

          if (sheet.push) {
            sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
          }
        };

        sheet.stepToggle = function stepToggle() {
          $el.toggleClass('modal-in-swipe-step');
        };

        $el[0].f7Modal = sheet;
        return sheet || _assertThisInitialized$l(_this);
      }

      return Sheet;
    }(Modal$2);

    var Sheet$2 = Sheet$1;

    var Sheet = {
      name: 'sheet',
      params: {
        sheet: {
          push: false,
          backdrop: undefined,
          backdropEl: undefined,
          closeByBackdropClick: true,
          closeByOutsideClick: false,
          closeOnEscape: false,
          swipeToClose: false,
          swipeToStep: false,
          swipeHandler: null,
          containerEl: null
        }
      },
      static: {
        Sheet: Sheet$2
      },
      create: function create() {
        var app = this;
        app.sheet = extend$2({}, ModalMethods({
          app: app,
          constructor: Sheet$2,
          defaultSelector: '.sheet-modal.modal-in'
        }), {
          stepOpen: function stepOpen(sheet) {
            var sheetInstance = app.sheet.get(sheet);
            if (sheetInstance && sheetInstance.stepOpen) return sheetInstance.stepOpen();
            return undefined;
          },
          stepClose: function stepClose(sheet) {
            var sheetInstance = app.sheet.get(sheet);
            if (sheetInstance && sheetInstance.stepClose) return sheetInstance.stepClose();
            return undefined;
          },
          stepToggle: function stepToggle(sheet) {
            var sheetInstance = app.sheet.get(sheet);
            if (sheetInstance && sheetInstance.stepToggle) return sheetInstance.stepToggle();
            return undefined;
          }
        });
      },
      clicks: {
        '.sheet-open': function openSheet($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;

          if ($('.sheet-modal.modal-in').length > 0 && data.sheet && $(data.sheet)[0] !== $('.sheet-modal.modal-in')[0]) {
            app.sheet.close('.sheet-modal.modal-in');
          }

          app.sheet.open(data.sheet, data.animate, $clickedEl);
        },
        '.sheet-close': function closeSheet($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.sheet.close(data.sheet, data.animate, $clickedEl);
        }
      }
    };

    function _assertThisInitialized$k(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$k(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$k(subClass, superClass); }

    function _setPrototypeOf$k(o, p) { _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$k(o, p); }

    var Toast$1 = /*#__PURE__*/function (_Modal) {
      _inheritsLoose$k(Toast, _Modal);

      function Toast(app, params) {
        var _this;

        var extendedParams = extend$2({
          on: {}
        }, app.params.toast, params); // Extends with open/close Modal methods;

        _this = _Modal.call(this, app, extendedParams) || this;

        var toast = _assertThisInitialized$k(_this);

        var window = getWindow();
        toast.app = app;
        toast.params = extendedParams;
        var _toast$params = toast.params,
            closeButton = _toast$params.closeButton,
            closeTimeout = _toast$params.closeTimeout;
        var $el;

        if (!toast.params.el) {
          // Find Element
          var toastHtml = toast.render();
          $el = $(toastHtml);
        } else {
          $el = $(toast.params.el);
        }

        if ($el && $el.length > 0 && $el[0].f7Modal) {
          return $el[0].f7Modal || _assertThisInitialized$k(_this);
        }

        if ($el.length === 0) {
          return toast.destroy() || _assertThisInitialized$k(_this);
        }

        extend$2(toast, {
          $el: $el,
          el: $el[0],
          type: 'toast'
        });
        $el[0].f7Modal = toast;

        if (closeButton) {
          $el.find('.toast-button').on('click', function () {
            toast.emit('local::closeButtonClick toastCloseButtonClick', toast);
            toast.close();
          });
          toast.on('beforeDestroy', function () {
            $el.find('.toast-button').off('click');
          });
        }

        var timeoutId;
        toast.on('open', function () {
          $('.toast.modal-in').each(function (openedEl) {
            var toastInstance = app.toast.get(openedEl);

            if (openedEl !== toast.el && toastInstance) {
              toastInstance.close();
            }
          });

          if (closeTimeout) {
            timeoutId = nextTick$1(function () {
              toast.close();
            }, closeTimeout);
          }
        });
        toast.on('close', function () {
          window.clearTimeout(timeoutId);
        });

        if (toast.params.destroyOnClose) {
          toast.once('closed', function () {
            setTimeout(function () {
              toast.destroy();
            }, 0);
          });
        }

        return toast || _assertThisInitialized$k(_this);
      }

      var _proto = Toast.prototype;

      _proto.render = function render() {
        var toast = this;
        if (toast.params.render) return toast.params.render.call(toast, toast);
        var _toast$params2 = toast.params,
            position = _toast$params2.position,
            horizontalPosition = _toast$params2.horizontalPosition,
            cssClass = _toast$params2.cssClass,
            icon = _toast$params2.icon,
            text = _toast$params2.text,
            closeButton = _toast$params2.closeButton,
            closeButtonColor = _toast$params2.closeButtonColor,
            closeButtonText = _toast$params2.closeButtonText;
        var horizontalClass = position === 'top' || position === 'bottom' ? "toast-horizontal-" + horizontalPosition : '';
        return $jsx$1("div", {
          class: "toast toast-" + position + " " + horizontalClass + " " + (cssClass || '') + " " + (icon ? 'toast-with-icon' : '')
        }, $jsx$1("div", {
          class: "toast-content"
        }, icon && $jsx$1("div", {
          class: "toast-icon"
        }, icon), $jsx$1("div", {
          class: "toast-text"
        }, text), closeButton && !icon && $jsx$1("a", {
          class: "toast-button button " + (closeButtonColor ? "color-" + closeButtonColor : '')
        }, closeButtonText)));
      };

      return Toast;
    }(Modal$2);

    var Toast$2 = Toast$1;

    var Toast = {
      name: 'toast',
      static: {
        Toast: Toast$2
      },
      create: function create() {
        var app = this;
        app.toast = extend$2({}, ModalMethods({
          app: app,
          constructor: Toast$2,
          defaultSelector: '.toast.modal-in'
        }), {
          // Shortcuts
          show: function show(params) {
            extend$2(params, {
              destroyOnClose: true
            });
            return new Toast$2(app, params).open();
          }
        });
      },
      params: {
        toast: {
          icon: null,
          text: null,
          position: 'bottom',
          horizontalPosition: 'left',
          closeButton: false,
          closeButtonColor: null,
          closeButtonText: 'Ok',
          closeTimeout: null,
          cssClass: null,
          render: null,
          containerEl: null
        }
      }
    };

    var Preloader$1 = {
      init: function init(el) {
        var app = this;
        var preloaders = {
          iosPreloaderContent: iosPreloaderContent,
          mdPreloaderContent: mdPreloaderContent,
          auroraPreloaderContent: auroraPreloaderContent
        };
        var $el = $(el);
        if ($el.length === 0 || $el.children('.preloader-inner').length > 0 || $el.children('.preloader-inner-line').length > 0) return;
        $el.append(preloaders[app.theme + "PreloaderContent"]);
      },
      // Modal
      visible: false,
      show: function show(color) {
        if (color === void 0) {
          color = 'white';
        }

        var app = this;
        if (Preloader$1.visible) return;
        var preloaders = {
          iosPreloaderContent: iosPreloaderContent,
          mdPreloaderContent: mdPreloaderContent,
          auroraPreloaderContent: auroraPreloaderContent
        };
        var preloaderInner = preloaders[app.theme + "PreloaderContent"] || '';
        $('html').addClass('with-modal-preloader'); // prettier-ignore

        app.$el.append("\n      <div class=\"preloader-backdrop\"></div>\n      <div class=\"preloader-modal\">\n        <div class=\"preloader color-" + color + "\">" + preloaderInner + "</div>\n      </div>\n    ");
        Preloader$1.visible = true;
      },
      showIn: function showIn(el, color) {
        if (color === void 0) {
          color = 'white';
        }

        var app = this;
        var preloaders = {
          iosPreloaderContent: iosPreloaderContent,
          mdPreloaderContent: mdPreloaderContent,
          auroraPreloaderContent: auroraPreloaderContent
        };
        var preloaderInner = preloaders[app.theme + "PreloaderContent"] || '';
        $(el || 'html').addClass('with-modal-preloader'); // prettier-ignore

        $(el || app.$el).append("\n      <div class=\"preloader-backdrop\"></div>\n      <div class=\"preloader-modal\">\n        <div class=\"preloader color-" + color + "\">" + preloaderInner + "</div>\n      </div>\n    ");
      },
      hide: function hide() {
        var app = this;
        if (!Preloader$1.visible) return;
        $('html').removeClass('with-modal-preloader');
        app.$el.find('.preloader-backdrop, .preloader-modal').remove();
        Preloader$1.visible = false;
      },
      hideIn: function hideIn(el) {
        var app = this;
        $(el || 'html').removeClass('with-modal-preloader');
        $(el || app.$el).find('.preloader-backdrop, .preloader-modal').remove();
      }
    };
    var Preloader$2 = {
      name: 'preloader',
      create: function create() {
        var app = this;
        bindMethods(app, {
          preloader: Preloader$1
        });
      },
      on: {
        photoBrowserOpen: function photoBrowserOpen(pb) {
          var app = this;
          pb.$el.find('.preloader').each(function (preloaderEl) {
            app.preloader.init(preloaderEl);
          });
        },
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.preloader').each(function (preloaderEl) {
            app.preloader.init(preloaderEl);
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.preloader').each(function (preloaderEl) {
            app.preloader.init(preloaderEl);
          });
        }
      },
      vnode: {
        preloader: {
          insert: function insert(vnode) {
            var app = this;
            var preloaderEl = vnode.elm;
            app.preloader.init(preloaderEl);
          }
        }
      }
    };

    var Progressbar = {
      set: function set() {
        var app = this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var el = args[0],
            progress = args[1],
            duration = args[2];

        if (typeof args[0] === 'number') {
          progress = args[0];
          duration = args[1];
          el = app.$el;
        }

        if (typeof progress === 'undefined' || progress === null) return el;
        if (!progress) progress = 0;
        var $el = $(el || app.$el);

        if ($el.length === 0) {
          return el;
        }

        var progressNormalized = Math.min(Math.max(progress, 0), 100);
        var $progressbarEl;
        if ($el.hasClass('progressbar')) $progressbarEl = $el.eq(0);else {
          $progressbarEl = $el.children('.progressbar');
        }

        if ($progressbarEl.length === 0 || $progressbarEl.hasClass('progressbar-infinite')) {
          return $progressbarEl;
        }

        var $progressbarLine = $progressbarEl.children('span');

        if ($progressbarLine.length === 0) {
          $progressbarLine = $('<span></span>');
          $progressbarEl.append($progressbarLine);
        }

        $progressbarLine.transition(typeof duration !== 'undefined' ? duration : '').transform("translate3d(" + (-100 + progressNormalized) + "%,0,0)");
        return $progressbarEl[0];
      },
      show: function show() {
        var app = this; // '.page', 50, 'multi'

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        var el = args[0],
            progress = args[1],
            color = args[2];
        var type = 'determined';

        if (args.length === 2) {
          if ((typeof args[0] === 'string' || typeof args[0] === 'object') && typeof args[1] === 'string') {
            // '.page', 'multi'
            el = args[0];
            color = args[1];
            progress = args[2];
            type = 'infinite';
          } else if (typeof args[0] === 'number' && typeof args[1] === 'string') {
            // 50, 'multi'
            progress = args[0];
            color = args[1];
            el = app.$el;
          }
        } else if (args.length === 1) {
          if (typeof args[0] === 'number') {
            el = app.$el;
            progress = args[0];
          } else if (typeof args[0] === 'string') {
            type = 'infinite';
            el = app.$el;
            color = args[0];
          }
        } else if (args.length === 0) {
          type = 'infinite';
          el = app.$el;
        }

        var $el = $(el);
        if ($el.length === 0) return undefined;
        var $progressbarEl;

        if ($el.hasClass('progressbar') || $el.hasClass('progressbar-infinite')) {
          $progressbarEl = $el;
        } else {
          $progressbarEl = $el.children('.progressbar:not(.progressbar-out), .progressbar-infinite:not(.progressbar-out)');

          if ($progressbarEl.length === 0) {
            $progressbarEl = $("\n          <span class=\"progressbar" + (type === 'infinite' ? '-infinite' : '') + (color ? " color-" + color : '') + " progressbar-in\">\n            " + (type === 'infinite' ? '' : '<span></span>') + "\n          </span>");
            $el.append($progressbarEl);
          }
        }

        if (typeof progress !== 'undefined') {
          app.progressbar.set($progressbarEl, progress);
        }

        return $progressbarEl[0];
      },
      hide: function hide(el, removeAfterHide) {
        if (removeAfterHide === void 0) {
          removeAfterHide = true;
        }

        var app = this;
        var $el = $(el || app.$el);
        if ($el.length === 0) return undefined;
        var $progressbarEl;

        if ($el.hasClass('progressbar') || $el.hasClass('progressbar-infinite')) {
          $progressbarEl = $el;
        } else {
          $progressbarEl = $el.children('.progressbar, .progressbar-infinite');
        }

        if ($progressbarEl.length === 0 || !$progressbarEl.hasClass('progressbar-in') || $progressbarEl.hasClass('progressbar-out')) {
          return $progressbarEl;
        }

        $progressbarEl.removeClass('progressbar-in').addClass('progressbar-out').animationEnd(function () {
          if (removeAfterHide) {
            $progressbarEl.remove();
          }
        });
        return $progressbarEl;
      }
    };
    var Progressbar$1 = {
      name: 'progressbar',
      create: function create() {
        var app = this;
        bindMethods(app, {
          progressbar: Progressbar
        });
      },
      on: {
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.progressbar').each(function (progressbarEl) {
            var $progressbarEl = $(progressbarEl);
            app.progressbar.set($progressbarEl, $progressbarEl.attr('data-progress'));
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.progressbar').each(function (progressbarEl) {
            var $progressbarEl = $(progressbarEl);
            app.progressbar.set($progressbarEl, $progressbarEl.attr('data-progress'));
          });
        }
      },
      vnode: {
        progressbar: {
          insert: function insert(vnode) {
            var app = this;
            var el = vnode.elm;
            app.progressbar.set(el, el.getAttribute('data-progress'));
          },
          update: function update(vnode) {
            var app = this;
            var el = vnode.elm;
            app.progressbar.set(el, el.getAttribute('data-progress'));
          }
        }
      }
    };

    var Sortable = {
      init: function init() {
        var app = this;
        var document = getDocument();
        var isTouched;
        var isMoved;
        var touchStartY;
        var touchesDiff;
        var $sortingEl;
        var $sortingItems;
        var $sortableContainer;
        var sortingElHeight;
        var minTop;
        var maxTop;
        var $insertAfterEl;
        var $insertBeforeEl;
        var indexFrom;
        var $pageEl;
        var $pageContentEl;
        var pageHeight;
        var pageOffset;
        var sortingElOffsetLocal;
        var sortingElOffsetTop;
        var initialScrollTop;
        var wasTapHold;

        function handleTouchStart(e, isTapHold) {
          isMoved = false;
          isTouched = true;
          wasTapHold = false;
          touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
          $sortingEl = $(e.target).closest('li').eq(0);
          indexFrom = $sortingEl.index();
          $sortableContainer = $sortingEl.parents('.sortable');
          var $listGroup = $sortingEl.parents('.list-group');

          if ($listGroup.length && $listGroup.parents($sortableContainer).length) {
            $sortableContainer = $listGroup;
          }

          $sortingItems = $sortableContainer.children('ul').children('li:not(.disallow-sorting):not(.no-sorting)');
          if (app.panel) app.panel.allowOpen = false;
          if (app.swipeout) app.swipeout.allow = false;

          if (isTapHold) {
            $sortingEl.addClass('sorting');
            $sortableContainer.addClass('sortable-sorting');
            wasTapHold = true;
          }
        }

        function handleTouchMove(e) {
          if (!isTouched || !$sortingEl) return;
          var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

          if (!isMoved) {
            $pageEl = $sortingEl.parents('.page');
            $pageContentEl = $sortingEl.parents('.page-content');
            var paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
            var paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
            initialScrollTop = $pageContentEl[0].scrollTop;
            pageOffset = $pageEl.offset().top + paddingTop;
            pageHeight = $pageEl.height() - paddingTop - paddingBottom;
            $sortingEl.addClass('sorting');
            $sortableContainer.addClass('sortable-sorting');
            sortingElOffsetLocal = $sortingEl[0].offsetTop;
            minTop = $sortingEl[0].offsetTop;
            maxTop = $sortingEl.parent().height() - sortingElOffsetLocal - $sortingEl.height();
            sortingElHeight = $sortingEl[0].offsetHeight;
            sortingElOffsetTop = $sortingEl.offset().top;
          }

          isMoved = true;
          e.preventDefault();
          e.f7PreventSwipePanel = true;
          touchesDiff = pageY - touchStartY;
          var translateScrollOffset = $pageContentEl[0].scrollTop - initialScrollTop;
          var translate = Math.min(Math.max(touchesDiff + translateScrollOffset, -minTop), maxTop);
          $sortingEl.transform("translate3d(0," + translate + "px,0)");
          var scrollAddition = 44;
          var allowScroll = true;

          if (touchesDiff + translateScrollOffset + scrollAddition < -minTop) {
            allowScroll = false;
          }

          if (touchesDiff + translateScrollOffset - scrollAddition > maxTop) {
            allowScroll = false;
          }

          $insertBeforeEl = undefined;
          $insertAfterEl = undefined;
          var scrollDiff;

          if (allowScroll) {
            if (sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition > pageOffset + pageHeight) {
              // To Bottom
              scrollDiff = sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition - (pageOffset + pageHeight);
            }

            if (sortingElOffsetTop + touchesDiff < pageOffset + scrollAddition) {
              // To Top
              scrollDiff = sortingElOffsetTop + touchesDiff - pageOffset - scrollAddition;
            }

            if (scrollDiff) {
              $pageContentEl[0].scrollTop += scrollDiff;
            }
          }

          $sortingItems.each(function (el) {
            var $currentEl = $(el);
            if ($currentEl[0] === $sortingEl[0]) return;
            var currentElOffset = $currentEl[0].offsetTop;
            var currentElHeight = $currentEl.height();
            var sortingElOffset = sortingElOffsetLocal + translate;

            if (sortingElOffset >= currentElOffset - currentElHeight / 2 && $sortingEl.index() < $currentEl.index()) {
              $currentEl.transform("translate3d(0, " + -sortingElHeight + "px,0)");
              $insertAfterEl = $currentEl;
              $insertBeforeEl = undefined;
            } else if (sortingElOffset <= currentElOffset + currentElHeight / 2 && $sortingEl.index() > $currentEl.index()) {
              $currentEl.transform("translate3d(0, " + sortingElHeight + "px,0)");
              $insertAfterEl = undefined;
              if (!$insertBeforeEl) $insertBeforeEl = $currentEl;
            } else {
              $currentEl.transform('translate3d(0, 0%,0)');
            }
          });
        }

        function handleTouchEnd() {
          if (!isTouched || !isMoved) {
            if (isTouched && !isMoved) {
              if (app.panel) app.panel.allowOpen = true;
              if (app.swipeout) app.swipeout.allow = true;

              if (wasTapHold) {
                $sortingEl.removeClass('sorting');
                $sortableContainer.removeClass('sortable-sorting');
              }
            }

            isTouched = false;
            isMoved = false;
            return;
          }

          if (app.panel) app.panel.allowOpen = true;
          if (app.swipeout) app.swipeout.allow = true;
          $sortingItems.transform('');
          $sortingEl.removeClass('sorting');
          $sortableContainer.removeClass('sortable-sorting');
          var indexTo;
          if ($insertAfterEl) indexTo = $insertAfterEl.index();else if ($insertBeforeEl) indexTo = $insertBeforeEl.index();
          var moveElements = $sortableContainer.dataset().sortableMoveElements;

          if (typeof moveElements === 'undefined') {
            moveElements = app.params.sortable.moveElements;
          }

          if (moveElements) {
            if ($insertAfterEl) {
              $sortingEl.insertAfter($insertAfterEl);
            }

            if ($insertBeforeEl) {
              $sortingEl.insertBefore($insertBeforeEl);
            }
          }

          if (($insertAfterEl || $insertBeforeEl) && $sortableContainer.hasClass('virtual-list')) {
            indexFrom = $sortingEl[0].f7VirtualListIndex;
            if (typeof indexFrom === 'undefined') indexFrom = $sortingEl.attr('data-virtual-list-index');

            if ($insertBeforeEl) {
              indexTo = $insertBeforeEl[0].f7VirtualListIndex;
              if (typeof indexTo === 'undefined') indexTo = $insertBeforeEl.attr('data-virtual-list-index');
            } else {
              indexTo = $insertAfterEl[0].f7VirtualListIndex;
              if (typeof indexTo === 'undefined') indexTo = $insertAfterEl.attr('data-virtual-list-index');
            }

            if (indexTo !== null) indexTo = parseInt(indexTo, 10);else indexTo = undefined;
            var virtualList = $sortableContainer[0].f7VirtualList;
            if (indexFrom) indexFrom = parseInt(indexFrom, 10);
            if (indexTo) indexTo = parseInt(indexTo, 10);
            if (virtualList) virtualList.moveItem(indexFrom, indexTo);
          }

          if (typeof indexTo !== 'undefined' && !Number.isNaN(indexTo) && indexTo !== indexFrom) {
            $sortingEl.trigger('sortable:sort', {
              from: indexFrom,
              to: indexTo
            });
            app.emit('sortableSort', $sortingEl[0], {
              from: indexFrom,
              to: indexTo,
              el: $sortingEl[0]
            }, $sortableContainer[0]);
          }

          $insertBeforeEl = undefined;
          $insertAfterEl = undefined;
          isTouched = false;
          isMoved = false;
        }

        var activeListener = getSupport$1().passiveListener ? {
          passive: false,
          capture: false
        } : false;
        $(document).on(app.touchEvents.start, '.list.sortable .sortable-handler', handleTouchStart, activeListener);
        app.on('touchmove:active', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
        $(document).on('taphold', '.sortable-tap-hold', function (e, pointerEvent) {
          handleTouchStart(pointerEvent, true);
        });
      },
      enable: function enable(el) {
        if (el === void 0) {
          el = '.list.sortable';
        }

        var app = this;
        var $el = $(el);
        if ($el.length === 0) return;
        $el.addClass('sortable-enabled');
        $el.trigger('sortable:enable');
        app.emit('sortableEnable', $el[0]);
      },
      disable: function disable(el) {
        if (el === void 0) {
          el = '.list.sortable';
        }

        var app = this;
        var $el = $(el);
        if ($el.length === 0) return;
        $el.removeClass('sortable-enabled');
        $el.trigger('sortable:disable');
        app.emit('sortableDisable', $el[0]);
      },
      toggle: function toggle(el) {
        if (el === void 0) {
          el = '.list.sortable';
        }

        var app = this;
        var $el = $(el);
        if ($el.length === 0) return;

        if ($el.hasClass('sortable-enabled')) {
          app.sortable.disable($el);
        } else {
          app.sortable.enable($el);
        }
      }
    };
    var Sortable$1 = {
      name: 'sortable',
      params: {
        sortable: {
          moveElements: true
        }
      },
      create: function create() {
        var app = this;
        bindMethods(app, {
          sortable: Sortable
        });
      },
      on: {
        init: function init() {
          var app = this;
          if (!app.params.sortable) return;
          app.sortable.init();
        }
      },
      clicks: {
        '.sortable-enable': function enable($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.sortable.enable(data.sortable);
        },
        '.sortable-disable': function disable($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.sortable.disable(data.sortable);
        },
        '.sortable-toggle': function toggle($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.sortable.toggle(data.sortable);
        }
      }
    };

    var Swipeout = {
      init: function init() {
        var app = this;
        var document = getDocument();
        var touchesStart = {};
        var isTouched;
        var isMoved;
        var isScrolling;
        var touchStartTime;
        var touchesDiff;
        var $swipeoutEl;
        var $swipeoutContent;
        var $actionsRight;
        var $actionsLeft;
        var actionsLeftWidth;
        var actionsRightWidth;
        var translate;
        var opened;
        var openedActionsSide;
        var $leftButtons;
        var $rightButtons;
        var direction;
        var $overswipeLeftButton;
        var $overswipeRightButton;
        var overswipeLeft;
        var overswipeRight;

        function handleTouchStart(e) {
          if (!app.swipeout.allow) return;
          isMoved = false;
          isTouched = true;
          isScrolling = undefined;
          touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
          touchStartTime = new Date().getTime();
          $swipeoutEl = $(this);
        }

        function handleTouchMove(e) {
          if (!isTouched) return;
          var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
          var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

          if (typeof isScrolling === 'undefined') {
            isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
          }

          if (isScrolling) {
            isTouched = false;
            return;
          }

          if (!isMoved) {
            if ($('.list.sortable-opened').length > 0) return;
            $swipeoutContent = $swipeoutEl.find('.swipeout-content');
            $actionsRight = $swipeoutEl.find('.swipeout-actions-right');
            $actionsLeft = $swipeoutEl.find('.swipeout-actions-left');
            actionsLeftWidth = null;
            actionsRightWidth = null;
            $leftButtons = null;
            $rightButtons = null;
            $overswipeRightButton = null;
            $overswipeLeftButton = null;

            if ($actionsLeft.length > 0) {
              actionsLeftWidth = $actionsLeft.outerWidth();
              $leftButtons = $actionsLeft.children('a');
              $overswipeLeftButton = $actionsLeft.find('.swipeout-overswipe');
            }

            if ($actionsRight.length > 0) {
              actionsRightWidth = $actionsRight.outerWidth();
              $rightButtons = $actionsRight.children('a');
              $overswipeRightButton = $actionsRight.find('.swipeout-overswipe');
            }

            opened = $swipeoutEl.hasClass('swipeout-opened');

            if (opened) {
              openedActionsSide = $swipeoutEl.find('.swipeout-actions-left.swipeout-actions-opened').length > 0 ? 'left' : 'right';
            }

            $swipeoutEl.removeClass('swipeout-transitioning');

            if (!app.params.swipeout.noFollow) {
              $swipeoutEl.find('.swipeout-actions-opened').removeClass('swipeout-actions-opened');
              $swipeoutEl.removeClass('swipeout-opened');
            }
          }

          isMoved = true;

          if (e.cancelable) {
            e.preventDefault();
          }

          touchesDiff = pageX - touchesStart.x;
          translate = touchesDiff;

          if (opened) {
            if (openedActionsSide === 'right') translate -= actionsRightWidth;else translate += actionsLeftWidth;
          }

          if (translate > 0 && $actionsLeft.length === 0 || translate < 0 && $actionsRight.length === 0) {
            if (!opened) {
              isTouched = false;
              isMoved = false;
              $swipeoutContent.transform('');

              if ($rightButtons && $rightButtons.length > 0) {
                $rightButtons.transform('');
              }

              if ($leftButtons && $leftButtons.length > 0) {
                $leftButtons.transform('');
              }

              return;
            }

            translate = 0;
          }

          if (translate < 0) direction = 'to-left';else if (translate > 0) direction = 'to-right';else if (!direction) direction = 'to-left';
          var buttonOffset;
          var progress;
          e.f7PreventSwipePanel = true;

          if (app.params.swipeout.noFollow) {
            if (opened) {
              if (openedActionsSide === 'right' && touchesDiff > 0) {
                app.swipeout.close($swipeoutEl);
              }

              if (openedActionsSide === 'left' && touchesDiff < 0) {
                app.swipeout.close($swipeoutEl);
              }
            } else {
              if (touchesDiff < 0 && $actionsRight.length > 0) {
                app.swipeout.open($swipeoutEl, 'right');
              }

              if (touchesDiff > 0 && $actionsLeft.length > 0) {
                app.swipeout.open($swipeoutEl, 'left');
              }
            }

            isTouched = false;
            isMoved = false;
            return;
          }

          overswipeLeft = false;
          overswipeRight = false;

          if ($actionsRight.length > 0) {
            // Show right actions
            var buttonTranslate = translate;
            progress = buttonTranslate / actionsRightWidth;

            if (buttonTranslate < -actionsRightWidth) {
              var ratio = buttonTranslate / -actionsRightWidth;
              buttonTranslate = -actionsRightWidth - Math.pow(-buttonTranslate - actionsRightWidth, 0.8);
              translate = buttonTranslate;

              if ($overswipeRightButton.length > 0 && ratio > app.params.swipeout.overswipeRatio) {
                overswipeRight = true;
              }
            }

            if (direction !== 'to-left') {
              progress = 0;
              buttonTranslate = 0;
            }

            $rightButtons.each(function (buttonEl) {
              var $buttonEl = $(buttonEl);

              if (typeof buttonEl.f7SwipeoutButtonOffset === 'undefined') {
                $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
              }

              buttonOffset = buttonEl.f7SwipeoutButtonOffset;

              if ($overswipeRightButton.length > 0 && $buttonEl.hasClass('swipeout-overswipe') && direction === 'to-left') {
                $buttonEl.css({
                  left: (overswipeRight ? -buttonOffset : 0) + "px"
                });

                if (overswipeRight) {
                  if (!$buttonEl.hasClass('swipeout-overswipe-active')) {
                    $swipeoutEl.trigger('swipeout:overswipeenter');
                    app.emit('swipeoutOverswipeEnter', $swipeoutEl[0]);
                  }

                  $buttonEl.addClass('swipeout-overswipe-active');
                } else {
                  if ($buttonEl.hasClass('swipeout-overswipe-active')) {
                    $swipeoutEl.trigger('swipeout:overswipeexit');
                    app.emit('swipeoutOverswipeExit', $swipeoutEl[0]);
                  }

                  $buttonEl.removeClass('swipeout-overswipe-active');
                }
              }

              $buttonEl.transform("translate3d(" + (buttonTranslate - buttonOffset * (1 + Math.max(progress, -1))) + "px,0,0)");
            });
          }

          if ($actionsLeft.length > 0) {
            // Show left actions
            var _buttonTranslate = translate;
            progress = _buttonTranslate / actionsLeftWidth;

            if (_buttonTranslate > actionsLeftWidth) {
              var _ratio = _buttonTranslate / actionsRightWidth;

              _buttonTranslate = actionsLeftWidth + Math.pow(_buttonTranslate - actionsLeftWidth, 0.8);
              translate = _buttonTranslate;

              if ($overswipeLeftButton.length > 0 && _ratio > app.params.swipeout.overswipeRatio) {
                overswipeLeft = true;
              }
            }

            if (direction !== 'to-right') {
              _buttonTranslate = 0;
              progress = 0;
            }

            $leftButtons.each(function (buttonEl, index) {
              var $buttonEl = $(buttonEl);

              if (typeof buttonEl.f7SwipeoutButtonOffset === 'undefined') {
                $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
              }

              buttonOffset = buttonEl.f7SwipeoutButtonOffset;

              if ($overswipeLeftButton.length > 0 && $buttonEl.hasClass('swipeout-overswipe') && direction === 'to-right') {
                $buttonEl.css({
                  left: (overswipeLeft ? buttonOffset : 0) + "px"
                });

                if (overswipeLeft) {
                  if (!$buttonEl.hasClass('swipeout-overswipe-active')) {
                    $swipeoutEl.trigger('swipeout:overswipeenter');
                    app.emit('swipeoutOverswipeEnter', $swipeoutEl[0]);
                  }

                  $buttonEl.addClass('swipeout-overswipe-active');
                } else {
                  if ($buttonEl.hasClass('swipeout-overswipe-active')) {
                    $swipeoutEl.trigger('swipeout:overswipeexit');
                    app.emit('swipeoutOverswipeExit', $swipeoutEl[0]);
                  }

                  $buttonEl.removeClass('swipeout-overswipe-active');
                }
              }

              if ($leftButtons.length > 1) {
                $buttonEl.css('z-index', $leftButtons.length - index);
              }

              $buttonEl.transform("translate3d(" + (_buttonTranslate + buttonOffset * (1 - Math.min(progress, 1))) + "px,0,0)");
            });
          }

          $swipeoutEl.trigger('swipeout', progress);
          app.emit('swipeout', $swipeoutEl[0], progress);
          $swipeoutContent.transform("translate3d(" + translate + "px,0,0)");
        }

        function handleTouchEnd() {
          if (!isTouched || !isMoved) {
            isTouched = false;
            isMoved = false;
            return;
          }

          isTouched = false;
          isMoved = false;
          var timeDiff = new Date().getTime() - touchStartTime;
          var $actions = direction === 'to-left' ? $actionsRight : $actionsLeft;
          var actionsWidth = direction === 'to-left' ? actionsRightWidth : actionsLeftWidth;
          var action;
          var $buttons;
          var i;

          if (timeDiff < 300 && (touchesDiff < -10 && direction === 'to-left' || touchesDiff > 10 && direction === 'to-right') || timeDiff >= 300 && Math.abs(translate) > actionsWidth / 2) {
            action = 'open';
          } else {
            action = 'close';
          }

          if (timeDiff < 300) {
            if (Math.abs(translate) === 0) action = 'close';
            if (Math.abs(translate) === actionsWidth) action = 'open';
          }

          if (action === 'open') {
            Swipeout.el = $swipeoutEl[0];
            $swipeoutEl.trigger('swipeout:open');
            app.emit('swipeoutOpen', $swipeoutEl[0]);
            $swipeoutEl.addClass('swipeout-opened swipeout-transitioning');
            var newTranslate = direction === 'to-left' ? -actionsWidth : actionsWidth;
            $swipeoutContent.transform("translate3d(" + newTranslate + "px,0,0)");
            $actions.addClass('swipeout-actions-opened');
            $buttons = direction === 'to-left' ? $rightButtons : $leftButtons;

            if ($buttons) {
              for (i = 0; i < $buttons.length; i += 1) {
                $($buttons[i]).transform("translate3d(" + newTranslate + "px,0,0)");
              }
            }

            if (overswipeRight) {
              $actionsRight.find('.swipeout-overswipe').trigger('click', 'f7Overswipe');
            }

            if (overswipeLeft) {
              $actionsLeft.find('.swipeout-overswipe').trigger('click', 'f7Overswipe');
            }
          } else {
            $swipeoutEl.trigger('swipeout:close');
            app.emit('swipeoutClose', $swipeoutEl[0]);
            Swipeout.el = undefined;
            $swipeoutEl.addClass('swipeout-transitioning').removeClass('swipeout-opened');
            $swipeoutContent.transform('');
            $actions.removeClass('swipeout-actions-opened');
          }

          var buttonOffset;

          if ($leftButtons && $leftButtons.length > 0 && $leftButtons !== $buttons) {
            $leftButtons.each(function (buttonEl) {
              var $buttonEl = $(buttonEl);
              buttonOffset = buttonEl.f7SwipeoutButtonOffset;

              if (typeof buttonOffset === 'undefined') {
                $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
              }

              $buttonEl.transform("translate3d(" + buttonOffset + "px,0,0)");
            });
          }

          if ($rightButtons && $rightButtons.length > 0 && $rightButtons !== $buttons) {
            $rightButtons.each(function (buttonEl) {
              var $buttonEl = $(buttonEl);
              buttonOffset = buttonEl.f7SwipeoutButtonOffset;

              if (typeof buttonOffset === 'undefined') {
                $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
              }

              $buttonEl.transform("translate3d(" + -buttonOffset + "px,0,0)");
            });
          }

          $swipeoutContent.transitionEnd(function () {
            if (opened && action === 'open' || !opened && action === 'close') return;
            $swipeoutEl.trigger(action === 'open' ? 'swipeout:opened' : 'swipeout:closed');
            app.emit(action === 'open' ? 'swipeoutOpened' : 'swipeoutClosed', $swipeoutEl[0]);
            $swipeoutEl.removeClass('swipeout-transitioning');

            if (opened && action === 'close') {
              if ($actionsRight.length > 0) {
                $rightButtons.transform('');
              }

              if ($actionsLeft.length > 0) {
                $leftButtons.transform('');
              }
            }
          });
        }

        var passiveListener = getSupport$1().passiveListener ? {
          passive: true
        } : false;
        app.on('touchstart', function (e) {
          if (Swipeout.el) {
            var $targetEl = $(e.target);

            if (!($(Swipeout.el).is($targetEl[0]) || $targetEl.parents('.swipeout').is(Swipeout.el) || $targetEl.hasClass('modal-in') || ($targetEl.attr('class') || '').indexOf('-backdrop') > 0 || $targetEl.hasClass('actions-modal') || $targetEl.parents('.actions-modal.modal-in, .dialog.modal-in').length > 0)) {
              app.swipeout.close(Swipeout.el);
            }
          }
        });
        $(document).on(app.touchEvents.start, 'li.swipeout', handleTouchStart, passiveListener);
        app.on('touchmove:active', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
      },
      allow: true,
      el: undefined,
      open: function open() {
        var app = this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var el = args[0],
            side = args[1],
            callback = args[2];

        if (typeof args[1] === 'function') {
          el = args[0];
          callback = args[1];
          side = args[2];
        }

        var $el = $(el).eq(0);
        if ($el.length === 0) return;
        if (!$el.hasClass('swipeout') || $el.hasClass('swipeout-opened')) return;

        if (!side) {
          if ($el.find('.swipeout-actions-right').length > 0) side = 'right';else side = 'left';
        }

        var $swipeoutActions = $el.find(".swipeout-actions-" + side);
        var $swipeoutContent = $el.find('.swipeout-content');
        if ($swipeoutActions.length === 0) return;
        $el.trigger('swipeout:open').addClass('swipeout-opened').removeClass('swipeout-transitioning');
        app.emit('swipeoutOpen', $el[0]);
        $swipeoutActions.addClass('swipeout-actions-opened');
        var $buttons = $swipeoutActions.children('a');
        var swipeoutActionsWidth = $swipeoutActions.outerWidth();
        var translate = side === 'right' ? -swipeoutActionsWidth : swipeoutActionsWidth;

        if ($buttons.length > 1) {
          $buttons.each(function (buttonEl, buttonIndex) {
            var $buttonEl = $(buttonEl);

            if (side === 'right') {
              $buttonEl.transform("translate3d(" + -buttonEl.offsetLeft + "px,0,0)");
            } else {
              $buttonEl.css('z-index', $buttons.length - buttonIndex).transform("translate3d(" + (swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft) + "px,0,0)");
            }
          });
        }

        $el.addClass('swipeout-transitioning');
        $swipeoutContent.transitionEnd(function () {
          $el.trigger('swipeout:opened');
          app.emit('swipeoutOpened', $el[0]);
          if (callback) callback.call($el[0]);
        });
        nextFrame(function () {
          $buttons.transform("translate3d(" + translate + "px,0,0)");
          $swipeoutContent.transform("translate3d(" + translate + "px,0,0)");
        });
        Swipeout.el = $el[0];
      },
      close: function close(el, callback) {
        var app = this;
        var $el = $(el).eq(0);
        if ($el.length === 0) return;
        if (!$el.hasClass('swipeout-opened')) return;
        var side = $el.find('.swipeout-actions-opened').hasClass('swipeout-actions-right') ? 'right' : 'left';
        var $swipeoutActions = $el.find('.swipeout-actions-opened').removeClass('swipeout-actions-opened');
        var $buttons = $swipeoutActions.children('a');
        var swipeoutActionsWidth = $swipeoutActions.outerWidth();
        app.swipeout.allow = false;
        $el.trigger('swipeout:close');
        app.emit('swipeoutClose', $el[0]);
        $el.removeClass('swipeout-opened').addClass('swipeout-transitioning');
        var closeTimeout;

        function onSwipeoutClose() {
          app.swipeout.allow = true;
          if ($el.hasClass('swipeout-opened')) return;
          $el.removeClass('swipeout-transitioning');
          $buttons.transform('');
          $el.trigger('swipeout:closed');
          app.emit('swipeoutClosed', $el[0]);
          if (callback) callback.call($el[0]);
          if (closeTimeout) clearTimeout(closeTimeout);
        }

        $el.find('.swipeout-content').transform('').transitionEnd(onSwipeoutClose);
        closeTimeout = setTimeout(onSwipeoutClose, 500);
        $buttons.each(function (buttonEl) {
          var $buttonEl = $(buttonEl);

          if (side === 'right') {
            $buttonEl.transform("translate3d(" + -buttonEl.offsetLeft + "px,0,0)");
          } else {
            $buttonEl.transform("translate3d(" + (swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft) + "px,0,0)");
          }

          $buttonEl.css({
            left: '0px'
          }).removeClass('swipeout-overswipe-active');
        });
        if (Swipeout.el && Swipeout.el === $el[0]) Swipeout.el = undefined;
      },
      delete: function _delete(el, callback) {
        var app = this;
        var $el = $(el).eq(0);
        if ($el.length === 0) return;
        Swipeout.el = undefined;
        $el.trigger('swipeout:delete');
        app.emit('swipeoutDelete', $el[0]);
        $el.css({
          height: $el.outerHeight() + "px"
        });
        $el.transitionEnd(function () {
          $el.trigger('swipeout:deleted');
          app.emit('swipeoutDeleted', $el[0]);
          if (callback) callback.call($el[0]);

          if ($el.parents('.virtual-list').length > 0) {
            var virtualList = $el.parents('.virtual-list')[0].f7VirtualList;
            var virtualIndex = $el[0].f7VirtualListIndex;
            if (virtualList && typeof virtualIndex !== 'undefined') virtualList.deleteItem(virtualIndex);
          } else if (app.params.swipeout.removeElements) {
            if (app.params.swipeout.removeElementsWithTimeout) {
              setTimeout(function () {
                $el.remove();
              }, app.params.swipeout.removeElementsTimeout);
            } else {
              $el.remove();
            }
          } else {
            $el.removeClass('swipeout-deleting swipeout-transitioning');
          }
        }); // eslint-disable-next-line
        // $el[0]._clientLeft = $el[0].clientLeft;

        nextFrame(function () {
          $el.addClass('swipeout-deleting swipeout-transitioning').css({
            height: '0px'
          }).find('.swipeout-content').transform('translate3d(-100%,0,0)');
        });
      }
    };
    var Swipeout$1 = {
      name: 'swipeout',
      params: {
        swipeout: {
          actionsNoFold: false,
          noFollow: false,
          removeElements: true,
          removeElementsWithTimeout: false,
          removeElementsTimeout: 0,
          overswipeRatio: 1.2
        }
      },
      create: function create() {
        var app = this;
        bindMethods(app, {
          swipeout: Swipeout
        });
      },
      clicks: {
        '.swipeout-open': function openSwipeout($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.swipeout.open(data.swipeout, data.side);
        },
        '.swipeout-close': function closeSwipeout($clickedEl) {
          var app = this;
          var $swipeoutEl = $clickedEl.closest('.swipeout');
          if ($swipeoutEl.length === 0) return;
          app.swipeout.close($swipeoutEl);
        },
        '.swipeout-delete': function deleteSwipeout($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          var $swipeoutEl = $clickedEl.closest('.swipeout');
          if ($swipeoutEl.length === 0) return;
          var _data = data,
              confirm = _data.confirm,
              confirmTitle = _data.confirmTitle;

          if (data.confirm) {
            app.dialog.confirm(confirm, confirmTitle, function () {
              app.swipeout.delete($swipeoutEl);
            });
          } else {
            app.swipeout.delete($swipeoutEl);
          }
        }
      },
      on: {
        init: function init() {
          var app = this;
          if (!app.params.swipeout) return;
          app.swipeout.init();
        }
      }
    };

    var Accordion = {
      toggleClicked: function toggleClicked($clickedEl) {
        var app = this;
        var $accordionItemEl = $clickedEl.closest('.accordion-item').eq(0);
        if (!$accordionItemEl.length) $accordionItemEl = $clickedEl.parents('li').eq(0);
        var $accordionContent = $clickedEl.parents('.accordion-item-content').eq(0);

        if ($accordionContent.length) {
          if ($accordionContent.parents($accordionItemEl).length) return;
        }

        if ($clickedEl.parents('li').length > 1 && $clickedEl.parents('li')[0] !== $accordionItemEl[0]) return;
        app.accordion.toggle($accordionItemEl);
      },
      open: function open(el) {
        var app = this;
        var $el = $(el);
        var prevented = false;

        function prevent() {
          prevented = true;
        }

        $el.trigger('accordion:beforeopen', {
          prevent: prevent
        }, prevent);
        app.emit('accordionBeforeOpen', $el[0], prevent);
        if (prevented) return;
        var $list = $el.parents('.accordion-list').eq(0);
        var $contentEl = $el.children('.accordion-item-content');
        $contentEl.removeAttr('aria-hidden');
        if ($contentEl.length === 0) $contentEl = $el.find('.accordion-item-content');
        if ($contentEl.length === 0) return;
        var $openedItem = $list.length > 0 && $el.parent().children('.accordion-item-opened');

        if ($openedItem.length > 0) {
          app.accordion.close($openedItem);
        }

        $contentEl.transitionEnd(function () {
          if ($el.hasClass('accordion-item-opened')) {
            $contentEl.transition(0);
            $contentEl.css('height', 'auto');
            nextFrame(function () {
              $contentEl.transition('');
              $el.trigger('accordion:opened');
              app.emit('accordionOpened', $el[0]);
            });
          } else {
            $contentEl.css('height', '');
            $el.trigger('accordion:closed');
            app.emit('accordionClosed', $el[0]);
          }
        });
        $contentEl.css('height', $contentEl[0].scrollHeight + "px");
        $el.trigger('accordion:open');
        $el.addClass('accordion-item-opened');
        app.emit('accordionOpen', $el[0]);
      },
      close: function close(el) {
        var app = this;
        var $el = $(el);
        var prevented = false;

        function prevent() {
          prevented = true;
        }

        $el.trigger('accordion:beforeclose', {
          prevent: prevent
        }, prevent);
        app.emit('accordionBeforeClose', $el[0], prevent);
        if (prevented) return;
        var $contentEl = $el.children('.accordion-item-content');
        if ($contentEl.length === 0) $contentEl = $el.find('.accordion-item-content');
        $el.removeClass('accordion-item-opened');
        $contentEl.attr('aria-hidden', true);
        $contentEl.transition(0);
        $contentEl.css('height', $contentEl[0].scrollHeight + "px"); // Close

        $contentEl.transitionEnd(function () {
          if ($el.hasClass('accordion-item-opened')) {
            $contentEl.transition(0);
            $contentEl.css('height', 'auto');
            nextFrame(function () {
              $contentEl.transition('');
              $el.trigger('accordion:opened');
              app.emit('accordionOpened', $el[0]);
            });
          } else {
            $contentEl.css('height', '');
            $el.trigger('accordion:closed');
            app.emit('accordionClosed', $el[0]);
          }
        });
        nextFrame(function () {
          $contentEl.transition('');
          $contentEl.css('height', '');
          $el.trigger('accordion:close');
          app.emit('accordionClose', $el[0]);
        });
      },
      toggle: function toggle(el) {
        var app = this;
        var $el = $(el);
        if ($el.length === 0) return;
        if ($el.hasClass('accordion-item-opened')) app.accordion.close(el);else app.accordion.open(el);
      }
    };
    var Accordion$1 = {
      name: 'accordion',
      create: function create() {
        var app = this;
        bindMethods(app, {
          accordion: Accordion
        });
      },
      clicks: {
        '.accordion-item .item-link, .accordion-item-toggle, .links-list.accordion-list > ul > li > a': function open($clickedEl) {
          var app = this;
          Accordion.toggleClicked.call(app, $clickedEl);
        }
      }
    };

    var ContactsList = {
      name: 'contactsList'
    };

    function _assertThisInitialized$j(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$j(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$j(subClass, superClass); }

    function _setPrototypeOf$j(o, p) { _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$j(o, p); }

    var VirtualList$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$j(VirtualList, _Framework7Class);

      function VirtualList(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params, [app]) || this;

        var vl = _assertThisInitialized$j(_this);

        var device = getDevice$1();
        var document = getDocument();
        var defaultHeight;

        if (app.theme === 'md') {
          defaultHeight = 48;
        } else if (app.theme === 'ios') {
          defaultHeight = 44;
        } else if (app.theme === 'aurora') {
          defaultHeight = 38;
        }

        var defaults = {
          cols: 1,
          height: defaultHeight,
          cache: true,
          dynamicHeightBufferSize: 1,
          showFilteredItemsOnly: false,
          renderExternal: undefined,
          setListHeight: true,
          searchByItem: undefined,
          searchAll: undefined,
          ul: null,
          createUl: true,
          scrollableParentEl: undefined,
          renderItem: function renderItem(item) {
            return ("\n          <li>\n            <div class=\"item-content\">\n              <div class=\"item-inner\">\n                <div class=\"item-title\">" + item + "</div>\n              </div>\n            </div>\n          </li>\n        ").trim();
          },
          on: {}
        }; // Extend defaults with modules params

        vl.useModulesParams(defaults);
        vl.params = extend$2(defaults, params);

        if (vl.params.height === undefined || !vl.params.height) {
          vl.params.height = defaultHeight;
        }

        vl.$el = $(params.el);
        vl.el = vl.$el[0];
        if (vl.$el.length === 0) return _assertThisInitialized$j(_this);
        vl.$el[0].f7VirtualList = vl;
        vl.items = vl.params.items;

        if (vl.params.showFilteredItemsOnly) {
          vl.filteredItems = [];
        }

        if (vl.params.renderItem) {
          vl.renderItem = vl.params.renderItem;
        }

        vl.$pageContentEl = vl.$el.parents('.page-content');
        vl.pageContentEl = vl.$pageContentEl[0];
        vl.$scrollableParentEl = vl.params.scrollableParentEl ? $(vl.params.scrollableParentEl).eq(0) : vl.$pageContentEl;

        if (!vl.$scrollableParentEl.length && vl.$pageContentEl.length) {
          vl.$scrollableParentEl = vl.$pageContentEl;
        }

        vl.scrollableParentEl = vl.$scrollableParentEl[0]; // Bad scroll

        if (typeof vl.params.updatableScroll !== 'undefined') {
          vl.updatableScroll = vl.params.updatableScroll;
        } else {
          vl.updatableScroll = true;

          if (device.ios && device.osVersion.split('.')[0] < 8) {
            vl.updatableScroll = false;
          }
        } // Append <ul>


        var ul = vl.params.ul;
        vl.$ul = ul ? $(vl.params.ul) : vl.$el.children('ul');

        if (vl.$ul.length === 0 && vl.params.createUl) {
          vl.$el.append('<ul></ul>');
          vl.$ul = vl.$el.children('ul');
        }

        vl.ul = vl.$ul[0];
        var $itemsWrapEl;
        if (!vl.ul && !vl.params.createUl) $itemsWrapEl = vl.$el;else $itemsWrapEl = vl.$ul;
        extend$2(vl, {
          $itemsWrapEl: $itemsWrapEl,
          itemsWrapEl: $itemsWrapEl[0],
          // DOM cached items
          domCache: {},
          displayDomCache: {},
          // Temporary DOM Element
          tempDomElement: document.createElement('ul'),
          // Last repain position
          lastRepaintY: null,
          // Fragment
          fragment: document.createDocumentFragment(),
          // Props
          pageHeight: undefined,
          rowsPerScreen: undefined,
          rowsBefore: undefined,
          rowsAfter: undefined,
          rowsToRender: undefined,
          maxBufferHeight: 0,
          listHeight: undefined,
          dynamicHeight: typeof vl.params.height === 'function'
        }); // Install Modules

        vl.useModules(); // Attach events

        var handleScrollBound = vl.handleScroll.bind(vl);
        var handleResizeBound = vl.handleResize.bind(vl);
        var $pageEl;
        var $tabEl;
        var $panelEl;
        var $popupEl;

        vl.attachEvents = function attachEvents() {
          $pageEl = vl.$el.parents('.page').eq(0);
          $tabEl = vl.$el.parents('.tab').filter(function (tabEl) {
            return $(tabEl).parent('.tabs').parent('.tabs-animated-wrap, .tabs-swipeable-wrap').length === 0;
          }).eq(0);
          $panelEl = vl.$el.parents('.panel').eq(0);
          $popupEl = vl.$el.parents('.popup').eq(0);
          vl.$scrollableParentEl.on('scroll', handleScrollBound);
          if ($pageEl.length) $pageEl.on('page:reinit', handleResizeBound);
          if ($tabEl.length) $tabEl.on('tab:show', handleResizeBound);
          if ($panelEl.length) $panelEl.on('panel:open', handleResizeBound);
          if ($popupEl.length) $popupEl.on('popup:open', handleResizeBound);
          app.on('resize', handleResizeBound);
        };

        vl.detachEvents = function attachEvents() {
          vl.$scrollableParentEl.off('scroll', handleScrollBound);
          if ($pageEl.length) $pageEl.off('page:reinit', handleResizeBound);
          if ($tabEl.length) $tabEl.off('tab:show', handleResizeBound);
          if ($panelEl.length) $panelEl.off('panel:open', handleResizeBound);
          if ($popupEl.length) $popupEl.off('popup:open', handleResizeBound);
          app.off('resize', handleResizeBound);
        }; // Init


        vl.init();
        return vl || _assertThisInitialized$j(_this);
      }

      var _proto = VirtualList.prototype;

      _proto.setListSize = function setListSize() {
        var vl = this;
        var items = vl.filteredItems || vl.items;
        vl.pageHeight = vl.$scrollableParentEl[0].offsetHeight;

        if (vl.dynamicHeight) {
          vl.listHeight = 0;
          vl.heights = [];

          for (var i = 0; i < items.length; i += 1) {
            var itemHeight = vl.params.height(items[i]);
            vl.listHeight += itemHeight;
            vl.heights.push(itemHeight);
          }
        } else {
          vl.listHeight = Math.ceil(items.length / vl.params.cols) * vl.params.height;
          vl.rowsPerScreen = Math.ceil(vl.pageHeight / vl.params.height);
          vl.rowsBefore = vl.params.rowsBefore || vl.rowsPerScreen * 2;
          vl.rowsAfter = vl.params.rowsAfter || vl.rowsPerScreen;
          vl.rowsToRender = vl.rowsPerScreen + vl.rowsBefore + vl.rowsAfter;
          vl.maxBufferHeight = vl.rowsBefore / 2 * vl.params.height;
        }

        if (vl.updatableScroll || vl.params.setListHeight) {
          vl.$itemsWrapEl.css({
            height: vl.listHeight + "px"
          });
        }
      };

      _proto.render = function render(force, forceScrollTop) {
        var vl = this;
        if (force) vl.lastRepaintY = null;
        var scrollTop = -(vl.$el[0].getBoundingClientRect().top - vl.$scrollableParentEl[0].getBoundingClientRect().top);
        if (typeof forceScrollTop !== 'undefined') scrollTop = forceScrollTop;

        if (vl.lastRepaintY === null || Math.abs(scrollTop - vl.lastRepaintY) > vl.maxBufferHeight || !vl.updatableScroll && vl.$scrollableParentEl[0].scrollTop + vl.pageHeight >= vl.$scrollableParentEl[0].scrollHeight) {
          vl.lastRepaintY = scrollTop;
        } else {
          return;
        }

        var items = vl.filteredItems || vl.items;
        var fromIndex;
        var toIndex;
        var heightBeforeFirstItem = 0;
        var heightBeforeLastItem = 0;

        if (vl.dynamicHeight) {
          var itemTop = 0;
          var itemHeight;
          vl.maxBufferHeight = vl.pageHeight;

          for (var j = 0; j < vl.heights.length; j += 1) {
            itemHeight = vl.heights[j];

            if (typeof fromIndex === 'undefined') {
              if (itemTop + itemHeight >= scrollTop - vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize) fromIndex = j;else heightBeforeFirstItem += itemHeight;
            }

            if (typeof toIndex === 'undefined') {
              if (itemTop + itemHeight >= scrollTop + vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize || j === vl.heights.length - 1) toIndex = j + 1;
              heightBeforeLastItem += itemHeight;
            }

            itemTop += itemHeight;
          }

          toIndex = Math.min(toIndex, items.length);
        } else {
          fromIndex = (parseInt(scrollTop / vl.params.height, 10) - vl.rowsBefore) * vl.params.cols;

          if (fromIndex < 0) {
            fromIndex = 0;
          }

          toIndex = Math.min(fromIndex + vl.rowsToRender * vl.params.cols, items.length);
        }

        var topPosition;
        var renderExternalItems = [];
        vl.reachEnd = false;
        var i;

        for (i = fromIndex; i < toIndex; i += 1) {
          var itemEl = void 0; // Define real item index

          var index = vl.items.indexOf(items[i]);
          if (i === fromIndex) vl.currentFromIndex = index;
          if (i === toIndex - 1) vl.currentToIndex = index;

          if (vl.filteredItems) {
            if (vl.items[index] === vl.filteredItems[vl.filteredItems.length - 1]) vl.reachEnd = true;
          } else if (index === vl.items.length - 1) vl.reachEnd = true; // Find items


          if (vl.params.renderExternal) {
            renderExternalItems.push(items[i]);
          } else if (vl.domCache[index]) {
            itemEl = vl.domCache[index];
            itemEl.f7VirtualListIndex = index;
          } else {
            if (vl.renderItem) {
              vl.tempDomElement.innerHTML = vl.renderItem(items[i], index).trim();
            } else {
              vl.tempDomElement.innerHTML = items[i].toString().trim();
            }

            itemEl = vl.tempDomElement.childNodes[0];
            if (vl.params.cache) vl.domCache[index] = itemEl;
            itemEl.f7VirtualListIndex = index;
          } // Set item top position


          if (i === fromIndex) {
            if (vl.dynamicHeight) {
              topPosition = heightBeforeFirstItem;
            } else {
              topPosition = i * vl.params.height / vl.params.cols;
            }
          }

          if (!vl.params.renderExternal) {
            itemEl.style.top = topPosition + "px"; // Before item insert

            vl.emit('local::itemBeforeInsert vlItemBeforeInsert', vl, itemEl, items[i]); // Append item to fragment

            vl.fragment.appendChild(itemEl);
          }
        } // Update list height with not updatable scroll


        if (!vl.updatableScroll) {
          if (vl.dynamicHeight) {
            vl.itemsWrapEl.style.height = heightBeforeLastItem + "px";
          } else {
            vl.itemsWrapEl.style.height = i * vl.params.height / vl.params.cols + "px";
          }
        } // Update list html


        if (vl.params.renderExternal) {
          if (items && items.length === 0) {
            vl.reachEnd = true;
          }
        } else {
          vl.emit('local::beforeClear vlBeforeClear', vl, vl.fragment);
          vl.itemsWrapEl.innerHTML = '';
          vl.emit('local::itemsBeforeInsert vlItemsBeforeInsert', vl, vl.fragment);

          if (items && items.length === 0) {
            vl.reachEnd = true;
            if (vl.params.emptyTemplate) vl.itemsWrapEl.innerHTML = vl.params.emptyTemplate;
          } else {
            vl.itemsWrapEl.appendChild(vl.fragment);
          }

          vl.emit('local::itemsAfterInsert vlItemsAfterInsert', vl, vl.fragment);
        }

        if (typeof forceScrollTop !== 'undefined' && force) {
          vl.$scrollableParentEl.scrollTop(forceScrollTop, 0);
        }

        if (vl.params.renderExternal) {
          vl.params.renderExternal(vl, {
            fromIndex: fromIndex,
            toIndex: toIndex,
            listHeight: vl.listHeight,
            topPosition: topPosition,
            items: renderExternalItems
          });
        }
      } // Filter
      ;

      _proto.filterItems = function filterItems(indexes, resetScrollTop) {
        if (resetScrollTop === void 0) {
          resetScrollTop = true;
        }

        var vl = this;
        vl.filteredItems = [];

        for (var i = 0; i < indexes.length; i += 1) {
          vl.filteredItems.push(vl.items[indexes[i]]);
        }

        if (resetScrollTop) {
          vl.$scrollableParentEl[0].scrollTop = 0;
        }

        vl.update();
      };

      _proto.resetFilter = function resetFilter() {
        var vl = this;

        if (vl.params.showFilteredItemsOnly) {
          vl.filteredItems = [];
        } else {
          vl.filteredItems = null;
          delete vl.filteredItems;
        }

        vl.update();
      };

      _proto.scrollToItem = function scrollToItem(index) {
        var vl = this;
        if (index > vl.items.length) return false;
        var itemTop = 0;

        if (vl.dynamicHeight) {
          for (var i = 0; i < index; i += 1) {
            itemTop += vl.heights[i];
          }
        } else {
          itemTop = index * vl.params.height;
        }

        var listTop = vl.$el[0].offsetTop;
        vl.render(true, listTop + itemTop - parseInt(vl.$scrollableParentEl.css('padding-top'), 10));
        return true;
      };

      _proto.handleScroll = function handleScroll() {
        var vl = this;
        vl.render();
      } // Handle resize event
      ;

      _proto.isVisible = function isVisible() {
        var vl = this;
        return !!(vl.el.offsetWidth || vl.el.offsetHeight || vl.el.getClientRects().length);
      };

      _proto.handleResize = function handleResize() {
        var vl = this;

        if (vl.isVisible()) {
          vl.setListSize();
          vl.render(true);
        }
      } // Append
      ;

      _proto.appendItems = function appendItems(items) {
        var vl = this;

        for (var i = 0; i < items.length; i += 1) {
          vl.items.push(items[i]);
        }

        vl.update();
      };

      _proto.appendItem = function appendItem(item) {
        var vl = this;
        vl.appendItems([item]);
      } // Replace
      ;

      _proto.replaceAllItems = function replaceAllItems(items) {
        var vl = this;
        vl.items = items;
        delete vl.filteredItems;
        vl.domCache = {};
        vl.update();
      };

      _proto.replaceItem = function replaceItem(index, item) {
        var vl = this;
        vl.items[index] = item;
        if (vl.params.cache) delete vl.domCache[index];
        vl.update();
      } // Prepend
      ;

      _proto.prependItems = function prependItems(items) {
        var vl = this;

        for (var i = items.length - 1; i >= 0; i -= 1) {
          vl.items.unshift(items[i]);
        }

        if (vl.params.cache) {
          var newCache = {};
          Object.keys(vl.domCache).forEach(function (cached) {
            newCache[parseInt(cached, 10) + items.length] = vl.domCache[cached];
          });
          vl.domCache = newCache;
        }

        vl.update();
      };

      _proto.prependItem = function prependItem(item) {
        var vl = this;
        vl.prependItems([item]);
      } // Move
      ;

      _proto.moveItem = function moveItem(from, to) {
        var vl = this;
        var fromIndex = from;
        var toIndex = to;
        if (fromIndex === toIndex) return; // remove item from array

        var item = vl.items.splice(fromIndex, 1)[0];

        if (toIndex >= vl.items.length) {
          // Add item to the end
          vl.items.push(item);
          toIndex = vl.items.length - 1;
        } else {
          // Add item to new index
          vl.items.splice(toIndex, 0, item);
        } // Update cache


        if (vl.params.cache) {
          var newCache = {};
          Object.keys(vl.domCache).forEach(function (cached) {
            var cachedIndex = parseInt(cached, 10);
            var leftIndex = fromIndex < toIndex ? fromIndex : toIndex;
            var rightIndex = fromIndex < toIndex ? toIndex : fromIndex;
            var indexShift = fromIndex < toIndex ? -1 : 1;
            if (cachedIndex < leftIndex || cachedIndex > rightIndex) newCache[cachedIndex] = vl.domCache[cachedIndex];
            if (cachedIndex === leftIndex) newCache[rightIndex] = vl.domCache[cachedIndex];
            if (cachedIndex > leftIndex && cachedIndex <= rightIndex) newCache[cachedIndex + indexShift] = vl.domCache[cachedIndex];
          });
          vl.domCache = newCache;
        }

        vl.update();
      } // Insert before
      ;

      _proto.insertItemBefore = function insertItemBefore(index, item) {
        var vl = this;

        if (index === 0) {
          vl.prependItem(item);
          return;
        }

        if (index >= vl.items.length) {
          vl.appendItem(item);
          return;
        }

        vl.items.splice(index, 0, item); // Update cache

        if (vl.params.cache) {
          var newCache = {};
          Object.keys(vl.domCache).forEach(function (cached) {
            var cachedIndex = parseInt(cached, 10);

            if (cachedIndex >= index) {
              newCache[cachedIndex + 1] = vl.domCache[cachedIndex];
            }
          });
          vl.domCache = newCache;
        }

        vl.update();
      } // Delete
      ;

      _proto.deleteItems = function deleteItems(indexes) {
        var vl = this;
        var prevIndex;
        var indexShift = 0;

        var _loop = function _loop(i) {
          var index = indexes[i];

          if (typeof prevIndex !== 'undefined') {
            if (index > prevIndex) {
              indexShift = -i;
            }
          }

          index += indexShift;
          prevIndex = indexes[i]; // Delete item

          var deletedItem = vl.items.splice(index, 1)[0]; // Delete from filtered

          if (vl.filteredItems && vl.filteredItems.indexOf(deletedItem) >= 0) {
            vl.filteredItems.splice(vl.filteredItems.indexOf(deletedItem), 1);
          } // Update cache


          if (vl.params.cache) {
            var newCache = {};
            Object.keys(vl.domCache).forEach(function (cached) {
              var cachedIndex = parseInt(cached, 10);

              if (cachedIndex === index) {
                delete vl.domCache[index];
              } else if (parseInt(cached, 10) > index) {
                newCache[cachedIndex - 1] = vl.domCache[cached];
              } else {
                newCache[cachedIndex] = vl.domCache[cached];
              }
            });
            vl.domCache = newCache;
          }
        };

        for (var i = 0; i < indexes.length; i += 1) {
          _loop(i);
        }

        vl.update();
      };

      _proto.deleteAllItems = function deleteAllItems() {
        var vl = this;
        vl.items = [];
        delete vl.filteredItems;
        if (vl.params.cache) vl.domCache = {};
        vl.update();
      };

      _proto.deleteItem = function deleteItem(index) {
        var vl = this;
        vl.deleteItems([index]);
      } // Clear cache
      ;

      _proto.clearCache = function clearCache() {
        var vl = this;
        vl.domCache = {};
      } // Update Virtual List
      ;

      _proto.update = function update(deleteCache) {
        var vl = this;

        if (deleteCache && vl.params.cache) {
          vl.domCache = {};
        }

        vl.setListSize();
        vl.render(true);
      };

      _proto.init = function init() {
        var vl = this;
        vl.attachEvents();
        vl.setListSize();
        vl.render();
      };

      _proto.destroy = function destroy() {
        var vl = this;
        vl.detachEvents();
        vl.$el[0].f7VirtualList = null;
        delete vl.$el[0].f7VirtualList;
        deleteProps$1(vl);
        vl = null;
      };

      return VirtualList;
    }(Framework7Class$1);

    var VirtualList$2 = VirtualList$1;

    var VirtualList = {
      name: 'virtualList',
      static: {
        VirtualList: VirtualList$2
      },
      create: function create() {
        var app = this;
        app.virtualList = ConstructorMethods({
          defaultSelector: '.virtual-list',
          constructor: VirtualList$2,
          app: app,
          domProp: 'f7VirtualList'
        });
      }
    };

    function _assertThisInitialized$i(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$i(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$i(subClass, superClass); }

    function _setPrototypeOf$i(o, p) { _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$i(o, p); }

    var ListIndex$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$i(ListIndex, _Framework7Class);

      function ListIndex(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params, [app]) || this;

        var index = _assertThisInitialized$i(_this);

        var defaults = {
          el: null,
          // where to render indexes
          listEl: null,
          // list el to generate indexes
          indexes: 'auto',
          // or array of indexes
          iosItemHeight: 14,
          mdItemHeight: 14,
          auroraItemHeight: 14,
          scrollList: true,
          label: false,
          // eslint-disable-next-line
          renderItem: function renderItem(itemContent, itemIndex) {
            return ("\n          <li>" + itemContent + "</li>\n        ").trim();
          },
          renderSkipPlaceholder: function renderSkipPlaceholder() {
            return '<li class="list-index-skip-placeholder"></li>';
          },
          on: {}
        }; // Extend defaults with modules params

        index.useModulesParams(defaults);
        index.params = extend$2(defaults, params);
        var $el;
        var $listEl;
        var $pageContentEl;
        var $ul;

        if (index.params.el) {
          $el = $(index.params.el);
        } else {
          return index || _assertThisInitialized$i(_this);
        }

        if ($el[0].f7ListIndex) {
          return $el[0].f7ListIndex || _assertThisInitialized$i(_this);
        }

        $ul = $el.find('ul');

        if ($ul.length === 0) {
          $ul = $('<ul></ul>');
          $el.append($ul);
        }

        if (index.params.listEl) {
          $listEl = $(index.params.listEl);
        }

        if (index.params.indexes === 'auto' && !$listEl) {
          return index || _assertThisInitialized$i(_this);
        }

        if ($listEl) {
          $pageContentEl = $listEl.parents('.page-content').eq(0);
        } else {
          $pageContentEl = $el.siblings('.page-content').eq(0);

          if ($pageContentEl.length === 0) {
            $pageContentEl = $el.parents('.page').eq(0).find('.page-content').eq(0);
          }
        }

        $el[0].f7ListIndex = index;
        extend$2(index, {
          app: app,
          $el: $el,
          el: $el && $el[0],
          $ul: $ul,
          ul: $ul && $ul[0],
          $listEl: $listEl,
          listEl: $listEl && $listEl[0],
          $pageContentEl: $pageContentEl,
          pageContentEl: $pageContentEl && $pageContentEl[0],
          indexes: params.indexes,
          height: 0,
          skipRate: 0
        }); // Install Modules

        index.useModules(); // Attach events

        function handleResize() {
          var height = {
            index: index
          };
          index.calcSize();

          if (height !== index.height) {
            index.render();
          }
        }

        function handleClick(e) {
          var $clickedLi = $(e.target).closest('li');
          if (!$clickedLi.length) return;
          var itemIndex = $clickedLi.index();

          if (index.skipRate > 0) {
            var percentage = itemIndex / ($clickedLi.siblings('li').length - 1);
            itemIndex = Math.round((index.indexes.length - 1) * percentage);
          }

          var itemContent = index.indexes[itemIndex];
          index.$el.trigger('listindex:click', {
            content: itemContent,
            index: itemIndex
          });
          index.emit('local::click listIndexClick', index, itemContent, itemIndex);
          index.$el.trigger('listindex:select', {
            content: itemContent,
            index: itemIndex
          });
          index.emit('local::select listIndexSelect', index, itemContent, itemIndex);

          if (index.$listEl && index.params.scrollList) {
            index.scrollListToIndex(itemContent, itemIndex);
          }
        }
        var isTouched;
        var isMoved;
        var topPoint;
        var bottomPoint;
        var $labelEl;
        var previousIndex = null;

        function handleTouchStart(e) {
          var $children = $ul.children();
          if (!$children.length) return;
          topPoint = $children[0].getBoundingClientRect().top;
          bottomPoint = $children[$children.length - 1].getBoundingClientRect().top + $children[0].offsetHeight;
          e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
          isTouched = true;
          isMoved = false;
          previousIndex = null;
        }

        function handleTouchMove(e) {
          if (!isTouched) return;

          if (!isMoved && index.params.label) {
            $labelEl = $('<span class="list-index-label"></span>');
            $el.append($labelEl);
          }

          isMoved = true;
          var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
          e.preventDefault();
          var percentage = (pageY - topPoint) / (bottomPoint - topPoint);
          percentage = Math.min(Math.max(percentage, 0), 1);
          var itemIndex = Math.round((index.indexes.length - 1) * percentage);
          var itemContent = index.indexes[itemIndex];
          var ulHeight = bottomPoint - topPoint;
          var bubbleBottom = (index.height - ulHeight) / 2 + (1 - percentage) * ulHeight;

          if (itemIndex !== previousIndex) {
            if (index.params.label) {
              $labelEl.html(itemContent).transform("translateY(-" + bubbleBottom + "px)");
            }

            if (index.$listEl && index.params.scrollList) {
              index.scrollListToIndex(itemContent, itemIndex);
            }
          }

          previousIndex = itemIndex;
          index.$el.trigger('listindex:select');
          index.emit('local::select listIndexSelect', index, itemContent, itemIndex);
        }

        function handleTouchEnd() {
          if (!isTouched) return;
          isTouched = false;
          isMoved = false;

          if (index.params.label) {
            if ($labelEl) $labelEl.remove();
            $labelEl = undefined;
          }
        }

        var passiveListener = getSupport$1().passiveListener ? {
          passive: true
        } : false;

        index.attachEvents = function attachEvents() {
          $el.parents('.tab').on('tab:show', handleResize);
          $el.parents('.page').on('page:reinit', handleResize);
          $el.parents('.panel').on('panel:open', handleResize);
          $el.parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast').on('modal:open', handleResize);
          app.on('resize', handleResize);
          $el.on('click', handleClick);
          $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
          app.on('touchmove:active', handleTouchMove);
          app.on('touchend:passive', handleTouchEnd);
        };

        index.detachEvents = function attachEvents() {
          $el.parents('.tab').off('tab:show', handleResize);
          $el.parents('.page').off('page:reinit', handleResize);
          $el.parents('.panel').off('panel:open', handleResize);
          $el.parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast').off('modal:open', handleResize);
          app.off('resize', handleResize);
          $el.off('click', handleClick);
          $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
          app.off('touchmove:active', handleTouchMove);
          app.off('touchend:passive', handleTouchEnd);
        }; // Init


        index.init();
        return index || _assertThisInitialized$i(_this);
      } // eslint-disable-next-line


      var _proto = ListIndex.prototype;

      _proto.scrollListToIndex = function scrollListToIndex(itemContent, itemIndex) {
        var index = this;
        var $listEl = index.$listEl,
            $pageContentEl = index.$pageContentEl,
            app = index.app;
        if (!$listEl || !$pageContentEl || $pageContentEl.length === 0) return index;
        var $scrollToEl;
        $listEl.find('.list-group-title, .item-divider').each(function (el) {
          if ($scrollToEl) return;
          var $el = $(el);

          if ($el.text() === itemContent) {
            $scrollToEl = $el;
          }
        });
        if (!$scrollToEl || $scrollToEl.length === 0) return index;
        var parentTop = $scrollToEl.parent().offset().top;
        var paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
        var scrollTop = $pageContentEl[0].scrollTop;
        var scrollToElTop = $scrollToEl.offset().top;

        if ($pageContentEl.parents('.page-with-navbar-large').length) {
          var navbarInnerEl = app.navbar.getElByPage($pageContentEl.parents('.page-with-navbar-large').eq(0));
          var $titleLargeEl = $(navbarInnerEl).find('.title-large');

          if ($titleLargeEl.length) {
            paddingTop -= $titleLargeEl[0].offsetHeight || 0;
          }
        }

        if (parentTop <= paddingTop) {
          $pageContentEl.scrollTop(parentTop + scrollTop - paddingTop);
        } else {
          $pageContentEl.scrollTop(scrollToElTop + scrollTop - paddingTop);
        }

        return index;
      };

      _proto.renderSkipPlaceholder = function renderSkipPlaceholder() {
        var index = this;
        return index.params.renderSkipPlaceholder.call(index);
      };

      _proto.renderItem = function renderItem(itemContent, itemIndex) {
        var index = this;
        return index.params.renderItem.call(index, itemContent, itemIndex);
      };

      _proto.render = function render() {
        var index = this;
        var $ul = index.$ul,
            indexes = index.indexes,
            skipRate = index.skipRate;
        var wasSkipped;
        var html = indexes.map(function (itemContent, itemIndex) {
          if (itemIndex % skipRate !== 0 && skipRate > 0) {
            wasSkipped = true;
            return '';
          }

          var itemHtml = index.renderItem(itemContent, itemIndex);

          if (wasSkipped) {
            itemHtml = index.renderSkipPlaceholder() + itemHtml;
          }

          wasSkipped = false;
          return itemHtml;
        }).join('');
        $ul.html(html);
        return index;
      };

      _proto.calcSize = function calcSize() {
        var index = this;
        var app = index.app,
            params = index.params,
            el = index.el,
            indexes = index.indexes;
        var height = el.offsetHeight;
        var itemHeight = params[app.theme + "ItemHeight"];
        var maxItems = Math.floor(height / itemHeight);
        var items = indexes.length;
        var skipRate = 0;

        if (items > maxItems) {
          skipRate = Math.ceil((items * 2 - 1) / maxItems);
        }

        index.height = height;
        index.skipRate = skipRate;
        return index;
      };

      _proto.calcIndexes = function calcIndexes() {
        var index = this;

        if (index.params.indexes === 'auto') {
          index.indexes = [];
          index.$listEl.find('.list-group-title, .item-divider').each(function (el) {
            var elContent = $(el).text();

            if (index.indexes.indexOf(elContent) < 0) {
              index.indexes.push(elContent);
            }
          });
        } else {
          index.indexes = index.params.indexes;
        }

        return index;
      };

      _proto.update = function update() {
        var index = this;
        index.calcIndexes();
        index.calcSize();
        index.render();
        return index;
      };

      _proto.init = function init() {
        var index = this;
        index.calcIndexes();
        index.calcSize();
        index.render();
        index.attachEvents();
      };

      _proto.destroy = function destroy() {
        var index = this;
        index.$el.trigger('listindex:beforedestroy', index);
        index.emit('local::beforeDestroy listIndexBeforeDestroy');
        index.detachEvents();

        if (index.$el[0]) {
          index.$el[0].f7ListIndex = null;
          delete index.$el[0].f7ListIndex;
        }

        deleteProps$1(index);
        index = null;
      };

      return ListIndex;
    }(Framework7Class$1);

    var ListIndex$2 = ListIndex$1;

    var ListIndex = {
      name: 'listIndex',
      static: {
        ListIndex: ListIndex$2
      },
      create: function create() {
        var app = this;
        app.listIndex = ConstructorMethods({
          defaultSelector: '.list-index',
          constructor: ListIndex$2,
          app: app,
          domProp: 'f7ListIndex'
        });
      },
      on: {
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.list-index-init').each(function (listIndexEl) {
            var params = extend$2($(listIndexEl).dataset(), {
              el: listIndexEl
            });
            app.listIndex.create(params);
          });
        },
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          $(tabEl).find('.list-index-init').each(function (listIndexEl) {
            if (listIndexEl.f7ListIndex) listIndexEl.f7ListIndex.destroy();
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.list-index-init').each(function (listIndexEl) {
            var params = extend$2($(listIndexEl).dataset(), {
              el: listIndexEl
            });
            app.listIndex.create(params);
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          page.$el.find('.list-index-init').each(function (listIndexEl) {
            if (listIndexEl.f7ListIndex) listIndexEl.f7ListIndex.destroy();
          });
        }
      },
      vnode: {
        'list-index-init': {
          insert: function insert(vnode) {
            var app = this;
            var listIndexEl = vnode.elm;
            var params = extend$2($(listIndexEl).dataset(), {
              el: listIndexEl
            });
            app.listIndex.create(params);
          },
          destroy: function destroy(vnode) {
            var listIndexEl = vnode.elm;
            if (listIndexEl.f7ListIndex) listIndexEl.f7ListIndex.destroy();
          }
        }
      }
    };

    var Timeline = {
      name: 'timeline'
    };

    var Tab = {
      show: function show() {
        var app = this;
        var tabEl;
        var tabLinkEl;
        var animate;
        var tabRoute;
        var animatedInit;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 1 && args[0] && args[0].constructor === Object) {
          tabEl = args[0].tabEl;
          tabLinkEl = args[0].tabLinkEl;
          animate = args[0].animate;
          tabRoute = args[0].tabRoute;
          animatedInit = args[0].animatedInit;
        } else {
          tabEl = args[0];
          tabLinkEl = args[1];
          animate = args[2];
          tabRoute = args[3];

          if (typeof args[1] === 'boolean') {
            tabEl = args[0];
            animate = args[1];
            tabLinkEl = args[2];
            tabRoute = args[3];

            if (args.length > 2 && tabLinkEl.constructor === Object) {
              tabEl = args[0];
              animate = args[1];
              tabRoute = args[2];
              tabLinkEl = args[3];
            }
          }
        }

        if (typeof animate === 'undefined') animate = true;
        var $newTabEl = $(tabEl);

        if (tabRoute && $newTabEl[0]) {
          $newTabEl[0].f7TabRoute = tabRoute;
        }

        if (!animatedInit && ($newTabEl.length === 0 || $newTabEl.hasClass('tab-active'))) {
          return {
            $newTabEl: $newTabEl,
            newTabEl: $newTabEl[0]
          };
        }

        var $tabLinkEl;
        if (tabLinkEl) $tabLinkEl = $(tabLinkEl);
        var $tabsEl = $newTabEl.parent('.tabs');

        if ($tabsEl.length === 0) {
          return {
            $newTabEl: $newTabEl,
            newTabEl: $newTabEl[0]
          };
        } // Release swipeouts in hidden tabs


        if (app.swipeout) app.swipeout.allowOpen = true; // Animated tabs

        var tabsChangedCallbacks = [];

        function onTabsChanged(callback) {
          tabsChangedCallbacks.push(callback);
        }

        function tabsChanged() {
          tabsChangedCallbacks.forEach(function (callback) {
            callback();
          });
        }

        var animated = false;

        if ($tabsEl.parent().hasClass('tabs-animated-wrap')) {
          $tabsEl.parent()[animate ? 'removeClass' : 'addClass']('not-animated');
          var transitionDuration = parseFloat($tabsEl.css('transition-duration').replace(',', '.'));

          if (animate && transitionDuration) {
            $tabsEl.transitionEnd(tabsChanged);
            animated = true;
          }

          var tabsTranslate = (app.rtl ? $newTabEl.index() : -$newTabEl.index()) * 100;
          $tabsEl.transform("translate3d(" + tabsTranslate + "%,0,0)");
        } // Swipeable tabs


        var swiper;

        if ($tabsEl.parent().hasClass('tabs-swipeable-wrap') && app.swiper) {
          swiper = $tabsEl.parent()[0].swiper;

          if (swiper && swiper.activeIndex !== $newTabEl.index()) {
            animated = true;
            swiper.once('slideChangeTransitionEnd', function () {
              tabsChanged();
            }).slideTo($newTabEl.index(), animate ? undefined : 0);
          } else if (swiper && swiper.animating) {
            animated = true;
            swiper.once('slideChangeTransitionEnd', function () {
              tabsChanged();
            });
          }
        } // Remove active class from old tabs


        var $oldTabEl = $tabsEl.children('.tab-active');
        $oldTabEl.removeClass('tab-active');

        if (!animatedInit && (!swiper || swiper && !swiper.animating || swiper && tabRoute)) {
          if ($oldTabEl.hasClass('view') && $oldTabEl.children('.page').length) {
            $oldTabEl.children('.page').each(function (pageEl) {
              $(pageEl).trigger('page:tabhide');
              app.emit('pageTabHide', pageEl);
            });
          }

          $oldTabEl.trigger('tab:hide');
          app.emit('tabHide', $oldTabEl[0]);
        } // Trigger 'show' event on new tab


        $newTabEl.addClass('tab-active');

        if (!animatedInit && (!swiper || swiper && !swiper.animating || swiper && tabRoute)) {
          if ($newTabEl.hasClass('view') && $newTabEl.children('.page').length) {
            $newTabEl.children('.page').each(function (pageEl) {
              $(pageEl).trigger('page:tabshow');
              app.emit('pageTabShow', pageEl);
            });
          }

          $newTabEl.trigger('tab:show');
          app.emit('tabShow', $newTabEl[0]);
        } // Find related link for new tab


        if (!$tabLinkEl) {
          // Search by id
          if (typeof tabEl === 'string') $tabLinkEl = $(".tab-link[href=\"" + tabEl + "\"]");else $tabLinkEl = $(".tab-link[href=\"#" + $newTabEl.attr('id') + "\"]"); // Search by data-tab

          if (!$tabLinkEl || $tabLinkEl && $tabLinkEl.length === 0) {
            $('[data-tab]').each(function (el) {
              if ($newTabEl.is($(el).attr('data-tab'))) $tabLinkEl = $(el);
            });
          }

          if (tabRoute && (!$tabLinkEl || $tabLinkEl && $tabLinkEl.length === 0)) {
            $tabLinkEl = $("[data-route-tab-id=\"" + tabRoute.route.tab.id + "\"]");

            if ($tabLinkEl.length === 0) {
              $tabLinkEl = $(".tab-link[href=\"" + tabRoute.url + "\"]");
            }
          }

          if ($tabLinkEl.length > 1 && $newTabEl.parents('.page').length) {
            // eslint-disable-next-line
            $tabLinkEl = $tabLinkEl.filter(function (tabLinkElement) {
              return $(tabLinkElement).parents('.page')[0] === $newTabEl.parents('.page')[0];
            });

            if (app.theme === 'ios' && $tabLinkEl.length === 0 && tabRoute) {
              var $pageEl = $newTabEl.parents('.page');
              var $navbarEl = $(app.navbar.getElByPage($pageEl));
              $tabLinkEl = $navbarEl.find("[data-route-tab-id=\"" + tabRoute.route.tab.id + "\"]");

              if ($tabLinkEl.length === 0) {
                $tabLinkEl = $navbarEl.find(".tab-link[href=\"" + tabRoute.url + "\"]");
              }
            }
          }
        }

        if ($tabLinkEl.length > 0) {
          // Find related link for old tab
          var $oldTabLinkEl;

          if ($oldTabEl && $oldTabEl.length > 0) {
            // Search by id
            var oldTabId = $oldTabEl.attr('id');

            if (oldTabId) {
              $oldTabLinkEl = $(".tab-link[href=\"#" + oldTabId + "\"]"); // Search by data-route-tab-id

              if (!$oldTabLinkEl || $oldTabLinkEl && $oldTabLinkEl.length === 0) {
                $oldTabLinkEl = $(".tab-link[data-route-tab-id=\"" + oldTabId + "\"]");
              }
            } // Search by data-tab


            if (!$oldTabLinkEl || $oldTabLinkEl && $oldTabLinkEl.length === 0) {
              $('[data-tab]').each(function (tabLinkElement) {
                if ($oldTabEl.is($(tabLinkElement).attr('data-tab'))) $oldTabLinkEl = $(tabLinkElement);
              });
            }

            if (!$oldTabLinkEl || $oldTabLinkEl && $oldTabLinkEl.length === 0) {
              $oldTabLinkEl = $tabLinkEl.siblings('.tab-link-active');
            }
          } else if (tabRoute) {
            $oldTabLinkEl = $tabLinkEl.siblings('.tab-link-active');
          }

          if ($oldTabLinkEl && $oldTabLinkEl.length > 1 && $oldTabEl && $oldTabEl.parents('.page').length) {
            // eslint-disable-next-line
            $oldTabLinkEl = $oldTabLinkEl.filter(function (tabLinkElement) {
              return $(tabLinkElement).parents('.page')[0] === $oldTabEl.parents('.page')[0];
            });
          }

          if ($oldTabLinkEl && $oldTabLinkEl.length > 0) $oldTabLinkEl.removeClass('tab-link-active'); // Update links' classes

          if ($tabLinkEl && $tabLinkEl.length > 0) {
            $tabLinkEl.addClass('tab-link-active'); // Material Highlight

            if (app.theme !== 'ios' && app.toolbar) {
              var $tabbarEl = $tabLinkEl.parents('.tabbar, .tabbar-labels');

              if ($tabbarEl.length > 0) {
                app.toolbar.setHighlight($tabbarEl);
              }
            }
          }
        }

        return {
          $newTabEl: $newTabEl,
          newTabEl: $newTabEl[0],
          $oldTabEl: $oldTabEl,
          oldTabEl: $oldTabEl[0],
          onTabsChanged: onTabsChanged,
          animated: animated
        };
      }
    };
    var Tabs = {
      name: 'tabs',
      create: function create() {
        var app = this;
        extend$2(app, {
          tab: {
            show: Tab.show.bind(app)
          }
        });
      },
      on: {
        'pageInit tabMounted': function onInit(pageOrTabEl) {
          var $el = $(pageOrTabEl.el || pageOrTabEl);
          var animatedTabEl = $el.find('.tabs-animated-wrap > .tabs > .tab-active')[0];
          if (!animatedTabEl) return;
          var app = this;
          app.tab.show({
            tabEl: animatedTabEl,
            animatedInit: true,
            animate: false
          });
        }
      },
      clicks: {
        '.tab-link': function tabLinkClick($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          if ($clickedEl.attr('href') && $clickedEl.attr('href').indexOf('#') === 0 || $clickedEl.attr('data-tab')) {
            var app = this;
            app.tab.show({
              tabEl: data.tab || $clickedEl.attr('href'),
              tabLinkEl: $clickedEl,
              animate: data.animate
            });
          }
        }
      }
    };

    function swipePanel(panel) {
      var app = panel.app;

      if (panel.swipeInitialized) {
        return;
      }

      extend$2(panel, {
        swipeable: true,
        swipeInitialized: true
      });
      var params = panel.params;
      var $el = panel.$el,
          $backdropEl = panel.$backdropEl,
          side = panel.side,
          effect = panel.effect;
      var otherPanel;
      var isTouched;
      var isGestureStarted;
      var isMoved;
      var isScrolling;
      var isInterrupted;
      var touchesStart = {};
      var touchStartTime;
      var touchesDiff;
      var translate;
      var backdropOpacity;
      var panelWidth;
      var direction;
      var $viewEl;
      var touchMoves = 0;

      function handleTouchStart(e) {
        if (!panel.swipeable || isGestureStarted) return;
        if (!app.panel.allowOpen || !params.swipe && !params.swipeOnlyClose || isTouched) return;
        if ($('.modal-in:not(.toast):not(.notification), .photo-browser-in').length > 0) return;
        otherPanel = app.panel.get(side === 'left' ? 'right' : 'left') || {};
        var otherPanelOpened = otherPanel.opened && otherPanel.$el && !otherPanel.$el.hasClass('panel-in-breakpoint');

        if (!panel.opened && otherPanelOpened) {
          return;
        }

        if (!params.swipeOnlyClose) {
          if (otherPanelOpened) return;
        }

        if (e.target && e.target.nodeName.toLowerCase() === 'input' && e.target.type === 'range') return;
        if ($(e.target).closest('.range-slider, .tabs-swipeable-wrap, .calendar-months, .no-swipe-panel, .card-opened').length > 0) return;
        touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;

        if (params.swipeOnlyClose && !panel.opened) {
          return;
        }

        if (params.swipeActiveArea && !panel.opened) {
          if (side === 'left') {
            if (touchesStart.x > params.swipeActiveArea) return;
          }

          if (side === 'right') {
            if (touchesStart.x < app.width - params.swipeActiveArea) return;
          }
        }

        touchMoves = 0;
        $viewEl = $(panel.getViewEl());
        isMoved = false;
        isTouched = true;
        isScrolling = undefined;
        isInterrupted = false;
        touchStartTime = now$2();
        direction = undefined;
      }

      function handleTouchMove(e) {
        if (!isTouched || isGestureStarted || isInterrupted) return;
        touchMoves += 1;
        if (touchMoves < 2) return;

        if (e.f7PreventSwipePanel || app.preventSwipePanelBySwipeBack || app.preventSwipePanel) {
          isTouched = false;
          return;
        }

        var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
        }

        if (isScrolling) {
          isTouched = false;
          return;
        }

        if (!direction) {
          if (pageX > touchesStart.x) {
            direction = 'to-right';
          } else {
            direction = 'to-left';
          }

          if (params.swipeActiveArea > 0 && !panel.opened) {
            if (side === 'left' && touchesStart.x > params.swipeActiveArea) {
              isTouched = false;
              return;
            }

            if (side === 'right' && touchesStart.x < app.width - params.swipeActiveArea) {
              isTouched = false;
              return;
            }
          }

          if ($el.hasClass('panel-in-breakpoint')) {
            isTouched = false;
            return;
          }

          if (side === 'left' && direction === 'to-left' && !$el.hasClass('panel-in') || side === 'right' && direction === 'to-right' && !$el.hasClass('panel-in')) {
            isTouched = false;
            return;
          }
        }

        var threshold = panel.opened ? 0 : -params.swipeThreshold;
        if (side === 'right') threshold = -threshold;

        if (!isMoved) {
          if (!panel.opened) {
            panel.insertToRoot();
            $el.addClass('panel-in-swipe');
            $backdropEl.css('visibility', 'visible');
            $el.trigger('panel:swipeopen');
            panel.emit('local::swipeOpen panelSwipeOpen', panel);
          }

          panelWidth = $el[0].offsetWidth;

          if (effect === 'reveal' && $el.hasClass('panel-in-collapsed')) {
            panelWidth -= parseFloat($viewEl.css("margin-" + side));
          }

          $el.transition(0);
        }

        isMoved = true;

        if (e.cancelable) {
          e.preventDefault();
        }

        touchesDiff = pageX - touchesStart.x + threshold;

        if (side === 'right') {
          if (effect === 'cover' || effect === 'push') {
            translate = touchesDiff + (panel.opened ? 0 : panelWidth);
            if (translate < 0) translate = 0;

            if (translate > panelWidth) {
              translate = panelWidth;
            }
          } else {
            translate = touchesDiff - (panel.opened ? panelWidth : 0);
            if (translate > 0) translate = 0;

            if (translate < -panelWidth) {
              translate = -panelWidth;
            }
          }
        } else {
          translate = touchesDiff + (panel.opened ? panelWidth : 0);
          if (translate < 0) translate = 0;

          if (translate > panelWidth) {
            translate = panelWidth;
          }
        }

        var noFollowProgress = Math.abs(translate / panelWidth);

        if (effect === 'reveal') {
          if (!params.swipeNoFollow) {
            $viewEl.transform("translate3d(" + translate + "px,0,0)").transition(0);
            $backdropEl.transform("translate3d(" + translate + "px,0,0)").transition(0);
          }

          $el.trigger('panel:swipe', Math.abs(translate / panelWidth));
          panel.emit('local::swipe panelSwipe', panel, Math.abs(translate / panelWidth));
        } else {
          if (side === 'left') translate -= panelWidth;

          if (!params.swipeNoFollow) {
            $backdropEl.transition(0);
            backdropOpacity = 1 - Math.abs(translate / panelWidth);
            $backdropEl.css({
              opacity: backdropOpacity
            });
            $el.transform("translate3d(" + translate + "px,0,0)").transition(0);

            if (effect === 'push') {
              var viewTranslate = side === 'left' ? translate + panelWidth : translate - panelWidth;
              $viewEl.transform("translate3d(" + viewTranslate + "px,0,0)").transition(0);
              $backdropEl.transform("translate3d(" + viewTranslate + "px,0,0)").transition(0);
            }
          }

          $el.trigger('panel:swipe', Math.abs(translate / panelWidth));
          panel.emit('local::swipe panelSwipe', panel, Math.abs(translate / panelWidth));
        }

        if (params.swipeNoFollow) {
          var stateChanged = panel.opened && noFollowProgress === 0 || !panel.opened && noFollowProgress === 1;

          if (stateChanged) {
            isInterrupted = true; // eslint-disable-next-line

            handleTouchEnd(e);
          }
        }
      }

      function handleTouchEnd(e) {
        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }

        var isGesture = e.type === 'gesturestart' || isGestureStarted;
        isTouched = false;
        isMoved = false;
        var timeDiff = new Date().getTime() - touchStartTime;
        var action;
        var edge = (translate === 0 || Math.abs(translate) === panelWidth) && !params.swipeNoFollow;
        var threshold = params.swipeThreshold || 0;

        if (isGesture) {
          action = 'reset';
        } else if (!panel.opened) {
          if (Math.abs(touchesDiff) < threshold) {
            action = 'reset';
          } else if (effect === 'cover' || effect === 'push') {
            if (translate === 0) {
              action = 'swap'; // open
            } else if (timeDiff < 300 && Math.abs(translate) > 0) {
              action = 'swap'; // open
            } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
              action = 'swap'; // open
            } else {
              action = 'reset'; // close
            }
          } else if (translate === 0) {
            action = 'reset';
          } else if (timeDiff < 300 && Math.abs(translate) > 0 || timeDiff >= 300 && Math.abs(translate) >= panelWidth / 2) {
            action = 'swap';
          } else {
            action = 'reset';
          }
        } else if (effect === 'cover' || effect === 'push') {
          if (translate === 0) {
            action = 'reset'; // open
          } else if (timeDiff < 300 && Math.abs(translate) > 0) {
            action = 'swap'; // open
          } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
            action = 'reset'; // open
          } else {
            action = 'swap'; // close
          }
        } else if (translate === -panelWidth) {
          action = 'reset';
        } else if (timeDiff < 300 && Math.abs(translate) >= 0 || timeDiff >= 300 && Math.abs(translate) <= panelWidth / 2) {
          if (side === 'left' && translate === panelWidth) action = 'reset';else action = 'swap';
        } else {
          action = 'reset';
        }

        if (action === 'swap') {
          if (panel.opened) {
            panel.close(!edge);
          } else {
            panel.open(!edge);
          }
        }

        var removePanelInClass = true;

        if (action === 'reset') {
          if (!panel.opened) {
            if (edge) {
              // edge position
              $el.removeClass('panel-in-swipe');
            } else {
              removePanelInClass = false;
              var target = effect === 'reveal' ? $viewEl : $el;
              panel.setStateClasses('before-closing');
              target.transitionEnd(function () {
                if ($el.hasClass('panel-in')) return;
                $el.removeClass('panel-in-swipe');
                panel.setStateClasses('after-closing');
              });
            }
          }
        }

        if (effect === 'reveal' || effect === 'push') {
          nextFrame(function () {
            $viewEl.transition('');
            $viewEl.transform('');
          });
        }

        if (removePanelInClass) {
          $el.removeClass('panel-in-swipe');
        }

        $el.transition('').transform('');
        $backdropEl.transform('').transition('').css({
          opacity: '',
          visibility: ''
        });
      }

      function handleGestureStart(e) {
        isGestureStarted = true;
        handleTouchEnd(e);
      }

      function handleGestureEnd() {
        isGestureStarted = false;
      } // Add Events


      app.on('touchstart:passive', handleTouchStart);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      app.on('gesturestart', handleGestureStart);
      app.on('gestureend', handleGestureEnd);
      panel.on('panelDestroy', function () {
        app.off('touchstart:passive', handleTouchStart);
        app.off('touchmove:active', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
        app.off('gesturestart', handleGestureStart);
        app.off('gestureend', handleGestureEnd);
      });
    }

    function resizablePanel(panel) {
      var app = panel.app;
      var support = getSupport$1();
      if (panel.resizableInitialized) return;
      extend$2(panel, {
        resizable: true,
        resizableWidth: null,
        resizableInitialized: true
      });
      var $htmlEl = $('html');
      var $el = panel.$el,
          $backdropEl = panel.$backdropEl,
          side = panel.side,
          effect = panel.effect;
      if (!$el) return;
      var isTouched;
      var isMoved;
      var touchesStart = {};
      var touchesDiff;
      var panelWidth;
      var $viewEl;
      var panelMinWidth;
      var panelMaxWidth;
      var visibleByBreakpoint;

      function transformCSSWidth(v) {
        if (!v) return null;

        if (v.indexOf('%') >= 0 || v.indexOf('vw') >= 0) {
          return parseInt(v, 10) / 100 * app.width;
        }

        var newV = parseInt(v, 10);
        if (Number.isNaN(newV)) return null;
        return newV;
      }

      function isResizable() {
        return panel.resizable && $el.hasClass('panel-resizable');
      }

      function handleTouchStart(e) {
        if (!isResizable()) return;
        touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        isMoved = false;
        isTouched = true;
        panelMinWidth = transformCSSWidth($el.css('min-width'));
        panelMaxWidth = transformCSSWidth($el.css('max-width'));
        visibleByBreakpoint = $el.hasClass('panel-in-breakpoint');
      }

      function handleTouchMove(e) {
        if (!isTouched) return;
        var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;

        if (!isMoved) {
          panelWidth = $el[0].offsetWidth;
          $el.transition(0);
          $el.addClass('panel-resizing');
          $htmlEl.css('cursor', 'col-resize');

          if (effect !== 'cover' || visibleByBreakpoint) {
            $viewEl = $(panel.getViewEl());

            if (panel.$containerEl && panel.$containerEl.hasClass('page')) {
              $viewEl.add(panel.$containerEl.children('.page-content, .tabs, .fab'));
            }
          }

          if (effect !== 'cover' && !visibleByBreakpoint) {
            $backdropEl.transition(0);
            $viewEl.transition(0);
          }
        }

        isMoved = true;
        e.preventDefault();
        touchesDiff = pageX - touchesStart.x;
        var newPanelWidth = side === 'left' ? panelWidth + touchesDiff : panelWidth - touchesDiff;

        if (panelMinWidth && !Number.isNaN(panelMinWidth)) {
          newPanelWidth = Math.max(newPanelWidth, panelMinWidth);
        }

        if (panelMaxWidth && !Number.isNaN(panelMaxWidth)) {
          newPanelWidth = Math.min(newPanelWidth, panelMaxWidth);
        }

        newPanelWidth = Math.min(Math.max(newPanelWidth, 0), app.width);
        panel.resizableWidth = newPanelWidth;
        $el[0].style.width = newPanelWidth + "px";

        if (effect !== 'cover' && !visibleByBreakpoint) {
          if ($viewEl) {
            $viewEl.transform("translate3d(" + (side === 'left' ? newPanelWidth : -newPanelWidth) + "px, 0, 0)");
          }

          if ($backdropEl) {
            $backdropEl.transform("translate3d(" + (side === 'left' ? newPanelWidth : -newPanelWidth) + "px, 0, 0)");
          }
        } else if (visibleByBreakpoint && $viewEl) {
          $viewEl.css("margin-" + side, newPanelWidth + "px");
        }

        $el.trigger('panel:resize', newPanelWidth);
        panel.emit('local::resize panelResize', panel, newPanelWidth);
      }

      function handleTouchEnd() {
        $('html').css('cursor', '');

        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }

        isTouched = false;
        isMoved = false;
        $htmlEl[0].style.setProperty("--f7-panel-" + side + "-width", panel.resizableWidth + "px");
        $el[0].style.width = '';

        if (effect !== 'cover' && !visibleByBreakpoint) {
          $viewEl.transform('');
          $backdropEl.transform('');
        }

        $el.removeClass('panel-resizing');
        nextFrame(function () {
          $el.transition('');

          if (effect !== 'cover') {
            $backdropEl.transition('');
            if ($viewEl) $viewEl.transition('');
          }
        });
      }

      function handleResize() {
        if (!panel.opened || !panel.resizableWidth) return;
        panelMinWidth = transformCSSWidth($el.css('min-width'));
        panelMaxWidth = transformCSSWidth($el.css('max-width'));

        if (panelMinWidth && !Number.isNaN(panelMinWidth) && panel.resizableWidth < panelMinWidth) {
          panel.resizableWidth = Math.max(panel.resizableWidth, panelMinWidth);
        }

        if (panelMaxWidth && !Number.isNaN(panelMaxWidth) && panel.resizableWidth > panelMaxWidth) {
          panel.resizableWidth = Math.min(panel.resizableWidth, panelMaxWidth);
        }

        panel.resizableWidth = Math.min(Math.max(panel.resizableWidth, 0), app.width);
        $htmlEl[0].style.setProperty("--f7-panel-" + side + "-width", panel.resizableWidth + "px");
      }

      if (panel.$el.find('.panel-resize-handler').length === 0) {
        panel.$el.append('<div class="panel-resize-handler"></div>');
      }

      panel.$resizeHandlerEl = panel.$el.children('.panel-resize-handler');
      $el.addClass('panel-resizable'); // Add Events

      var passive = support.passiveListener ? {
        passive: true
      } : false;
      panel.$el.on(app.touchEvents.start, '.panel-resize-handler', handleTouchStart, passive);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      app.on('resize', handleResize);
      panel.on('beforeOpen', handleResize);
      panel.once('panelDestroy', function () {
        $el.removeClass('panel-resizable');
        panel.$resizeHandlerEl.remove();
        panel.$el.off(app.touchEvents.start, '.panel-resize-handler', handleTouchStart, passive);
        app.off('touchmove:active', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
        app.off('resize', handleResize);
        panel.off('beforeOpen', handleResize);
      });
    }

    function _assertThisInitialized$h(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$h(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$h(subClass, superClass); }

    function _setPrototypeOf$h(o, p) { _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$h(o, p); }

    var Panel$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$h(Panel, _Framework7Class);

      function Panel(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        var extendedParams = extend$2({
          on: {}
        }, app.params.panel, params);
        _this = _Framework7Class.call(this, extendedParams, [app]) || this;

        var panel = _assertThisInitialized$h(_this);

        panel.params = extendedParams;
        panel.$containerEl = panel.params.containerEl ? $(panel.params.containerEl).eq(0) : app.$el;
        panel.containerEl = panel.$containerEl[0];

        if (!panel.containerEl) {
          panel.$containerEl = app.$el;
          panel.containerEl = app.$el[0];
        }

        var $el;

        if (panel.params.el) {
          $el = $(panel.params.el).eq(0);
        } else if (panel.params.content) {
          $el = $(panel.params.content).filter(function (node) {
            return node.nodeType === 1;
          }).eq(0);
        }

        if ($el.length === 0) return panel || _assertThisInitialized$h(_this);
        if ($el[0].f7Panel) return $el[0].f7Panel || _assertThisInitialized$h(_this);
        $el[0].f7Panel = panel;
        var _panel$params = panel.params,
            side = _panel$params.side,
            effect = _panel$params.effect,
            resizable = _panel$params.resizable;
        if (typeof side === 'undefined') side = $el.hasClass('panel-left') ? 'left' : 'right';
        if (typeof effect === 'undefined') // eslint-disable-next-line
          effect = $el.hasClass('panel-cover') ? 'cover' : $el.hasClass('panel-push') ? 'push' : 'reveal';
        if (typeof resizable === 'undefined') resizable = $el.hasClass('panel-resizable');
        var $backdropEl;

        if (panel.params.backdrop && panel.params.backdropEl) {
          $backdropEl = $(panel.params.backdropEl);
        } else if (panel.params.backdrop) {
          $backdropEl = panel.$containerEl.children('.panel-backdrop');

          if ($backdropEl.length === 0) {
            $backdropEl = $('<div class="panel-backdrop"></div>');
            panel.$containerEl.prepend($backdropEl);
          }
        }

        extend$2(panel, {
          app: app,
          side: side,
          effect: effect,
          resizable: resizable,
          $el: $el,
          el: $el[0],
          opened: false,
          $backdropEl: $backdropEl,
          backdropEl: $backdropEl && $backdropEl[0]
        }); // Install Modules

        panel.useModules(); // Init

        panel.init();
        return panel || _assertThisInitialized$h(_this);
      }

      var _proto = Panel.prototype;

      _proto.getViewEl = function getViewEl() {
        var panel = this;
        var viewEl;

        if (panel.$containerEl.children('.views').length > 0) {
          viewEl = panel.$containerEl.children('.views')[0];
        } else {
          viewEl = panel.$containerEl.children('.view')[0];
        }

        return viewEl;
      };

      _proto.setStateClasses = function setStateClasses(state) {
        var panel = this;
        var side = panel.side,
            el = panel.el;
        var viewEl = panel.getViewEl();
        var panelInView = viewEl && viewEl.contains(el);
        var $targetEl = !viewEl || panelInView ? panel.$containerEl : $('html');

        if (state === 'open') {
          $targetEl.addClass("with-panel with-panel-" + panel.side + "-" + panel.effect);
        }

        if (state === 'before-closing') {
          $targetEl.addClass('with-panel-closing');
        }

        if (state === 'closing') {
          $targetEl.addClass('with-panel-closing');
          $targetEl.removeClass("with-panel with-panel-" + panel.side + "-" + panel.effect);
        }

        if (state === 'after-closing') {
          $targetEl.removeClass('with-panel-closing');
        }

        if (state === 'closed') {
          $targetEl.removeClass("with-panel-" + side + "-reveal with-panel-" + side + "-cover with-panel-" + side + "-push with-panel");
        }
      };

      _proto.enableVisibleBreakpoint = function enableVisibleBreakpoint() {
        var panel = this;
        panel.visibleBreakpointDisabled = false;
        panel.setVisibleBreakpoint();
        return panel;
      };

      _proto.disableVisibleBreakpoint = function disableVisibleBreakpoint() {
        var panel = this;
        panel.visibleBreakpointDisabled = true;
        panel.setVisibleBreakpoint();
        return panel;
      };

      _proto.toggleVisibleBreakpoint = function toggleVisibleBreakpoint() {
        var panel = this;
        panel.visibleBreakpointDisabled = !panel.visibleBreakpointDisabled;
        panel.setVisibleBreakpoint();
        return panel;
      };

      _proto.setVisibleBreakpoint = function setVisibleBreakpoint(emitEvents) {
        if (emitEvents === void 0) {
          emitEvents = true;
        }

        var panel = this;
        var app = panel.app;

        if (!panel.visibleBreakpointResizeHandler) {
          panel.visibleBreakpointResizeHandler = function visibleBreakpointResizeHandler() {
            panel.setVisibleBreakpoint();
          };

          app.on('resize', panel.visibleBreakpointResizeHandler);
        }

        var side = panel.side,
            $el = panel.$el,
            $containerEl = panel.$containerEl,
            params = panel.params,
            visibleBreakpointDisabled = panel.visibleBreakpointDisabled;
        var breakpoint = params.visibleBreakpoint;
        var $viewEl = $(panel.getViewEl());
        var wasVisible = $el.hasClass('panel-in-breakpoint');

        if ($containerEl && $containerEl.hasClass('page')) {
          $viewEl.add($containerEl.children('.page-content, .tabs, .fab'));
        }

        if (app.width >= breakpoint && typeof breakpoint !== 'undefined' && breakpoint !== null && !visibleBreakpointDisabled) {
          if (!wasVisible) {
            var _$viewEl$css;

            panel.setStateClasses('closed');
            $el.addClass('panel-in-breakpoint').removeClass('panel-in panel-in-collapsed');
            panel.onOpen(false);
            panel.onOpened();
            $viewEl.css((_$viewEl$css = {}, _$viewEl$css["margin-" + side] = $el.width() + "px", _$viewEl$css));
            app.allowPanelOpen = true;

            if (emitEvents) {
              panel.emit('local::breakpoint panelBreakpoint', panel);
              panel.$el.trigger('panel:breakpoint');
            }
          } else {
            var _$viewEl$css2;

            $viewEl.css((_$viewEl$css2 = {}, _$viewEl$css2["margin-" + side] = $el.width() + "px", _$viewEl$css2));
          }
        } else if (wasVisible) {
          var _$viewEl$css3;

          $el.removeClass('panel-in-breakpoint panel-in');
          panel.onClose();
          panel.onClosed();
          $viewEl.css((_$viewEl$css3 = {}, _$viewEl$css3["margin-" + side] = '', _$viewEl$css3));

          if (emitEvents) {
            panel.emit('local::breakpoint panelBreakpoint', panel);
            panel.$el.trigger('panel:breakpoint');
          }
        }
      };

      _proto.enableCollapsedBreakpoint = function enableCollapsedBreakpoint() {
        var panel = this;
        panel.collapsedBreakpointDisabled = false;
        panel.setCollapsedBreakpoint();
        return panel;
      };

      _proto.disableCollapsedBreakpoint = function disableCollapsedBreakpoint() {
        var panel = this;
        panel.collapsedBreakpointDisabled = true;
        panel.setCollapsedBreakpoint();
        return panel;
      };

      _proto.toggleCollapsedBreakpoint = function toggleCollapsedBreakpoint() {
        var panel = this;
        panel.collapsedBreakpointDisabled = !panel.collapsedBreakpointDisabled;
        panel.setCollapsedBreakpoint();
        return panel;
      };

      _proto.setCollapsedBreakpoint = function setCollapsedBreakpoint(emitEvents) {
        if (emitEvents === void 0) {
          emitEvents = true;
        }

        var panel = this;
        var app = panel.app;

        if (!panel.collapsedBreakpointResizeHandler) {
          panel.collapsedBreakpointResizeHandler = function collapsedBreakpointResizeHandler() {
            panel.setCollapsedBreakpoint();
          };

          app.on('resize', panel.collapsedBreakpointResizeHandler);
        }

        var $el = panel.$el,
            params = panel.params,
            collapsedBreakpointDisabled = panel.collapsedBreakpointDisabled;
        if ($el.hasClass('panel-in-breakpoint')) return;
        var breakpoint = params.collapsedBreakpoint;
        var wasVisible = $el.hasClass('panel-in-collapsed');

        if (app.width >= breakpoint && typeof breakpoint !== 'undefined' && breakpoint !== null && !collapsedBreakpointDisabled) {
          if (!wasVisible) {
            panel.setStateClasses('closed');
            $el.addClass('panel-in-collapsed').removeClass('panel-in');
            panel.collapsed = true;
            app.allowPanelOpen = true;

            if (emitEvents) {
              panel.emit('local::collapsedBreakpoint panelCollapsedBreakpoint', panel);
              panel.$el.trigger('panel:collapsedbreakpoint');
            }
          }
        } else if (wasVisible) {
          $el.removeClass('panel-in-collapsed panel-in');
          panel.collapsed = false;

          if (emitEvents) {
            panel.emit('local::collapsedBreakpoint panelCollapsedBreakpoint', panel);
            panel.$el.trigger('panel:collapsedbreakpoint');
          }
        }
      };

      _proto.enableResizable = function enableResizable() {
        var panel = this;

        if (panel.resizableInitialized) {
          panel.resizable = true;
          panel.$el.addClass('panel-resizable');
        } else {
          resizablePanel(panel);
        }

        return panel;
      };

      _proto.disableResizable = function disableResizable() {
        var panel = this;
        panel.resizable = false;
        panel.$el.removeClass('panel-resizable');
        return panel;
      };

      _proto.enableSwipe = function enableSwipe() {
        var panel = this;

        if (panel.swipeInitialized) {
          panel.swipeable = true;
        } else {
          swipePanel(panel);
        }

        return panel;
      };

      _proto.disableSwipe = function disableSwipe() {
        var panel = this;
        panel.swipeable = false;
        return panel;
      };

      _proto.onOpen = function onOpen(modifyHtmlClasses) {
        if (modifyHtmlClasses === void 0) {
          modifyHtmlClasses = true;
        }

        var panel = this;
        var app = panel.app;
        panel.opened = true;
        app.panel.allowOpen = false;
        panel.$el.trigger('panel:beforeopen');
        panel.emit('local::beforeOpen panelBeforeOpen', panel);

        if (modifyHtmlClasses) {
          panel.setStateClasses('open');
        }

        panel.$el.trigger('panel:open');
        panel.emit('local::open panelOpen', panel);
      };

      _proto.onOpened = function onOpened() {
        var panel = this;
        var app = panel.app;
        app.panel.allowOpen = true;
        panel.$el.trigger('panel:opened');
        panel.emit('local::opened panelOpened', panel);
      };

      _proto.onClose = function onClose() {
        var panel = this;
        var app = panel.app;
        panel.opened = false;
        app.panel.allowOpen = false;
        panel.$el.trigger('panel:beforeclose');
        panel.emit('local::beforeClose panelBeforeClose', panel);
        panel.setStateClasses('closing');
        panel.$el.trigger('panel:close');
        panel.emit('local::close panelClose', panel);
      };

      _proto.onClosed = function onClosed() {
        var panel = this;
        var app = panel.app;
        app.panel.allowOpen = true;
        panel.setStateClasses('after-closing');
        panel.$el.removeClass('panel-out');

        if (panel.$backdropEl) {
          var otherPanel = app.panel.get('.panel-in');
          var shouldHideBackdrop = !otherPanel || otherPanel && !otherPanel.$backdropEl;

          if (shouldHideBackdrop) {
            panel.$backdropEl.removeClass('panel-backdrop-in');
          }
        }

        panel.$el.trigger('panel:closed');
        panel.emit('local::closed panelClosed', panel);
      };

      _proto.toggle = function toggle(animate) {
        if (animate === void 0) {
          animate = true;
        }

        var panel = this;
        var breakpoint = panel.params.visibleBreakpoint;
        var app = panel.app;

        if (app.width >= breakpoint && typeof breakpoint !== 'undefined' && breakpoint !== null) {
          return panel.toggleVisibleBreakpoint();
        }

        if (panel.opened) panel.close(animate);else panel.open(animate);
        return panel;
      };

      _proto.insertToRoot = function insertToRoot() {
        var panel = this;
        var document = getDocument();
        var $el = panel.$el,
            $backdropEl = panel.$backdropEl,
            $containerEl = panel.$containerEl;
        var $panelParentEl = $el.parent();
        var wasInDom = $el.parents(document).length > 0;

        if (!$panelParentEl.is($containerEl) || $el.prevAll('.views, .view').length) {
          var $insertBeforeEl = $containerEl.children('.panel, .views, .view').eq(0);
          var $insertAfterEl = $containerEl.children('.panel-backdrop').eq(0);

          if ($insertBeforeEl.length) {
            $el.insertBefore($insertBeforeEl);
          } else if ($insertAfterEl) {
            $el.insertBefore($insertAfterEl);
          } else {
            $containerEl.prepend($el);
          }

          if ($backdropEl && $backdropEl.length && (!$backdropEl.parent().is($containerEl) && $backdropEl.nextAll('.panel').length === 0 || $backdropEl.parent().is($containerEl) && $backdropEl.nextAll('.panel').length === 0)) {
            $backdropEl.insertBefore($el);
          }

          panel.once('panelClosed', function () {
            if (wasInDom) {
              $panelParentEl.append($el);
            } else {
              $el.remove();
            }
          });
        }
      };

      _proto.open = function open(animate) {
        if (animate === void 0) {
          animate = true;
        }

        var panel = this;
        var app = panel.app;
        if (!app.panel.allowOpen) return false;
        var effect = panel.effect,
            $el = panel.$el,
            $backdropEl = panel.$backdropEl,
            opened = panel.opened,
            $containerEl = panel.$containerEl;

        if (!$el || $el.hasClass('panel-in')) {
          return panel;
        }

        panel.insertToRoot(); // Ignore if opened

        if (opened || $el.hasClass('panel-in-breakpoint') || $el.hasClass('panel-in')) return false; // Close if some panel is opened

        var otherOpenedPanel = app.panel.get('.panel-in');

        if (otherOpenedPanel && otherOpenedPanel !== panel) {
          otherOpenedPanel.close(animate);
        }

        $el[animate ? 'removeClass' : 'addClass']('not-animated');
        $el.addClass('panel-in');

        if ($backdropEl) {
          $backdropEl.addClass('panel-backdrop-in');
          $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
        }

        if (panel.effect === 'cover' || panel.effect === 'push') {
          /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
          panel._clientLeft = $el[0].clientLeft;
        } // Transitionend


        var $viewEl = $(panel.getViewEl());

        if ($containerEl && $containerEl.hasClass('page')) {
          $viewEl.add($containerEl.children('.page-content, .tabs'));
        }

        var transitionEndTarget = effect === 'reveal' ? $viewEl : $el;

        function panelTransitionEnd() {
          transitionEndTarget.transitionEnd(function (e) {
            if ($(e.target).is(transitionEndTarget)) {
              if ($el.hasClass('panel-out')) {
                panel.onClosed();
              } else {
                panel.onOpened();
              }
            } else panelTransitionEnd();
          });
        }

        if (animate) {
          if ($backdropEl) {
            $backdropEl.removeClass('not-animated');
          }

          panelTransitionEnd();
          $el.removeClass('panel-out not-animated').addClass('panel-in');
          panel.onOpen();
        } else {
          if ($backdropEl) {
            $backdropEl.addClass('not-animated');
          }

          $el.removeClass('panel-out').addClass('panel-in not-animated');
          panel.onOpen();
          panel.onOpened();
        }

        return true;
      };

      _proto.close = function close(animate) {
        if (animate === void 0) {
          animate = true;
        }

        var panel = this;
        var effect = panel.effect,
            $el = panel.$el,
            $backdropEl = panel.$backdropEl,
            opened = panel.opened,
            $containerEl = panel.$containerEl;
        if (!opened || $el.hasClass('panel-in-breakpoint') || !$el.hasClass('panel-in')) return panel;
        $el[animate ? 'removeClass' : 'addClass']('not-animated');

        if ($backdropEl) {
          $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
        }

        var $viewEl = $(panel.getViewEl());

        if ($containerEl && $containerEl.hasClass('page')) {
          $viewEl.add($containerEl.children('.page-content, .tabs'));
        }

        var transitionEndTarget = effect === 'reveal' ? $viewEl : $el;

        function transitionEnd() {
          if ($el.hasClass('panel-out')) {
            panel.onClosed();
          } else if ($el.hasClass('panel-in')) {
            panel.onOpened();
          }

          panel.setStateClasses('after-closing');
        }

        if (animate) {
          transitionEndTarget.transitionEnd(function () {
            transitionEnd();
          });
          $el.removeClass('panel-in').addClass('panel-out'); // Emit close

          panel.onClose();
        } else {
          $el.addClass('not-animated').removeClass('panel-in').addClass('panel-out'); // Emit close

          panel.onClose();
          panel.onClosed();
        }

        return panel;
      };

      _proto.init = function init() {
        var panel = this; // const app = panel.app;

        if (typeof panel.params.visibleBreakpoint !== 'undefined') {
          panel.setVisibleBreakpoint();
        }

        if (typeof panel.params.collapsedBreakpoint !== 'undefined') {
          panel.setCollapsedBreakpoint();
        }

        if (panel.params.swipe) {
          panel.enableSwipe();
        }

        if (panel.resizable) {
          panel.enableResizable();
        }
      };

      _proto.destroy = function destroy() {
        var panel = this;
        var app = panel.app;
        var _panel = panel,
            $containerEl = _panel.$containerEl;

        if (!panel.$el) {
          // Panel already destroyed
          return;
        }

        panel.emit('local::beforeDestroy panelBeforeDestroy', panel);
        panel.$el.trigger('panel:beforedestroy');

        if (panel.visibleBreakpointResizeHandler) {
          app.off('resize', panel.visibleBreakpointResizeHandler);
        }

        if (panel.collapsedBreakpointResizeHandler) {
          app.off('resize', panel.collapsedBreakpointResizeHandler);
        }

        if (panel.$el.hasClass('panel-in-breakpoint') || panel.$el.hasClass('panel-in-collapsed')) {
          var _$viewEl$css4;

          var $viewEl = $(panel.getViewEl());

          if ($containerEl && $containerEl.hasClass('page')) {
            $viewEl.add($containerEl.children('.page-content, .tabs'));
          }

          panel.$el.removeClass('panel-in-breakpoint panel-in-collapsed panel-in');
          $viewEl.css((_$viewEl$css4 = {}, _$viewEl$css4["margin-" + panel.side] = '', _$viewEl$css4));
          panel.emit('local::breakpoint panelBreakpoint', panel);
          panel.$el.trigger('panel:breakpoint');
        }

        panel.$el.trigger('panel:destroy');
        panel.emit('local::destroy panelDestroy', panel);

        if (panel.el) {
          panel.el.f7Panel = null;
          delete panel.el.f7Panel;
        }

        deleteProps$1(panel);
        panel = null;
      };

      return Panel;
    }(Framework7Class$1);

    var Panel$2 = Panel$1;

    var Panel = {
      name: 'panel',
      params: {
        panel: {
          opened: undefined,
          // default based on panel-in class
          side: undefined,
          // default based on panel class
          effect: undefined,
          // default based on panel class
          resizable: undefined,
          // default based on panel-resizable class
          backdrop: true,
          backdropEl: undefined,
          visibleBreakpoint: undefined,
          collapsedBreakpoint: undefined,
          swipe: false,
          // or true
          swipeNoFollow: false,
          // or true
          swipeOnlyClose: false,
          swipeActiveArea: 0,
          swipeThreshold: 0,
          closeByBackdropClick: true,
          containerEl: undefined
        }
      },
      static: {
        Panel: Panel$2
      },
      create: function create() {
        var app = this;
        extend$2(app, {
          panel: {
            allowOpen: true,
            create: function create(params) {
              return new Panel$2(app, params);
            },
            get: function get(el) {
              if (el === void 0) {
                el = '.panel';
              }

              if (el instanceof Panel$2) return el;
              if (el === 'left' || el === 'right') el = ".panel-" + el; // eslint-disable-line

              var $el = $(el);
              if ($el.length === 0 || $el.length > 1) return undefined;
              return $el[0].f7Panel;
            },
            destroy: function destroy(el) {
              if (el === void 0) {
                el = '.panel';
              }

              var panel = app.panel.get(el);
              if (panel && panel.destroy) return panel.destroy();
              return undefined;
            },
            open: function open(el, animate) {
              if (el === void 0) {
                el = '.panel';
              }

              if (el === 'left' || el === 'right') el = ".panel-" + el; // eslint-disable-line

              var panel = app.panel.get(el);
              if (panel && panel.open) return panel.open(animate);

              if (!panel) {
                panel = app.panel.create({
                  el: el
                });
                return panel.open(animate);
              }

              return undefined;
            },
            close: function close(el, animate) {
              if (el === void 0) {
                el = '.panel-in';
              }

              if (el === 'left' || el === 'right') el = ".panel-" + el; // eslint-disable-line

              var panel = app.panel.get(el);
              if (panel && panel.open) return panel.close(animate);

              if (!panel) {
                panel = app.panel.create({
                  el: el
                });
                return panel.close(animate);
              }

              return undefined;
            },
            toggle: function toggle(el, animate) {
              if (el === void 0) {
                el = '.panel';
              }

              if (el === 'left' || el === 'right') el = ".panel-" + el; // eslint-disable-line

              var panel = app.panel.get(el);
              if (panel && panel.toggle) return panel.toggle(animate);

              if (!panel) {
                panel = app.panel.create({
                  el: el
                });
                return panel.toggle(animate);
              }

              return undefined;
            }
          }
        });
      },
      on: {
        init: function init() {
          var app = this;
          $('.panel-init').each(function (panelEl) {
            var params = Object.assign({
              el: panelEl
            }, $(panelEl).dataset() || {});
            app.panel.create(params);
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.panel-init').each(function (panelEl) {
            var params = Object.assign({
              el: panelEl
            }, $(panelEl).dataset() || {});
            app.panel.create(params);
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          var app = this;
          page.$el.find('.panel-init').each(function (panelEl) {
            var panel = app.panel.get(panelEl);
            if (panel && panel.destroy) panel.destroy();
          });
        }
      },
      vnode: {
        'panel-init': {
          insert: function insert(vnode) {
            var app = this;
            var panelEl = vnode.elm;
            var params = Object.assign({
              el: panelEl
            }, $(panelEl).dataset() || {});
            app.panel.create(params);
          },
          destroy: function destroy(vnode) {
            var app = this;
            var panelEl = vnode.elm;
            var panel = app.panel.get(panelEl);
            if (panel && panel.destroy) panel.destroy();
          }
        }
      },
      clicks: {
        '.panel-open': function open(clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.panel.open(data.panel, data.animate);
        },
        '.panel-close': function close(clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.panel.close(data.panel, data.animate);
        },
        '.panel-toggle': function close(clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.panel.toggle(data.panel, data.animate);
        },
        '.panel-backdrop': function close() {
          var app = this;
          var $panelEl = $('.panel-in:not(.panel-out)');
          if (!$panelEl.length) return;
          var instance = $panelEl[0] && $panelEl[0].f7Panel;
          $panelEl.trigger('panel:backdrop-click');

          if (instance) {
            instance.emit('backdropClick', instance);
          }

          app.emit('panelBackdropClick', instance || $panelEl[0]);
          if (app.params.panel.closeByBackdropClick) app.panel.close();
        }
      }
    };

    /* eslint no-param-reassign: "off" */
    var CardExpandable = {
      open: function open(cardEl, animate) {
        if (cardEl === void 0) {
          cardEl = '.card-expandable';
        }

        if (animate === void 0) {
          animate = true;
        }

        var app = this;
        var device = getDevice$1();
        var document = getDocument();
        var support = getSupport$1();
        var $cardEl = $(cardEl).eq(0);
        if (!$cardEl || !$cardEl.length) return;
        if ($cardEl.hasClass('card-opened') || $cardEl.hasClass('card-opening') || $cardEl.hasClass('card-closing')) return;
        var $pageEl = $cardEl.parents('.page').eq(0);
        if (!$pageEl.length) return;

        if ($pageEl.find('.card-opened').length) {
          return;
        }

        var prevented;

        function prevent() {
          prevented = true;
        }

        $cardEl.trigger('card:beforeopen', {
          prevent: prevent
        });
        app.emit('cardBeforeOpen', $cardEl[0], prevent);
        if (prevented) return;
        var cardParams = Object.assign({
          animate: animate
        }, app.params.card, $cardEl.dataset());
        var $pageContentEl = $cardEl.parents('.page-content');
        var $backdropEl;

        if ($cardEl.attr('data-backdrop-el')) {
          $backdropEl = $($cardEl.attr('data-backdrop-el'));
        }

        if (!$backdropEl && cardParams.backdrop) {
          $backdropEl = $pageContentEl.find('.card-backdrop');

          if (!$backdropEl.length) {
            $backdropEl = $('<div class="card-backdrop"></div>');
            $pageContentEl.append($backdropEl);
          }
        }

        var $navbarEl;
        var $toolbarEl;

        if (cardParams.hideNavbarOnOpen) {
          $navbarEl = $pageEl.children('.navbar');

          if (!$navbarEl.length) {
            if ($pageEl[0].f7Page) $navbarEl = $pageEl[0].f7Page.$navbarEl;
          }
        }

        if (cardParams.hideToolbarOnOpen) {
          $toolbarEl = $pageEl.children('.toolbar');

          if (!$toolbarEl.length) {
            $toolbarEl = $pageEl.parents('.view').children('.toolbar');
          }

          if (!$toolbarEl.length) {
            $toolbarEl = $pageEl.parents('.views').children('.toolbar');
          }
        }

        var currTransform = $cardEl.css('transform');
        var hasTransform;

        if (currTransform && currTransform.match(/[2-9]/)) {
          hasTransform = true;
        }

        var $cardContentEl = $cardEl.children('.card-content');
        var $cardSizeEl = $(document.createElement('div')).addClass('card-expandable-size');
        $cardEl.append($cardSizeEl);
        var cardWidth = $cardEl[0].offsetWidth;
        var cardHeight = $cardEl[0].offsetHeight;
        var pageWidth = $pageEl[0].offsetWidth;
        var pageHeight = $pageEl[0].offsetHeight;
        var maxWidth = $cardSizeEl[0].offsetWidth || pageWidth;
        var maxHeight = $cardSizeEl[0].offsetHeight || pageHeight;
        var statusbarHeight;

        if ($navbarEl && !cardParams.hideStatusbarOnOpen && maxHeight === pageHeight) {
          statusbarHeight = parseInt($navbarEl.css('--f7-safe-area-top'), 10);
          if (Number.isNaN(statusbarHeight)) statusbarHeight = 0;
        }

        if (statusbarHeight) {
          maxHeight -= statusbarHeight;
        }

        var scaleX = maxWidth / cardWidth;
        var scaleY = maxHeight / cardHeight;
        var offset = $cardEl.offset();
        var pageOffset = $pageEl.offset();

        if (statusbarHeight) {
          pageOffset.top += statusbarHeight / 2;
        }

        offset.left -= pageOffset.left;
        var cardLeftOffset;
        var cardTopOffset;

        if (hasTransform) {
          var transformValues = currTransform.replace(/matrix\(|\)/g, '').split(',').map(function (el) {
            return el.trim();
          });

          if (transformValues && transformValues.length > 1) {
            var scale = parseFloat(transformValues[0]);
            cardLeftOffset = offset.left - cardWidth * (1 - scale) / 2;
            cardTopOffset = offset.top - pageOffset.top - cardHeight * (1 - scale) / 2;
            if (app.rtl) cardLeftOffset -= $cardEl[0].scrollLeft;
          } else {
            cardLeftOffset = $cardEl[0].offsetLeft;
            cardTopOffset = $cardEl[0].offsetTop - ($pageContentEl.length ? $pageContentEl[0].scrollTop : 0);
          }
        } else {
          cardLeftOffset = offset.left;
          cardTopOffset = offset.top - pageOffset.top;
          if (app.rtl) cardLeftOffset -= $cardEl[0].scrollLeft;
        }

        cardLeftOffset -= (pageWidth - maxWidth) / 2;
        cardTopOffset -= (pageHeight - maxHeight) / 2;
        var cardRightOffset = maxWidth - cardWidth - cardLeftOffset;

        if (app.rtl) {
          var _ref = [cardRightOffset, cardLeftOffset];
          cardLeftOffset = _ref[0];
          cardRightOffset = _ref[1];
        }

        var cardBottomOffset = maxHeight - cardHeight - cardTopOffset;
        var translateX = (cardRightOffset - cardLeftOffset) / 2;
        var translateY = (cardBottomOffset - cardTopOffset) / 2;

        if (cardParams.hideNavbarOnOpen && $navbarEl && $navbarEl.length) {
          if ($navbarEl.closest('.navbar-hidden').length) {
            // Was hidden
            $cardEl[0].f7KeepNavbarOnClose = true;
          } else {
            delete $cardEl[0].f7KeepNavbarOnClose;
            app.navbar.hide($navbarEl, cardParams.animate, cardParams.hideStatusbarOnOpen, true);
          }
        }

        if (cardParams.hideToolbarOnOpen && $toolbarEl && $toolbarEl.length) {
          if ($toolbarEl.closest('.toolbar-hidden').length) {
            // Was hidden
            $cardEl[0].f7KeepToolbarOnClose = true;
          } else {
            delete $cardEl[0].f7KeepToolbarOnClose;
            app.toolbar.hide($toolbarEl, cardParams.animate);
          }
        }

        if ($backdropEl) {
          $backdropEl.removeClass('card-backdrop-out').addClass('card-backdrop-in');
        }

        $cardEl.removeClass('card-transitioning');

        if (cardParams.animate) {
          $cardEl.addClass('card-opening');
        }

        $cardEl.trigger('card:open');
        app.emit('cardOpen', $cardEl[0]);

        function transitionEnd() {
          $pageEl.addClass('page-with-card-opened');

          if (device.ios && $pageContentEl.length) {
            $pageContentEl.css('height', $pageContentEl[0].offsetHeight + 1 + "px");
            setTimeout(function () {
              $pageContentEl.css('height', '');
            });
          }

          $cardEl.addClass('card-opened');
          $cardEl.removeClass('card-opening');
          $cardEl.trigger('card:opened');
          app.emit('cardOpened', $cardEl[0], $pageEl[0]);
        }

        $cardContentEl.css({
          width: maxWidth + "px",
          height: maxHeight + "px"
        }).transform("translate3d(" + (app.rtl ? cardLeftOffset + translateX : -cardLeftOffset - translateX) + "px, 0px, 0) scale(" + 1 / scaleX + ", " + 1 / scaleY + ")");
        $cardEl.transform("translate3d(" + (app.rtl ? -translateX : translateX) + "px, " + translateY + "px, 0) scale(" + scaleX + ", " + scaleY + ")");

        if (cardParams.animate) {
          $cardEl.transitionEnd(function () {
            transitionEnd();
          });
        } else {
          transitionEnd();
        }

        function onResize() {
          $cardEl.removeClass('card-transitioning');
          cardWidth = $cardEl[0].offsetWidth;
          cardHeight = $cardEl[0].offsetHeight;
          pageWidth = $pageEl[0].offsetWidth;
          pageHeight = $pageEl[0].offsetHeight;
          maxWidth = $cardSizeEl[0].offsetWidth || pageWidth;
          maxHeight = $cardSizeEl[0].offsetHeight || pageHeight;
          statusbarHeight = 0;

          if ($navbarEl && !cardParams.hideStatusbarOnOpen && maxHeight === pageHeight) {
            statusbarHeight = parseInt($navbarEl.css('--f7-safe-area-top'), 10);
            if (Number.isNaN(statusbarHeight)) statusbarHeight = 0;
          }

          if (statusbarHeight) {
            maxHeight -= statusbarHeight;
          }

          scaleX = maxWidth / cardWidth;
          scaleY = maxHeight / cardHeight;
          $cardEl.transform('translate3d(0px, 0px, 0) scale(1)');
          offset = $cardEl.offset();
          pageOffset = $pageEl.offset();

          if (statusbarHeight) {
            pageOffset.top += statusbarHeight / 2;
          }

          offset.left -= pageOffset.left;
          offset.top -= pageOffset.top;
          cardLeftOffset = offset.left - (pageWidth - maxWidth) / 2;
          if (app.rtl) cardLeftOffset -= $cardEl[0].scrollLeft;
          cardTopOffset = offset.top - (pageHeight - maxHeight) / 2;
          cardRightOffset = maxWidth - cardWidth - cardLeftOffset;
          cardBottomOffset = maxHeight - cardHeight - cardTopOffset;

          if (app.rtl) {
            var _ref2 = [cardRightOffset, cardLeftOffset];
            cardLeftOffset = _ref2[0];
            cardRightOffset = _ref2[1];
          }

          translateX = (cardRightOffset - cardLeftOffset) / 2;
          translateY = (cardBottomOffset - cardTopOffset) / 2;
          $cardEl.transform("translate3d(" + (app.rtl ? -translateX : translateX) + "px, " + translateY + "px, 0) scale(" + scaleX + ", " + scaleY + ")");
          $cardContentEl.css({
            width: maxWidth + "px",
            height: maxHeight + "px"
          }).transform("translate3d(" + (app.rtl ? cardLeftOffset + translateX : -cardLeftOffset - translateX) + "px, 0px, 0) scale(" + 1 / scaleX + ", " + 1 / scaleY + ")");
        }

        var cardScrollTop;
        var isTouched;
        var isMoved;
        var touchStartX;
        var touchStartY;
        var touchEndX;
        var touchEndY;
        var isScrolling;
        var progress;
        var isV;
        var isH;
        var $cardScrollableEl;

        function onTouchStart(e) {
          if (!$(e.target).closest($cardEl).length) return;
          if (!$cardEl.hasClass('card-opened')) return;
          $cardScrollableEl = $cardEl.find(cardParams.scrollableEl);

          if ($cardScrollableEl[0] && $cardScrollableEl[0] !== $cardContentEl[0] && !$cardScrollableEl[0].contains(e.target)) {
            cardScrollTop = 0;
          } else {
            cardScrollTop = $cardScrollableEl.scrollTop();
          }

          isTouched = true;
          touchStartX = e.targetTouches[0].pageX;
          touchStartY = e.targetTouches[0].pageY;
          isScrolling = undefined;
          isV = false;
          isH = false;
        }

        function onTouchMove(e) {
          if (!isTouched) return;
          touchEndX = e.targetTouches[0].pageX;
          touchEndY = e.targetTouches[0].pageY;

          if (typeof isScrolling === 'undefined') {
            isScrolling = !!(isScrolling || Math.abs(touchEndY - touchStartY) > Math.abs(touchEndX - touchStartX));
          }

          if (!isH && !isV) {
            if (!isScrolling && e.targetTouches[0].clientX <= 50) {
              isH = true;
            } else {
              isV = true;
            }
          }

          if (!(isH || isV) || isV && cardScrollTop !== 0) {
            isTouched = true;
            isMoved = true;
            return;
          }

          if (!isMoved) {
            $cardEl.removeClass('card-transitioning');
          }

          isMoved = true;
          progress = isV ? Math.max((touchEndY - touchStartY) / 150, 0) : Math.max((touchEndX - touchStartX) / (cardWidth / 2), 0);

          if (progress > 0 && isV || isH) {
            if (isV && device.ios && $cardScrollableEl[0] === $cardContentEl[0]) {
              $cardScrollableEl.css('-webkit-overflow-scrolling', 'auto');
              $cardScrollableEl.scrollTop(0);
            }

            e.preventDefault();
          }

          if (progress > 1) progress = Math.pow(progress, 0.3);

          if (progress > (isV ? 1.3 : 1.1)) {
            isTouched = false;
            isMoved = false;
            app.card.close($cardEl);
          } else {
            $cardEl.transform("translate3d(" + (app.rtl ? -translateX : translateX) + "px, " + translateY + "px, 0) scale(" + scaleX * (1 - progress * 0.2) + ", " + scaleY * (1 - progress * 0.2) + ")");
          }
        }

        function onTouchEnd() {
          if (!isTouched || !isMoved) return;
          isTouched = false;
          isMoved = false;

          if (device.ios) {
            $cardScrollableEl.css('-webkit-overflow-scrolling', '');
          }

          if (progress >= 0.8) {
            app.card.close($cardEl);
          } else {
            $cardEl.addClass('card-transitioning').transform("translate3d(" + (app.rtl ? -translateX : translateX) + "px, " + translateY + "px, 0) scale(" + scaleX + ", " + scaleY + ")");
          }
        }

        $cardEl[0].detachEventHandlers = function detachEventHandlers() {
          app.off('resize', onResize);

          if (support.touch && cardParams.swipeToClose) {
            app.off('touchstart:passive', onTouchStart);
            app.off('touchmove:active', onTouchMove);
            app.off('touchend:passive', onTouchEnd);
          }
        };

        app.on('resize', onResize);

        if (support.touch && cardParams.swipeToClose) {
          app.on('touchstart:passive', onTouchStart);
          app.on('touchmove:active', onTouchMove);
          app.on('touchend:passive', onTouchEnd);
        }
      },
      close: function close(cardEl, animate) {
        if (cardEl === void 0) {
          cardEl = '.card-expandable.card-opened';
        }

        if (animate === void 0) {
          animate = true;
        }

        var app = this;
        var device = getDevice$1();
        var $cardEl = $(cardEl).eq(0);
        if (!$cardEl || !$cardEl.length) return;
        if (!$cardEl.hasClass('card-opened') || $cardEl.hasClass('card-opening') || $cardEl.hasClass('card-closing')) return;
        var $cardContentEl = $cardEl.children('.card-content');
        var $pageContentEl = $cardEl.parents('.page-content');
        var $pageEl = $cardEl.parents('.page').eq(0);
        if (!$pageEl.length) return;
        var cardParams = Object.assign({
          animate: animate
        }, app.params.card, $cardEl.dataset());
        var $cardScrollableEl = $cardEl.find(cardParams.scrollableEl);
        var $navbarEl;
        var $toolbarEl;
        var $backdropEl;

        if ($cardEl.attr('data-backdrop-el')) {
          $backdropEl = $($cardEl.attr('data-backdrop-el'));
        }

        if (cardParams.backdrop) {
          $backdropEl = $cardEl.parents('.page-content').find('.card-backdrop');
        }

        if (cardParams.hideNavbarOnOpen) {
          $navbarEl = $pageEl.children('.navbar');

          if (!$navbarEl.length) {
            if ($pageEl[0].f7Page) $navbarEl = $pageEl[0].f7Page.$navbarEl;
          }

          if ($navbarEl && $navbarEl.length && !$cardEl[0].f7KeepNavbarOnClose) {
            app.navbar.show($navbarEl, cardParams.animate, true);
          }
        }

        if (cardParams.hideToolbarOnOpen) {
          $toolbarEl = $pageEl.children('.toolbar');

          if (!$toolbarEl.length) {
            $toolbarEl = $pageEl.parents('.view').children('.toolbar');
          }

          if (!$toolbarEl.length) {
            $toolbarEl = $pageEl.parents('.views').children('.toolbar');
          }

          if ($toolbarEl && $toolbarEl.length && !$cardEl[0].f7KeepToolbarOnClose) {
            app.toolbar.show($toolbarEl, cardParams.animate);
          }
        }

        $pageEl.removeClass('page-with-card-opened');

        if (device.ios && $pageContentEl.length) {
          $pageContentEl.css('height', $pageContentEl[0].offsetHeight + 1 + "px");
          setTimeout(function () {
            $pageContentEl.css('height', '');
          });
        }

        if ($backdropEl && $backdropEl.length) {
          $backdropEl.removeClass('card-backdrop-in').addClass('card-backdrop-out');
        }

        $cardEl.removeClass('card-opened card-transitioning');

        if (cardParams.animate) {
          $cardEl.addClass('card-closing');
        } else {
          $cardEl.addClass('card-no-transition');
        }

        $cardEl.transform('');
        $cardEl.trigger('card:close');
        app.emit('cardClose', $cardEl[0], $pageEl[0]);
        var animateWidth = $cardEl.hasClass('card-expandable-animate-width');

        function transitionEnd() {
          if (!animateWidth) {
            $cardContentEl.css({
              width: '',
              height: ''
            });
          }

          if ($backdropEl && $backdropEl.length) {
            $backdropEl.removeClass('card-backdrop-in card-backdrop-out');
          }

          $cardEl.removeClass('card-closing card-no-transition');
          $cardEl.trigger('card:closed');
          $cardEl.find('.card-expandable-size').remove();
          app.emit('cardClosed', $cardEl[0], $pageEl[0]);
        }

        if (animateWidth) {
          $cardContentEl.css({
            width: '',
            height: ''
          });
        }

        $cardContentEl.transform('').scrollTop(0, animate ? 300 : 0);

        if ($cardScrollableEl.length && $cardScrollableEl[0] !== $cardContentEl[0]) {
          $cardScrollableEl.scrollTop(0, animate ? 300 : 0);
        }

        if (animate) {
          $cardContentEl.transitionEnd(function () {
            transitionEnd();
          });
        } else {
          transitionEnd();
        }

        if ($cardEl[0].detachEventHandlers) {
          $cardEl[0].detachEventHandlers();
          delete $cardEl[0].detachEventHandlers;
        }
      },
      toggle: function toggle(cardEl, animate) {
        if (cardEl === void 0) {
          cardEl = '.card-expandable';
        }

        var app = this;
        var $cardEl = $(cardEl).eq(0);
        if (!$cardEl.length) return;

        if ($cardEl.hasClass('card-opened')) {
          app.card.close($cardEl, animate);
        } else {
          app.card.open($cardEl, animate);
        }
      }
    };
    var Card = {
      name: 'card',
      params: {
        card: {
          hideNavbarOnOpen: true,
          hideStatusbarOnOpen: true,
          hideToolbarOnOpen: true,
          scrollableEl: '.card-content',
          swipeToClose: true,
          closeByBackdropClick: true,
          backdrop: true
        }
      },
      create: function create() {
        var app = this;
        bindMethods(app, {
          card: CardExpandable
        });
      },
      on: {
        pageBeforeIn: function pageBeforeIn(page) {
          var app = this;

          if (app.params.card.hideNavbarOnOpen && page.navbarEl && page.$el.find('.card-opened.card-expandable').length) {
            app.navbar.hide(page.navbarEl, true, app.params.card.hideStatusbarOnOpen, true);
          }

          if (app.params.card.hideToolbarOnOpen && page.$el.find('.card-opened.card-expandable').length) {
            var $toolbarEl = page.$el.children('.toolbar');

            if (!$toolbarEl.length) {
              $toolbarEl = page.$el.parents('.view').children('.toolbar');
            }

            if (!$toolbarEl.length) {
              $toolbarEl = page.$el.parents('.views').children('.toolbar');
            }

            if ($toolbarEl && $toolbarEl.length) {
              app.toolbar.hide($toolbarEl);
            }
          }
        }
      },
      clicks: {
        '.card-close': function closeCard($clickedEl, data) {
          var app = this;
          app.card.close(data.card, data.animate);
        },
        '.card-open': function closeCard($clickedEl, data) {
          var app = this;
          app.card.open(data.card, data.animate);
        },
        '.card-expandable': function toggleExpandableCard($clickedEl, data, e) {
          var app = this;
          if ($clickedEl.hasClass('card-opened') || $clickedEl.hasClass('card-opening') || $clickedEl.hasClass('card-closing')) return;
          if ($(e.target).closest('.card-prevent-open, .card-close').length) return;
          app.card.open($clickedEl);
        },
        '.card-backdrop-in': function onBackdropClick() {
          var app = this;
          var needToClose = false;
          if (app.params.card.closeByBackdropClick) needToClose = true;
          var $openedCardEl = $('.card-opened');
          if (!$openedCardEl.length) return;

          if ($openedCardEl.attr('data-close-by-backdrop-click') === 'true') {
            needToClose = true;
          } else if ($openedCardEl.attr('data-close-by-backdrop-click') === 'false') {
            needToClose = false;
          }

          if (needToClose) app.card.close($openedCardEl);
        }
      }
    };

    var Chip = {
      name: 'chip'
    };

    var FormData$1 = {
      store: function store(form, data) {
        var app = this;
        var window = getWindow();
        var formId = form;
        var $formEl = $(form);

        if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
          formId = $formEl.attr('id');
        } // Store form data in app.formsData


        app.form.data["form-" + formId] = data; // Store form data in local storage also

        window.localStorage["f7form-" + formId] = JSON.stringify(data);
      },
      get: function get(form) {
        var app = this;
        var window = getWindow();
        var formId = form;
        var $formEl = $(form);

        if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
          formId = $formEl.attr('id');
        }

        if (window.localStorage["f7form-" + formId]) {
          return JSON.parse(window.localStorage["f7form-" + formId]);
        }

        if (app.form.data["form-" + formId]) {
          return app.form.data["form-" + formId];
        }

        return undefined;
      },
      remove: function remove(form) {
        var app = this;
        var window = getWindow();
        var formId = form;
        var $formEl = $(form);

        if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
          formId = $formEl.attr('id');
        } // Delete form data from app.formsData


        if (app.form.data["form-" + formId]) {
          app.form.data["form-" + formId] = '';
          delete app.form.data["form-" + formId];
        } // Delete form data from local storage also


        if (window.localStorage["f7form-" + formId]) {
          window.localStorage["f7form-" + formId] = '';
          window.localStorage.removeItem("f7form-" + formId);
        }
      }
    }; // Form Storage

    var FormStorage = {
      init: function init(formEl) {
        var app = this;
        var $formEl = $(formEl);
        var formId = $formEl.attr('id');
        if (!formId) return;
        var initialData = app.form.getFormData(formId);

        if (initialData) {
          app.form.fillFromData($formEl, initialData);
        }

        function store() {
          var data = app.form.convertToData($formEl);
          if (!data) return;
          app.form.storeFormData(formId, data);
          $formEl.trigger('form:storedata', data);
          app.emit('formStoreData', $formEl[0], data);
        }

        $formEl.on('change submit', store);
      },
      destroy: function destroy(formEl) {
        var $formEl = $(formEl);
        $formEl.off('change submit');
      }
    }; // Form To/From Data

    function formToData(formEl) {
      var app = this;
      var $formEl = $(formEl).eq(0);
      if ($formEl.length === 0) return undefined; // Form data

      var data = {}; // Skip input types

      var skipTypes = ['submit', 'image', 'button', 'file'];
      var skipNames = [];
      $formEl.find('input, select, textarea').each(function (inputEl) {
        var $inputEl = $(inputEl);

        if ($inputEl.hasClass('ignore-store-data') || $inputEl.hasClass('no-store-data')) {
          return;
        }

        var name = $inputEl.attr('name');
        var type = $inputEl.attr('type');
        var tag = inputEl.nodeName.toLowerCase();
        if (skipTypes.indexOf(type) >= 0) return;
        if (skipNames.indexOf(name) >= 0 || !name) return;

        if (tag === 'select' && $inputEl.prop('multiple')) {
          skipNames.push(name);
          data[name] = [];
          $formEl.find("select[name=\"" + name + "\"] option").each(function (el) {
            if (el.selected) data[name].push(el.value);
          });
        } else {
          switch (type) {
            case 'checkbox':
              skipNames.push(name);
              data[name] = [];
              $formEl.find("input[name=\"" + name + "\"]").each(function (el) {
                if (el.checked) data[name].push(el.value);
              });
              break;

            case 'radio':
              skipNames.push(name);
              $formEl.find("input[name=\"" + name + "\"]").each(function (el) {
                if (el.checked) data[name] = el.value;
              });
              break;

            default:
              data[name] = $inputEl.val();
              break;
          }
        }
      });
      $formEl.trigger('form:todata', data);
      app.emit('formToData', $formEl[0], data);
      return data;
    }

    function formFromData(formEl, formData) {
      var app = this;
      var $formEl = $(formEl).eq(0);
      if (!$formEl.length) return;
      var data = formData;
      var formId = $formEl.attr('id');

      if (!data && formId) {
        data = app.form.getFormData(formId);
      }

      if (!data) return; // Skip input types

      var skipTypes = ['submit', 'image', 'button', 'file'];
      var skipNames = [];
      $formEl.find('input, select, textarea').each(function (inputEl) {
        var $inputEl = $(inputEl);

        if ($inputEl.hasClass('ignore-store-data') || $inputEl.hasClass('no-store-data')) {
          return;
        }

        var name = $inputEl.attr('name');
        var type = $inputEl.attr('type');
        var tag = inputEl.nodeName.toLowerCase();
        if (typeof data[name] === 'undefined' || data[name] === null) return;
        if (skipTypes.indexOf(type) >= 0) return;
        if (skipNames.indexOf(name) >= 0 || !name) return;

        if (tag === 'select' && $inputEl.prop('multiple')) {
          skipNames.push(name);
          $formEl.find("select[name=\"" + name + "\"] option").each(function (el) {
            var selectEl = el;
            if (data[name].indexOf(el.value) >= 0) selectEl.selected = true;else selectEl.selected = false;
          });
        } else {
          switch (type) {
            case 'checkbox':
              skipNames.push(name);
              $formEl.find("input[name=\"" + name + "\"]").each(function (el) {
                var checkboxEl = el;
                if (data[name].indexOf(el.value) >= 0) checkboxEl.checked = true;else checkboxEl.checked = false;
              });
              break;

            case 'radio':
              skipNames.push(name);
              $formEl.find("input[name=\"" + name + "\"]").each(function (el) {
                var radioEl = el;
                if (data[name] === el.value) radioEl.checked = true;else radioEl.checked = false;
              });
              break;

            default:
              $inputEl.val(data[name]);
              break;
          }
        }

        if (tag === 'select' || tag === 'input' || tag === 'textarea') {
          $inputEl.trigger('change', 'fromdata');
        }
      });
      $formEl.trigger('form:fromdata', data);
      app.emit('formFromData', $formEl[0], data);
    }

    function initAjaxForm() {
      var app = this;
      var window = getWindow();
      var document = getDocument();

      function onSubmitChange(e, fromData) {
        var $formEl = $(this);
        if (e.type === 'change' && !$formEl.hasClass('form-ajax-submit-onchange')) return;
        if (e.type === 'submit') e.preventDefault();
        if (e.type === 'change' && fromData === 'fromdata') return;
        var method = ($formEl.attr('method') || 'GET').toUpperCase();
        var contentType = $formEl.prop('enctype') || $formEl.attr('enctype');
        var url = $formEl.attr('action');
        if (!url) return;
        var data;

        if (method === 'POST') {
          if (contentType === 'application/x-www-form-urlencoded') {
            data = app.form.convertToData($formEl[0]);
          } else {
            data = new window.FormData($formEl[0]);
          }
        } else {
          data = serializeObject(app.form.convertToData($formEl[0]));
        }

        app.request({
          method: method,
          url: url,
          contentType: contentType,
          data: data,
          beforeSend: function beforeSend(xhr) {
            $formEl.trigger('formajax:beforesend', {
              data: data,
              xhr: xhr
            });
            app.emit('formAjaxBeforeSend', $formEl[0], data, xhr);
          },
          error: function error(xhr) {
            $formEl.trigger('formajax:error', {
              data: data,
              xhr: xhr
            });
            app.emit('formAjaxError', $formEl[0], data, xhr);
          },
          complete: function complete(xhr) {
            $formEl.trigger('formajax:complete', {
              data: data,
              xhr: xhr
            });
            app.emit('formAjaxComplete', $formEl[0], data, xhr);
          },
          success: function success(response, status, xhr) {
            $formEl.trigger('formajax:success', {
              data: data,
              xhr: xhr
            });
            app.emit('formAjaxSuccess', $formEl[0], data, xhr);
          }
        });
      }

      $(document).on('submit change', 'form.form-ajax-submit, form.form-ajax-submit-onchange', onSubmitChange);
    }

    var Form = {
      name: 'form',
      create: function create() {
        var app = this;
        extend$2(app, {
          form: {
            data: {},
            storeFormData: FormData$1.store.bind(app),
            getFormData: FormData$1.get.bind(app),
            removeFormData: FormData$1.remove.bind(app),
            convertToData: formToData.bind(app),
            fillFromData: formFromData.bind(app),
            storage: {
              init: FormStorage.init.bind(app),
              destroy: FormStorage.destroy.bind(app)
            }
          }
        });
      },
      on: {
        init: function init() {
          var app = this;
          initAjaxForm.call(app);
        },
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          var app = this;
          $(tabEl).find('.form-store-data').each(function (formEl) {
            app.form.storage.destroy(formEl);
          });
        },
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.form-store-data').each(function (formEl) {
            app.form.storage.init(formEl);
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          var app = this;
          page.$el.find('.form-store-data').each(function (formEl) {
            app.form.storage.destroy(formEl);
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.form-store-data').each(function (formEl) {
            app.form.storage.init(formEl);
          });
        }
      }
    };

    var Input = {
      ignoreTypes: ['checkbox', 'button', 'submit', 'range', 'radio', 'image'],
      createTextareaResizableShadow: function createTextareaResizableShadow() {
        var document = getDocument();
        var $shadowEl = $(document.createElement('textarea'));
        $shadowEl.addClass('textarea-resizable-shadow');
        $shadowEl.prop({
          disabled: true,
          readonly: true
        });
        Input.textareaResizableShadow = $shadowEl;
      },
      textareaResizableShadow: undefined,
      resizeTextarea: function resizeTextarea(textareaEl) {
        var app = this;
        var window = getWindow();
        var $textareaEl = $(textareaEl);

        if (!Input.textareaResizableShadow) {
          Input.createTextareaResizableShadow();
        }

        var $shadowEl = Input.textareaResizableShadow;
        if (!$textareaEl.length) return;
        if (!$textareaEl.hasClass('resizable')) return;

        if (Input.textareaResizableShadow.parents().length === 0) {
          app.$el.append($shadowEl);
        }

        var styles = window.getComputedStyle($textareaEl[0]);
        'padding-top padding-bottom padding-left padding-right margin-left margin-right margin-top margin-bottom width font-size font-family font-style font-weight line-height font-variant text-transform letter-spacing border box-sizing display'.split(' ').forEach(function (style) {
          var styleValue = styles[style];

          if ('font-size line-height letter-spacing width'.split(' ').indexOf(style) >= 0) {
            styleValue = styleValue.replace(',', '.');
          }

          $shadowEl.css(style, styleValue);
        });
        var currentHeight = $textareaEl[0].clientHeight;
        $shadowEl.val('');
        var initialHeight = $shadowEl[0].scrollHeight;
        $shadowEl.val($textareaEl.val());
        $shadowEl.css('height', 0);
        var scrollHeight = $shadowEl[0].scrollHeight;

        if (currentHeight !== scrollHeight) {
          if (scrollHeight > initialHeight) {
            $textareaEl.css('height', scrollHeight + "px");
          } else if (scrollHeight < currentHeight) {
            $textareaEl.css('height', '');
          }

          if (scrollHeight > initialHeight || scrollHeight < currentHeight) {
            $textareaEl.trigger('textarea:resize', {
              initialHeight: initialHeight,
              currentHeight: currentHeight,
              scrollHeight: scrollHeight
            });
            app.emit('textareaResize', {
              initialHeight: initialHeight,
              currentHeight: currentHeight,
              scrollHeight: scrollHeight
            });
          }
        }
      },
      validate: function validate(inputEl) {
        var $inputEl = $(inputEl);
        if (!$inputEl.length) return true;
        var $itemInputEl = $inputEl.parents('.item-input');
        var $inputWrapEl = $inputEl.parents('.input');

        function unsetReadonly() {
          if ($inputEl[0].f7ValidateReadonly) {
            $inputEl[0].readOnly = false;
          }
        }

        function setReadonly() {
          if ($inputEl[0].f7ValidateReadonly) {
            $inputEl[0].readOnly = true;
          }
        }

        unsetReadonly();
        var validity = $inputEl[0].validity;
        var validationMessage = $inputEl.dataset().errorMessage || $inputEl[0].validationMessage || '';

        if (!validity) {
          setReadonly();
          return true;
        }

        if (!validity.valid) {
          var $errorEl = $inputEl.nextAll('.item-input-error-message, .input-error-message');

          if (validationMessage) {
            if ($errorEl.length === 0) {
              $errorEl = $("<div class=\"" + ($inputWrapEl.length ? 'input-error-message' : 'item-input-error-message') + "\"></div>");
              $errorEl.insertAfter($inputEl);
            }

            $errorEl.text(validationMessage);
          }

          if ($errorEl.length > 0) {
            $itemInputEl.addClass('item-input-with-error-message');
            $inputWrapEl.addClass('input-with-error-message');
          }

          $itemInputEl.addClass('item-input-invalid');
          $inputWrapEl.addClass('input-invalid');
          $inputEl.addClass('input-invalid');
          setReadonly();
          return false;
        }

        $itemInputEl.removeClass('item-input-invalid item-input-with-error-message');
        $inputWrapEl.removeClass('input-invalid input-with-error-message');
        $inputEl.removeClass('input-invalid');
        setReadonly();
        return true;
      },
      validateInputs: function validateInputs(el) {
        var app = this;
        var validates = $(el).find('input, textarea, select').map(function (inputEl) {
          return app.input.validate(inputEl);
        });
        return validates.indexOf(false) < 0;
      },
      focus: function focus(inputEl) {
        var $inputEl = $(inputEl);
        var type = $inputEl.attr('type');
        if (Input.ignoreTypes.indexOf(type) >= 0) return;
        $inputEl.parents('.item-input').addClass('item-input-focused');
        $inputEl.parents('.input').addClass('input-focused');
        $inputEl.addClass('input-focused');
      },
      blur: function blur(inputEl) {
        var $inputEl = $(inputEl);
        $inputEl.parents('.item-input').removeClass('item-input-focused');
        $inputEl.parents('.input').removeClass('input-focused');
        $inputEl.removeClass('input-focused');
      },
      checkEmptyState: function checkEmptyState(inputEl) {
        var app = this;
        var $inputEl = $(inputEl);

        if (!$inputEl.is('input, select, textarea, .item-input [contenteditable]')) {
          $inputEl = $inputEl.find('input, select, textarea, .item-input [contenteditable]').eq(0);
        }

        if (!$inputEl.length) return;
        var isContentEditable = $inputEl[0].hasAttribute('contenteditable');
        var value;

        if (isContentEditable) {
          if ($inputEl.find('.text-editor-placeholder').length) value = '';else value = $inputEl.html();
        } else {
          value = $inputEl.val();
        }

        var $itemInputEl = $inputEl.parents('.item-input');
        var $inputWrapEl = $inputEl.parents('.input');

        if (value && typeof value === 'string' && value.trim() !== '' || Array.isArray(value) && value.length > 0) {
          $itemInputEl.addClass('item-input-with-value');
          $inputWrapEl.addClass('input-with-value');
          $inputEl.addClass('input-with-value');
          $inputEl.trigger('input:notempty');
          app.emit('inputNotEmpty', $inputEl[0]);
        } else {
          $itemInputEl.removeClass('item-input-with-value');
          $inputWrapEl.removeClass('input-with-value');
          $inputEl.removeClass('input-with-value');
          $inputEl.trigger('input:empty');
          app.emit('inputEmpty', $inputEl[0]);
        }
      },
      scrollIntoView: function scrollIntoView(inputEl, duration, centered, force) {
        if (duration === void 0) {
          duration = 0;
        }

        var $inputEl = $(inputEl);
        var $scrollableEl = $inputEl.parents('.page-content, .panel, .card-expandable .card-content').eq(0);

        if (!$scrollableEl.length) {
          return false;
        }

        var contentHeight = $scrollableEl[0].offsetHeight;
        var contentScrollTop = $scrollableEl[0].scrollTop;
        var contentPaddingTop = parseInt($scrollableEl.css('padding-top'), 10);
        var contentPaddingBottom = parseInt($scrollableEl.css('padding-bottom'), 10);
        var contentOffsetTop = $scrollableEl.offset().top - contentScrollTop;
        var inputOffsetTop = $inputEl.offset().top - contentOffsetTop;
        var inputHeight = $inputEl[0].offsetHeight;
        var min = inputOffsetTop + contentScrollTop - contentPaddingTop;
        var max = inputOffsetTop + contentScrollTop - contentHeight + contentPaddingBottom + inputHeight;
        var centeredPosition = min + (max - min) / 2;

        if (contentScrollTop > min) {
          $scrollableEl.scrollTop(centered ? centeredPosition : min, duration);
          return true;
        }

        if (contentScrollTop < max) {
          $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
          return true;
        }

        if (force) {
          $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
        }

        return false;
      },
      init: function init() {
        var app = this;
        var device = getDevice$1();
        var window = getWindow();
        var document = getDocument();
        Input.createTextareaResizableShadow();

        function onFocus() {
          var inputEl = this;

          if (app.params.input.scrollIntoViewOnFocus) {
            if (device.android) {
              $(window).once('resize', function () {
                if (document && document.activeElement === inputEl) {
                  app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewDuration, app.params.input.scrollIntoViewCentered, app.params.input.scrollIntoViewAlways);
                }
              });
            } else {
              app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewDuration, app.params.input.scrollIntoViewCentered, app.params.input.scrollIntoViewAlways);
            }
          }

          app.input.focus(inputEl);
        }

        function onBlur() {
          var $inputEl = $(this);
          var tag = $inputEl[0].nodeName.toLowerCase();
          app.input.blur($inputEl);

          if ($inputEl.dataset().validate || $inputEl.attr('validate') !== null || $inputEl.attr('data-validate-on-blur') !== null) {
            app.input.validate($inputEl);
          } // Resize textarea


          if (tag === 'textarea' && $inputEl.hasClass('resizable')) {
            if (Input.textareaResizableShadow) Input.textareaResizableShadow.remove();
          }
        }

        function onChange() {
          var $inputEl = $(this);
          var type = $inputEl.attr('type');
          var tag = $inputEl[0].nodeName.toLowerCase();
          var isContentEditable = $inputEl[0].hasAttribute('contenteditable');
          if (Input.ignoreTypes.indexOf(type) >= 0) return; // Check Empty State

          app.input.checkEmptyState($inputEl);
          if (isContentEditable) return; // Check validation

          if ($inputEl.attr('data-validate-on-blur') === null && ($inputEl.dataset().validate || $inputEl.attr('validate') !== null)) {
            app.input.validate($inputEl);
          } // Resize textarea


          if (tag === 'textarea' && $inputEl.hasClass('resizable')) {
            app.input.resizeTextarea($inputEl);
          }
        }

        function onInvalid(e) {
          var $inputEl = $(this);

          if ($inputEl.attr('data-validate-on-blur') === null && ($inputEl.dataset().validate || $inputEl.attr('validate') !== null)) {
            e.preventDefault();
            app.input.validate($inputEl);
          }
        }

        function clearInput() {
          var $clicked = $(this);
          var $inputEl = $clicked.siblings('input, textarea').eq(0);
          var previousValue = $inputEl.val();
          $inputEl.val('').trigger('input change').focus().trigger('input:clear', previousValue);
          app.emit('inputClear', previousValue);
        }

        function preventDefault(e) {
          e.preventDefault();
        }

        $(document).on('click', '.input-clear-button', clearInput);
        $(document).on('mousedown', '.input-clear-button', preventDefault);
        $(document).on('change input', 'input, textarea, select, .item-input [contenteditable]', onChange, true);
        $(document).on('focus', 'input, textarea, select, .item-input [contenteditable]', onFocus, true);
        $(document).on('blur', 'input, textarea, select, .item-input [contenteditable]', onBlur, true);
        $(document).on('invalid', 'input, textarea, select', onInvalid, true);
      }
    };
    var Input$1 = {
      name: 'input',
      params: {
        input: {
          scrollIntoViewOnFocus: undefined,
          scrollIntoViewCentered: false,
          scrollIntoViewDuration: 0,
          scrollIntoViewAlways: false
        }
      },
      create: function create() {
        var app = this;

        if (typeof app.params.input.scrollIntoViewOnFocus === 'undefined') {
          app.params.input.scrollIntoViewOnFocus = getDevice$1().android;
        }

        bindMethods(app, {
          input: Input
        });
      },
      on: {
        init: function init() {
          var app = this;
          app.input.init();
        },
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          var $tabEl = $(tabEl);
          $tabEl.find('.item-input, .input').each(function (itemInputEl) {
            var $itemInputEl = $(itemInputEl);
            $itemInputEl.find('input, select, textarea, [contenteditable]').each(function (inputEl) {
              var $inputEl = $(inputEl);
              if (Input.ignoreTypes.indexOf($inputEl.attr('type')) >= 0) return;
              app.input.checkEmptyState($inputEl);
            });
          });
          $tabEl.find('textarea.resizable').each(function (textareaEl) {
            app.input.resizeTextarea(textareaEl);
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          var $pageEl = page.$el;
          $pageEl.find('.item-input, .input').each(function (itemInputEl) {
            var $itemInputEl = $(itemInputEl);
            $itemInputEl.find('input, select, textarea, [contenteditable]').each(function (inputEl) {
              var $inputEl = $(inputEl);
              if (Input.ignoreTypes.indexOf($inputEl.attr('type')) >= 0) return;
              app.input.checkEmptyState($inputEl);
            });
          });
          $pageEl.find('textarea.resizable').each(function (textareaEl) {
            app.input.resizeTextarea(textareaEl);
          });
        },
        'panelBreakpoint panelCollapsedBreakpoint panelResize panelOpen panelSwipeOpen resize viewMasterDetailBreakpoint': function onPanelOpen(instance) {
          var app = this;

          if (instance && instance.$el) {
            instance.$el.find('textarea.resizable').each(function (textareaEl) {
              app.input.resizeTextarea(textareaEl);
            });
          } else {
            $('textarea.resizable').each(function (textareaEl) {
              app.input.resizeTextarea(textareaEl);
            });
          }
        }
      }
    };

    var Checkbox = {
      name: 'checkbox'
    };

    var Radio = {
      name: 'radio'
    };

    function _assertThisInitialized$g(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$g(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$g(subClass, superClass); }

    function _setPrototypeOf$g(o, p) { _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$g(o, p); }

    var Toggle$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$g(Toggle, _Framework7Class);

      function Toggle(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params, [app]) || this;

        var toggle = _assertThisInitialized$g(_this);

        var support = getSupport$1();
        var defaults = {}; // Extend defaults with modules params

        toggle.useModulesParams(defaults);
        toggle.params = extend$2(defaults, params);
        var el = toggle.params.el;
        if (!el) return toggle || _assertThisInitialized$g(_this);
        var $el = $(el);
        if ($el.length === 0) return toggle || _assertThisInitialized$g(_this);
        if ($el[0].f7Toggle) return $el[0].f7Toggle || _assertThisInitialized$g(_this);
        var $inputEl = $el.children('input[type="checkbox"]');
        extend$2(toggle, {
          app: app,
          $el: $el,
          el: $el[0],
          $inputEl: $inputEl,
          inputEl: $inputEl[0],
          disabled: $el.hasClass('disabled') || $inputEl.hasClass('disabled') || $inputEl.attr('disabled') || $inputEl[0].disabled
        });
        Object.defineProperty(toggle, 'checked', {
          enumerable: true,
          configurable: true,
          set: function set(checked) {
            if (!toggle || typeof toggle.$inputEl === 'undefined') return;
            if (toggle.checked === checked) return;
            $inputEl[0].checked = checked;
            toggle.$inputEl.trigger('change');
          },
          get: function get() {
            return $inputEl[0].checked;
          }
        });
        $el[0].f7Toggle = toggle;
        var isTouched;
        var touchesStart = {};
        var isScrolling;
        var touchesDiff;
        var toggleWidth;
        var touchStartTime;
        var touchStartChecked;

        function handleTouchStart(e) {
          if (isTouched || toggle.disabled) return;
          touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
          touchesDiff = 0;
          isTouched = true;
          isScrolling = undefined;
          touchStartTime = now$2();
          touchStartChecked = toggle.checked;
          toggleWidth = $el[0].offsetWidth;
          nextTick$1(function () {
            if (isTouched) {
              $el.addClass('toggle-active-state');
            }
          });
        }

        function handleTouchMove(e) {
          if (!isTouched || toggle.disabled) return;
          var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
          var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
          var inverter = app.rtl ? -1 : 1;

          if (typeof isScrolling === 'undefined') {
            isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
          }

          if (isScrolling) {
            isTouched = false;
            return;
          }

          e.preventDefault();
          touchesDiff = pageX - touchesStart.x;
          var changed;

          if (touchesDiff * inverter < 0 && Math.abs(touchesDiff) > toggleWidth / 3 && touchStartChecked) {
            changed = true;
          }

          if (touchesDiff * inverter > 0 && Math.abs(touchesDiff) > toggleWidth / 3 && !touchStartChecked) {
            changed = true;
          }

          if (changed) {
            touchesStart.x = pageX;
            toggle.checked = !touchStartChecked;
            touchStartChecked = !touchStartChecked;
          }
        }

        function handleTouchEnd() {
          if (!isTouched || toggle.disabled) {
            if (isScrolling) $el.removeClass('toggle-active-state');
            isTouched = false;
            return;
          }

          var inverter = app.rtl ? -1 : 1;
          isTouched = false;
          $el.removeClass('toggle-active-state');
          var changed;

          if (now$2() - touchStartTime < 300) {
            if (touchesDiff * inverter < 0 && touchStartChecked) {
              changed = true;
            }

            if (touchesDiff * inverter > 0 && !touchStartChecked) {
              changed = true;
            }

            if (changed) {
              toggle.checked = !touchStartChecked;
            }
          }
        }

        function handleInputChange() {
          toggle.$el.trigger('toggle:change');
          toggle.emit('local::change toggleChange', toggle);
        }

        toggle.attachEvents = function attachEvents() {
          var passive = support.passiveListener ? {
            passive: true
          } : false;
          $el.on(app.touchEvents.start, handleTouchStart, passive);
          app.on('touchmove', handleTouchMove);
          app.on('touchend:passive', handleTouchEnd);
          toggle.$inputEl.on('change', handleInputChange);
        };

        toggle.detachEvents = function detachEvents() {
          var passive = support.passiveListener ? {
            passive: true
          } : false;
          $el.off(app.touchEvents.start, handleTouchStart, passive);
          app.off('touchmove', handleTouchMove);
          app.off('touchend:passive', handleTouchEnd);
          toggle.$inputEl.off('change', handleInputChange);
        }; // Install Modules


        toggle.useModules(); // Init

        toggle.init();
        return _this;
      }

      var _proto = Toggle.prototype;

      _proto.toggle = function toggle() {
        var toggle = this;
        toggle.checked = !toggle.checked;
      };

      _proto.init = function init() {
        var toggle = this;
        toggle.attachEvents();
      };

      _proto.destroy = function destroy() {
        var toggle = this;
        toggle.$el.trigger('toggle:beforedestroy');
        toggle.emit('local::beforeDestroy toggleBeforeDestroy', toggle);
        delete toggle.$el[0].f7Toggle;
        toggle.detachEvents();
        deleteProps$1(toggle);
        toggle = null;
      };

      return Toggle;
    }(Framework7Class$1);

    var Toggle$2 = Toggle$1;

    var Toggle = {
      name: 'toggle',
      create: function create() {
        var app = this;
        app.toggle = ConstructorMethods({
          defaultSelector: '.toggle',
          constructor: Toggle$2,
          app: app,
          domProp: 'f7Toggle'
        });
      },
      static: {
        Toggle: Toggle$2
      },
      on: {
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.toggle-init').each(function (toggleEl) {
            return app.toggle.create({
              el: toggleEl
            });
          });
        },
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          $(tabEl).find('.toggle-init').each(function (toggleEl) {
            if (toggleEl.f7Toggle) toggleEl.f7Toggle.destroy();
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.toggle-init').each(function (toggleEl) {
            return app.toggle.create({
              el: toggleEl
            });
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          page.$el.find('.toggle-init').each(function (toggleEl) {
            if (toggleEl.f7Toggle) toggleEl.f7Toggle.destroy();
          });
        }
      },
      vnode: {
        'toggle-init': {
          insert: function insert(vnode) {
            var app = this;
            var toggleEl = vnode.elm;
            app.toggle.create({
              el: toggleEl
            });
          },
          destroy: function destroy(vnode) {
            var toggleEl = vnode.elm;
            if (toggleEl.f7Toggle) toggleEl.f7Toggle.destroy();
          }
        }
      }
    };

    function _assertThisInitialized$f(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$f(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$f(subClass, superClass); }

    function _setPrototypeOf$f(o, p) { _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$f(o, p); }

    var Range$2 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$f(Range, _Framework7Class);

      function Range(app, params) {
        var _this;

        _this = _Framework7Class.call(this, params, [app]) || this;

        var range = _assertThisInitialized$f(_this);

        var support = getSupport$1();
        var defaults = {
          el: null,
          inputEl: null,
          dual: false,
          step: 1,
          label: false,
          min: 0,
          max: 100,
          value: 0,
          draggableBar: true,
          vertical: false,
          verticalReversed: false,
          formatLabel: null,
          scale: false,
          scaleSteps: 5,
          scaleSubSteps: 0,
          formatScaleLabel: null,
          limitKnobPosition: app.theme === 'ios'
        }; // Extend defaults with modules params

        range.useModulesParams(defaults);
        range.params = extend$2(defaults, params);
        var el = range.params.el;
        if (!el) return range || _assertThisInitialized$f(_this);
        var $el = $(el);
        if ($el.length === 0) return range || _assertThisInitialized$f(_this);
        if ($el[0].f7Range) return $el[0].f7Range || _assertThisInitialized$f(_this);
        var dataset = $el.dataset();
        'step min max value scaleSteps scaleSubSteps'.split(' ').forEach(function (paramName) {
          if (typeof params[paramName] === 'undefined' && typeof dataset[paramName] !== 'undefined') {
            range.params[paramName] = parseFloat(dataset[paramName]);
          }
        });
        'dual label vertical verticalReversed scale'.split(' ').forEach(function (paramName) {
          if (typeof params[paramName] === 'undefined' && typeof dataset[paramName] !== 'undefined') {
            range.params[paramName] = dataset[paramName];
          }
        });

        if (!range.params.value) {
          if (typeof dataset.value !== 'undefined') range.params.value = dataset.value;

          if (typeof dataset.valueLeft !== 'undefined' && typeof dataset.valueRight !== 'undefined') {
            range.params.value = [parseFloat(dataset.valueLeft), parseFloat(dataset.valueRight)];
          }
        }

        var $inputEl;

        if (!range.params.dual) {
          if (range.params.inputEl) {
            $inputEl = $(range.params.inputEl);
          } else if ($el.find('input[type="range"]').length) {
            $inputEl = $el.find('input[type="range"]').eq(0);
          }
        }

        var _range$params = range.params,
            dual = _range$params.dual,
            step = _range$params.step,
            label = _range$params.label,
            min = _range$params.min,
            max = _range$params.max,
            value = _range$params.value,
            vertical = _range$params.vertical,
            verticalReversed = _range$params.verticalReversed,
            scale = _range$params.scale,
            scaleSteps = _range$params.scaleSteps,
            scaleSubSteps = _range$params.scaleSubSteps,
            limitKnobPosition = _range$params.limitKnobPosition;
        extend$2(range, {
          app: app,
          $el: $el,
          el: $el[0],
          $inputEl: $inputEl,
          inputEl: $inputEl ? $inputEl[0] : undefined,
          dual: dual,
          step: step,
          label: label,
          min: min,
          max: max,
          value: value,
          previousValue: value,
          vertical: vertical,
          verticalReversed: verticalReversed,
          scale: scale,
          scaleSteps: scaleSteps,
          scaleSubSteps: scaleSubSteps,
          limitKnobPosition: limitKnobPosition
        });

        if ($inputEl) {
          'step min max'.split(' ').forEach(function (paramName) {
            if (!params[paramName] && $inputEl.attr(paramName)) {
              range.params[paramName] = parseFloat($inputEl.attr(paramName));
              range[paramName] = parseFloat($inputEl.attr(paramName));
            }
          });

          if (typeof $inputEl.val() !== 'undefined') {
            range.params.value = parseFloat($inputEl.val());
            range.value = parseFloat($inputEl.val());
          }
        } // Dual


        if (range.dual) {
          $el.addClass('range-slider-dual');
        }

        if (range.label) {
          $el.addClass('range-slider-label');
        } // Vertical


        if (range.vertical) {
          $el.addClass('range-slider-vertical');

          if (range.verticalReversed) {
            $el.addClass('range-slider-vertical-reversed');
          }
        } else {
          $el.addClass('range-slider-horizontal');
        } // Check for layout


        var $barEl = $('<div class="range-bar"></div>');
        var $barActiveEl = $('<div class="range-bar-active"></div>');
        $barEl.append($barActiveEl); // Create Knobs
        // prettier-ignore

        var knobHTML = "\n      <div class=\"range-knob-wrap\">\n        <div class=\"range-knob\"></div>\n        " + (range.label ? '<div class="range-knob-label"></div>' : '') + "\n      </div>\n    ";
        var knobs = [$(knobHTML)];

        if (range.dual) {
          knobs.push($(knobHTML));
        }

        $el.append($barEl);
        knobs.forEach(function ($knobEl) {
          $el.append($knobEl);
        }); // Labels

        var labels = [];

        if (range.label) {
          labels.push(knobs[0].find('.range-knob-label'));

          if (range.dual) {
            labels.push(knobs[1].find('.range-knob-label'));
          }
        } // Scale


        var $scaleEl;

        if (range.scale && range.scaleSteps >= 1) {
          $scaleEl = $("\n        <div class=\"range-scale\">\n          " + range.renderScale() + "\n        </div>\n      ");
          $el.append($scaleEl);
        }

        extend$2(range, {
          knobs: knobs,
          labels: labels,
          $barEl: $barEl,
          $barActiveEl: $barActiveEl,
          $scaleEl: $scaleEl
        });
        $el[0].f7Range = range; // Touch Events

        var isTouched;
        var touchesStart = {};
        var isScrolling;
        var rangeOffset;
        var rangeOffsetLeft;
        var rangeOffsetTop;
        var $touchedKnobEl;
        var dualValueIndex;
        var valueChangedByTouch;
        var targetTouchIdentifier;

        function onTouchChange() {
          valueChangedByTouch = true;
        }

        function handleTouchStart(e) {
          if (isTouched) return;

          if (!range.params.draggableBar) {
            if ($(e.target).closest('.range-knob').length === 0) {
              return;
            }
          }

          valueChangedByTouch = false;
          touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;

          if (e.type === 'touchstart') {
            targetTouchIdentifier = e.targetTouches[0].identifier;
          }

          isTouched = true;
          isScrolling = undefined;
          rangeOffset = $el.offset();
          rangeOffsetLeft = rangeOffset.left;
          rangeOffsetTop = rangeOffset.top;
          var progress;

          if (range.vertical) {
            progress = (touchesStart.y - rangeOffsetTop) / range.rangeHeight;
            if (!range.verticalReversed) progress = 1 - progress;
          } else if (range.app.rtl) {
            progress = (rangeOffsetLeft + range.rangeWidth - touchesStart.x) / range.rangeWidth;
          } else {
            progress = (touchesStart.x - rangeOffsetLeft) / range.rangeWidth;
          }

          var newValue = progress * (range.max - range.min) + range.min;

          if (range.dual) {
            if (Math.abs(range.value[0] - newValue) < Math.abs(range.value[1] - newValue)) {
              dualValueIndex = 0;
              $touchedKnobEl = range.knobs[0];
              newValue = [newValue, range.value[1]];
            } else {
              dualValueIndex = 1;
              $touchedKnobEl = range.knobs[1];
              newValue = [range.value[0], newValue];
            }
          } else {
            $touchedKnobEl = range.knobs[0];
            newValue = progress * (range.max - range.min) + range.min;
          }

          nextTick$1(function () {
            if (isTouched) $touchedKnobEl.addClass('range-knob-active-state');
          }, 70);
          range.on('change', onTouchChange);
          range.setValue(newValue, true);
        }

        function handleTouchMove(e) {
          if (!isTouched) return;
          var pageX;
          var pageY;

          if (e.type === 'touchmove') {
            for (var i = 0; i < e.targetTouches.length; i += 1) {
              if (e.targetTouches[i].identifier === targetTouchIdentifier) {
                pageX = e.targetTouches[i].pageX;
                pageY = e.targetTouches[i].pageY;
              }
            }
          } else {
            pageX = e.pageX;
            pageY = e.pageY;
          }

          if (typeof pageX === 'undefined' && typeof pageY === 'undefined') return;

          if (typeof isScrolling === 'undefined' && !range.vertical) {
            isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
          }

          if (isScrolling) {
            isTouched = false;
            return;
          }

          e.preventDefault();
          var progress;

          if (range.vertical) {
            progress = (pageY - rangeOffsetTop) / range.rangeHeight;
            if (!range.verticalReversed) progress = 1 - progress;
          } else if (range.app.rtl) {
            progress = (rangeOffsetLeft + range.rangeWidth - pageX) / range.rangeWidth;
          } else {
            progress = (pageX - rangeOffsetLeft) / range.rangeWidth;
          }

          var newValue = progress * (range.max - range.min) + range.min;

          if (range.dual) {
            var leftValue;
            var rightValue;

            if (dualValueIndex === 0) {
              leftValue = newValue;
              rightValue = range.value[1];

              if (leftValue > rightValue) {
                rightValue = leftValue;
              }
            } else {
              leftValue = range.value[0];
              rightValue = newValue;

              if (rightValue < leftValue) {
                leftValue = rightValue;
              }
            }

            newValue = [leftValue, rightValue];
          }

          range.setValue(newValue, true);
        }

        function handleTouchEnd(e) {
          if (e.type === 'touchend') {
            var touchEnded;

            for (var i = 0; i < e.changedTouches.length; i += 1) {
              if (e.changedTouches[i].identifier === targetTouchIdentifier) touchEnded = true;
            }

            if (!touchEnded) return;
          }

          if (!isTouched) {
            if (isScrolling) $touchedKnobEl.removeClass('range-knob-active-state');
            isTouched = false;
            return;
          }

          range.off('change', onTouchChange);
          isTouched = false;
          $touchedKnobEl.removeClass('range-knob-active-state');

          if (valueChangedByTouch && range.$inputEl && !range.dual) {
            range.$inputEl.trigger('change');
          }

          valueChangedByTouch = false;

          if (typeof range.previousValue !== 'undefined') {
            if (range.dual && (range.previousValue[0] !== range.value[0] || range.previousValue[1] !== range.value[1]) || !range.dual && range.previousValue !== range.value) {
              range.$el.trigger('range:changed', range.value);
              range.emit('local::changed rangeChanged', range, range.value);
            }
          }
        }

        function handleResize() {
          range.calcSize();
          range.layout();
        }

        var parentModals;
        var parentPanel;
        var parentPage;

        range.attachEvents = function attachEvents() {
          var passive = support.passiveListener ? {
            passive: true
          } : false;
          range.$el.on(app.touchEvents.start, handleTouchStart, passive);
          app.on('touchmove', handleTouchMove);
          app.on('touchend:passive', handleTouchEnd);
          app.on('tabShow', handleResize);
          app.on('resize', handleResize);
          parentModals = range.$el.parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast');
          parentModals.on('modal:open', handleResize);
          parentPanel = range.$el.parents('.panel');
          parentPanel.on('panel:open panel:resize', handleResize);
          parentPage = range.$el.parents('.page').eq(0);
          parentPage.on('page:reinit', handleResize);
        };

        range.detachEvents = function detachEvents() {
          var passive = support.passiveListener ? {
            passive: true
          } : false;
          range.$el.off(app.touchEvents.start, handleTouchStart, passive);
          app.off('touchmove', handleTouchMove);
          app.off('touchend:passive', handleTouchEnd);
          app.off('tabShow', handleResize);
          app.off('resize', handleResize);

          if (parentModals) {
            parentModals.off('modal:open', handleResize);
          }

          if (parentPanel) {
            parentPanel.off('panel:open panel:resize', handleResize);
          }

          if (parentPage) {
            parentPage.off('page:reinit', handleResize);
          }

          parentModals = null;
          parentPanel = null;
          parentPage = null;
        }; // Install Modules


        range.useModules(); // Init

        range.init();
        return range || _assertThisInitialized$f(_this);
      }

      var _proto = Range.prototype;

      _proto.calcSize = function calcSize() {
        var range = this;

        if (range.vertical) {
          var height = range.$el.outerHeight();
          if (height === 0) return;
          range.rangeHeight = height;
          range.knobHeight = range.knobs[0].outerHeight();
        } else {
          var width = range.$el.outerWidth();
          if (width === 0) return;
          range.rangeWidth = width;
          range.knobWidth = range.knobs[0].outerWidth();
        }
      };

      _proto.layout = function layout() {
        var range = this;
        var app = range.app,
            knobWidth = range.knobWidth,
            knobHeight = range.knobHeight,
            rangeWidth = range.rangeWidth,
            rangeHeight = range.rangeHeight,
            min = range.min,
            max = range.max,
            knobs = range.knobs,
            $barActiveEl = range.$barActiveEl,
            value = range.value,
            label = range.label,
            labels = range.labels,
            vertical = range.vertical,
            verticalReversed = range.verticalReversed,
            limitKnobPosition = range.limitKnobPosition;
        var knobSize = vertical ? knobHeight : knobWidth;
        var rangeSize = vertical ? rangeHeight : rangeWidth; // eslint-disable-next-line

        var positionProperty = vertical ? verticalReversed ? 'top' : 'bottom' : app.rtl ? 'right' : 'left';

        if (range.dual) {
          var _$barActiveEl$css;

          var progress = [(value[0] - min) / (max - min), (value[1] - min) / (max - min)];
          $barActiveEl.css((_$barActiveEl$css = {}, _$barActiveEl$css[positionProperty] = progress[0] * 100 + "%", _$barActiveEl$css[vertical ? 'height' : 'width'] = (progress[1] - progress[0]) * 100 + "%", _$barActiveEl$css));
          knobs.forEach(function ($knobEl, knobIndex) {
            var startPos = rangeSize * progress[knobIndex];

            if (limitKnobPosition) {
              var realStartPos = rangeSize * progress[knobIndex] - knobSize / 2;
              if (realStartPos < 0) startPos = knobSize / 2;
              if (realStartPos + knobSize > rangeSize) startPos = rangeSize - knobSize / 2;
            }

            $knobEl.css(positionProperty, startPos + "px");
            if (label) labels[knobIndex].text(range.formatLabel(value[knobIndex], labels[knobIndex][0]));
          });
        } else {
          var _progress = (value - min) / (max - min);

          $barActiveEl.css(vertical ? 'height' : 'width', _progress * 100 + "%");
          var startPos = rangeSize * _progress;

          if (limitKnobPosition) {
            var realStartPos = rangeSize * _progress - knobSize / 2;
            if (realStartPos < 0) startPos = knobSize / 2;
            if (realStartPos + knobSize > rangeSize) startPos = rangeSize - knobSize / 2;
          }

          knobs[0].css(positionProperty, startPos + "px");
          if (label) labels[0].text(range.formatLabel(value, labels[0][0]));
        }

        if (range.dual && value.indexOf(min) >= 0 || !range.dual && value === min) {
          range.$el.addClass('range-slider-min');
        } else {
          range.$el.removeClass('range-slider-min');
        }

        if (range.dual && value.indexOf(max) >= 0 || !range.dual && value === max) {
          range.$el.addClass('range-slider-max');
        } else {
          range.$el.removeClass('range-slider-max');
        }
      };

      _proto.setValue = function setValue(newValue, byTouchMove) {
        var range = this;
        var step = range.step,
            min = range.min,
            max = range.max;
        var valueChanged;
        var oldValue;

        if (range.dual) {
          oldValue = [range.value[0], range.value[1]];
          var newValues = newValue;
          if (!Array.isArray(newValues)) newValues = [newValue, newValue];

          if (newValue[0] > newValue[1]) {
            newValues = [newValues[0], newValues[0]];
          }

          newValues = newValues.map(function (value) {
            return Math.max(Math.min(Math.round(value / step) * step, max), min);
          });

          if (newValues[0] === range.value[0] && newValues[1] === range.value[1]) {
            return range;
          }

          newValues.forEach(function (value, valueIndex) {
            range.value[valueIndex] = value;
          });
          valueChanged = oldValue[0] !== newValues[0] || oldValue[1] !== newValues[1];
          range.layout();
        } else {
          oldValue = range.value;
          var value = Math.max(Math.min(Math.round(newValue / step) * step, max), min);
          range.value = value;
          range.layout();
          valueChanged = oldValue !== value;
        }

        if (valueChanged) {
          range.previousValue = oldValue;
        } // Events


        if (!valueChanged) return range;
        range.$el.trigger('range:change', range.value);

        if (range.$inputEl && !range.dual) {
          range.$inputEl.val(range.value);

          if (!byTouchMove) {
            range.$inputEl.trigger('input change');
          } else {
            range.$inputEl.trigger('input');
          }
        }

        if (!byTouchMove) {
          range.$el.trigger('range:changed', range.value);
          range.emit('local::changed rangeChanged', range, range.value);
        }

        range.emit('local::change rangeChange', range, range.value);
        return range;
      };

      _proto.getValue = function getValue() {
        return this.value;
      };

      _proto.formatLabel = function formatLabel(value, labelEl) {
        var range = this;
        if (range.params.formatLabel) return range.params.formatLabel.call(range, value, labelEl);
        return value;
      };

      _proto.formatScaleLabel = function formatScaleLabel(value) {
        var range = this;
        if (range.params.formatScaleLabel) return range.params.formatScaleLabel.call(range, value);
        return value;
      };

      _proto.renderScale = function renderScale() {
        var range = this;
        var app = range.app,
            verticalReversed = range.verticalReversed,
            vertical = range.vertical; // eslint-disable-next-line

        var positionProperty = vertical ? verticalReversed ? 'top' : 'bottom' : app.rtl ? 'right' : 'left';
        var html = '';
        Array.from({
          length: range.scaleSteps + 1
        }).forEach(function (scaleEl, index) {
          var scaleStepValue = (range.max - range.min) / range.scaleSteps;
          var scaleValue = range.min + scaleStepValue * index;
          var progress = (scaleValue - range.min) / (range.max - range.min);
          html += "<div class=\"range-scale-step\" style=\"" + positionProperty + ": " + progress * 100 + "%\">" + range.formatScaleLabel(scaleValue) + "</div>";

          if (range.scaleSubSteps && range.scaleSubSteps > 1 && index < range.scaleSteps) {
            Array.from({
              length: range.scaleSubSteps - 1
            }).forEach(function (subStepEl, subIndex) {
              var subStep = scaleStepValue / range.scaleSubSteps;
              var scaleSubValue = scaleValue + subStep * (subIndex + 1);
              var subProgress = (scaleSubValue - range.min) / (range.max - range.min);
              html += "<div class=\"range-scale-step range-scale-substep\" style=\"" + positionProperty + ": " + subProgress * 100 + "%\"></div>";
            });
          }
        });
        return html;
      };

      _proto.updateScale = function updateScale() {
        var range = this;

        if (!range.scale || range.scaleSteps < 1) {
          if (range.$scaleEl) range.$scaleEl.remove();
          delete range.$scaleEl;
          return;
        }

        if (!range.$scaleEl) {
          range.$scaleEl = $('<div class="range-scale"></div>');
          range.$el.append(range.$scaleEl);
        }

        range.$scaleEl.html(range.renderScale());
      };

      _proto.init = function init() {
        var range = this;
        range.calcSize();
        range.layout();
        range.attachEvents();
        return range;
      };

      _proto.destroy = function destroy() {
        var range = this;
        range.$el.trigger('range:beforedestroy');
        range.emit('local::beforeDestroy rangeBeforeDestroy', range);
        delete range.$el[0].f7Range;
        range.detachEvents();
        deleteProps$1(range);
        range = null;
      };

      return Range;
    }(Framework7Class$1);

    var Range$3 = Range$2;

    var Range$1 = {
      name: 'range',
      create: function create() {
        var app = this;
        app.range = extend$2(ConstructorMethods({
          defaultSelector: '.range-slider',
          constructor: Range$3,
          app: app,
          domProp: 'f7Range'
        }), {
          getValue: function getValue(el) {
            if (el === void 0) {
              el = '.range-slider';
            }

            var range = app.range.get(el);
            if (range) return range.getValue();
            return undefined;
          },
          setValue: function setValue(el, value) {
            if (el === void 0) {
              el = '.range-slider';
            }

            var range = app.range.get(el);
            if (range) return range.setValue(value);
            return undefined;
          }
        });
      },
      static: {
        Range: Range$3
      },
      on: {
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.range-slider-init').each(function (rangeEl) {
            return new Range$3(app, {
              el: rangeEl
            });
          });
        },
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          $(tabEl).find('.range-slider-init').each(function (rangeEl) {
            if (rangeEl.f7Range) rangeEl.f7Range.destroy();
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.range-slider-init').each(function (rangeEl) {
            return new Range$3(app, {
              el: rangeEl
            });
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          page.$el.find('.range-slider-init').each(function (rangeEl) {
            if (rangeEl.f7Range) rangeEl.f7Range.destroy();
          });
        }
      },
      vnode: {
        'range-slider-init': {
          insert: function insert(vnode) {
            var rangeEl = vnode.elm;
            var app = this;
            app.range.create({
              el: rangeEl
            });
          },
          destroy: function destroy(vnode) {
            var rangeEl = vnode.elm;
            if (rangeEl.f7Range) rangeEl.f7Range.destroy();
          }
        }
      }
    };

    function _assertThisInitialized$e(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$e(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$e(subClass, superClass); }

    function _setPrototypeOf$e(o, p) { _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$e(o, p); }

    var Stepper$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$e(Stepper, _Framework7Class);

      function Stepper(app, params) {
        var _this;

        _this = _Framework7Class.call(this, params, [app]) || this;

        var stepper = _assertThisInitialized$e(_this);

        var defaults = {
          el: null,
          inputEl: null,
          valueEl: null,
          value: 0,
          formatValue: null,
          step: 1,
          min: 0,
          max: 100,
          watchInput: true,
          autorepeat: false,
          autorepeatDynamic: false,
          wraps: false,
          manualInputMode: false,
          decimalPoint: 4,
          buttonsEndInputMode: true
        }; // Extend defaults with modules params

        stepper.useModulesParams(defaults);
        stepper.params = extend$2(defaults, params);

        if (stepper.params.value < stepper.params.min) {
          stepper.params.value = stepper.params.min;
        }

        if (stepper.params.value > stepper.params.max) {
          stepper.params.value = stepper.params.max;
        }

        var el = stepper.params.el;
        if (!el) return stepper || _assertThisInitialized$e(_this);
        var $el = $(el);
        if ($el.length === 0) return stepper || _assertThisInitialized$e(_this);
        if ($el[0].f7Stepper) return $el[0].f7Stepper || _assertThisInitialized$e(_this);
        var $inputEl;

        if (stepper.params.inputEl) {
          $inputEl = $(stepper.params.inputEl);
        } else if ($el.find('.stepper-input-wrap').find('input, textarea').length) {
          $inputEl = $el.find('.stepper-input-wrap').find('input, textarea').eq(0);
        }

        if ($inputEl && $inputEl.length) {
          'step min max'.split(' ').forEach(function (paramName) {
            if (!params[paramName] && $inputEl.attr(paramName)) {
              stepper.params[paramName] = parseFloat($inputEl.attr(paramName));
            }
          });

          var _decimalPoint = parseInt(stepper.params.decimalPoint, 10);

          if (Number.isNaN(_decimalPoint)) {
            stepper.params.decimalPoint = 0;
          } else {
            stepper.params.decimalPoint = _decimalPoint;
          }

          var inputValue = parseFloat($inputEl.val());

          if (typeof params.value === 'undefined' && !Number.isNaN(inputValue) && (inputValue || inputValue === 0)) {
            stepper.params.value = inputValue;
          }
        }

        var $valueEl;

        if (stepper.params.valueEl) {
          $valueEl = $(stepper.params.valueEl);
        } else if ($el.find('.stepper-value').length) {
          $valueEl = $el.find('.stepper-value').eq(0);
        }

        var $buttonPlusEl = $el.find('.stepper-button-plus');
        var $buttonMinusEl = $el.find('.stepper-button-minus');
        var _stepper$params = stepper.params,
            step = _stepper$params.step,
            min = _stepper$params.min,
            max = _stepper$params.max,
            value = _stepper$params.value,
            decimalPoint = _stepper$params.decimalPoint;
        extend$2(stepper, {
          app: app,
          $el: $el,
          el: $el[0],
          $buttonPlusEl: $buttonPlusEl,
          buttonPlusEl: $buttonPlusEl[0],
          $buttonMinusEl: $buttonMinusEl,
          buttonMinusEl: $buttonMinusEl[0],
          $inputEl: $inputEl,
          inputEl: $inputEl ? $inputEl[0] : undefined,
          $valueEl: $valueEl,
          valueEl: $valueEl ? $valueEl[0] : undefined,
          step: step,
          min: min,
          max: max,
          value: value,
          decimalPoint: decimalPoint,
          typeModeChanged: false
        });
        $el[0].f7Stepper = stepper; // Handle Events

        var touchesStart = {};
        var isTouched;
        var isScrolling;
        var preventButtonClick;
        var intervalId;
        var timeoutId;
        var autorepeatAction = null;
        var autorepeatInAction = false;
        var manualInput = false;

        function dynamicRepeat(current, progressions, startsIn, progressionStep, repeatEvery, action) {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(function () {
            if (current === 1) {
              preventButtonClick = true;
              autorepeatInAction = true;
            }

            clearInterval(intervalId);
            action();
            intervalId = setInterval(function () {
              action();
            }, repeatEvery);

            if (current < progressions) {
              dynamicRepeat(current + 1, progressions, startsIn, progressionStep, repeatEvery / 2, action);
            }
          }, current === 1 ? startsIn : progressionStep);
        }

        function onTouchStart(e) {
          if (isTouched) return;

          if (manualInput) {
            return;
          }

          if ($(e.target).closest($buttonPlusEl).length) {
            autorepeatAction = 'increment';
          } else if ($(e.target).closest($buttonMinusEl).length) {
            autorepeatAction = 'decrement';
          }

          if (!autorepeatAction) return;
          touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
          isTouched = true;
          isScrolling = undefined;
          var progressions = stepper.params.autorepeatDynamic ? 4 : 1;
          dynamicRepeat(1, progressions, 500, 1000, 300, function () {
            stepper[autorepeatAction]();
          });
        }

        function onTouchMove(e) {
          if (!isTouched) return;

          if (manualInput) {
            return;
          }

          var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
          var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

          if (typeof isScrolling === 'undefined' && !autorepeatInAction) {
            isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
          }

          var distance = Math.pow(Math.pow(pageX - touchesStart.x, 2) + Math.pow(pageY - touchesStart.y, 2), 0.5);

          if (isScrolling || distance > 20) {
            isTouched = false;
            clearTimeout(timeoutId);
            clearInterval(intervalId);
          }
        }

        function onTouchEnd() {
          clearTimeout(timeoutId);
          clearInterval(intervalId);
          autorepeatAction = null;
          autorepeatInAction = false;
          isTouched = false;
        }

        function onMinusClick() {
          if (manualInput) {
            if (stepper.params.buttonsEndInputMode) {
              manualInput = false;
              stepper.endTypeMode(true);
            }

            return;
          }

          if (preventButtonClick) {
            preventButtonClick = false;
            return;
          }

          stepper.decrement(true);
        }

        function onPlusClick() {
          if (manualInput) {
            if (stepper.params.buttonsEndInputMode) {
              manualInput = false;
              stepper.endTypeMode(true);
            }

            return;
          }

          if (preventButtonClick) {
            preventButtonClick = false;
            return;
          }

          stepper.increment(true);
        }

        function onInputClick(e) {
          if (!e.target.readOnly && stepper.params.manualInputMode) {
            manualInput = true;

            if (typeof e.target.selectionStart === 'number') {
              e.target.selectionStart = e.target.value.length;
              e.target.selectionEnd = e.target.value.length;
            }
          }
        }

        function onInputKey(e) {
          if (e.keyCode === 13 || e.which === 13) {
            e.preventDefault();
            manualInput = false;
            stepper.endTypeMode();
          }
        }

        function onInputBlur() {
          manualInput = false;
          stepper.endTypeMode(true);
        }

        function onInput(e) {
          if (manualInput) {
            stepper.typeValue(e.target.value);
            return;
          }

          if (e.detail && e.detail.sentByF7Stepper) return;
          stepper.setValue(e.target.value, true);
        }

        stepper.attachEvents = function attachEvents() {
          $buttonMinusEl.on('click', onMinusClick);
          $buttonPlusEl.on('click', onPlusClick);

          if (stepper.params.watchInput && $inputEl && $inputEl.length) {
            $inputEl.on('input', onInput);
            $inputEl.on('click', onInputClick);
            $inputEl.on('blur', onInputBlur);
            $inputEl.on('keyup', onInputKey);
          }

          if (stepper.params.autorepeat) {
            app.on('touchstart:passive', onTouchStart);
            app.on('touchmove:active', onTouchMove);
            app.on('touchend:passive', onTouchEnd);
          }
        };

        stepper.detachEvents = function detachEvents() {
          $buttonMinusEl.off('click', onMinusClick);
          $buttonPlusEl.off('click', onPlusClick);

          if (stepper.params.watchInput && $inputEl && $inputEl.length) {
            $inputEl.off('input', onInput);
            $inputEl.off('click', onInputClick);
            $inputEl.off('blur', onInputBlur);
            $inputEl.off('keyup', onInputKey);
          }
        }; // Install Modules


        stepper.useModules(); // Init

        stepper.init();
        return stepper || _assertThisInitialized$e(_this);
      }

      var _proto = Stepper.prototype;

      _proto.minus = function minus() {
        return this.decrement();
      };

      _proto.plus = function plus() {
        return this.increment();
      };

      _proto.decrement = function decrement() {
        var stepper = this;
        return stepper.setValue(stepper.value - stepper.step, false, true);
      };

      _proto.increment = function increment() {
        var stepper = this;
        return stepper.setValue(stepper.value + stepper.step, false, true);
      };

      _proto.setValue = function setValue(newValue, forceUpdate, withWraps) {
        var stepper = this;
        var step = stepper.step,
            min = stepper.min,
            max = stepper.max;
        var oldValue = stepper.value;
        var value = Math.round(newValue / step) * step;

        if (stepper.params.wraps && withWraps) {
          if (value > max) value = min;
          if (value < min) value = max;
        } else {
          value = Math.max(Math.min(value, max), min);
        }

        if (Number.isNaN(value)) {
          value = oldValue;
        }

        stepper.value = value;
        var valueChanged = oldValue !== value; // Events

        if (!valueChanged && !forceUpdate) return stepper;
        stepper.$el.trigger('stepper:change', stepper.value);
        var formattedValue = stepper.formatValue(stepper.value);

        if (stepper.$inputEl && stepper.$inputEl.length) {
          stepper.$inputEl.val(formattedValue);
          stepper.$inputEl.trigger('input change', {
            sentByF7Stepper: true
          });
        }

        if (stepper.$valueEl && stepper.$valueEl.length) {
          stepper.$valueEl.html(formattedValue);
        }

        stepper.emit('local::change stepperChange', stepper, stepper.value);
        return stepper;
      };

      _proto.endTypeMode = function endTypeMode(noBlur) {
        var stepper = this;
        var min = stepper.min,
            max = stepper.max;
        var value = parseFloat(stepper.value);
        if (Number.isNaN(value)) value = 0;
        value = Math.max(Math.min(value, max), min);
        stepper.value = value;

        if (!stepper.typeModeChanged) {
          if (stepper.$inputEl && stepper.$inputEl.length && !noBlur) {
            stepper.$inputEl.blur();
          }

          return stepper;
        }

        stepper.typeModeChanged = false;
        stepper.$el.trigger('stepper:change', stepper.value);
        var formattedValue = stepper.formatValue(stepper.value);

        if (stepper.$inputEl && stepper.$inputEl.length) {
          stepper.$inputEl.val(formattedValue);
          stepper.$inputEl.trigger('input change', {
            sentByF7Stepper: true
          });
          if (!noBlur) stepper.$inputEl.blur();
        }

        if (stepper.$valueEl && stepper.$valueEl.length) {
          stepper.$valueEl.html(formattedValue);
        }

        stepper.emit('local::change stepperChange', stepper, stepper.value);
        return stepper;
      };

      _proto.typeValue = function typeValue(value) {
        var stepper = this;
        stepper.typeModeChanged = true;
        var inputTxt = String(value);
        if (inputTxt.length === 1 && inputTxt === '-') return stepper;

        if (inputTxt.lastIndexOf('.') + 1 === inputTxt.length || inputTxt.lastIndexOf(',') + 1 === inputTxt.length) {
          if (inputTxt.lastIndexOf('.') !== inputTxt.indexOf('.') || inputTxt.lastIndexOf(',') !== inputTxt.indexOf(',')) {
            inputTxt = inputTxt.slice(0, -1);
            stepper.value = inputTxt;
            stepper.$inputEl.val(stepper.value);
            return stepper;
          }
        } else {
          var newValue = parseFloat(inputTxt.replace(',', '.'));

          if (newValue === 0) {
            stepper.value = inputTxt.replace(',', '.');
            stepper.$inputEl.val(stepper.value);
            return stepper;
          }

          if (Number.isNaN(newValue)) {
            stepper.value = 0;
            stepper.$inputEl.val(stepper.value);
            return stepper;
          }

          var powVal = Math.pow(10, stepper.params.decimalPoint);
          newValue = Math.round(newValue * powVal).toFixed(stepper.params.decimalPoint + 1) / powVal;
          stepper.value = parseFloat(String(newValue).replace(',', '.'));
          stepper.$inputEl.val(stepper.value);
          return stepper;
        }

        stepper.value = inputTxt;
        stepper.$inputEl.val(inputTxt);
        return stepper;
      };

      _proto.getValue = function getValue() {
        return this.value;
      };

      _proto.formatValue = function formatValue(value) {
        var stepper = this;
        if (!stepper.params.formatValue) return value;
        return stepper.params.formatValue.call(stepper, value);
      };

      _proto.init = function init() {
        var stepper = this;
        stepper.attachEvents();

        if (stepper.$valueEl && stepper.$valueEl.length) {
          var formattedValue = stepper.formatValue(stepper.value);
          stepper.$valueEl.html(formattedValue);
        }

        return stepper;
      };

      _proto.destroy = function destroy() {
        var stepper = this;
        stepper.$el.trigger('stepper:beforedestroy');
        stepper.emit('local::beforeDestroy stepperBeforeDestroy', stepper);
        delete stepper.$el[0].f7Stepper;
        stepper.detachEvents();
        deleteProps$1(stepper);
        stepper = null;
      };

      return Stepper;
    }(Framework7Class$1);

    var Stepper$2 = Stepper$1;

    var Stepper = {
      name: 'stepper',
      create: function create() {
        var app = this;
        app.stepper = extend$2(ConstructorMethods({
          defaultSelector: '.stepper',
          constructor: Stepper$2,
          app: app,
          domProp: 'f7Stepper'
        }), {
          getValue: function getValue(el) {
            if (el === void 0) {
              el = '.stepper';
            }

            var stepper = app.stepper.get(el);
            if (stepper) return stepper.getValue();
            return undefined;
          },
          setValue: function setValue(el, value) {
            if (el === void 0) {
              el = '.stepper';
            }

            var stepper = app.stepper.get(el);
            if (stepper) return stepper.setValue(value);
            return undefined;
          }
        });
      },
      static: {
        Stepper: Stepper$2
      },
      on: {
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.stepper-init').each(function (stepperEl) {
            var dataset = $(stepperEl).dataset();
            app.stepper.create(extend$2({
              el: stepperEl
            }, dataset || {}));
          });
        },
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          $(tabEl).find('.stepper-init').each(function (stepperEl) {
            if (stepperEl.f7Stepper) stepperEl.f7Stepper.destroy();
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.stepper-init').each(function (stepperEl) {
            var dataset = $(stepperEl).dataset();
            app.stepper.create(extend$2({
              el: stepperEl
            }, dataset || {}));
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          page.$el.find('.stepper-init').each(function (stepperEl) {
            if (stepperEl.f7Stepper) stepperEl.f7Stepper.destroy();
          });
        }
      },
      vnode: {
        'stepper-init': {
          insert: function insert(vnode) {
            var app = this;
            var stepperEl = vnode.elm;
            var dataset = $(stepperEl).dataset();
            app.stepper.create(extend$2({
              el: stepperEl
            }, dataset || {}));
          },
          destroy: function destroy(vnode) {
            var stepperEl = vnode.elm;
            if (stepperEl.f7Stepper) stepperEl.f7Stepper.destroy();
          }
        }
      }
    };

    function _defineProperties$6(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass$6(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$6(Constructor.prototype, protoProps); if (staticProps) _defineProperties$6(Constructor, staticProps); return Constructor; }

    function _assertThisInitialized$d(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$d(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$d(subClass, superClass); }

    function _setPrototypeOf$d(o, p) { _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$d(o, p); }

    var SmartSelect$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$d(SmartSelect, _Framework7Class);

      function SmartSelect(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params, [app]) || this;

        var ss = _assertThisInitialized$d(_this);

        var defaults = extend$2({
          on: {}
        }, app.params.smartSelect);

        if (typeof defaults.searchbarDisableButton === 'undefined') {
          defaults.searchbarDisableButton = app.theme !== 'aurora';
        } // Extend defaults with modules params


        ss.useModulesParams(defaults);
        ss.params = extend$2({}, defaults, params);
        ss.app = app;
        var $el = $(ss.params.el).eq(0);
        if ($el.length === 0) return ss || _assertThisInitialized$d(_this);
        if ($el[0].f7SmartSelect) return $el[0].f7SmartSelect || _assertThisInitialized$d(_this);
        var $selectEl = $el.find('select').eq(0);
        if ($selectEl.length === 0) return ss || _assertThisInitialized$d(_this);
        var $valueEl;

        if (ss.params.setValueText) {
          $valueEl = $(ss.params.valueEl);

          if ($valueEl.length === 0) {
            $valueEl = $el.find('.item-after');
          }

          if ($valueEl.length === 0) {
            $valueEl = $('<div class="item-after"></div>');
            $valueEl.insertAfter($el.find('.item-title'));
          }
        } // Url


        var url = params.url;

        if (!url) {
          if ($el.attr('href') && $el.attr('href') !== '#') url = $el.attr('href');else if ($selectEl.attr('name')) url = $selectEl.attr('name').toLowerCase() + "-select/";
        }

        if (!url) url = ss.params.url;
        var multiple = $selectEl[0].multiple;
        var inputType = multiple ? 'checkbox' : 'radio';
        var selectId = id();
        extend$2(ss, {
          $el: $el,
          el: $el[0],
          $selectEl: $selectEl,
          selectEl: $selectEl[0],
          $valueEl: $valueEl,
          valueEl: $valueEl && $valueEl[0],
          url: url,
          multiple: multiple,
          inputType: inputType,
          id: selectId,
          inputName: inputType + "-" + selectId,
          selectName: $selectEl.attr('name'),
          maxLength: $selectEl.attr('maxlength') || params.maxLength
        });
        $el[0].f7SmartSelect = ss; // Events

        function onClick() {
          ss.open();
        }

        function onChange() {
          var value = ss.$selectEl.val();
          ss.$el.trigger('smartselect:change', value);
          ss.emit('local::change smartSelectChange', ss, value);

          if (ss.vl) {
            ss.vl.clearCache();
          }

          ss.setValueText();
        }

        ss.attachEvents = function attachEvents() {
          $el.on('click', onClick);
          $el.on('change', 'select', onChange);
        };

        ss.detachEvents = function detachEvents() {
          $el.off('click', onClick);
          $el.off('change', 'select', onChange);
        };

        function handleInputChange() {
          var optionEl;
          var text;
          var inputEl = this;
          var value = inputEl.value;
          var optionText = [];
          var displayAs;

          if (inputEl.type === 'checkbox') {
            for (var i = 0; i < ss.selectEl.options.length; i += 1) {
              optionEl = ss.selectEl.options[i];

              if (optionEl.value === value) {
                optionEl.selected = inputEl.checked;
              }

              if (optionEl.selected) {
                displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-value-as');
                text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
                optionText.push(text.trim());
              }
            }

            if (ss.maxLength) {
              ss.checkMaxLength();
            }
          } else {
            optionEl = ss.$selectEl.find("option[value=\"" + value + "\"]")[0];

            if (!optionEl) {
              optionEl = ss.$selectEl.find('option').filter(function (optEl) {
                return optEl.value === value;
              })[0];
            }

            displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-as');
            text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
            optionText = [text];
            ss.selectEl.value = value;
          }

          ss.$selectEl.trigger('change');

          if (ss.params.setValueText) {
            ss.$valueEl.text(ss.formatValueText(optionText));
          }

          if (ss.params.closeOnSelect && ss.inputType === 'radio') {
            ss.close();
          }
        }

        ss.attachInputsEvents = function attachInputsEvents() {
          ss.$containerEl.on('change', 'input[type="checkbox"], input[type="radio"]', handleInputChange);
        };

        ss.detachInputsEvents = function detachInputsEvents() {
          ss.$containerEl.off('change', 'input[type="checkbox"], input[type="radio"]', handleInputChange);
        }; // Install Modules


        ss.useModules(); // Init

        ss.init();
        return ss || _assertThisInitialized$d(_this);
      }

      var _proto = SmartSelect.prototype;

      _proto.setValue = function setValue(value) {
        var ss = this;
        var newValue = value;
        var optionText = [];
        var optionEl;
        var displayAs;
        var text;

        if (ss.multiple) {
          if (!Array.isArray(newValue)) newValue = [newValue];

          for (var i = 0; i < ss.selectEl.options.length; i += 1) {
            optionEl = ss.selectEl.options[i];

            if (newValue.indexOf(optionEl.value) >= 0) {
              optionEl.selected = true;
            } else {
              optionEl.selected = false;
            }

            if (optionEl.selected) {
              displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-value-as');
              text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
              optionText.push(text.trim());
            }
          }
        } else {
          optionEl = ss.$selectEl.find("option[value=\"" + newValue + "\"]")[0];

          if (optionEl) {
            displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-as');
            text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
            optionText = [text];
          }

          ss.selectEl.value = newValue;
        }

        if (ss.params.setValueText) {
          ss.$valueEl.text(ss.formatValueText(optionText));
        }

        ss.$selectEl.trigger('change');
        return ss;
      };

      _proto.unsetValue = function unsetValue() {
        var ss = this;

        if (ss.params.setValueText) {
          ss.$valueEl.text(ss.formatValueText([]));
        }

        ss.$selectEl.find('option').each(function (optionEl) {
          optionEl.selected = false;
          optionEl.checked = false;
        });
        ss.$selectEl[0].value = null;

        if (ss.$containerEl) {
          ss.$containerEl.find("input[name=\"" + ss.inputName + "\"][type=\"checkbox\"], input[name=\"" + ss.inputName + "\"][type=\"radio\"]").prop('checked', false);
        }

        ss.$selectEl.trigger('change');
      };

      _proto.getValue = function getValue() {
        var ss = this;
        return ss.$selectEl.val();
      };

      _proto.checkMaxLength = function checkMaxLength() {
        var ss = this;
        var $containerEl = ss.$containerEl;

        if (ss.selectEl.selectedOptions.length >= ss.maxLength) {
          $containerEl.find('input[type="checkbox"]').each(function (inputEl) {
            if (!inputEl.checked) {
              $(inputEl).parents('li').addClass('disabled');
            } else {
              $(inputEl).parents('li').removeClass('disabled');
            }
          });
        } else {
          $containerEl.find('.disabled').removeClass('disabled');
        }
      };

      _proto.formatValueText = function formatValueText(values) {
        var ss = this;
        var textValue;

        if (ss.params.formatValueText) {
          textValue = ss.params.formatValueText.call(ss, values, ss);
        } else {
          textValue = values.join(', ');
        }

        return textValue;
      };

      _proto.setValueText = function setValueText(value) {
        var ss = this;
        var valueArray = [];

        if (typeof value !== 'undefined') {
          if (Array.isArray(value)) {
            valueArray = value;
          } else {
            valueArray = [value];
          }
        } else {
          ss.$selectEl.find('option').each(function (optionEl) {
            var $optionEl = $(optionEl);

            if (optionEl.selected) {
              var displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $optionEl.data('display-value-as');

              if (displayAs && typeof displayAs !== 'undefined') {
                valueArray.push(displayAs);
              } else {
                valueArray.push(optionEl.textContent.trim());
              }
            }
          });
        }

        if (ss.params.setValueText) {
          ss.$valueEl.text(ss.formatValueText(valueArray));
        }
      };

      _proto.getItemsData = function getItemsData() {
        var ss = this;
        var theme = ss.app.theme;
        var items = [];
        var previousGroupEl;
        ss.$selectEl.find('option').each(function (optionEl) {
          var $optionEl = $(optionEl);
          var optionData = $optionEl.dataset();
          var optionImage = optionData.optionImage || ss.params.optionImage;
          var optionIcon = optionData.optionIcon || ss.params.optionIcon;
          var optionIconIos = theme === 'ios' && (optionData.optionIconIos || ss.params.optionIconIos);
          var optionIconMd = theme === 'md' && (optionData.optionIconMd || ss.params.optionIconMd);
          var optionIconAurora = theme === 'aurora' && (optionData.optionIconAurora || ss.params.optionIconAurora);
          var optionHasMedia = optionImage || optionIcon || optionIconIos || optionIconMd || optionIconAurora;
          var optionColor = optionData.optionColor;
          var optionClassName = optionData.optionClass || '';
          if ($optionEl[0].disabled) optionClassName += ' disabled';
          var optionGroupEl = $optionEl.parent('optgroup')[0];
          var optionGroupLabel = optionGroupEl && optionGroupEl.label;
          var optionIsLabel = false;

          if (optionGroupEl && optionGroupEl !== previousGroupEl) {
            optionIsLabel = true;
            previousGroupEl = optionGroupEl;
            items.push({
              groupLabel: optionGroupLabel,
              isLabel: optionIsLabel
            });
          }

          items.push({
            value: $optionEl[0].value,
            text: $optionEl[0].textContent.trim(),
            selected: $optionEl[0].selected,
            groupEl: optionGroupEl,
            groupLabel: optionGroupLabel,
            image: optionImage,
            icon: optionIcon,
            iconIos: optionIconIos,
            iconMd: optionIconMd,
            iconAurora: optionIconAurora,
            color: optionColor,
            className: optionClassName,
            disabled: $optionEl[0].disabled,
            id: ss.id,
            hasMedia: optionHasMedia,
            checkbox: ss.inputType === 'checkbox',
            radio: ss.inputType === 'radio',
            inputName: ss.inputName,
            inputType: ss.inputType
          });
        });
        ss.items = items;
        return items;
      };

      _proto.renderSearchbar = function renderSearchbar() {
        var ss = this;
        if (ss.params.renderSearchbar) return ss.params.renderSearchbar.call(ss);
        return $jsx$1("form", {
          class: "searchbar"
        }, $jsx$1("div", {
          class: "searchbar-inner"
        }, $jsx$1("div", {
          class: "searchbar-input-wrap"
        }, $jsx$1("input", {
          type: "search",
          spellcheck: ss.params.searchbarSpellcheck || 'false',
          placeholder: ss.params.searchbarPlaceholder
        }), $jsx$1("i", {
          class: "searchbar-icon"
        }), $jsx$1("span", {
          class: "input-clear-button"
        })), ss.params.searchbarDisableButton && $jsx$1("span", {
          class: "searchbar-disable-button"
        }, ss.params.searchbarDisableText)));
      };

      _proto.renderItem = function renderItem(item, index) {
        var ss = this;
        if (ss.params.renderItem) return ss.params.renderItem.call(ss, item, index);

        function getIconContent(iconValue) {
          if (iconValue === void 0) {
            iconValue = '';
          }

          if (iconValue.indexOf(':') >= 0) {
            return iconValue.split(':')[1];
          }

          return '';
        }

        function getIconClass(iconValue) {
          if (iconValue === void 0) {
            iconValue = '';
          }

          if (iconValue.indexOf(':') >= 0) {
            var className = iconValue.split(':')[0];
            if (className === 'f7') className = 'f7-icons';
            if (className === 'material') className = 'material-icons';
            return className;
          }

          return iconValue;
        }

        var itemHtml;

        if (item.isLabel) {
          itemHtml = "<li class=\"item-divider\">" + item.groupLabel + "</li>";
        } else {
          var selected = item.selected;
          var disabled;

          if (ss.params.virtualList) {
            var ssValue = ss.getValue();
            selected = ss.multiple ? ssValue.indexOf(item.value) >= 0 : ssValue === item.value;

            if (ss.multiple) {
              disabled = ss.multiple && !selected && ssValue.length === parseInt(ss.maxLength, 10);
            }
          }

          var icon = item.icon,
              iconIos = item.iconIos,
              iconMd = item.iconMd,
              iconAurora = item.iconAurora;
          var hasIcon = icon || iconIos || iconMd || iconAurora;
          var iconContent = getIconContent(icon || iconIos || iconMd || iconAurora || '');
          var iconClass = getIconClass(icon || iconIos || iconMd || iconAurora || '');
          itemHtml = $jsx$1("li", {
            class: "" + (item.className || '') + (disabled ? ' disabled' : '')
          }, $jsx$1("label", {
            class: "item-" + item.inputType + " item-content"
          }, $jsx$1("input", {
            type: item.inputType,
            name: item.inputName,
            value: item.value,
            _checked: selected
          }), $jsx$1("i", {
            class: "icon icon-" + item.inputType
          }), item.hasMedia && $jsx$1("div", {
            class: "item-media"
          }, hasIcon && $jsx$1("i", {
            class: "icon " + iconClass
          }, iconContent), item.image && $jsx$1("img", {
            src: item.image
          })), $jsx$1("div", {
            class: "item-inner"
          }, $jsx$1("div", {
            class: "item-title" + (item.color ? " text-color-" + item.color : '')
          }, item.text))));
        }

        return itemHtml;
      };

      _proto.renderItems = function renderItems() {
        var ss = this;
        if (ss.params.renderItems) return ss.params.renderItems.call(ss, ss.items);
        var itemsHtml = "\n      " + ss.items.map(function (item, index) {
          return "" + ss.renderItem(item, index);
        }).join('') + "\n    ";
        return itemsHtml;
      };

      _proto.renderPage = function renderPage() {
        var ss = this;
        if (ss.params.renderPage) return ss.params.renderPage.call(ss, ss.items);
        var pageTitle = ss.params.pageTitle;

        if (typeof pageTitle === 'undefined') {
          var $itemTitleEl = ss.$el.find('.item-title');
          pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : '';
        }

        var cssClass = ss.params.cssClass;
        return $jsx$1("div", {
          class: "page smart-select-page " + cssClass,
          "data-name": "smart-select-page",
          "data-select-name": ss.selectName
        }, $jsx$1("div", {
          class: "navbar " + (ss.params.navbarColorTheme ? "color-" + ss.params.navbarColorTheme : '')
        }, $jsx$1("div", {
          class: "navbar-bg"
        }), $jsx$1("div", {
          class: "navbar-inner sliding " + (ss.params.navbarColorTheme ? "color-" + ss.params.navbarColorTheme : '')
        }, $jsx$1("div", {
          class: "left"
        }, $jsx$1("a", {
          class: "link back"
        }, $jsx$1("i", {
          class: "icon icon-back"
        }), $jsx$1("span", {
          class: "if-not-md"
        }, ss.params.pageBackLinkText))), pageTitle && $jsx$1("div", {
          class: "title"
        }, pageTitle), ss.params.searchbar && $jsx$1("div", {
          class: "subnavbar"
        }, ss.renderSearchbar()))), ss.params.searchbar && $jsx$1("div", {
          class: "searchbar-backdrop"
        }), $jsx$1("div", {
          class: "page-content"
        }, $jsx$1("div", {
          class: "list smart-select-list-" + ss.id + " " + (ss.params.virtualList ? ' virtual-list' : '') + " " + (ss.params.formColorTheme ? "color-" + ss.params.formColorTheme : '')
        }, $jsx$1("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))));
      };

      _proto.renderPopup = function renderPopup() {
        var ss = this;
        if (ss.params.renderPopup) return ss.params.renderPopup.call(ss, ss.items);
        var pageTitle = ss.params.pageTitle;

        if (typeof pageTitle === 'undefined') {
          var $itemTitleEl = ss.$el.find('.item-title');
          pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : '';
        }

        var cssClass = ss.params.cssClass || '';
        return $jsx$1("div", {
          class: "popup smart-select-popup " + cssClass + " " + (ss.params.popupTabletFullscreen ? 'popup-tablet-fullscreen' : ''),
          "data-select-name": ss.selectName
        }, $jsx$1("div", {
          class: "view"
        }, $jsx$1("div", {
          class: "page smart-select-page " + (ss.params.searchbar ? 'page-with-subnavbar' : ''),
          "data-name": "smart-select-page"
        }, $jsx$1("div", {
          class: "navbar " + (ss.params.navbarColorTheme ? "color-" + ss.params.navbarColorTheme : '')
        }, $jsx$1("div", {
          class: "navbar-bg"
        }), $jsx$1("div", {
          class: "navbar-inner sliding"
        }, pageTitle && $jsx$1("div", {
          class: "title"
        }, pageTitle), $jsx$1("div", {
          class: "right"
        }, $jsx$1("a", {
          class: "link popup-close",
          "data-popup": ".smart-select-popup[data-select-name='" + ss.selectName + "']"
        }, ss.params.popupCloseLinkText)), ss.params.searchbar && $jsx$1("div", {
          class: "subnavbar"
        }, ss.renderSearchbar()))), ss.params.searchbar && $jsx$1("div", {
          class: "searchbar-backdrop"
        }), $jsx$1("div", {
          class: "page-content"
        }, $jsx$1("div", {
          class: "list smart-select-list-" + ss.id + " " + (ss.params.virtualList ? ' virtual-list' : '') + " " + (ss.params.formColorTheme ? "color-" + ss.params.formColorTheme : '')
        }, $jsx$1("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))))));
      };

      _proto.renderSheet = function renderSheet() {
        var ss = this;
        if (ss.params.renderSheet) return ss.params.renderSheet.call(ss, ss.items);
        var cssClass = ss.params.cssClass; // prettier-ignore

        return $jsx$1("div", {
          class: "sheet-modal smart-select-sheet " + cssClass,
          "data-select-name": ss.selectName
        }, $jsx$1("div", {
          class: "toolbar toolbar-top " + (ss.params.toolbarColorTheme ? "color-" + ss.params.toolbarColorTheme : '')
        }, $jsx$1("div", {
          class: "toolbar-inner"
        }, $jsx$1("div", {
          class: "left"
        }), $jsx$1("div", {
          class: "right"
        }, $jsx$1("a", {
          class: "link sheet-close"
        }, ss.params.sheetCloseLinkText)))), $jsx$1("div", {
          class: "sheet-modal-inner"
        }, $jsx$1("div", {
          class: "page-content"
        }, $jsx$1("div", {
          class: "list smart-select-list-" + ss.id + " " + (ss.params.virtualList ? ' virtual-list' : '') + " " + (ss.params.formColorTheme ? "color-" + ss.params.formColorTheme : '')
        }, $jsx$1("ul", null, !ss.params.virtualList && ss.renderItems(ss.items))))));
      };

      _proto.renderPopover = function renderPopover() {
        var ss = this;
        if (ss.params.renderPopover) return ss.params.renderPopover.call(ss, ss.items);
        var cssClass = ss.params.cssClass; // prettier-ignore

        return $jsx$1("div", {
          class: "popover smart-select-popover " + cssClass,
          "data-select-name": ss.selectName
        }, $jsx$1("div", {
          class: "popover-inner"
        }, $jsx$1("div", {
          class: "list smart-select-list-" + ss.id + " " + (ss.params.virtualList ? ' virtual-list' : '') + " " + (ss.params.formColorTheme ? "color-" + ss.params.formColorTheme : '')
        }, $jsx$1("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))));
      };

      _proto.scrollToSelectedItem = function scrollToSelectedItem() {
        var ss = this;
        var params = ss.params,
            $containerEl = ss.$containerEl;
        if (!ss.opened) return ss;

        if (params.virtualList) {
          var selectedIndex;
          ss.vl.items.forEach(function (item, index) {
            if (typeof selectedIndex === 'undefined' && item.selected) {
              selectedIndex = index;
            }
          });

          if (typeof selectedIndex !== 'undefined') {
            ss.vl.scrollToItem(selectedIndex);
          }
        } else {
          var $selectedItemEl = $containerEl.find('input:checked').parents('li');
          if (!$selectedItemEl.length) return ss;
          var $scrollableEl = $containerEl.find('.page-content, .popover-inner');
          if (!$scrollableEl.length) return ss;
          $scrollableEl.scrollTop($selectedItemEl.offset().top - $scrollableEl.offset().top - parseInt($scrollableEl.css('padding-top'), 10));
        }

        return ss;
      };

      _proto.onOpen = function onOpen(type, containerEl) {
        var ss = this;
        var app = ss.app;
        var $containerEl = $(containerEl);
        ss.$containerEl = $containerEl;
        ss.openedIn = type;
        ss.opened = true; // Init VL

        if (ss.params.virtualList) {
          ss.vl = app.virtualList.create({
            el: $containerEl.find('.virtual-list'),
            items: ss.items,
            renderItem: ss.renderItem.bind(ss),
            height: ss.params.virtualListHeight,
            searchByItem: function searchByItem(query, item) {
              if (item.text && item.text.toLowerCase().indexOf(query.trim().toLowerCase()) >= 0) return true;
              return false;
            }
          });
        }

        if (ss.params.scrollToSelectedItem) {
          ss.scrollToSelectedItem();
        } // Init SB


        if (ss.params.searchbar) {
          var $searchbarEl = $containerEl.find('.searchbar');

          if (type === 'page' && app.theme === 'ios') {
            $searchbarEl = $(app.navbar.getElByPage($containerEl)).find('.searchbar');
          }

          if (ss.params.appendSearchbarNotFound && (type === 'page' || type === 'popup')) {
            var $notFoundEl = null;

            if (typeof ss.params.appendSearchbarNotFound === 'string') {
              $notFoundEl = $("<div class=\"block searchbar-not-found\">" + ss.params.appendSearchbarNotFound + "</div>");
            } else if (typeof ss.params.appendSearchbarNotFound === 'boolean') {
              $notFoundEl = $('<div class="block searchbar-not-found">Nothing found</div>');
            } else {
              $notFoundEl = ss.params.appendSearchbarNotFound;
            }

            if ($notFoundEl) {
              $containerEl.find('.page-content').append($notFoundEl[0]);
            }
          }

          var searchbarParams = extend$2({
            el: $searchbarEl,
            backdropEl: $containerEl.find('.searchbar-backdrop'),
            searchContainer: ".smart-select-list-" + ss.id,
            searchIn: '.item-title'
          }, typeof ss.params.searchbar === 'object' ? ss.params.searchbar : {});
          ss.searchbar = app.searchbar.create(searchbarParams);
        } // Check for max length


        if (ss.maxLength) {
          ss.checkMaxLength();
        } // Close on select


        if (ss.params.closeOnSelect) {
          ss.$containerEl.find("input[type=\"radio\"][name=\"" + ss.inputName + "\"]:checked").parents('label').once('click', function () {
            ss.close();
          });
        } // Attach input events


        ss.attachInputsEvents();
        ss.$el.trigger('smartselect:open');
        ss.emit('local::open smartSelectOpen', ss);
      };

      _proto.onOpened = function onOpened() {
        var ss = this;
        ss.$el.trigger('smartselect:opened');
        ss.emit('local::opened smartSelectOpened', ss);
      };

      _proto.onClose = function onClose() {
        var ss = this;
        if (ss.destroyed) return; // Destroy VL

        if (ss.vl && ss.vl.destroy) {
          ss.vl.destroy();
          ss.vl = null;
          delete ss.vl;
        } // Destroy SB


        if (ss.searchbar && ss.searchbar.destroy) {
          ss.searchbar.destroy();
          ss.searchbar = null;
          delete ss.searchbar;
        } // Detach events


        ss.detachInputsEvents();
        ss.$el.trigger('smartselect:close');
        ss.emit('local::close smartSelectClose', ss);
      };

      _proto.onClosed = function onClosed() {
        var ss = this;
        if (ss.destroyed) return;
        ss.opened = false;
        ss.$containerEl = null;
        delete ss.$containerEl;
        ss.$el.trigger('smartselect:closed');
        ss.emit('local::closed smartSelectClosed', ss);
      };

      _proto.openPage = function openPage() {
        var ss = this;
        if (ss.opened) return ss;
        ss.getItemsData();
        var pageHtml = ss.renderPage(ss.items);
        ss.view.router.navigate({
          url: ss.url,
          route: {
            content: pageHtml,
            path: ss.url,
            on: {
              pageBeforeIn: function pageBeforeIn(e, page) {
                ss.onOpen('page', page.el);
              },
              pageAfterIn: function pageAfterIn(e, page) {
                ss.onOpened('page', page.el);
              },
              pageBeforeOut: function pageBeforeOut(e, page) {
                ss.onClose('page', page.el);
              },
              pageAfterOut: function pageAfterOut(e, page) {
                ss.onClosed('page', page.el);
              }
            }
          }
        });
        return ss;
      };

      _proto.openPopup = function openPopup() {
        var ss = this;
        if (ss.opened) return ss;
        ss.getItemsData();
        var popupHtml = ss.renderPopup(ss.items);
        var popupParams = {
          content: popupHtml,
          push: ss.params.popupPush,
          swipeToClose: ss.params.popupSwipeToClose,
          on: {
            popupOpen: function popupOpen(popup) {
              ss.onOpen('popup', popup.el);
            },
            popupOpened: function popupOpened(popup) {
              ss.onOpened('popup', popup.el);
            },
            popupClose: function popupClose(popup) {
              ss.onClose('popup', popup.el);
            },
            popupClosed: function popupClosed(popup) {
              ss.onClosed('popup', popup.el);
            }
          }
        };

        if (ss.params.routableModals && ss.view) {
          ss.view.router.navigate({
            url: ss.url,
            route: {
              path: ss.url,
              popup: popupParams
            }
          });
        } else {
          ss.modal = ss.app.popup.create(popupParams).open();
        }

        return ss;
      };

      _proto.openSheet = function openSheet() {
        var ss = this;
        if (ss.opened) return ss;
        ss.getItemsData();
        var sheetHtml = ss.renderSheet(ss.items);
        var sheetParams = {
          content: sheetHtml,
          backdrop: ss.params.sheetBackdrop,
          scrollToEl: ss.$el,
          closeByOutsideClick: true,
          push: ss.params.sheetPush,
          swipeToClose: ss.params.sheetSwipeToClose,
          on: {
            sheetOpen: function sheetOpen(sheet) {
              ss.onOpen('sheet', sheet.el);
            },
            sheetOpened: function sheetOpened(sheet) {
              ss.onOpened('sheet', sheet.el);
            },
            sheetClose: function sheetClose(sheet) {
              ss.onClose('sheet', sheet.el);
            },
            sheetClosed: function sheetClosed(sheet) {
              ss.onClosed('sheet', sheet.el);
            }
          }
        };

        if (ss.params.routableModals && ss.view) {
          ss.view.router.navigate({
            url: ss.url,
            route: {
              path: ss.url,
              sheet: sheetParams
            }
          });
        } else {
          ss.modal = ss.app.sheet.create(sheetParams).open();
        }

        return ss;
      };

      _proto.openPopover = function openPopover() {
        var ss = this;
        if (ss.opened) return ss;
        ss.getItemsData();
        var popoverHtml = ss.renderPopover(ss.items);
        var popoverParams = {
          content: popoverHtml,
          targetEl: ss.$el,
          on: {
            popoverOpen: function popoverOpen(popover) {
              ss.onOpen('popover', popover.el);
            },
            popoverOpened: function popoverOpened(popover) {
              ss.onOpened('popover', popover.el);
            },
            popoverClose: function popoverClose(popover) {
              ss.onClose('popover', popover.el);
            },
            popoverClosed: function popoverClosed(popover) {
              ss.onClosed('popover', popover.el);
            }
          }
        };

        if (ss.params.routableModals && ss.view) {
          ss.view.router.navigate({
            url: ss.url,
            route: {
              path: ss.url,
              popover: popoverParams
            }
          });
        } else {
          ss.modal = ss.app.popover.create(popoverParams).open();
        }

        return ss;
      };

      _proto.open = function open(type) {
        var ss = this;
        if (ss.opened) return ss;
        var prevented = false;

        function prevent() {
          prevented = true;
        }

        if (ss.$el) {
          ss.$el.trigger('smartselect:beforeopen', {
            prevent: prevent
          });
        }

        ss.emit('local::beforeOpen smartSelectBeforeOpen', ss, prevent);
        if (prevented) return ss;
        var openIn = type || ss.params.openIn;
        ss["open" + openIn.split('').map(function (el, index) {
          if (index === 0) return el.toUpperCase();
          return el;
        }).join('')]();
        return ss;
      };

      _proto.close = function close() {
        var ss = this;
        if (!ss.opened) return ss;

        if (ss.params.routableModals && ss.view || ss.openedIn === 'page') {
          ss.view.router.back();
        } else {
          ss.modal.once('modalClosed', function () {
            nextTick$1(function () {
              if (ss.destroyed) return;
              ss.modal.destroy();
              delete ss.modal;
            });
          });
          ss.modal.close();
        }

        return ss;
      };

      _proto.init = function init() {
        var ss = this;
        ss.attachEvents();
        ss.setValueText();
      };

      _proto.destroy = function destroy() {
        var ss = this;
        ss.emit('local::beforeDestroy smartSelectBeforeDestroy', ss);
        ss.$el.trigger('smartselect:beforedestroy');
        ss.detachEvents();
        delete ss.$el[0].f7SmartSelect;
        deleteProps$1(ss);
        ss.destroyed = true;
      };

      _createClass$6(SmartSelect, [{
        key: "view",
        get: function get() {
          var params = this.params,
              $el = this.$el;
          var view;

          if (params.view) {
            view = params.view;
          }

          if (!view) {
            view = $el.parents('.view').length && $el.parents('.view')[0].f7View;
          }

          if (!view && params.openIn === 'page') {
            throw Error('Smart Select requires initialized View');
          }

          return view;
        }
      }]);

      return SmartSelect;
    }(Framework7Class$1);

    var SmartSelect$2 = SmartSelect$1;

    var SmartSelect = {
      name: 'smartSelect',
      params: {
        smartSelect: {
          el: undefined,
          valueEl: undefined,
          setValueText: true,
          formatValueText: null,
          openIn: 'page',
          // or 'popup' or 'sheet' or 'popover'
          popupPush: false,
          popupSwipeToClose: undefined,
          // defaults to app
          sheetPush: false,
          sheetSwipeToClose: undefined,
          // defaults to app
          sheetBackdrop: false,
          pageTitle: undefined,
          pageBackLinkText: 'Back',
          popupCloseLinkText: 'Close',
          popupTabletFullscreen: false,
          sheetCloseLinkText: 'Done',
          searchbar: false,
          searchbarPlaceholder: 'Search',
          searchbarDisableText: 'Cancel',
          searchbarDisableButton: undefined,
          searchbarSpellcheck: false,
          closeOnSelect: false,
          virtualList: false,
          virtualListHeight: undefined,
          scrollToSelectedItem: false,
          formColorTheme: undefined,
          navbarColorTheme: undefined,
          routableModals: false,
          url: 'select/',
          cssClass: '',

          /*
            Custom render functions
          */
          renderPage: undefined,
          renderPopup: undefined,
          renderSheet: undefined,
          renderPopover: undefined,
          renderItems: undefined,
          renderItem: undefined,
          renderSearchbar: undefined
        }
      },
      static: {
        SmartSelect: SmartSelect$2
      },
      create: function create() {
        var app = this;
        app.smartSelect = extend$2(ConstructorMethods({
          defaultSelector: '.smart-select',
          constructor: SmartSelect$2,
          app: app,
          domProp: 'f7SmartSelect'
        }), {
          open: function open(smartSelectEl) {
            var ss = app.smartSelect.get(smartSelectEl);
            if (ss && ss.open) return ss.open();
            return undefined;
          },
          close: function close(smartSelectEl) {
            var ss = app.smartSelect.get(smartSelectEl);
            if (ss && ss.close) return ss.close();
            return undefined;
          }
        });
      },
      on: {
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.smart-select-init').each(function (smartSelectEl) {
            app.smartSelect.create(extend$2({
              el: smartSelectEl
            }, $(smartSelectEl).dataset()));
          });
        },
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          $(tabEl).find('.smart-select-init').each(function (smartSelectEl) {
            if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
              smartSelectEl.f7SmartSelect.destroy();
            }
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.smart-select-init').each(function (smartSelectEl) {
            app.smartSelect.create(extend$2({
              el: smartSelectEl
            }, $(smartSelectEl).dataset()));
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          page.$el.find('.smart-select-init').each(function (smartSelectEl) {
            if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
              smartSelectEl.f7SmartSelect.destroy();
            }
          });
        }
      },
      clicks: {
        '.smart-select': function open($clickedEl, data) {
          var app = this;

          if (!$clickedEl[0].f7SmartSelect) {
            var ss = app.smartSelect.create(extend$2({
              el: $clickedEl
            }, data));
            ss.open();
          }
        }
      },
      vnode: {
        'smart-select-init': {
          insert: function insert(vnode) {
            var app = this;
            var smartSelectEl = vnode.elm;
            app.smartSelect.create(extend$2({
              el: smartSelectEl
            }, $(smartSelectEl).dataset()));
          },
          destroy: function destroy(vnode) {
            var smartSelectEl = vnode.elm;

            if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
              smartSelectEl.f7SmartSelect.destroy();
            }
          }
        }
      }
    };

    function getElMinSize(dimension, $el) {
      var minSize = $el.css("min-" + dimension);

      if (minSize === 'auto' || minSize === 'none') {
        minSize = 0;
      } else if (minSize.indexOf('px') >= 0) {
        minSize = parseFloat(minSize);
      } else if (minSize.indexOf('%') >= 0) {
        minSize = $el.parent()[0][dimension === 'height' ? 'offsetHeight' : 'offsetWidth'] * parseFloat(minSize) / 100;
      }

      return minSize;
    }

    function getElMaxSize(dimension, $el) {
      var maxSize = $el.css("max-" + dimension);

      if (maxSize === 'auto' || maxSize === 'none') {
        maxSize = null;
      } else if (maxSize.indexOf('px') >= 0) {
        maxSize = parseFloat(maxSize);
      } else if (maxSize.indexOf('%') >= 0) {
        maxSize = $el.parent()[0][dimension === 'height' ? 'offsetHeight' : 'offsetWidth'] * parseFloat(maxSize) / 100;
      }

      return maxSize;
    }

    var Grid = {
      init: function init() {
        var app = this;
        var isTouched;
        var isMoved;
        var touchStartX;
        var touchStartY;
        var $resizeHandlerEl;
        var $prevResizableEl;
        var $nextResizableEl;
        var prevElSize;
        var prevElMinSize;
        var prevElMaxSize;
        var nextElSize;
        var nextElMinSize;
        var nextElMaxSize;
        var parentSize;
        var itemsInFlow;
        var gapSize;
        var isScrolling;

        function handleTouchStart(e) {
          if (isTouched || isMoved) return;
          $resizeHandlerEl = $(e.target).closest('.resize-handler');
          touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
          isTouched = true;
          $prevResizableEl = undefined;
          $nextResizableEl = undefined;
          isScrolling = undefined;
        }

        function handleTouchMove(e) {
          if (!isTouched) return;
          var isRow = $resizeHandlerEl.parent('.row').length === 1;
          var sizeProp = isRow ? 'height' : 'width';
          var getSizeProp = isRow ? 'offsetHeight' : 'offsetWidth';

          if (!isMoved) {
            $prevResizableEl = $resizeHandlerEl.parent(isRow ? '.row' : '.col');

            if ($prevResizableEl.length && (!$prevResizableEl.hasClass('resizable') || $prevResizableEl.hasClass('resizable-fixed'))) {
              $prevResizableEl = $prevResizableEl.prevAll('.resizable:not(.resizable-fixed)').eq(0);
            }

            $nextResizableEl = $prevResizableEl.next(isRow ? '.row' : '.col');

            if ($nextResizableEl.length && (!$nextResizableEl.hasClass('resizable') || $nextResizableEl.hasClass('resizable-fixed'))) {
              $nextResizableEl = $nextResizableEl.nextAll('.resizable:not(.resizable-fixed)').eq(0);
            }

            if ($prevResizableEl.length) {
              prevElSize = $prevResizableEl[0][getSizeProp];
              prevElMinSize = getElMinSize(sizeProp, $prevResizableEl);
              prevElMaxSize = getElMaxSize(sizeProp, $prevResizableEl);
              parentSize = $prevResizableEl.parent()[0][getSizeProp];
              itemsInFlow = $prevResizableEl.parent().children(isRow ? '.row' : '[class*="col-"], .col').length;
              gapSize = parseFloat($prevResizableEl.css(isRow ? '--f7-grid-row-gap' : '--f7-grid-gap'));
            }

            if ($nextResizableEl.length) {
              nextElSize = $nextResizableEl[0][getSizeProp];
              nextElMinSize = getElMinSize(sizeProp, $nextResizableEl);
              nextElMaxSize = getElMaxSize(sizeProp, $nextResizableEl);

              if (!$prevResizableEl.length) {
                parentSize = $nextResizableEl.parent()[0][getSizeProp];
                itemsInFlow = $nextResizableEl.parent().children(isRow ? '.row' : '[class*="col-"], .col').length;
                gapSize = parseFloat($nextResizableEl.css(isRow ? '--f7-grid-row-gap' : '--f7-grid-gap'));
              }
            }
          }

          isMoved = true;
          var touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
          var touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

          if (typeof isScrolling === 'undefined' && !isRow) {
            isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
          }

          if (isScrolling) {
            isTouched = false;
            isMoved = false;
            return;
          }

          var isAbsolute = $prevResizableEl.hasClass('resizable-absolute') || $nextResizableEl.hasClass('resizable-absolute');
          var resizeNextEl = !isRow || isRow && !isAbsolute;

          if (resizeNextEl && !$nextResizableEl.length || !$prevResizableEl.length) {
            isTouched = false;
            isMoved = false;
            return;
          }

          e.preventDefault();
          var diff = isRow ? touchCurrentY - touchStartY : touchCurrentX - touchStartX;
          var prevElNewSize;
          var nextElNewSize;

          if ($prevResizableEl.length) {
            prevElNewSize = prevElSize + diff;

            if (prevElNewSize < prevElMinSize) {
              prevElNewSize = prevElMinSize;
              diff = prevElNewSize - prevElSize;
            }

            if (prevElMaxSize && prevElNewSize > prevElMaxSize) {
              prevElNewSize = prevElMaxSize;
              diff = prevElNewSize - prevElSize;
            }
          }

          if ($nextResizableEl.length && resizeNextEl) {
            nextElNewSize = nextElSize - diff;

            if (nextElNewSize < nextElMinSize) {
              nextElNewSize = nextElMinSize;
              diff = nextElSize - nextElNewSize;
              prevElNewSize = prevElSize + diff;
            }

            if (nextElMaxSize && nextElNewSize > nextElMaxSize) {
              nextElNewSize = nextElMaxSize;
              diff = nextElSize - nextElNewSize;
              prevElNewSize = prevElSize + diff;
            }
          }

          if (isAbsolute) {
            $prevResizableEl[0].style[sizeProp] = prevElNewSize + "px";

            if (resizeNextEl) {
              $nextResizableEl[0].style[sizeProp] = nextElNewSize + "px";
            }

            $prevResizableEl.trigger('grid:resize');
            $nextResizableEl.trigger('grid:resize');
            app.emit('gridResize', $prevResizableEl[0]);
            app.emit('gridResize', $nextResizableEl[0]);
            return;
          }

          var gapAddSize = (itemsInFlow - 1) * gapSize / itemsInFlow;
          var gapAddSizeCSS = isRow ? itemsInFlow - 1 + " * var(--f7-grid-row-gap) / " + itemsInFlow : '(var(--f7-cols-per-row) - 1) * var(--f7-grid-gap) / var(--f7-cols-per-row)';
          var prevElNewSizeNormalized = prevElNewSize + gapAddSize;
          var nextElNewSizeNormalized = nextElNewSize + gapAddSize;
          $prevResizableEl[0].style[sizeProp] = "calc(" + prevElNewSizeNormalized / parentSize * 100 + "% - " + gapAddSizeCSS + ")";
          $nextResizableEl[0].style[sizeProp] = "calc(" + nextElNewSizeNormalized / parentSize * 100 + "% - " + gapAddSizeCSS + ")";
          $prevResizableEl.trigger('grid:resize');
          $nextResizableEl.trigger('grid:resize');
          app.emit('gridResize', $prevResizableEl[0]);
          app.emit('gridResize', $nextResizableEl[0]);
        }

        function handleTouchEnd() {
          if (!isTouched) return;

          if (!isMoved) {
            isTouched = false;
          }

          isTouched = false;
          isMoved = false;
        }

        var document = getDocument();
        $(document).on(app.touchEvents.start, '.col > .resize-handler, .row > .resize-handler', handleTouchStart);
        app.on('touchmove', handleTouchMove);
        app.on('touchend', handleTouchEnd);
      }
    };
    var Grid$1 = {
      name: 'grid',
      create: function create() {
        var app = this;
        extend$2(app, {
          grid: {
            init: Grid.init.bind(app)
          }
        });
      },
      on: {
        init: function init() {
          var app = this;
          app.grid.init();
        }
      }
    };

    function _defineProperties$5(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass$5(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$5(Constructor.prototype, protoProps); if (staticProps) _defineProperties$5(Constructor, staticProps); return Constructor; }

    function _assertThisInitialized$c(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$c(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$c(subClass, superClass); }

    function _setPrototypeOf$c(o, p) { _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$c(o, p); }

    var Calendar$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$c(Calendar, _Framework7Class);

      function Calendar(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params, [app]) || this;

        var calendar = _assertThisInitialized$c(_this);

        calendar.params = extend$2({}, app.params.calendar, params);
        var $containerEl;

        if (calendar.params.containerEl) {
          $containerEl = $(calendar.params.containerEl);
          if ($containerEl.length === 0) return calendar || _assertThisInitialized$c(_this);
        }

        var $inputEl;

        if (calendar.params.inputEl) {
          $inputEl = $(calendar.params.inputEl);
        }

        var isHorizontal = calendar.params.direction === 'horizontal';
        var inverter = 1;

        if (isHorizontal) {
          inverter = app.rtl ? -1 : 1;
        }

        extend$2(calendar, {
          app: app,
          $containerEl: $containerEl,
          containerEl: $containerEl && $containerEl[0],
          inline: $containerEl && $containerEl.length > 0,
          $inputEl: $inputEl,
          inputEl: $inputEl && $inputEl[0],
          initialized: false,
          opened: false,
          url: calendar.params.url,
          isHorizontal: isHorizontal,
          inverter: inverter,
          animating: false,
          allowTouchMove: true,
          hasTimePicker: calendar.params.timePicker && !calendar.params.rangePicker && !calendar.params.multiple
        });
        calendar.dayFormatter = new Intl.DateTimeFormat(calendar.params.locale, {
          day: 'numeric'
        });
        calendar.monthFormatter = new Intl.DateTimeFormat(calendar.params.locale, {
          month: 'long'
        });
        calendar.yearFormatter = new Intl.DateTimeFormat(calendar.params.locale, {
          year: 'numeric'
        });
        calendar.timeSelectorFormatter = new Intl.DateTimeFormat(calendar.params.locale, calendar.params.timePickerFormat);
        var timeFormatCheckDate = calendar.timeSelectorFormatter.format(new Date()).toLowerCase();
        calendar.is12HoursFormat = timeFormatCheckDate.indexOf('pm') >= 0 || timeFormatCheckDate.indexOf('am') >= 0; // Auto names

        var _calendar$params = calendar.params,
            monthNames = _calendar$params.monthNames,
            monthNamesShort = _calendar$params.monthNamesShort,
            dayNames = _calendar$params.dayNames,
            dayNamesShort = _calendar$params.dayNamesShort;

        var _calendar$getIntlName = calendar.getIntlNames(),
            monthNamesIntl = _calendar$getIntlName.monthNamesIntl,
            monthNamesShortIntl = _calendar$getIntlName.monthNamesShortIntl,
            dayNamesIntl = _calendar$getIntlName.dayNamesIntl,
            dayNamesShortIntl = _calendar$getIntlName.dayNamesShortIntl;

        if (monthNames === 'auto') monthNames = monthNamesIntl;
        if (monthNamesShort === 'auto') monthNamesShort = monthNamesShortIntl;
        if (dayNames === 'auto') dayNames = dayNamesIntl;
        if (dayNamesShort === 'auto') dayNamesShort = dayNamesShortIntl;
        extend$2(calendar, {
          monthNames: monthNames,
          monthNamesShort: monthNamesShort,
          dayNames: dayNames,
          dayNamesShort: dayNamesShort
        });

        function onInputClick() {
          calendar.open();
        }

        function onInputFocus(e) {
          e.preventDefault();
        }

        function onInputClear() {
          calendar.setValue([]);

          if (calendar.opened) {
            calendar.update();
          }
        }

        function onHtmlClick(e) {
          var $targetEl = $(e.target);
          if (calendar.destroyed || !calendar.params) return;
          if (calendar.isPopover()) return;
          if (!calendar.opened || calendar.closing) return;
          if ($targetEl.closest('[class*="backdrop"]').length) return;

          if ($inputEl && $inputEl.length > 0) {
            if ($targetEl[0] !== $inputEl[0] && $targetEl.closest('.sheet-modal, .calendar-modal').length === 0) {
              calendar.close();
            }
          } else if ($(e.target).closest('.sheet-modal, .calendar-modal').length === 0) {
            calendar.close();
          }
        } // Events


        extend$2(calendar, {
          attachInputEvents: function attachInputEvents() {
            calendar.$inputEl.on('click', onInputClick);
            calendar.$inputEl.on('input:clear', onInputClear);

            if (calendar.params.inputReadOnly) {
              calendar.$inputEl.on('focus mousedown', onInputFocus);

              if (calendar.$inputEl[0]) {
                calendar.$inputEl[0].f7ValidateReadonly = true;
              }
            }
          },
          detachInputEvents: function detachInputEvents() {
            calendar.$inputEl.off('click', onInputClick);
            calendar.$inputEl.off('input:clear', onInputClear);

            if (calendar.params.inputReadOnly) {
              calendar.$inputEl.off('focus mousedown', onInputFocus);

              if (calendar.$inputEl[0]) {
                delete calendar.$inputEl[0].f7ValidateReadonly;
              }
            }
          },
          attachHtmlEvents: function attachHtmlEvents() {
            app.on('click', onHtmlClick);
          },
          detachHtmlEvents: function detachHtmlEvents() {
            app.off('click', onHtmlClick);
          }
        });

        calendar.attachCalendarEvents = function attachCalendarEvents() {
          var allowItemClick = true;
          var isTouched;
          var isMoved;
          var touchStartX;
          var touchStartY;
          var touchCurrentX;
          var touchCurrentY;
          var touchStartTime;
          var touchEndTime;
          var currentTranslate;
          var wrapperWidth;
          var wrapperHeight;
          var percentage;
          var touchesDiff;
          var isScrolling;
          var $el = calendar.$el,
              $wrapperEl = calendar.$wrapperEl;

          function handleTouchStart(e) {
            if (isMoved || isTouched) return;
            isTouched = true;
            touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
            touchCurrentX = touchStartX;
            touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
            touchCurrentY = touchStartY;
            touchStartTime = new Date().getTime();
            percentage = 0;
            allowItemClick = true;
            isScrolling = undefined;
            currentTranslate = calendar.monthsTranslate;
          }

          function handleTouchMove(e) {
            if (!isTouched) return;
            var isH = calendar.isHorizontal;
            touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
            touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

            if (typeof isScrolling === 'undefined') {
              isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
            }

            if (isH && isScrolling || !calendar.allowTouchMove) {
              isTouched = false;
              return;
            }

            e.preventDefault();

            if (calendar.animating) {
              isTouched = false;
              return;
            }

            allowItemClick = false;

            if (!isMoved) {
              // First move
              isMoved = true;
              wrapperWidth = $wrapperEl[0].offsetWidth;
              wrapperHeight = $wrapperEl[0].offsetHeight;
              $wrapperEl.transition(0);
            }

            touchesDiff = isH ? touchCurrentX - touchStartX : touchCurrentY - touchStartY;
            percentage = touchesDiff / (isH ? wrapperWidth : wrapperHeight);
            currentTranslate = (calendar.monthsTranslate * calendar.inverter + percentage) * 100; // Transform wrapper

            $wrapperEl.transform("translate3d(" + (isH ? currentTranslate : 0) + "%, " + (isH ? 0 : currentTranslate) + "%, 0)");
          }

          function handleTouchEnd() {
            if (!isTouched || !isMoved) {
              isTouched = false;
              isMoved = false;
              return;
            }

            isTouched = false;
            isMoved = false;
            touchEndTime = new Date().getTime();

            if (touchEndTime - touchStartTime < 300) {
              if (Math.abs(touchesDiff) < 10) {
                calendar.resetMonth();
              } else if (touchesDiff >= 10) {
                if (app.rtl) calendar.nextMonth();else calendar.prevMonth();
              } else if (app.rtl) calendar.prevMonth();else calendar.nextMonth();
            } else if (percentage <= -0.5) {
              if (app.rtl) calendar.prevMonth();else calendar.nextMonth();
            } else if (percentage >= 0.5) {
              if (app.rtl) calendar.nextMonth();else calendar.prevMonth();
            } else {
              calendar.resetMonth();
            } // Allow click


            setTimeout(function () {
              allowItemClick = true;
            }, 100);
          }

          function handleDayClick(e) {
            if (!allowItemClick) return;
            var $dayEl = $(e.target).parents('.calendar-day');

            if ($dayEl.length === 0 && $(e.target).hasClass('calendar-day')) {
              $dayEl = $(e.target);
            }

            if ($dayEl.length === 0) return;
            if ($dayEl.hasClass('calendar-day-disabled')) return;

            if (!calendar.params.rangePicker) {
              if ($dayEl.hasClass('calendar-day-next')) calendar.nextMonth();
              if ($dayEl.hasClass('calendar-day-prev')) calendar.prevMonth();
            }

            var dateYear = parseInt($dayEl.attr('data-year'), 10);
            var dateMonth = parseInt($dayEl.attr('data-month'), 10);
            var dateDay = parseInt($dayEl.attr('data-day'), 10);
            calendar.emit('local::dayClick calendarDayClick', calendar, $dayEl[0], dateYear, dateMonth, dateDay);

            if (!$dayEl.hasClass('calendar-day-selected') || calendar.params.multiple || calendar.params.rangePicker) {
              var valueToAdd = new Date(dateYear, dateMonth, dateDay, 0, 0, 0);

              if (calendar.hasTimePicker) {
                if (calendar.value && calendar.value[0]) {
                  valueToAdd.setHours(calendar.value[0].getHours(), calendar.value[0].getMinutes());
                } else {
                  valueToAdd.setHours(new Date().getHours(), new Date().getMinutes());
                }
              }

              calendar.addValue(valueToAdd);
            }

            if (calendar.params.closeOnSelect) {
              if (calendar.params.rangePicker && calendar.value.length === 2 || !calendar.params.rangePicker) {
                calendar.close();
              }
            }
          }

          function onNextMonthClick() {
            calendar.nextMonth();
          }

          function onPrevMonthClick() {
            calendar.prevMonth();
          }

          function onNextYearClick() {
            calendar.nextYear();
          }

          function onPrevYearClick() {
            calendar.prevYear();
          }

          function onMonthSelectorClick() {
            $el.append(calendar.renderMonthPicker());
          }

          function onMonthSelectorItemClick() {
            var $clickedEl = $(this);

            if ($clickedEl.hasClass('calendar-month-picker-item-current')) {
              $el.find('.calendar-month-picker').remove();
              return;
            }

            $el.find('.calendar-month-picker-item-current').add($clickedEl).toggleClass('calendar-month-picker-item-current');
            var index = $clickedEl.index();
            var localeMonthIndex = parseInt(calendar.$el.find('.calendar-month-current').attr('data-locale-month'), 10);
            var monthIndex = calendar.currentMonth;
            var diff = localeMonthIndex - monthIndex;
            var diffIndex = index - diff;
            calendar.setYearMonth(calendar.currentYear, diffIndex, 0);
            setTimeout(function () {
              $el.find('.calendar-month-picker').remove();
            }, 200);
          }

          function onYearSelectorClick() {
            $el.append(calendar.renderYearPicker());
            var $currentEl = $el.find('.calendar-year-picker-item-current');
            var $yearPickerEl = $el.find('.calendar-year-picker');
            if (!$currentEl || !$currentEl.length) return;
            $yearPickerEl.scrollTop($currentEl[0].offsetTop - $yearPickerEl[0].offsetHeight / 2 + $currentEl[0].offsetHeight / 2);
          }

          function onYearSelectorItemClick() {
            var $clickedEl = $(this);

            if ($clickedEl.hasClass('calendar-year-picker-item-current')) {
              $el.find('.calendar-year-picker').remove();
              return;
            }

            $el.find('.calendar-year-picker-item-current').add($clickedEl).toggleClass('calendar-year-picker-item-current');
            var year = parseInt($clickedEl.attr('data-year'), 10);
            calendar.setYearMonth(year, undefined, 0);
            setTimeout(function () {
              $el.find('.calendar-year-picker').remove();
            }, 200);
          }

          function onTimeSelectorClick() {
            calendar.openTimePicker();
          }

          function onTimePickerCloseClick() {
            calendar.closeTimePicker();
          }

          var passiveListener = app.touchEvents.start === 'touchstart' && getSupport$1().passiveListener ? {
            passive: true,
            capture: false
          } : false; // Selectors clicks

          $el.find('.calendar-prev-month-button').on('click', onPrevMonthClick);
          $el.find('.calendar-next-month-button').on('click', onNextMonthClick);
          $el.find('.calendar-prev-year-button').on('click', onPrevYearClick);
          $el.find('.calendar-next-year-button').on('click', onNextYearClick);

          if (calendar.params.monthPicker) {
            $el.find('.current-month-value').on('click', onMonthSelectorClick);
            $el.on('click', '.calendar-month-picker-item', onMonthSelectorItemClick);
          }

          if (calendar.params.yearPicker) {
            $el.find('.current-year-value').on('click', onYearSelectorClick);
            $el.on('click', '.calendar-year-picker-item', onYearSelectorItemClick);
          }

          if (calendar.hasTimePicker) {
            $el.find('.calendar-time-selector a').on('click', onTimeSelectorClick);
            $el.on('click', '.calendar-time-picker-close', onTimePickerCloseClick);
          } // Day clicks


          $wrapperEl.on('click', handleDayClick); // Touch events

          if (calendar.params.touchMove) {
            $wrapperEl.on(app.touchEvents.start, handleTouchStart, passiveListener);
            app.on('touchmove:active', handleTouchMove);
            app.on('touchend:passive', handleTouchEnd);
          }

          calendar.detachCalendarEvents = function detachCalendarEvents() {
            $el.find('.calendar-prev-month-button').off('click', onPrevMonthClick);
            $el.find('.calendar-next-month-button').off('click', onNextMonthClick);
            $el.find('.calendar-prev-year-button').off('click', onPrevYearClick);
            $el.find('.calendar-next-year-button').off('click', onNextYearClick);

            if (calendar.params.monthPicker) {
              $el.find('.current-month-value').off('click', onMonthSelectorClick);
              $el.off('click', '.calendar-month-picker-item', onMonthSelectorItemClick);
            }

            if (calendar.params.yearPicker) {
              $el.find('.current-year-value').off('click', onYearSelectorClick);
              $el.off('click', '.calendar-year-picker-item', onYearSelectorItemClick);
            }

            if (calendar.hasTimePicker) {
              $el.find('.calendar-time-selector a').off('click', onTimeSelectorClick);
              $el.off('click', '.calendar-time-picker-close', onTimePickerCloseClick);
            }

            $wrapperEl.off('click', handleDayClick);

            if (calendar.params.touchMove) {
              $wrapperEl.off(app.touchEvents.start, handleTouchStart, passiveListener);
              app.off('touchmove:active', handleTouchMove);
              app.off('touchend:passive', handleTouchEnd);
            }
          };
        };

        calendar.init();
        return calendar || _assertThisInitialized$c(_this);
      }

      var _proto = Calendar.prototype;

      _proto.getIntlNames = function getIntlNames() {
        var calendar = this;
        var locale = calendar.params.locale;
        var monthNamesIntl = [];
        var monthNamesShortIntl = [];
        var dayNamesIntl = [];
        var dayNamesShortIntl = [];
        var formatterMonthNames = new Intl.DateTimeFormat(locale, {
          month: 'long'
        });
        var formatterMonthNamesShort = new Intl.DateTimeFormat(locale, {
          month: 'short'
        });
        var formatterDayNames = new Intl.DateTimeFormat(locale, {
          weekday: 'long'
        });
        var formatterDayNamesShort = new Intl.DateTimeFormat(locale, {
          weekday: 'short'
        });
        var year;
        var yearStarted;
        var yearEnded;

        for (var i = 0; i < 24; i += 1) {
          var date = new Date().setMonth(i, 1);
          var currentYear = calendar.yearFormatter.format(date);

          if (year && currentYear !== year) {
            if (yearStarted) yearEnded = true;
            yearStarted = true;
            year = currentYear;
          }

          if (!year) {
            year = currentYear;
          }

          if (yearStarted && year === currentYear && !yearEnded) {
            monthNamesIntl.push(formatterMonthNames.format(date));
            monthNamesShortIntl.push(formatterMonthNamesShort.format(date));
          }
        }

        var weekDay = new Date().getDay();

        for (var _i = 0; _i < 7; _i += 1) {
          var _date = new Date().getTime() + (_i - weekDay) * 24 * 60 * 60 * 1000;

          dayNamesIntl.push(formatterDayNames.format(_date));
          dayNamesShortIntl.push(formatterDayNamesShort.format(_date));
        }

        return {
          monthNamesIntl: monthNamesIntl,
          monthNamesShortIntl: monthNamesShortIntl,
          dayNamesIntl: dayNamesIntl,
          dayNamesShortIntl: dayNamesShortIntl
        };
      };

      _proto.normalizeDate = function normalizeDate(date) {
        var calendar = this;
        var d = new Date(date);

        if (calendar.hasTimePicker) {
          return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());
        }

        return new Date(d.getFullYear(), d.getMonth(), d.getDate());
      };

      _proto.normalizeValues = function normalizeValues(values) {
        var calendar = this;
        var newValues = [];

        if (values && Array.isArray(values)) {
          newValues = values.map(function (val) {
            return calendar.normalizeDate(val);
          });
        }

        return newValues;
      };

      _proto.initInput = function initInput() {
        var calendar = this;
        if (!calendar.$inputEl) return;
        if (calendar.params.inputReadOnly) calendar.$inputEl.prop('readOnly', true);
      };

      _proto.isPopover = function isPopover() {
        var calendar = this;
        var app = calendar.app,
            modal = calendar.modal,
            params = calendar.params;
        var device = getDevice$1();
        if (params.openIn === 'sheet') return false;
        if (modal && modal.type !== 'popover') return false;

        if (!calendar.inline && calendar.inputEl) {
          if (params.openIn === 'popover') return true;

          if (device.ios) {
            return !!device.ipad;
          }

          if (app.width >= 768) {
            return true;
          }

          if (device.desktop && app.theme === 'aurora') {
            return true;
          }
        }

        return false;
      };

      _proto.formatDate = function formatDate(d) {
        var calendar = this;
        var date = new Date(d);
        var year = date.getFullYear();
        var month = date.getMonth();
        var month1 = month + 1;
        var day = date.getDate();
        var weekDay = date.getDay();
        var monthNames = calendar.monthNames,
            monthNamesShort = calendar.monthNamesShort,
            dayNames = calendar.dayNames,
            dayNamesShort = calendar.dayNamesShort;
        var _calendar$params2 = calendar.params,
            dateFormat = _calendar$params2.dateFormat,
            locale = _calendar$params2.locale;

        function twoDigits(number) {
          return number < 10 ? "0" + number : number;
        }

        if (typeof dateFormat === 'string') {
          var tokens = {
            yyyy: year,
            yy: String(year).substring(2),
            mm: twoDigits(month1),
            m: month1,
            MM: monthNames[month],
            M: monthNamesShort[month],
            dd: twoDigits(day),
            d: day,
            DD: dayNames[weekDay],
            D: dayNamesShort[weekDay]
          };

          if (calendar.params.timePicker) {
            var hours = date.getHours();
            var minutes = date.getMinutes();
            var seconds = date.getSeconds();
            var hours12 = hours;
            if (hours > 12) hours12 = hours - 12;
            if (hours === 0) hours12 = 12;
            var a = hours >= 12 && hours !== 0 ? 'pm' : 'am';
            Object.assign(tokens, {
              HH: twoDigits(hours),
              H: hours,
              hh: twoDigits(hours12),
              h: hours12,
              ss: twoDigits(seconds),
              s: seconds,
              ':mm': twoDigits(minutes),
              ':m': minutes,
              a: a,
              A: a.toUpperCase()
            });
          }

          var regexp = new RegExp(Object.keys(tokens).map(function (t) {
            return "(" + t + ")";
          }).join('|'), 'g');
          return dateFormat.replace(regexp, function (token) {
            if (token in tokens) return tokens[token];
            return token;
          });
        }

        if (typeof dateFormat === 'function') {
          return dateFormat(date);
        } // Intl Object


        var formatter = new Intl.DateTimeFormat(locale, dateFormat);
        return formatter.format(date);
      };

      _proto.formatValue = function formatValue() {
        var calendar = this;
        var value = calendar.value;

        if (calendar.params.formatValue) {
          return calendar.params.formatValue.call(calendar, value);
        }

        return value.map(function (v) {
          return calendar.formatDate(v);
        }).join(calendar.params.rangePicker ? ' - ' : ', ');
      };

      _proto.addValue = function addValue(newValue) {
        var calendar = this;
        var _calendar$params3 = calendar.params,
            multiple = _calendar$params3.multiple,
            rangePicker = _calendar$params3.rangePicker,
            rangePickerMinDays = _calendar$params3.rangePickerMinDays,
            rangePickerMaxDays = _calendar$params3.rangePickerMaxDays;

        if (multiple) {
          if (!calendar.value) calendar.value = [];
          var inValuesIndex;

          for (var i = 0; i < calendar.value.length; i += 1) {
            if (new Date(newValue).getTime() === new Date(calendar.value[i]).getTime()) {
              inValuesIndex = i;
            }
          }

          if (typeof inValuesIndex === 'undefined') {
            calendar.value.push(newValue);
          } else {
            calendar.value.splice(inValuesIndex, 1);
          }

          calendar.updateValue();
        } else if (rangePicker) {
          if (!calendar.value) calendar.value = [];

          if (calendar.value.length === 2 || calendar.value.length === 0) {
            calendar.value = [];
          }

          if (calendar.value.length === 0 || Math.abs(calendar.value[0].getTime() - newValue.getTime()) >= (rangePickerMinDays - 1) * 60 * 60 * 24 * 1000 && (rangePickerMaxDays === 0 || Math.abs(calendar.value[0].getTime() - newValue.getTime()) <= (rangePickerMaxDays - 1) * 60 * 60 * 24 * 1000)) calendar.value.push(newValue);else calendar.value = [];
          calendar.value.sort(function (a, b) {
            return a - b;
          });
          calendar.updateValue();
        } else {
          calendar.value = [newValue];
          calendar.updateValue();
        }
      };

      _proto.setValue = function setValue(values) {
        var calendar = this;
        var currentValue = calendar.value;

        if (Array.isArray(currentValue) && Array.isArray(values) && currentValue.length === values.length) {
          var equal = true;
          currentValue.forEach(function (v, index) {
            if (v !== values[index]) equal = false;
          });
          if (equal) return;
        }

        calendar.value = values;
        calendar.updateValue();
      };

      _proto.getValue = function getValue() {
        var calendar = this;
        return calendar.value;
      };

      _proto.updateValue = function updateValue(onlyHeader) {
        var calendar = this;
        var $el = calendar.$el,
            $wrapperEl = calendar.$wrapperEl,
            $inputEl = calendar.$inputEl,
            value = calendar.value,
            params = calendar.params;
        var i;

        if ($el && $el.length > 0) {
          $wrapperEl.find('.calendar-day-selected').removeClass('calendar-day-selected calendar-day-selected-range calendar-day-selected-left calendar-day-selected-right');
          var valueDate;

          if (params.rangePicker && value.length === 2) {
            var leftDate = new Date(value[0]).getTime();
            var rightDate = new Date(value[1]).getTime();

            for (i = leftDate; i <= rightDate; i += 24 * 60 * 60 * 1000) {
              valueDate = new Date(i);
              var addClass = 'calendar-day-selected';

              if (leftDate !== rightDate) {
                if (i !== leftDate && i !== rightDate) {
                  addClass += ' calendar-day-selected-range';
                }

                if (i === leftDate) {
                  addClass += ' calendar-day-selected-left';
                }

                if (i === rightDate) {
                  addClass += ' calendar-day-selected-right';
                }
              }

              $wrapperEl.find(".calendar-day[data-date=\"" + valueDate.getFullYear() + "-" + valueDate.getMonth() + "-" + valueDate.getDate() + "\"]").addClass(addClass);
            }

            valueDate = new Date(leftDate);
            $wrapperEl.find(".calendar-day[data-date=\"" + valueDate.getFullYear() + "-" + valueDate.getMonth() + "-" + valueDate.getDate() + "\"]").removeClass('calendar-day-selected-range').addClass('calendar-day-selected calendar-day-selected-left');
            valueDate = new Date(rightDate);
            $wrapperEl.find(".calendar-day[data-date=\"" + valueDate.getFullYear() + "-" + valueDate.getMonth() + "-" + valueDate.getDate() + "\"]").removeClass('calendar-day-selected-range').addClass('calendar-day-selected calendar-day-selected-right');
          } else {
            for (i = 0; i < calendar.value.length; i += 1) {
              valueDate = new Date(value[i]);
              $wrapperEl.find(".calendar-day[data-date=\"" + valueDate.getFullYear() + "-" + valueDate.getMonth() + "-" + valueDate.getDate() + "\"]").addClass('calendar-day-selected');
            }
          }
        }

        if (!onlyHeader) {
          calendar.emit('local::change calendarChange', calendar, value);
        }

        if ($el && $el.length > 0 && calendar.hasTimePicker) {
          $el.find('.calendar-time-selector a').text(value && value.length ? calendar.timeSelectorFormatter.format(value[0]) : calendar.params.timePickerPlaceholder);
        }

        if ($inputEl && $inputEl.length || params.header) {
          var inputValue = calendar.formatValue(value);

          if (params.header && $el && $el.length) {
            $el.find('.calendar-selected-date').text(inputValue);
          }

          if ($inputEl && $inputEl.length && !onlyHeader) {
            $inputEl.val(inputValue);
            $inputEl.trigger('change');
          }
        }
      };

      _proto.updateCurrentMonthYear = function updateCurrentMonthYear(dir) {
        var calendar = this;
        var $months = calendar.$months,
            $el = calendar.$el,
            monthNames = calendar.monthNames;
        var currentLocaleMonth;
        var currentLocaleYear;

        if (typeof dir === 'undefined') {
          calendar.currentMonth = parseInt($months.eq(1).attr('data-month'), 10);
          calendar.currentYear = parseInt($months.eq(1).attr('data-year'), 10);
          currentLocaleMonth = $months.eq(1).attr('data-locale-month');
          currentLocaleYear = $months.eq(1).attr('data-locale-year');
        } else {
          calendar.currentMonth = parseInt($months.eq(dir === 'next' ? $months.length - 1 : 0).attr('data-month'), 10);
          calendar.currentYear = parseInt($months.eq(dir === 'next' ? $months.length - 1 : 0).attr('data-year'), 10);
          currentLocaleMonth = $months.eq(dir === 'next' ? $months.length - 1 : 0).attr('data-locale-month');
          currentLocaleYear = $months.eq(dir === 'next' ? $months.length - 1 : 0).attr('data-locale-year');
        }

        $el.find('.current-month-value').text(monthNames[currentLocaleMonth]);
        $el.find('.current-year-value').text(currentLocaleYear);
      };

      _proto.update = function update() {
        var calendar = this;
        var currentYear = calendar.currentYear,
            currentMonth = calendar.currentMonth,
            $wrapperEl = calendar.$wrapperEl;
        var currentDate = new Date(currentYear, currentMonth);
        var prevMonthHtml = calendar.renderMonth(currentDate, 'prev');
        var currentMonthHtml = calendar.renderMonth(currentDate);
        var nextMonthHtml = calendar.renderMonth(currentDate, 'next');
        $wrapperEl.transition(0).html("" + prevMonthHtml + currentMonthHtml + nextMonthHtml).transform('translate3d(0,0,0)');
        calendar.$months = $wrapperEl.find('.calendar-month');
        calendar.monthsTranslate = 0;
        calendar.setMonthsTranslate();
        calendar.$months.each(function (monthEl) {
          calendar.emit('local::monthAdd calendarMonthAdd', monthEl);
        });
      };

      _proto.onMonthChangeStart = function onMonthChangeStart(dir) {
        var calendar = this;
        var $months = calendar.$months,
            currentYear = calendar.currentYear,
            currentMonth = calendar.currentMonth;
        calendar.updateCurrentMonthYear(dir);
        $months.removeClass('calendar-month-current calendar-month-prev calendar-month-next');
        var currentIndex = dir === 'next' ? $months.length - 1 : 0;
        $months.eq(currentIndex).addClass('calendar-month-current');
        $months.eq(dir === 'next' ? currentIndex - 1 : currentIndex + 1).addClass(dir === 'next' ? 'calendar-month-prev' : 'calendar-month-next');
        calendar.emit('local::monthYearChangeStart calendarMonthYearChangeStart', calendar, currentYear, currentMonth);
      };

      _proto.onMonthChangeEnd = function onMonthChangeEnd(dir, rebuildBoth) {
        var calendar = this;
        var currentYear = calendar.currentYear,
            currentMonth = calendar.currentMonth,
            $wrapperEl = calendar.$wrapperEl,
            monthsTranslate = calendar.monthsTranslate;
        calendar.animating = false;
        var nextMonthHtml;
        var prevMonthHtml;
        var currentMonthHtml;
        $wrapperEl.find('.calendar-month:not(.calendar-month-prev):not(.calendar-month-current):not(.calendar-month-next)').remove();

        if (typeof dir === 'undefined') {
          dir = 'next'; // eslint-disable-line

          rebuildBoth = true; // eslint-disable-line
        }

        if (!rebuildBoth) {
          currentMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), dir);
        } else {
          $wrapperEl.find('.calendar-month-next, .calendar-month-prev').remove();
          prevMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), 'prev');
          nextMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), 'next');
        }

        if (dir === 'next' || rebuildBoth) {
          $wrapperEl.append(currentMonthHtml || nextMonthHtml);
        }

        if (dir === 'prev' || rebuildBoth) {
          $wrapperEl.prepend(currentMonthHtml || prevMonthHtml);
        }

        var $months = $wrapperEl.find('.calendar-month');
        calendar.$months = $months;
        calendar.setMonthsTranslate(monthsTranslate);
        calendar.emit('local::monthAdd calendarMonthAdd', calendar, dir === 'next' ? $months.eq($months.length - 1)[0] : $months.eq(0)[0]);
        calendar.emit('local::monthYearChangeEnd calendarMonthYearChangeEnd', calendar, currentYear, currentMonth);
      };

      _proto.setMonthsTranslate = function setMonthsTranslate(translate) {
        var calendar = this;
        var $months = calendar.$months,
            isH = calendar.isHorizontal,
            inverter = calendar.inverter; // eslint-disable-next-line

        translate = translate || calendar.monthsTranslate || 0;

        if (typeof calendar.monthsTranslate === 'undefined') {
          calendar.monthsTranslate = translate;
        }

        $months.removeClass('calendar-month-current calendar-month-prev calendar-month-next');
        var prevMonthTranslate = -(translate + 1) * 100 * inverter;
        var currentMonthTranslate = -translate * 100 * inverter;
        var nextMonthTranslate = -(translate - 1) * 100 * inverter;
        $months.eq(0).transform("translate3d(" + (isH ? prevMonthTranslate : 0) + "%, " + (isH ? 0 : prevMonthTranslate) + "%, 0)").addClass('calendar-month-prev');
        $months.eq(1).transform("translate3d(" + (isH ? currentMonthTranslate : 0) + "%, " + (isH ? 0 : currentMonthTranslate) + "%, 0)").addClass('calendar-month-current');
        $months.eq(2).transform("translate3d(" + (isH ? nextMonthTranslate : 0) + "%, " + (isH ? 0 : nextMonthTranslate) + "%, 0)").addClass('calendar-month-next');
      };

      _proto.nextMonth = function nextMonth(transition) {
        var calendar = this;
        var params = calendar.params,
            $wrapperEl = calendar.$wrapperEl,
            inverter = calendar.inverter,
            isH = calendar.isHorizontal;

        if (typeof transition === 'undefined' || typeof transition === 'object') {
          transition = ''; // eslint-disable-line

          if (!params.animate) transition = 0; // eslint-disable-line
        }

        var nextMonth = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr('data-month'), 10);
        var nextYear = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr('data-year'), 10);
        var nextDate = new Date(nextYear, nextMonth);
        var nextDateTime = nextDate.getTime();
        var transitionEndCallback = !calendar.animating;

        if (params.maxDate) {
          if (nextDateTime > new Date(params.maxDate).getTime()) {
            calendar.resetMonth();
            return;
          }
        }

        calendar.monthsTranslate -= 1;

        if (nextMonth === calendar.currentMonth) {
          var nextMonthTranslate = -calendar.monthsTranslate * 100 * inverter;
          var nextMonthHtml = $(calendar.renderMonth(nextDateTime, 'next')).transform("translate3d(" + (isH ? nextMonthTranslate : 0) + "%, " + (isH ? 0 : nextMonthTranslate) + "%, 0)").addClass('calendar-month-next');
          $wrapperEl.append(nextMonthHtml[0]);
          calendar.$months = $wrapperEl.find('.calendar-month');
          calendar.emit('local::monthAdd calendarMonthAdd', calendar.$months.eq(calendar.$months.length - 1)[0]);
        }

        calendar.animating = true;
        calendar.onMonthChangeStart('next');
        var translate = calendar.monthsTranslate * 100 * inverter;
        $wrapperEl.transition(transition).transform("translate3d(" + (isH ? translate : 0) + "%, " + (isH ? 0 : translate) + "%, 0)");

        if (transitionEndCallback) {
          $wrapperEl.transitionEnd(function () {
            calendar.onMonthChangeEnd('next');
          });
        }

        if (!params.animate) {
          calendar.onMonthChangeEnd('next');
        }
      };

      _proto.prevMonth = function prevMonth(transition) {
        var calendar = this;
        var params = calendar.params,
            $wrapperEl = calendar.$wrapperEl,
            inverter = calendar.inverter,
            isH = calendar.isHorizontal;

        if (typeof transition === 'undefined' || typeof transition === 'object') {
          transition = ''; // eslint-disable-line

          if (!params.animate) transition = 0; // eslint-disable-line
        }

        var prevMonth = parseInt(calendar.$months.eq(0).attr('data-month'), 10);
        var prevYear = parseInt(calendar.$months.eq(0).attr('data-year'), 10);
        var prevDate = new Date(prevYear, prevMonth + 1, -1);
        var prevDateTime = prevDate.getTime();
        var transitionEndCallback = !calendar.animating;

        if (params.minDate) {
          var minDate = new Date(params.minDate);
          minDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);

          if (prevDateTime < minDate.getTime()) {
            calendar.resetMonth();
            return;
          }
        }

        calendar.monthsTranslate += 1;

        if (prevMonth === calendar.currentMonth) {
          var prevMonthTranslate = -calendar.monthsTranslate * 100 * inverter;
          var prevMonthHtml = $(calendar.renderMonth(prevDateTime, 'prev')).transform("translate3d(" + (isH ? prevMonthTranslate : 0) + "%, " + (isH ? 0 : prevMonthTranslate) + "%, 0)").addClass('calendar-month-prev');
          $wrapperEl.prepend(prevMonthHtml[0]);
          calendar.$months = $wrapperEl.find('.calendar-month');
          calendar.emit('local::monthAdd calendarMonthAdd', calendar.$months.eq(0)[0]);
        }

        calendar.animating = true;
        calendar.onMonthChangeStart('prev');
        var translate = calendar.monthsTranslate * 100 * inverter;
        $wrapperEl.transition(transition).transform("translate3d(" + (isH ? translate : 0) + "%, " + (isH ? 0 : translate) + "%, 0)");

        if (transitionEndCallback) {
          $wrapperEl.transitionEnd(function () {
            calendar.onMonthChangeEnd('prev');
          });
        }

        if (!params.animate) {
          calendar.onMonthChangeEnd('prev');
        }
      };

      _proto.resetMonth = function resetMonth(transition) {
        if (transition === void 0) {
          transition = '';
        }

        var calendar = this;
        var $wrapperEl = calendar.$wrapperEl,
            inverter = calendar.inverter,
            isH = calendar.isHorizontal,
            monthsTranslate = calendar.monthsTranslate;
        var translate = monthsTranslate * 100 * inverter;
        $wrapperEl.transition(transition).transform("translate3d(" + (isH ? translate : 0) + "%, " + (isH ? 0 : translate) + "%, 0)");
      } // eslint-disable-next-line
      ;

      _proto.setYearMonth = function setYearMonth(year, month, transition) {
        var calendar = this;
        var params = calendar.params,
            isH = calendar.isHorizontal,
            $wrapperEl = calendar.$wrapperEl,
            inverter = calendar.inverter; // eslint-disable-next-line

        if (typeof year === 'undefined') year = calendar.currentYear; // eslint-disable-next-line

        if (typeof month === 'undefined') month = calendar.currentMonth;

        if (typeof transition === 'undefined' || typeof transition === 'object') {
          // eslint-disable-next-line
          transition = ''; // eslint-disable-next-line

          if (!params.animate) transition = 0;
        }

        var targetDate;

        if (year < calendar.currentYear) {
          targetDate = new Date(year, month + 1, -1).getTime();
        } else {
          targetDate = new Date(year, month).getTime();
        }

        if (params.maxDate && targetDate > new Date(params.maxDate).getTime()) {
          return false;
        }

        if (params.minDate) {
          var minDate = new Date(params.minDate);
          minDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);

          if (targetDate < minDate.getTime()) {
            return false;
          }
        }

        var currentDate = new Date(calendar.currentYear, calendar.currentMonth).getTime();
        var dir = targetDate > currentDate ? 'next' : 'prev';
        var newMonthHTML = calendar.renderMonth(new Date(year, month));
        calendar.monthsTranslate = calendar.monthsTranslate || 0;
        var prevTranslate = calendar.monthsTranslate;
        var monthTranslate;
        var transitionEndCallback = !calendar.animating && transition !== 0;

        if (targetDate > currentDate) {
          // To next
          calendar.monthsTranslate -= 1;
          if (!calendar.animating) calendar.$months.eq(calendar.$months.length - 1).remove();
          $wrapperEl.append(newMonthHTML);
          calendar.$months = $wrapperEl.find('.calendar-month');
          monthTranslate = -(prevTranslate - 1) * 100 * inverter;
          calendar.$months.eq(calendar.$months.length - 1).transform("translate3d(" + (isH ? monthTranslate : 0) + "%, " + (isH ? 0 : monthTranslate) + "%, 0)").addClass('calendar-month-next');
        } else {
          // To prev
          calendar.monthsTranslate += 1;
          if (!calendar.animating) calendar.$months.eq(0).remove();
          $wrapperEl.prepend(newMonthHTML);
          calendar.$months = $wrapperEl.find('.calendar-month');
          monthTranslate = -(prevTranslate + 1) * 100 * inverter;
          calendar.$months.eq(0).transform("translate3d(" + (isH ? monthTranslate : 0) + "%, " + (isH ? 0 : monthTranslate) + "%, 0)").addClass('calendar-month-prev');
        }

        calendar.emit('local::monthAdd calendarMonthAdd', dir === 'next' ? calendar.$months.eq(calendar.$months.length - 1)[0] : calendar.$months.eq(0)[0]);
        calendar.animating = true;
        calendar.onMonthChangeStart(dir);
        var wrapperTranslate = calendar.monthsTranslate * 100 * inverter;
        $wrapperEl.transition(transition).transform("translate3d(" + (isH ? wrapperTranslate : 0) + "%, " + (isH ? 0 : wrapperTranslate) + "%, 0)");

        if (transitionEndCallback) {
          $wrapperEl.transitionEnd(function () {
            calendar.onMonthChangeEnd(dir, true);
          });
        }

        if (!params.animate || transition === 0) {
          calendar.onMonthChangeEnd(dir, true);
        }
      };

      _proto.nextYear = function nextYear() {
        var calendar = this;
        calendar.setYearMonth(calendar.currentYear + 1);
      };

      _proto.prevYear = function prevYear() {
        var calendar = this;
        calendar.setYearMonth(calendar.currentYear - 1);
      } // eslint-disable-next-line
      ;

      _proto.dateInRange = function dateInRange(dayDate, range) {
        var match = false;
        var i;
        if (!range) return false;

        if (Array.isArray(range)) {
          for (i = 0; i < range.length; i += 1) {
            if (range[i].from || range[i].to) {
              if (range[i].from && range[i].to) {
                if (dayDate <= new Date(range[i].to).getTime() && dayDate >= new Date(range[i].from).getTime()) {
                  match = true;
                }
              } else if (range[i].from) {
                if (dayDate >= new Date(range[i].from).getTime()) {
                  match = true;
                }
              } else if (range[i].to) {
                if (dayDate <= new Date(range[i].to).getTime()) {
                  match = true;
                }
              }
            } else if (range[i].date) {
              if (dayDate === new Date(range[i].date).getTime()) {
                match = true;
              }
            } else if (dayDate === new Date(range[i]).getTime()) {
              match = true;
            }
          }
        } else if (range.from || range.to) {
          if (range.from && range.to) {
            if (dayDate <= new Date(range.to).getTime() && dayDate >= new Date(range.from).getTime()) {
              match = true;
            }
          } else if (range.from) {
            if (dayDate >= new Date(range.from).getTime()) {
              match = true;
            }
          } else if (range.to) {
            if (dayDate <= new Date(range.to).getTime()) {
              match = true;
            }
          }
        } else if (range.date) {
          match = dayDate === new Date(range.date).getTime();
        } else if (typeof range === 'function') {
          match = range(new Date(dayDate));
        }

        return match;
      } // eslint-disable-next-line
      ;

      _proto.daysInMonth = function daysInMonth(date) {
        var d = new Date(date);
        return new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
      };

      _proto.renderMonths = function renderMonths(date) {
        var calendar = this;

        if (calendar.params.renderMonths) {
          return calendar.params.renderMonths.call(calendar, date);
        }

        return $jsx$1("div", {
          class: "calendar-months-wrapper"
        }, calendar.renderMonth(date, 'prev'), calendar.renderMonth(date), calendar.renderMonth(date, 'next'));
      };

      _proto.renderMonth = function renderMonth(d, offset) {
        var calendar = this;
        var params = calendar.params,
            value = calendar.value;

        if (params.renderMonth) {
          return params.renderMonth.call(calendar, d, offset);
        }

        var date = new Date(d);
        var year = date.getFullYear();
        var month = date.getMonth();
        var localeMonth = calendar.monthNames.indexOf(calendar.monthFormatter.format(date));
        if (localeMonth < 0) localeMonth = month;
        var localeYear = calendar.yearFormatter.format(date);

        if (offset === 'next') {
          if (month === 11) date = new Date(year + 1, 0);else date = new Date(year, month + 1, 1);
        }

        if (offset === 'prev') {
          if (month === 0) date = new Date(year - 1, 11);else date = new Date(year, month - 1, 1);
        }

        if (offset === 'next' || offset === 'prev') {
          month = date.getMonth();
          year = date.getFullYear();
          localeMonth = calendar.monthNames.indexOf(calendar.monthFormatter.format(date));
          if (localeMonth < 0) localeMonth = month;
          localeYear = calendar.yearFormatter.format(date);
        }

        var currentValues = [];
        var today = new Date().setHours(0, 0, 0, 0);
        var minDate = params.minDate ? new Date(params.minDate).getTime() : null;
        var maxDate = params.maxDate ? new Date(params.maxDate).getTime() : null;
        var rows = 6;
        var cols = 7;
        var daysInPrevMonth = calendar.daysInMonth(new Date(date.getFullYear(), date.getMonth()).getTime() - 10 * 24 * 60 * 60 * 1000);
        var daysInMonth = calendar.daysInMonth(date);
        var minDayNumber = params.firstDay === 6 ? 0 : 1;
        var monthHtml = '';
        var dayIndex = 0 + (params.firstDay - 1);
        var disabled;
        var hasEvents;
        var firstDayOfMonthIndex = new Date(date.getFullYear(), date.getMonth()).getDay();
        if (firstDayOfMonthIndex === 0) firstDayOfMonthIndex = 7;

        if (value && value.length) {
          for (var i = 0; i < value.length; i += 1) {
            currentValues.push(new Date(value[i]).setHours(0, 0, 0, 0));
          }
        }

        for (var row = 1; row <= rows; row += 1) {
          var rowHtml = '';

          var _loop = function _loop(col) {
            dayIndex += 1;
            var dayDate = void 0;
            var dayNumber = dayIndex - firstDayOfMonthIndex;
            var addClass = '';

            if (row === 1 && col === 1 && dayNumber > minDayNumber && params.firstDay !== 1) {
              dayIndex -= 7;
              dayNumber = dayIndex - firstDayOfMonthIndex;
            }

            var weekDayIndex = col - 1 + params.firstDay > 6 ? col - 1 - 7 + params.firstDay : col - 1 + params.firstDay;

            if (dayNumber < 0) {
              dayNumber = daysInPrevMonth + dayNumber + 1;
              addClass += ' calendar-day-prev';
              dayDate = new Date(month - 1 < 0 ? year - 1 : year, month - 1 < 0 ? 11 : month - 1, dayNumber).getTime();
            } else {
              dayNumber += 1;

              if (dayNumber > daysInMonth) {
                dayNumber -= daysInMonth;
                addClass += ' calendar-day-next';
                dayDate = new Date(month + 1 > 11 ? year + 1 : year, month + 1 > 11 ? 0 : month + 1, dayNumber).getTime();
              } else {
                dayDate = new Date(year, month, dayNumber).getTime();
              }
            } // Today


            if (dayDate === today) addClass += ' calendar-day-today'; // Selected

            if (params.rangePicker && currentValues.length === 2) {
              if (dayDate >= currentValues[0] && dayDate <= currentValues[1]) {
                addClass += ' calendar-day-selected';
              }

              if (currentValues[0] !== currentValues[1]) {
                if (dayDate > currentValues[0] && dayDate < currentValues[1]) {
                  addClass += ' calendar-day-selected-range';
                }

                if (dayDate === currentValues[0]) {
                  addClass += ' calendar-day-selected-left';
                }

                if (dayDate === currentValues[1]) {
                  addClass += ' calendar-day-selected-right';
                }
              }
            } else if (currentValues.indexOf(dayDate) >= 0) addClass += ' calendar-day-selected'; // Weekend


            if (params.weekendDays.indexOf(weekDayIndex) >= 0) {
              addClass += ' calendar-day-weekend';
            } // Events


            var eventsHtml = '';
            hasEvents = false;

            if (params.events) {
              if (calendar.dateInRange(dayDate, params.events)) {
                hasEvents = true;
              }
            }

            if (hasEvents) {
              addClass += ' calendar-day-has-events'; // prettier-ignore

              eventsHtml = "\n            <span class=\"calendar-day-events\">\n              <span class=\"calendar-day-event\"></span>\n            </span>\n          ";

              if (Array.isArray(params.events)) {
                var eventDots = [];
                params.events.forEach(function (ev) {
                  var color = ev.color || '';

                  if (eventDots.indexOf(color) < 0 && calendar.dateInRange(dayDate, ev)) {
                    eventDots.push(color);
                  }
                }); // prettier-ignore

                eventsHtml = "\n              <span class=\"calendar-day-events\">\n                " + eventDots.map(function (color) {
                  return ("\n                  <span class=\"calendar-day-event\" style=\"" + (color ? "background-color: " + color : '') + "\"></span>\n                ").trim();
                }).join('') + "\n              </span>\n            ";
              }
            } // Custom Ranges


            if (params.rangesClasses) {
              for (var k = 0; k < params.rangesClasses.length; k += 1) {
                if (calendar.dateInRange(dayDate, params.rangesClasses[k].range)) {
                  addClass += " " + params.rangesClasses[k].cssClass;
                }
              }
            } // Disabled


            disabled = false;

            if (minDate && dayDate < minDate || maxDate && dayDate > maxDate) {
              disabled = true;
            }

            if (params.disabled) {
              if (calendar.dateInRange(dayDate, params.disabled)) {
                disabled = true;
              }
            }

            if (disabled) {
              addClass += ' calendar-day-disabled';
            }

            dayDate = new Date(dayDate);
            var dayYear = dayDate.getFullYear();
            var dayMonth = dayDate.getMonth();
            var dayNumberDisplay = calendar.dayFormatter.format(dayDate); // prettier-ignore

            rowHtml += ("\n          <div data-year=\"" + dayYear + "\" data-month=\"" + dayMonth + "\" data-day=\"" + dayNumber + "\" class=\"calendar-day" + addClass + "\" data-date=\"" + dayYear + "-" + dayMonth + "-" + dayNumber + "\">\n            <span class=\"calendar-day-number\">" + dayNumberDisplay + eventsHtml + "</span>\n          </div>").trim();
          };

          for (var col = 1; col <= cols; col += 1) {
            _loop(col);
          }

          monthHtml += "<div class=\"calendar-row\">" + rowHtml + "</div>";
        }

        monthHtml = "<div class=\"calendar-month\" data-year=\"" + year + "\" data-month=\"" + month + "\" data-locale-year=\"" + localeYear + "\" data-locale-month=\"" + localeMonth + "\">" + monthHtml + "</div>";
        return monthHtml;
      };

      _proto.renderWeekHeader = function renderWeekHeader() {
        var calendar = this;

        if (calendar.params.renderWeekHeader) {
          return calendar.params.renderWeekHeader.call(calendar);
        }

        var params = calendar.params;
        var weekDaysHtml = '';

        for (var i = 0; i < 7; i += 1) {
          var dayIndex = i + params.firstDay > 6 ? i - 7 + params.firstDay : i + params.firstDay;
          var dayName = calendar.dayNamesShort[dayIndex];
          weekDaysHtml += "<div class=\"calendar-week-day\">" + dayName + "</div>";
        }

        return $jsx$1("div", {
          class: "calendar-week-header"
        }, weekDaysHtml);
      };

      _proto.renderMonthSelector = function renderMonthSelector() {
        var calendar = this;

        if (calendar.params.renderMonthSelector) {
          return calendar.params.renderMonthSelector.call(calendar);
        }

        return $jsx$1("div", {
          class: "calendar-month-selector"
        }, $jsx$1("a", {
          class: "link icon-only calendar-prev-month-button"
        }, $jsx$1("i", {
          class: "icon icon-prev"
        })), calendar.params.monthPicker ? $jsx$1("a", {
          class: "current-month-value link"
        }) : $jsx$1("span", {
          class: "current-month-value"
        }), $jsx$1("a", {
          class: "link icon-only calendar-next-month-button"
        }, $jsx$1("i", {
          class: "icon icon-next"
        })));
      };

      _proto.renderMonthPicker = function renderMonthPicker() {
        var calendar = this;
        var localeMonth = parseInt(calendar.$el.find('.calendar-month-current').attr('data-locale-month'), 10);
        return $jsx$1("div", {
          class: "calendar-month-picker"
        }, calendar.monthNames.map(function (m, index) {
          return $jsx$1("div", {
            class: "calendar-month-picker-item " + (localeMonth === index ? 'calendar-month-picker-item-current' : '')
          }, $jsx$1("span", null, m));
        }));
      };

      _proto.renderYearSelector = function renderYearSelector() {
        var calendar = this;

        if (calendar.params.renderYearSelector) {
          return calendar.params.renderYearSelector.call(calendar);
        }

        return $jsx$1("div", {
          class: "calendar-year-selector"
        }, $jsx$1("a", {
          class: "link icon-only calendar-prev-year-button"
        }, $jsx$1("i", {
          class: "icon icon-prev"
        })), calendar.params.yearPicker ? $jsx$1("a", {
          class: "current-year-value link"
        }) : $jsx$1("span", {
          class: "current-year-value"
        }), $jsx$1("a", {
          class: "link icon-only calendar-next-year-button"
        }, $jsx$1("i", {
          class: "icon icon-next"
        })));
      };

      _proto.renderYearPicker = function renderYearPicker() {
        var calendar = this;
        var currentYear = calendar.currentYear;
        var yearMin = calendar.params.yearPickerMin || new Date().getFullYear() - 100;

        if (calendar.params.minDate) {
          yearMin = Math.max(yearMin, new Date(calendar.params.minDate).getFullYear());
        }

        var yearMax = calendar.params.yearPickerMax || new Date().getFullYear() + 100;

        if (calendar.params.maxDate) {
          yearMax = Math.min(yearMax, new Date(calendar.params.maxDate).getFullYear());
        }

        var years = [];

        for (var i = yearMin; i <= yearMax; i += 1) {
          years.push(i);
        }

        return $jsx$1("div", {
          class: "calendar-year-picker"
        }, years.map(function (year) {
          return $jsx$1("div", {
            "data-year": year,
            class: "calendar-year-picker-item " + (year === currentYear ? 'calendar-year-picker-item-current' : '')
          }, $jsx$1("span", null, calendar.yearFormatter.format(new Date().setFullYear(year))));
        }));
      } // eslint-disable-next-line
      ;

      _proto.renderTimeSelector = function renderTimeSelector() {
        var calendar = this;
        var value = calendar.value && calendar.value[0];
        var timeString;
        if (value) timeString = calendar.timeSelectorFormatter.format(value);
        return $jsx$1("div", {
          class: "calendar-time-selector"
        }, $jsx$1("a", {
          class: "link"
        }, timeString || calendar.params.timePickerPlaceholder));
      };

      _proto.renderHeader = function renderHeader() {
        var calendar = this;

        if (calendar.params.renderHeader) {
          return calendar.params.renderHeader.call(calendar);
        }

        return $jsx$1("div", {
          class: "calendar-header"
        }, $jsx$1("div", {
          class: "calendar-selected-date"
        }, calendar.params.headerPlaceholder));
      };

      _proto.renderFooter = function renderFooter() {
        var calendar = this;
        var app = calendar.app;

        if (calendar.params.renderFooter) {
          return calendar.params.renderFooter.call(calendar);
        }

        return $jsx$1("div", {
          class: "calendar-footer"
        }, $jsx$1("a", {
          class: (app.theme === 'md' ? 'button' : 'link') + " calendar-close sheet-close popover-close"
        }, calendar.params.toolbarCloseText));
      };

      _proto.renderToolbar = function renderToolbar() {
        var calendar = this;

        if (calendar.params.renderToolbar) {
          return calendar.params.renderToolbar.call(calendar, calendar);
        } // prettier-ignore


        return $jsx$1("div", {
          class: "toolbar toolbar-top no-shadow"
        }, $jsx$1("div", {
          class: "toolbar-inner"
        }, calendar.params.monthSelector ? calendar.renderMonthSelector() : '', calendar.params.yearSelector ? calendar.renderYearSelector() : ''));
      } // eslint-disable-next-line
      ;

      _proto.renderInline = function renderInline() {
        var calendar = this;
        var _calendar$params4 = calendar.params,
            cssClass = _calendar$params4.cssClass,
            toolbar = _calendar$params4.toolbar,
            header = _calendar$params4.header,
            footer = _calendar$params4.footer,
            rangePicker = _calendar$params4.rangePicker,
            weekHeader = _calendar$params4.weekHeader;
        var value = calendar.value,
            hasTimePicker = calendar.hasTimePicker;
        var date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
        return $jsx$1("div", {
          class: "calendar calendar-inline " + (rangePicker ? 'calendar-range' : '') + " " + (cssClass || '')
        }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), $jsx$1("div", {
          class: "calendar-months"
        }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
      };

      _proto.renderCustomModal = function renderCustomModal() {
        var calendar = this;
        var _calendar$params5 = calendar.params,
            cssClass = _calendar$params5.cssClass,
            toolbar = _calendar$params5.toolbar,
            header = _calendar$params5.header,
            footer = _calendar$params5.footer,
            rangePicker = _calendar$params5.rangePicker,
            weekHeader = _calendar$params5.weekHeader;
        var value = calendar.value,
            hasTimePicker = calendar.hasTimePicker;
        var date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
        return $jsx$1("div", {
          class: "calendar calendar-modal " + (rangePicker ? 'calendar-range' : '') + " " + (cssClass || '')
        }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), $jsx$1("div", {
          class: "calendar-months"
        }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
      };

      _proto.renderSheet = function renderSheet() {
        var calendar = this;
        var _calendar$params6 = calendar.params,
            cssClass = _calendar$params6.cssClass,
            toolbar = _calendar$params6.toolbar,
            header = _calendar$params6.header,
            footer = _calendar$params6.footer,
            rangePicker = _calendar$params6.rangePicker,
            weekHeader = _calendar$params6.weekHeader;
        var value = calendar.value,
            hasTimePicker = calendar.hasTimePicker;
        var date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
        return $jsx$1("div", {
          class: "sheet-modal calendar calendar-sheet " + (rangePicker ? 'calendar-range' : '') + " " + (cssClass || '')
        }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), $jsx$1("div", {
          class: "sheet-modal-inner calendar-months"
        }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
      };

      _proto.renderPopover = function renderPopover() {
        var calendar = this;
        var _calendar$params7 = calendar.params,
            cssClass = _calendar$params7.cssClass,
            toolbar = _calendar$params7.toolbar,
            header = _calendar$params7.header,
            footer = _calendar$params7.footer,
            rangePicker = _calendar$params7.rangePicker,
            weekHeader = _calendar$params7.weekHeader;
        var value = calendar.value,
            hasTimePicker = calendar.hasTimePicker;
        var date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
        return $jsx$1("div", {
          class: "popover calendar-popover"
        }, $jsx$1("div", {
          class: "popover-inner"
        }, $jsx$1("div", {
          class: "calendar " + (rangePicker ? 'calendar-range' : '') + " " + (cssClass || '')
        }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), $jsx$1("div", {
          class: "calendar-months"
        }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter())));
      };

      _proto.render = function render() {
        var calendar = this;
        var params = calendar.params;
        if (params.render) return params.render.call(calendar);

        if (!calendar.inline) {
          var modalType = params.openIn;
          if (modalType === 'auto') modalType = calendar.isPopover() ? 'popover' : 'sheet';
          if (modalType === 'popover') return calendar.renderPopover();
          if (modalType === 'sheet') return calendar.renderSheet();
          return calendar.renderCustomModal();
        }

        return calendar.renderInline();
      };

      _proto.openTimePicker = function openTimePicker() {
        var calendar = this;
        var $el = calendar.$el,
            app = calendar.app,
            is12HoursFormat = calendar.is12HoursFormat;
        if (!$el || !$el.length) return;
        $el.append('<div class="calendar-time-picker"></div>');
        var hoursArr = [];
        var minutesArr = [];
        var hoursMin = is12HoursFormat ? 1 : 0;
        var hoursMax = is12HoursFormat ? 12 : 23;

        for (var i = hoursMin; i <= hoursMax; i += 1) {
          hoursArr.push(i);
        }

        for (var _i2 = 0; _i2 <= 59; _i2 += 1) {
          minutesArr.push(_i2);
        }

        var value;

        if (calendar.value && calendar.value.length) {
          value = [calendar.value[0].getHours(), calendar.value[0].getMinutes()];
        } else {
          value = [new Date().getHours(), new Date().getMinutes()];
        }

        if (is12HoursFormat) {
          value.push(value[0] < 12 ? 'AM' : 'PM');
          if (value[0] > 12) value[0] -= 12;
          if (value[0] === 0) value[0] = 12;
        }

        calendar.timePickerInstance = app.picker.create({
          containerEl: $el.find('.calendar-time-picker'),
          value: value,
          toolbar: true,
          rotateEffect: false,
          toolbarCloseText: calendar.params.toolbarCloseText,
          cols: [{
            values: hoursArr
          }, {
            divider: true,
            content: ':'
          }, {
            values: minutesArr,
            displayValues: minutesArr.map(function (m) {
              return m < 10 ? "0" + m : m;
            })
          }].concat(is12HoursFormat ? [{
            values: ['AM', 'PM']
          }] : [])
        });
        calendar.timePickerInstance.$el.find('.toolbar a').removeClass('sheet-close popover-close').addClass('calendar-time-picker-close');
      };

      _proto.closeTimePicker = function closeTimePicker() {
        var calendar = this;
        var is12HoursFormat = calendar.is12HoursFormat;

        if (calendar.timePickerInstance) {
          var timePickerValue = calendar.timePickerInstance.value;
          var hours = parseInt(timePickerValue[0], 10);
          var minutes = parseInt(timePickerValue[1], 10);
          var period = calendar.timePickerInstance.value[2];

          if (is12HoursFormat) {
            if (period === 'AM' && hours === 12) {
              hours = 0;
            } else if (period === 'PM' && hours !== 12) {
              hours += 12;
            }
          }

          var value = calendar.value && calendar.value.length && calendar.value[0];

          if (!value) {
            value = new Date();
            value.setHours(hours, minutes, 0, 0);
          } else {
            value = new Date(value);
            value.setHours(hours, minutes);
          }

          calendar.setValue([value]);
          calendar.timePickerInstance.close();
          calendar.timePickerInstance.destroy();
          delete calendar.timePickerInstance;
        }

        if (calendar.$el && calendar.$el.length) {
          calendar.$el.find('.calendar-time-picker').remove();
        }
      };

      _proto.onOpen = function onOpen() {
        var calendar = this;
        var initialized = calendar.initialized,
            $el = calendar.$el,
            app = calendar.app,
            $inputEl = calendar.$inputEl,
            inline = calendar.inline,
            value = calendar.value,
            params = calendar.params;
        calendar.closing = false;
        calendar.opened = true;
        calendar.opening = true; // Init main events

        calendar.attachCalendarEvents();
        var updateValue = !value && params.value; // Set value

        if (!initialized) {
          if (value) calendar.setValue(value, 0);else if (params.value) {
            calendar.setValue(calendar.normalizeValues(params.value), 0);
          }
        } else if (value) {
          calendar.setValue(value, 0);
        } // Update current month and year


        calendar.updateCurrentMonthYear(); // Set initial translate

        calendar.monthsTranslate = 0;
        calendar.setMonthsTranslate(); // Update input value

        if (updateValue) calendar.updateValue();else if (params.header && value) {
          calendar.updateValue(true);
        } // Extra focus

        if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
          $inputEl.trigger('focus');
        }

        calendar.initialized = true;
        calendar.$months.each(function (monthEl) {
          calendar.emit('local::monthAdd calendarMonthAdd', monthEl);
        }); // Trigger events

        if ($el) {
          $el.trigger('calendar:open');
        }

        if ($inputEl) {
          $inputEl.trigger('calendar:open');
        }

        calendar.emit('local::open calendarOpen', calendar);
      };

      _proto.onOpened = function onOpened() {
        var calendar = this;
        calendar.opening = false;

        if (calendar.$el) {
          calendar.$el.trigger('calendar:opened');
        }

        if (calendar.$inputEl) {
          calendar.$inputEl.trigger('calendar:opened');
        }

        calendar.emit('local::opened calendarOpened', calendar);
      };

      _proto.onClose = function onClose() {
        var calendar = this;
        var app = calendar.app;
        calendar.opening = false;
        calendar.closing = true;

        if (calendar.$inputEl) {
          if (app.theme === 'md') {
            calendar.$inputEl.trigger('blur');
          } else {
            var validate = calendar.$inputEl.attr('validate');
            var required = calendar.$inputEl.attr('required');

            if (validate && required) {
              app.input.validate(calendar.$inputEl);
            }
          }
        }

        if (calendar.detachCalendarEvents) {
          calendar.detachCalendarEvents();
        }

        if (calendar.$el) {
          calendar.$el.trigger('calendar:close');
        }

        if (calendar.$inputEl) {
          calendar.$inputEl.trigger('calendar:close');
        }

        calendar.emit('local::close calendarClose', calendar);
      };

      _proto.onClosed = function onClosed() {
        var calendar = this;
        calendar.opened = false;
        calendar.closing = false;

        if (!calendar.inline) {
          nextTick$1(function () {
            if (calendar.modal && calendar.modal.el && calendar.modal.destroy) {
              if (!calendar.params.routableModals) {
                calendar.modal.destroy();
              }
            }

            delete calendar.modal;
          });
        }

        if (calendar.timePickerInstance) {
          if (calendar.timePickerInstance.destroy) calendar.timePickerInstance.destroy();
          delete calendar.timePickerInstance;
        }

        if (calendar.$el) {
          calendar.$el.trigger('calendar:closed');
        }

        if (calendar.$inputEl) {
          calendar.$inputEl.trigger('calendar:closed');
        }

        calendar.emit('local::closed calendarClosed', calendar);
      };

      _proto.open = function open() {
        var calendar = this;
        var app = calendar.app,
            opened = calendar.opened,
            inline = calendar.inline,
            $inputEl = calendar.$inputEl,
            params = calendar.params;
        if (opened) return;

        if (inline) {
          calendar.$el = $(calendar.render());
          calendar.$el[0].f7Calendar = calendar;
          calendar.$wrapperEl = calendar.$el.find('.calendar-months-wrapper');
          calendar.$months = calendar.$wrapperEl.find('.calendar-month');
          calendar.$containerEl.append(calendar.$el);
          calendar.onOpen();
          calendar.onOpened();
          return;
        }

        var modalType = params.openIn;

        if (modalType === 'auto') {
          modalType = calendar.isPopover() ? 'popover' : 'sheet';
        }

        var modalContent = calendar.render();
        var modalParams = {
          targetEl: $inputEl,
          scrollToEl: params.scrollToInput ? $inputEl : undefined,
          content: modalContent,
          backdrop: params.backdrop === true || modalType === 'popover' && app.params.popover.backdrop !== false && params.backdrop !== false,
          closeByBackdropClick: params.closeByBackdropClick,
          on: {
            open: function open() {
              var modal = this;
              calendar.modal = modal;
              calendar.$el = modalType === 'popover' ? modal.$el.find('.calendar') : modal.$el;
              calendar.$wrapperEl = calendar.$el.find('.calendar-months-wrapper');
              calendar.$months = calendar.$wrapperEl.find('.calendar-month');
              calendar.$el[0].f7Calendar = calendar;

              if (modalType === 'customModal') {
                $(calendar.$el).find('.calendar-close').once('click', function () {
                  calendar.close();
                });
              }

              calendar.onOpen();
            },
            opened: function opened() {
              calendar.onOpened();
            },
            close: function close() {
              calendar.onClose();
            },
            closed: function closed() {
              calendar.onClosed();
            }
          }
        };

        if (modalType === 'sheet') {
          modalParams.push = params.sheetPush;
          modalParams.swipeToClose = params.sheetSwipeToClose;
        }

        if (params.routableModals && calendar.view) {
          var _route;

          calendar.view.router.navigate({
            url: calendar.url,
            route: (_route = {
              path: calendar.url
            }, _route[modalType] = modalParams, _route)
          });
        } else {
          calendar.modal = app[modalType].create(modalParams);
          calendar.modal.open();
        }
      };

      _proto.close = function close() {
        var calendar = this;
        var opened = calendar.opened,
            inline = calendar.inline;
        if (!opened) return;

        if (inline) {
          calendar.onClose();
          calendar.onClosed();
          return;
        }

        if (calendar.params.routableModals && calendar.view) {
          calendar.view.router.back();
        } else {
          calendar.modal.close();
        }
      };

      _proto.init = function init() {
        var calendar = this;
        calendar.initInput();

        if (calendar.inline) {
          calendar.open();
          calendar.emit('local::init calendarInit', calendar);
          return;
        }

        if (!calendar.initialized && calendar.params.value) {
          calendar.setValue(calendar.normalizeValues(calendar.params.value));
        } // Attach input Events


        if (calendar.$inputEl) {
          calendar.attachInputEvents();
        }

        if (calendar.params.closeByOutsideClick) {
          calendar.attachHtmlEvents();
        }

        calendar.emit('local::init calendarInit', calendar);
      };

      _proto.destroy = function destroy() {
        var calendar = this;
        if (calendar.destroyed) return;
        var $el = calendar.$el;
        calendar.emit('local::beforeDestroy calendarBeforeDestroy', calendar);
        if ($el) $el.trigger('calendar:beforedestroy');
        calendar.close(); // Detach Events

        if (calendar.$inputEl) {
          calendar.detachInputEvents();
        }

        if (calendar.params.closeByOutsideClick) {
          calendar.detachHtmlEvents();
        }

        if (calendar.timePickerInstance) {
          if (calendar.timePickerInstance.destroy) calendar.timePickerInstance.destroy();
          delete calendar.timePickerInstance;
        }

        if ($el && $el.length) delete calendar.$el[0].f7Calendar;
        deleteProps$1(calendar);
        calendar.destroyed = true;
      };

      _createClass$5(Calendar, [{
        key: "view",
        get: function get() {
          var $inputEl = this.$inputEl,
              app = this.app,
              params = this.params;
          var view;

          if (params.view) {
            view = params.view;
          } else if ($inputEl) {
            view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
          }

          if (!view) view = app.views.main;
          return view;
        }
      }]);

      return Calendar;
    }(Framework7Class$1);

    var Calendar$2 = Calendar$1;

    var Calendar = {
      name: 'calendar',
      static: {
        Calendar: Calendar$2
      },
      create: function create() {
        var app = this;
        app.calendar = ConstructorMethods({
          defaultSelector: '.calendar',
          constructor: Calendar$2,
          app: app,
          domProp: 'f7Calendar'
        });

        app.calendar.close = function close(el) {
          if (el === void 0) {
            el = '.calendar';
          }

          var $el = $(el);
          if ($el.length === 0) return;
          var calendar = $el[0].f7Calendar;
          if (!calendar || calendar && !calendar.opened) return;
          calendar.close();
        };
      },
      params: {
        calendar: {
          // Calendar settings
          dateFormat: undefined,
          monthNames: 'auto',
          monthNamesShort: 'auto',
          dayNames: 'auto',
          dayNamesShort: 'auto',
          locale: undefined,
          firstDay: 1,
          // First day of the week, Monday
          weekendDays: [0, 6],
          // Sunday and Saturday
          multiple: false,
          rangePicker: false,
          rangePickerMinDays: 1,
          // when calendar is used as rangePicker
          rangePickerMaxDays: 0,
          // when calendar is used as rangePicker, 0 means unlimited
          direction: 'horizontal',
          // or 'vertical'
          minDate: null,
          maxDate: null,
          disabled: null,
          // dates range of disabled days
          events: null,
          // dates range of days with events
          rangesClasses: null,
          // array with custom classes date ranges
          touchMove: true,
          animate: true,
          closeOnSelect: false,
          monthSelector: true,
          monthPicker: true,
          yearSelector: true,
          yearPicker: true,
          yearPickerMin: undefined,
          yearPickerMax: undefined,
          timePicker: false,
          timePickerFormat: {
            hour: 'numeric',
            minute: 'numeric'
          },
          timePickerPlaceholder: 'Select time',
          weekHeader: true,
          value: null,
          // Common opener settings
          containerEl: null,
          openIn: 'auto',
          // or 'popover' or 'sheet' or 'customModal'
          sheetPush: false,
          sheetSwipeToClose: undefined,
          formatValue: null,
          inputEl: null,
          inputReadOnly: true,
          closeByOutsideClick: true,
          scrollToInput: true,
          header: false,
          headerPlaceholder: 'Select date',
          toolbar: true,
          toolbarCloseText: 'Done',
          footer: false,
          cssClass: null,
          routableModals: false,
          view: null,
          url: 'date/',
          backdrop: null,
          closeByBackdropClick: true,
          // Render functions
          renderWeekHeader: null,
          renderMonths: null,
          renderMonth: null,
          renderMonthSelector: null,
          renderYearSelector: null,
          renderHeader: null,
          renderFooter: null,
          renderToolbar: null,
          renderInline: null,
          renderPopover: null,
          renderSheet: null,
          render: null
        }
      }
    };

    function pickerColumn(colEl, updateItems) {
      var picker = this;
      var app = picker.app;
      var $colEl = $(colEl);
      var colIndex = $colEl.index();
      var col = picker.cols[colIndex];
      if (col.divider) return;
      col.$el = $colEl;
      col.el = $colEl[0];
      col.$itemsEl = col.$el.find('.picker-items');
      col.items = col.$itemsEl.find('.picker-item');
      var itemHeight;
      var itemsHeight;
      var minTranslate;
      var maxTranslate;
      var animationFrameId;

      function updateDuringScroll() {
        animationFrameId = requestAnimationFrame(function () {
          col.updateItems(undefined, undefined, 0);
          updateDuringScroll();
        });
      }

      col.replaceValues = function replaceColValues(values, displayValues) {
        col.detachEvents();
        col.values = values;
        col.displayValues = displayValues;
        col.$itemsEl.html(picker.renderColumn(col, true));
        col.items = col.$itemsEl.find('.picker-item');
        col.calcSize();
        col.setValue(col.values[0], 0, true);
        col.attachEvents();
      };

      col.calcSize = function calcColSize() {
        if (picker.params.rotateEffect) {
          col.$el.removeClass('picker-column-absolute');
          if (!col.width) col.$el.css({
            width: ''
          });
        }

        var colWidth = 0;
        var colHeight = col.$el[0].offsetHeight;
        itemHeight = col.items[0].offsetHeight;
        itemsHeight = itemHeight * col.items.length;
        minTranslate = colHeight / 2 - itemsHeight + itemHeight / 2;
        maxTranslate = colHeight / 2 - itemHeight / 2;

        if (col.width) {
          colWidth = col.width;
          if (parseInt(colWidth, 10) === colWidth) colWidth += 'px';
          col.$el.css({
            width: colWidth
          });
        }

        if (picker.params.rotateEffect) {
          if (!col.width) {
            col.items.each(function (itemEl) {
              var item = $(itemEl).children('span');
              colWidth = Math.max(colWidth, item[0].offsetWidth);
            });
            col.$el.css({
              width: colWidth + 2 + "px"
            });
          }

          col.$el.addClass('picker-column-absolute');
        }
      };

      col.setValue = function setColValue(newValue, transition, valueCallbacks) {
        if (transition === void 0) {
          transition = '';
        }

        var newActiveIndex = col.$itemsEl.find(".picker-item[data-picker-value=\"" + newValue + "\"]").index();

        if (typeof newActiveIndex === 'undefined' || newActiveIndex === -1) {
          return;
        }

        var newTranslate = -newActiveIndex * itemHeight + maxTranslate; // Update wrapper

        col.$itemsEl.transition(transition);
        col.$itemsEl.transform("translate3d(0," + newTranslate + "px,0)"); // Watch items

        if (picker.params.updateValuesOnMomentum && col.activeIndex && col.activeIndex !== newActiveIndex) {
          cancelAnimationFrame(animationFrameId);
          col.$itemsEl.transitionEnd(function () {
            cancelAnimationFrame(animationFrameId);
          });
          updateDuringScroll();
        } // Update items


        col.updateItems(newActiveIndex, newTranslate, transition, valueCallbacks);
      };

      col.updateItems = function updateColItems(activeIndex, translate, transition, valueCallbacks) {
        if (typeof translate === 'undefined') {
          // eslint-disable-next-line
          translate = getTranslate$1(col.$itemsEl[0], 'y');
        }

        if (typeof activeIndex === 'undefined') // eslint-disable-next-line
          activeIndex = -Math.round((translate - maxTranslate) / itemHeight); // eslint-disable-next-line

        if (activeIndex < 0) activeIndex = 0; // eslint-disable-next-line

        if (activeIndex >= col.items.length) activeIndex = col.items.length - 1;
        var previousActiveIndex = col.activeIndex;
        col.activeIndex = activeIndex;
        col.$itemsEl.find('.picker-item-selected').removeClass('picker-item-selected');
        col.items.transition(transition);
        var selectedItem = col.items.eq(activeIndex).addClass('picker-item-selected').transform(''); // Set 3D rotate effect

        if (picker.params.rotateEffect) {
          col.items.each(function (itemEl) {
            var $itemEl = $(itemEl);
            var itemOffsetTop = $itemEl.index() * itemHeight;
            var translateOffset = maxTranslate - translate;
            var itemOffset = itemOffsetTop - translateOffset;
            var percentage = itemOffset / itemHeight;
            var itemsFit = Math.ceil(col.height / itemHeight / 2) + 1;
            var angle = -18 * percentage;
            if (angle > 180) angle = 180;
            if (angle < -180) angle = -180;

            if (Math.abs(percentage) > itemsFit) {
              $itemEl.addClass('picker-item-far');
            } else {
              $itemEl.removeClass('picker-item-far');
            }

            $itemEl.transform("translate3d(0, " + (-translate + maxTranslate) + "px, " + (picker.needsOriginFix ? -110 : 0) + "px) rotateX(" + angle + "deg)");
          });
        }

        if (valueCallbacks || typeof valueCallbacks === 'undefined') {
          // Update values
          col.value = selectedItem.attr('data-picker-value');
          col.displayValue = col.displayValues ? col.displayValues[activeIndex] : col.value; // On change callback

          if (previousActiveIndex !== activeIndex) {
            if (col.onChange) {
              col.onChange(picker, col.value, col.displayValue);
            }

            picker.updateValue();
          }
        }
      };

      var allowItemClick = true;
      var isTouched;
      var isMoved;
      var touchStartY;
      var touchCurrentY;
      var touchStartTime;
      var touchEndTime;
      var startTranslate;
      var returnTo;
      var currentTranslate;
      var prevTranslate;
      var velocityTranslate;

      function handleTouchStart(e) {
        if (isMoved || isTouched) return;
        e.preventDefault();
        isTouched = true;
        touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        touchCurrentY = touchStartY;
        touchStartTime = new Date().getTime();
        allowItemClick = true;
        startTranslate = getTranslate$1(col.$itemsEl[0], 'y');
        currentTranslate = startTranslate;
      }

      function handleTouchMove(e) {
        if (!isTouched) return;
        e.preventDefault();
        allowItemClick = false;
        touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

        if (!isMoved) {
          // First move
          cancelAnimationFrame(animationFrameId);
          isMoved = true;
          startTranslate = getTranslate$1(col.$itemsEl[0], 'y');
          currentTranslate = startTranslate;
          col.$itemsEl.transition(0);
        }

        var diff = touchCurrentY - touchStartY;
        currentTranslate = startTranslate + diff;
        returnTo = undefined; // Normalize translate

        if (currentTranslate < minTranslate) {
          currentTranslate = minTranslate - Math.pow(minTranslate - currentTranslate, 0.8);
          returnTo = 'min';
        }

        if (currentTranslate > maxTranslate) {
          currentTranslate = maxTranslate + Math.pow(currentTranslate - maxTranslate, 0.8);
          returnTo = 'max';
        } // Transform wrapper


        col.$itemsEl.transform("translate3d(0," + currentTranslate + "px,0)"); // Update items

        col.updateItems(undefined, currentTranslate, 0, picker.params.updateValuesOnTouchmove); // Calc velocity

        velocityTranslate = currentTranslate - prevTranslate || currentTranslate;
        prevTranslate = currentTranslate;
      }

      function handleTouchEnd() {
        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }

        isTouched = false;
        isMoved = false;
        col.$itemsEl.transition('');

        if (returnTo) {
          if (returnTo === 'min') {
            col.$itemsEl.transform("translate3d(0," + minTranslate + "px,0)");
          } else {
            col.$itemsEl.transform("translate3d(0," + maxTranslate + "px,0)");
          }
        }

        touchEndTime = new Date().getTime();
        var newTranslate;

        if (touchEndTime - touchStartTime > 300) {
          newTranslate = currentTranslate;
        } else {
          newTranslate = currentTranslate + velocityTranslate * picker.params.momentumRatio;
        }

        newTranslate = Math.max(Math.min(newTranslate, maxTranslate), minTranslate); // Active Index

        var activeIndex = Math.round(Math.abs((newTranslate - maxTranslate) / itemHeight)); // Normalize translate

        if (!picker.params.freeMode) newTranslate = -activeIndex * itemHeight + maxTranslate; // Transform wrapper

        col.$itemsEl.transform("translate3d(0," + parseInt(newTranslate, 10) + "px,0)"); // Update items

        col.updateItems(activeIndex, newTranslate, '', true); // Watch items

        if (picker.params.updateValuesOnMomentum) {
          updateDuringScroll();
          col.$itemsEl.transitionEnd(function () {
            cancelAnimationFrame(animationFrameId);
          });
        } // Allow click


        setTimeout(function () {
          allowItemClick = true;
        }, 100);
      }

      var mousewheelTimeout;

      function handleMouseWheel(e) {
        var deltaX = e.deltaX,
            deltaY = e.deltaY;
        if (Math.abs(deltaX) > Math.abs(deltaY)) return;
        clearTimeout(mousewheelTimeout);
        e.preventDefault();
        cancelAnimationFrame(animationFrameId);
        startTranslate = getTranslate$1(col.$itemsEl[0], 'y');
        col.$itemsEl.transition(0);
        currentTranslate = startTranslate - deltaY;
        returnTo = undefined; // Normalize translate

        if (currentTranslate < minTranslate) {
          currentTranslate = minTranslate;
          returnTo = 'min';
        }

        if (currentTranslate > maxTranslate) {
          currentTranslate = maxTranslate;
          returnTo = 'max';
        } // Transform wrapper


        col.$itemsEl.transform("translate3d(0," + currentTranslate + "px,0)"); // Update items

        col.updateItems(undefined, currentTranslate, 0, picker.params.updateValuesOnMousewheel); // On end

        mousewheelTimeout = setTimeout(function () {
          col.$itemsEl.transition('');

          if (returnTo) {
            if (returnTo === 'min') {
              col.$itemsEl.transform("translate3d(0," + minTranslate + "px,0)");
            } else {
              col.$itemsEl.transform("translate3d(0," + maxTranslate + "px,0)");
            }
          }

          touchEndTime = new Date().getTime();
          var newTranslate = currentTranslate;
          newTranslate = Math.max(Math.min(newTranslate, maxTranslate), minTranslate); // Active Index

          var activeIndex = Math.round(Math.abs((newTranslate - maxTranslate) / itemHeight)); // Normalize translate

          if (!picker.params.freeMode) newTranslate = -activeIndex * itemHeight + maxTranslate; // Transform wrapper

          col.$itemsEl.transform("translate3d(0," + parseInt(newTranslate, 10) + "px,0)"); // Update items

          col.updateItems(activeIndex, newTranslate, '', true);
        }, 200);
      }

      function handleClick() {
        if (!allowItemClick) return;
        cancelAnimationFrame(animationFrameId);
        var value = $(this).attr('data-picker-value');
        col.setValue(value);
      }

      var activeListener = getSupport$1().passiveListener ? {
        passive: false,
        capture: false
      } : false;

      col.attachEvents = function attachColEvents() {
        col.$el.on(app.touchEvents.start, handleTouchStart, activeListener);
        app.on('touchmove:active', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);

        if (picker.params.mousewheel) {
          col.$el.on('wheel', handleMouseWheel);
        }

        col.items.on('click', handleClick);
      };

      col.detachEvents = function detachColEvents() {
        col.$el.off(app.touchEvents.start, handleTouchStart, activeListener);
        app.off('touchmove:active', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);

        if (picker.params.mousewheel) {
          col.$el.off('wheel', handleMouseWheel);
        }

        col.items.off('click', handleClick);
      };

      col.init = function initCol() {
        col.calcSize();
        col.$itemsEl.transform("translate3d(0," + maxTranslate + "px,0)").transition(0);
        if (colIndex === 0) col.$el.addClass('picker-column-first');
        if (colIndex === picker.cols.length - 1) col.$el.addClass('picker-column-last'); // Update items on init

        if (updateItems) col.updateItems(0, maxTranslate, 0);
        col.attachEvents();
      };

      col.destroy = function destroyCol() {
        col.detachEvents();
      };

      col.init();
    }

    function _defineProperties$4(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass$4(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$4(Constructor.prototype, protoProps); if (staticProps) _defineProperties$4(Constructor, staticProps); return Constructor; }

    function _assertThisInitialized$b(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$b(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$b(subClass, superClass); }

    function _setPrototypeOf$b(o, p) { _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$b(o, p); }

    var Picker$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$b(Picker, _Framework7Class);

      function Picker(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params, [app]) || this;

        var picker = _assertThisInitialized$b(_this);

        var device = getDevice$1();
        var window = getWindow();
        picker.params = extend$2({}, app.params.picker, params);
        var $containerEl;

        if (picker.params.containerEl) {
          $containerEl = $(picker.params.containerEl);
          if ($containerEl.length === 0) return picker || _assertThisInitialized$b(_this);
        }

        var $inputEl;

        if (picker.params.inputEl) {
          $inputEl = $(picker.params.inputEl);
        }

        var $scrollToEl = picker.params.scrollToInput ? $inputEl : undefined;

        if (picker.params.scrollToEl) {
          var scrollToEl = $(picker.params.scrollToEl);

          if (scrollToEl.length > 0) {
            $scrollToEl = scrollToEl;
          }
        }

        extend$2(picker, {
          app: app,
          $containerEl: $containerEl,
          containerEl: $containerEl && $containerEl[0],
          inline: $containerEl && $containerEl.length > 0,
          needsOriginFix: device.ios || window.navigator.userAgent.toLowerCase().indexOf('safari') >= 0 && window.navigator.userAgent.toLowerCase().indexOf('chrome') < 0 && !device.android,
          cols: [],
          $inputEl: $inputEl,
          inputEl: $inputEl && $inputEl[0],
          $scrollToEl: $scrollToEl,
          initialized: false,
          opened: false,
          url: picker.params.url
        });

        function onResize() {
          picker.resizeCols();
        }

        function onInputClick() {
          picker.open();
        }

        function onInputFocus(e) {
          e.preventDefault();
        }

        var htmlTouchStartTarget = null;

        function onHtmlTouchStart(e) {
          htmlTouchStartTarget = e.target;
        }

        function onHtmlClick(e) {
          if (picker.destroyed || !picker.params) return;
          var $targetEl = $(e.target);
          if (picker.isPopover()) return;
          if (!picker.opened || picker.closing) return;
          if ($targetEl.closest('[class*="backdrop"]').length) return;

          if ($inputEl && $inputEl.length > 0) {
            if (htmlTouchStartTarget === e.target && $targetEl[0] !== $inputEl[0] && $targetEl.closest('.sheet-modal').length === 0) {
              picker.close();
            }
          } else if ($(e.target).closest('.sheet-modal').length === 0) {
            picker.close();
          }
        } // Events


        extend$2(picker, {
          attachResizeEvent: function attachResizeEvent() {
            app.on('resize', onResize);
          },
          detachResizeEvent: function detachResizeEvent() {
            app.off('resize', onResize);
          },
          attachInputEvents: function attachInputEvents() {
            picker.$inputEl.on('click', onInputClick);

            if (picker.params.inputReadOnly) {
              picker.$inputEl.on('focus mousedown', onInputFocus);

              if (picker.$inputEl[0]) {
                picker.$inputEl[0].f7ValidateReadonly = true;
              }
            }
          },
          detachInputEvents: function detachInputEvents() {
            picker.$inputEl.off('click', onInputClick);

            if (picker.params.inputReadOnly) {
              picker.$inputEl.off('focus mousedown', onInputFocus);

              if (picker.$inputEl[0]) {
                delete picker.$inputEl[0].f7ValidateReadonly;
              }
            }
          },
          attachHtmlEvents: function attachHtmlEvents() {
            app.on('click', onHtmlClick);
            app.on('touchstart', onHtmlTouchStart);
          },
          detachHtmlEvents: function detachHtmlEvents() {
            app.off('click', onHtmlClick);
            app.off('touchstart', onHtmlTouchStart);
          }
        });
        picker.init();
        return picker || _assertThisInitialized$b(_this);
      }

      var _proto = Picker.prototype;

      _proto.initInput = function initInput() {
        var picker = this;
        if (!picker.$inputEl) return;
        if (picker.params.inputReadOnly) picker.$inputEl.prop('readOnly', true);
      };

      _proto.resizeCols = function resizeCols() {
        var picker = this;
        if (!picker.opened) return;

        for (var i = 0; i < picker.cols.length; i += 1) {
          if (!picker.cols[i].divider) {
            picker.cols[i].calcSize();
            picker.cols[i].setValue(picker.cols[i].value, 0, false);
          }
        }
      };

      _proto.isPopover = function isPopover() {
        var picker = this;
        var app = picker.app,
            modal = picker.modal,
            params = picker.params;
        var device = getDevice$1();
        if (params.openIn === 'sheet') return false;
        if (modal && modal.type !== 'popover') return false;

        if (!picker.inline && picker.inputEl) {
          if (params.openIn === 'popover') return true;

          if (device.ios) {
            return !!device.ipad;
          }

          if (app.width >= 768) {
            return true;
          }

          if (device.desktop && app.theme === 'aurora') {
            return true;
          }
        }

        return false;
      };

      _proto.formatValue = function formatValue() {
        var picker = this;
        var value = picker.value,
            displayValue = picker.displayValue;

        if (picker.params.formatValue) {
          return picker.params.formatValue.call(picker, value, displayValue);
        }

        return value.join(' ');
      };

      _proto.setValue = function setValue(values, transition) {
        var picker = this;
        var valueIndex = 0;

        if (picker.cols.length === 0) {
          picker.value = values;
          picker.updateValue(values);
          return;
        }

        for (var i = 0; i < picker.cols.length; i += 1) {
          if (picker.cols[i] && !picker.cols[i].divider) {
            picker.cols[i].setValue(values[valueIndex], transition);
            valueIndex += 1;
          }
        }
      };

      _proto.getValue = function getValue() {
        var picker = this;
        return picker.value;
      };

      _proto.updateValue = function updateValue(forceValues) {
        var picker = this;
        var newValue = forceValues || [];
        var newDisplayValue = [];
        var column;

        if (picker.cols.length === 0) {
          var noDividerColumns = picker.params.cols.filter(function (c) {
            return !c.divider;
          });

          for (var i = 0; i < noDividerColumns.length; i += 1) {
            column = noDividerColumns[i];

            if (column.displayValues !== undefined && column.values !== undefined && column.values.indexOf(newValue[i]) !== -1) {
              newDisplayValue.push(column.displayValues[column.values.indexOf(newValue[i])]);
            } else {
              newDisplayValue.push(newValue[i]);
            }
          }
        } else {
          for (var _i = 0; _i < picker.cols.length; _i += 1) {
            if (!picker.cols[_i].divider) {
              newValue.push(picker.cols[_i].value);
              newDisplayValue.push(picker.cols[_i].displayValue);
            }
          }
        }

        if (newValue.indexOf(undefined) >= 0) {
          return;
        }

        picker.value = newValue;
        picker.displayValue = newDisplayValue;
        picker.emit('local::change pickerChange', picker, picker.value, picker.displayValue);

        if (picker.inputEl) {
          picker.$inputEl.val(picker.formatValue());
          picker.$inputEl.trigger('change');
        }
      };

      _proto.initColumn = function initColumn(colEl, updateItems) {
        var picker = this;
        pickerColumn.call(picker, colEl, updateItems);
      } // eslint-disable-next-line
      ;

      _proto.destroyColumn = function destroyColumn(colEl) {
        var picker = this;
        var $colEl = $(colEl);
        var index = $colEl.index();

        if (picker.cols[index] && picker.cols[index].destroy) {
          picker.cols[index].destroy();
        }
      };

      _proto.renderToolbar = function renderToolbar() {
        var picker = this;
        if (picker.params.renderToolbar) return picker.params.renderToolbar.call(picker, picker);
        return $jsx$1("div", {
          class: "toolbar toolbar-top no-shadow"
        }, $jsx$1("div", {
          class: "toolbar-inner"
        }, $jsx$1("div", {
          class: "left"
        }), $jsx$1("div", {
          class: "right"
        }, $jsx$1("a", {
          class: "link sheet-close popover-close"
        }, picker.params.toolbarCloseText))));
      } // eslint-disable-next-line
      ;

      _proto.renderColumn = function renderColumn(col, onlyItems) {
        var colClasses = "picker-column " + (col.textAlign ? "picker-column-" + col.textAlign : '') + " " + (col.cssClass || '');
        var columnHtml;
        var columnItemsHtml;

        if (col.divider) {
          // prettier-ignore
          columnHtml = "\n        <div class=\"" + colClasses + " picker-column-divider\">" + col.content + "</div>\n      ";
        } else {
          // prettier-ignore
          columnItemsHtml = col.values.map(function (value, index) {
            return "\n        <div class=\"picker-item\" data-picker-value=\"" + value + "\">\n          <span>" + (col.displayValues ? col.displayValues[index] : value) + "</span>\n        </div>\n      ";
          }).join(''); // prettier-ignore

          columnHtml = "\n        <div class=\"" + colClasses + "\">\n          <div class=\"picker-items\">" + columnItemsHtml + "</div>\n        </div>\n      ";
        }

        return onlyItems ? columnItemsHtml.trim() : columnHtml.trim();
      };

      _proto.renderInline = function renderInline() {
        var picker = this;
        var _picker$params = picker.params,
            rotateEffect = _picker$params.rotateEffect,
            cssClass = _picker$params.cssClass,
            toolbar = _picker$params.toolbar;
        var inlineHtml = $jsx$1("div", {
          class: "picker picker-inline " + (rotateEffect ? 'picker-3d' : '') + " " + (cssClass || '')
        }, toolbar && picker.renderToolbar(), $jsx$1("div", {
          class: "picker-columns"
        }, picker.cols.map(function (col) {
          return picker.renderColumn(col);
        }), $jsx$1("div", {
          class: "picker-center-highlight"
        })));
        return inlineHtml;
      };

      _proto.renderSheet = function renderSheet() {
        var picker = this;
        var _picker$params2 = picker.params,
            rotateEffect = _picker$params2.rotateEffect,
            cssClass = _picker$params2.cssClass,
            toolbar = _picker$params2.toolbar;
        var sheetHtml = $jsx$1("div", {
          class: "sheet-modal picker picker-sheet " + (rotateEffect ? 'picker-3d' : '') + " " + (cssClass || '')
        }, toolbar && picker.renderToolbar(), $jsx$1("div", {
          class: "sheet-modal-inner picker-columns"
        }, picker.cols.map(function (col) {
          return picker.renderColumn(col);
        }), $jsx$1("div", {
          class: "picker-center-highlight"
        })));
        return sheetHtml;
      };

      _proto.renderPopover = function renderPopover() {
        var picker = this;
        var _picker$params3 = picker.params,
            rotateEffect = _picker$params3.rotateEffect,
            cssClass = _picker$params3.cssClass,
            toolbar = _picker$params3.toolbar;
        var popoverHtml = $jsx$1("div", {
          class: "popover picker-popover"
        }, $jsx$1("div", {
          class: "popover-inner"
        }, $jsx$1("div", {
          class: "picker " + (rotateEffect ? 'picker-3d' : '') + " " + (cssClass || '')
        }, toolbar && picker.renderToolbar(), $jsx$1("div", {
          class: "picker-columns"
        }, picker.cols.map(function (col) {
          return picker.renderColumn(col);
        }), $jsx$1("div", {
          class: "picker-center-highlight"
        })))));
        return popoverHtml;
      };

      _proto.render = function render() {
        var picker = this;
        if (picker.params.render) return picker.params.render.call(picker);

        if (!picker.inline) {
          if (picker.isPopover()) return picker.renderPopover();
          return picker.renderSheet();
        }

        return picker.renderInline();
      };

      _proto.onOpen = function onOpen() {
        var picker = this;
        var initialized = picker.initialized,
            $el = picker.$el,
            app = picker.app,
            $inputEl = picker.$inputEl,
            inline = picker.inline,
            value = picker.value,
            params = picker.params;
        picker.opened = true;
        picker.closing = false;
        picker.opening = true; // Init main events

        picker.attachResizeEvent(); // Init cols

        $el.find('.picker-column').each(function (colEl) {
          var updateItems = true;

          if (!initialized && params.value || initialized && value) {
            updateItems = false;
          }

          picker.initColumn(colEl, updateItems);
        }); // Set value

        if (!initialized) {
          if (value) picker.setValue(value, 0);else if (params.value) {
            picker.setValue(params.value, 0);
          }
        } else if (value) {
          picker.setValue(value, 0);
        } // Extra focus


        if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
          $inputEl.trigger('focus');
        }

        picker.initialized = true; // Trigger events

        if ($el) {
          $el.trigger('picker:open');
        }

        if ($inputEl) {
          $inputEl.trigger('picker:open');
        }

        picker.emit('local::open pickerOpen', picker);
      };

      _proto.onOpened = function onOpened() {
        var picker = this;
        picker.opening = false;

        if (picker.$el) {
          picker.$el.trigger('picker:opened');
        }

        if (picker.$inputEl) {
          picker.$inputEl.trigger('picker:opened');
        }

        picker.emit('local::opened pickerOpened', picker);
      };

      _proto.onClose = function onClose() {
        var picker = this;
        var app = picker.app;
        picker.opening = false;
        picker.closing = true; // Detach events

        picker.detachResizeEvent();
        picker.cols.forEach(function (col) {
          if (col.destroy) col.destroy();
        });

        if (picker.$inputEl) {
          if (app.theme === 'md') {
            picker.$inputEl.trigger('blur');
          } else {
            var validate = picker.$inputEl.attr('validate');
            var required = picker.$inputEl.attr('required');

            if (validate && required) {
              app.input.validate(picker.$inputEl);
            }
          }
        }

        if (picker.$el) {
          picker.$el.trigger('picker:close');
        }

        if (picker.$inputEl) {
          picker.$inputEl.trigger('picker:close');
        }

        picker.emit('local::close pickerClose', picker);
      };

      _proto.onClosed = function onClosed() {
        var picker = this;
        picker.opened = false;
        picker.closing = false;

        if (!picker.inline) {
          nextTick$1(function () {
            if (picker.modal && picker.modal.el && picker.modal.destroy) {
              if (!picker.params.routableModals) {
                picker.modal.destroy();
              }
            }

            delete picker.modal;
          });
        }

        if (picker.$el) {
          picker.$el.trigger('picker:closed');
        }

        if (picker.$inputEl) {
          picker.$inputEl.trigger('picker:closed');
        }

        picker.emit('local::closed pickerClosed', picker);
      };

      _proto.open = function open() {
        var picker = this;
        var app = picker.app,
            opened = picker.opened,
            inline = picker.inline,
            $inputEl = picker.$inputEl,
            $scrollToEl = picker.$scrollToEl,
            params = picker.params;
        if (opened) return;

        if (picker.cols.length === 0 && params.cols.length) {
          params.cols.forEach(function (col) {
            picker.cols.push(col);
          });
        }

        if (inline) {
          picker.$el = $(picker.render());
          picker.$el[0].f7Picker = picker;
          picker.$containerEl.append(picker.$el);
          picker.onOpen();
          picker.onOpened();
          return;
        }

        var isPopover = picker.isPopover();
        var modalType = isPopover ? 'popover' : 'sheet';
        var modalParams = {
          targetEl: $inputEl,
          scrollToEl: $scrollToEl,
          content: picker.render(),
          backdrop: typeof params.backdrop !== 'undefined' ? params.backdrop : isPopover,
          on: {
            open: function open() {
              var modal = this;
              picker.modal = modal;
              picker.$el = isPopover ? modal.$el.find('.picker') : modal.$el;
              picker.$el[0].f7Picker = picker;
              picker.onOpen();
            },
            opened: function opened() {
              picker.onOpened();
            },
            close: function close() {
              picker.onClose();
            },
            closed: function closed() {
              picker.onClosed();
            }
          }
        };

        if (modalType === 'sheet') {
          modalParams.push = params.sheetPush;
          modalParams.swipeToClose = params.sheetSwipeToClose;
        }

        if (params.routableModals && picker.view) {
          var _route;

          picker.view.router.navigate({
            url: picker.url,
            route: (_route = {
              path: picker.url
            }, _route[modalType] = modalParams, _route)
          });
        } else {
          picker.modal = app[modalType].create(modalParams);
          picker.modal.open();
        }
      };

      _proto.close = function close() {
        var picker = this;
        var opened = picker.opened,
            inline = picker.inline;
        if (!opened) return;

        if (inline) {
          picker.onClose();
          picker.onClosed();
          return;
        }

        if (picker.params.routableModals && picker.view) {
          picker.view.router.back();
        } else {
          picker.modal.close();
        }
      };

      _proto.init = function init() {
        var picker = this;
        picker.initInput();

        if (picker.inline) {
          picker.open();
          picker.emit('local::init pickerInit', picker);
          return;
        }

        if (!picker.initialized && picker.params.value) {
          picker.setValue(picker.params.value);
        } // Attach input Events


        if (picker.$inputEl) {
          picker.attachInputEvents();
        }

        if (picker.params.closeByOutsideClick) {
          picker.attachHtmlEvents();
        }

        picker.emit('local::init pickerInit', picker);
      };

      _proto.destroy = function destroy() {
        var picker = this;
        if (picker.destroyed) return;
        var $el = picker.$el;
        picker.emit('local::beforeDestroy pickerBeforeDestroy', picker);
        if ($el) $el.trigger('picker:beforedestroy');
        picker.close(); // Detach Events

        if (picker.$inputEl) {
          picker.detachInputEvents();
        }

        if (picker.params.closeByOutsideClick) {
          picker.detachHtmlEvents();
        }

        if ($el && $el.length) delete picker.$el[0].f7Picker;
        deleteProps$1(picker);
        picker.destroyed = true;
      };

      _createClass$4(Picker, [{
        key: "view",
        get: function get() {
          var app = this.app,
              params = this.params,
              $inputEl = this.$inputEl;
          var view;

          if (params.view) {
            view = params.view;
          } else if ($inputEl) {
            view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
          }

          if (!view) view = app.views.main;
          return view;
        }
      }]);

      return Picker;
    }(Framework7Class$1);

    var Picker$2 = Picker$1;

    var Picker = {
      name: 'picker',
      static: {
        Picker: Picker$2
      },
      create: function create() {
        var app = this;
        app.picker = ConstructorMethods({
          defaultSelector: '.picker',
          constructor: Picker$2,
          app: app,
          domProp: 'f7Picker'
        });

        app.picker.close = function close(el) {
          if (el === void 0) {
            el = '.picker';
          }

          var $el = $(el);
          if ($el.length === 0) return;
          var picker = $el[0].f7Picker;
          if (!picker || picker && !picker.opened) return;
          picker.close();
        };
      },
      params: {
        picker: {
          // Picker settings
          updateValuesOnMomentum: false,
          updateValuesOnTouchmove: true,
          updateValuesOnMousewheel: true,
          mousewheel: true,
          rotateEffect: false,
          momentumRatio: 7,
          freeMode: false,
          cols: [],
          // Common opener settings
          containerEl: null,
          openIn: 'auto',
          // or 'popover' or 'sheet'
          sheetPush: false,
          sheetSwipeToClose: undefined,
          backdrop: undefined,
          // uses Popover or Sheet defaults
          formatValue: null,
          inputEl: null,
          inputReadOnly: true,
          closeByOutsideClick: true,
          scrollToInput: true,
          scrollToEl: undefined,
          toolbar: true,
          toolbarCloseText: 'Done',
          cssClass: null,
          routableModals: false,
          view: null,
          url: 'select/',
          // Render functions
          renderToolbar: null,
          render: null
        }
      }
    };

    var InfiniteScroll = {
      handle: function handle(el, e) {
        var app = this;
        var $el = $(el);
        var scrollTop = $el[0].scrollTop;
        var scrollHeight = $el[0].scrollHeight;
        var height = $el[0].offsetHeight;
        var distance = $el[0].getAttribute('data-infinite-distance');
        var virtualListContainer = $el.find('.virtual-list');
        var virtualList;
        var onTop = $el.hasClass('infinite-scroll-top');
        if (!distance) distance = 50;

        if (typeof distance === 'string' && distance.indexOf('%') >= 0) {
          distance = parseInt(distance, 10) / 100 * height;
        }

        if (distance > height) distance = height;

        if (onTop) {
          if (scrollTop < distance) {
            $el.trigger('infinite', e);
            app.emit('infinite', $el[0], e);
          }
        } else if (scrollTop + height >= scrollHeight - distance) {
          if (virtualListContainer.length > 0) {
            virtualList = virtualListContainer.eq(-1)[0].f7VirtualList;

            if (virtualList && !virtualList.reachEnd && !virtualList.params.updatableScroll) {
              return;
            }
          }

          $el.trigger('infinite', e);
          app.emit('infinite', $el[0], e);
        }
      },
      create: function create(el) {
        var $el = $(el);
        var app = this;

        function scrollHandler(e) {
          app.infiniteScroll.handle(this, e);
        }

        $el.each(function (element) {
          element.f7InfiniteScrollHandler = scrollHandler;
          element.addEventListener('scroll', element.f7InfiniteScrollHandler);
        });
      },
      destroy: function destroy(el) {
        var $el = $(el);
        $el.each(function (element) {
          element.removeEventListener('scroll', element.f7InfiniteScrollHandler);
          delete element.f7InfiniteScrollHandler;
        });
      }
    };
    var InfiniteScroll$1 = {
      name: 'infiniteScroll',
      create: function create() {
        var app = this;
        bindMethods(app, {
          infiniteScroll: InfiniteScroll
        });
      },
      on: {
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          var $tabEl = $(tabEl);
          var $isEls = $tabEl.find('.infinite-scroll-content');
          if ($tabEl.is('.infinite-scroll-content')) $isEls.add($tabEl);
          $isEls.each(function (el) {
            app.infiniteScroll.create(el);
          });
        },
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          var $tabEl = $(tabEl);
          var app = this;
          var $isEls = $tabEl.find('.infinite-scroll-content');
          if ($tabEl.is('.infinite-scroll-content')) $isEls.add($tabEl);
          $isEls.each(function (el) {
            app.infiniteScroll.destroy(el);
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.infinite-scroll-content').each(function (el) {
            app.infiniteScroll.create(el);
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          var app = this;
          page.$el.find('.infinite-scroll-content').each(function (el) {
            app.infiniteScroll.destroy(el);
          });
        }
      }
    };

    function _assertThisInitialized$a(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$a(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$a(subClass, superClass); }

    function _setPrototypeOf$a(o, p) { _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$a(o, p); }

    var PullToRefresh$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$a(PullToRefresh, _Framework7Class);

      function PullToRefresh(app, el) {
        var _this;

        _this = _Framework7Class.call(this, {}, [app]) || this;

        var ptr = _assertThisInitialized$a(_this);

        var device = getDevice$1();
        var support = getSupport$1();
        var $el = $(el);
        var $preloaderEl = $el.find('.ptr-preloader');
        ptr.$el = $el;
        ptr.el = $el[0];
        ptr.app = app;
        ptr.bottom = ptr.$el.hasClass('ptr-bottom'); // Extend defaults with modules params

        ptr.useModulesParams({});
        var isMaterial = app.theme === 'md';
        var isIos = app.theme === 'ios';
        var isAurora = app.theme === 'aurora'; // Done

        ptr.done = function done() {
          var $transitionTarget = isMaterial ? $preloaderEl : $el;

          var onTranstionEnd = function onTranstionEnd(e) {
            if ($(e.target).closest($preloaderEl).length) return;
            $el.removeClass('ptr-transitioning ptr-pull-up ptr-pull-down ptr-closing');
            $el.trigger('ptr:done');
            ptr.emit('local::done ptrDone', $el[0]);
            $transitionTarget.off('transitionend', onTranstionEnd);
          };

          $transitionTarget.on('transitionend', onTranstionEnd);
          $el.removeClass('ptr-refreshing').addClass('ptr-transitioning ptr-closing');
          return ptr;
        };

        ptr.refresh = function refresh() {
          if ($el.hasClass('ptr-refreshing')) return ptr;
          $el.addClass('ptr-transitioning ptr-refreshing');
          $el.trigger('ptr:refresh', ptr.done);
          ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
          return ptr;
        }; // Mousewheel


        ptr.mousewheel = $el.attr('data-ptr-mousewheel') === 'true'; // Events handling

        var touchId;
        var isTouched;
        var isMoved;
        var touchesStart = {};
        var isScrolling;
        var touchesDiff;
        var refresh = false;
        var useTranslate = false;
        var forceUseTranslate = false;
        var startTranslate = 0;
        var translate;
        var scrollTop;
        var wasScrolled;
        var triggerDistance;
        var dynamicTriggerDistance;
        var pullStarted;
        var hasNavbar = false;
        var scrollHeight;
        var offsetHeight;
        var maxScrollTop;
        var $pageEl = $el.parents('.page');
        if ($pageEl.find('.navbar').length > 0 || $pageEl.parents('.view').children('.navbars').length > 0) hasNavbar = true;
        if ($pageEl.hasClass('no-navbar')) hasNavbar = false;

        if (!ptr.bottom) {
          var pageNavbarEl = app.navbar.getElByPage($pageEl[0]);

          if (pageNavbarEl) {
            var $pageNavbarEl = $(pageNavbarEl);
            var isLargeTransparent = $pageNavbarEl.hasClass('navbar-large-transparent') || $pageNavbarEl.hasClass('navbar-large') && $pageNavbarEl.hasClass('navbar-transparent');
            var isTransparent = $pageNavbarEl.hasClass('navbar-transparent') && !$pageNavbarEl.hasClass('navbar-large');

            if (isLargeTransparent) {
              $el.addClass('ptr-with-navbar-large-transparent');
            } else if (isTransparent) {
              $el.addClass('ptr-with-navbar-transparent');
            }
          }
        }

        if (!hasNavbar && !ptr.bottom) $el.addClass('ptr-no-navbar'); // Define trigger distance

        if ($el.attr('data-ptr-distance')) {
          dynamicTriggerDistance = true;
        } else if (isMaterial) {
          triggerDistance = 66;
        } else if (isIos) {
          triggerDistance = 44;
        } else if (isAurora) {
          triggerDistance = 38;
        }

        function setPreloaderProgress(progress) {
          if (progress === void 0) {
            progress = 0;
          }

          var $bars = $preloaderEl.find('.preloader-inner-line');
          var perBarProgress = 1 / $bars.length;
          $bars.forEach(function (barEl, barIndex) {
            var barProgress = (progress - barIndex * perBarProgress) / perBarProgress;
            barEl.style.opacity = Math.max(Math.min(barProgress, 1), 0) * 0.27;
          });
        }

        function unsetPreloaderProgress() {
          $preloaderEl.find('.preloader-inner-line').css('opacity', '');
        }

        function handleTouchStart(e) {
          if (isTouched) {
            if (device.os === 'android') {
              if ('targetTouches' in e && e.targetTouches.length > 1) return;
            } else return;
          }

          if ($el.hasClass('ptr-refreshing')) {
            return;
          }

          if ($(e.target).closest('.sortable-handler, .ptr-ignore, .card-expandable.card-opened').length) return;
          isMoved = false;
          pullStarted = false;
          isTouched = true;
          isScrolling = undefined;
          wasScrolled = undefined;
          if (e.type === 'touchstart') touchId = e.targetTouches[0].identifier;
          touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        }

        function handleTouchMove(e) {
          if (!isTouched) return;
          var pageX;
          var pageY;
          var touch;

          if (e.type === 'touchmove') {
            if (touchId && e.touches) {
              for (var i = 0; i < e.touches.length; i += 1) {
                if (e.touches[i].identifier === touchId) {
                  touch = e.touches[i];
                }
              }
            }

            if (!touch) touch = e.targetTouches[0];
            pageX = touch.pageX;
            pageY = touch.pageY;
          } else {
            pageX = e.pageX;
            pageY = e.pageY;
          }

          if (!pageX || !pageY) return;

          if (typeof isScrolling === 'undefined') {
            isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
          }

          if (!isScrolling) {
            isTouched = false;
            return;
          }

          scrollTop = $el[0].scrollTop;

          if (!isMoved) {
            $el.removeClass('ptr-transitioning');

            if (isIos) {
              setPreloaderProgress(0);
            }

            var targetIsScrollable;
            scrollHeight = $el[0].scrollHeight;
            offsetHeight = $el[0].offsetHeight;

            if (ptr.bottom) {
              maxScrollTop = scrollHeight - offsetHeight;
            }

            if (scrollTop > scrollHeight) {
              isTouched = false;
              return;
            }

            var $ptrWatchScrollable = $(e.target).closest('.ptr-watch-scroll');

            if ($ptrWatchScrollable.length) {
              $ptrWatchScrollable.each(function (ptrScrollableEl) {
                if (ptrScrollableEl === el) return;

                if (ptrScrollableEl.scrollHeight > ptrScrollableEl.offsetHeight && $(ptrScrollableEl).css('overflow') === 'auto' && (!ptr.bottom && ptrScrollableEl.scrollTop > 0 || ptr.bottom && ptrScrollableEl.scrollTop < ptrScrollableEl.scrollHeight - ptrScrollableEl.offsetHeight)) {
                  targetIsScrollable = true;
                }
              });
            }

            if (targetIsScrollable) {
              isTouched = false;
              return;
            }

            if (dynamicTriggerDistance) {
              triggerDistance = $el.attr('data-ptr-distance');
              if (triggerDistance.indexOf('%') >= 0) triggerDistance = scrollHeight * parseInt(triggerDistance, 10) / 100;
            }

            startTranslate = $el.hasClass('ptr-refreshing') ? triggerDistance : 0;

            if (scrollHeight === offsetHeight || device.os !== 'ios' || isMaterial) {
              useTranslate = true;
            } else {
              useTranslate = false;
            }

            forceUseTranslate = false;
          }

          isMoved = true;
          touchesDiff = pageY - touchesStart.y;
          if (typeof wasScrolled === 'undefined' && (ptr.bottom ? scrollTop !== maxScrollTop : scrollTop !== 0)) wasScrolled = true;
          var ptrStarted = ptr.bottom ? touchesDiff < 0 && scrollTop >= maxScrollTop || scrollTop > maxScrollTop : touchesDiff > 0 && scrollTop <= 0 || scrollTop < 0;

          if (ptrStarted) {
            // iOS 8 fix
            if (device.os === 'ios' && parseInt(device.osVersion.split('.')[0], 10) > 7) {
              if (!ptr.bottom && scrollTop === 0 && !wasScrolled) useTranslate = true;
              if (ptr.bottom && scrollTop === maxScrollTop && !wasScrolled) useTranslate = true;
            }

            if (!useTranslate && ptr.bottom && !isMaterial) {
              $el.css('-webkit-overflow-scrolling', 'auto');
              $el.scrollTop(maxScrollTop);
              forceUseTranslate = true;
            }

            if (useTranslate || forceUseTranslate) {
              if (e.cancelable) {
                e.preventDefault();
              }

              translate = (ptr.bottom ? -1 * Math.pow(Math.abs(touchesDiff), 0.85) : Math.pow(touchesDiff, 0.85)) + startTranslate;

              if (isMaterial) {
                $preloaderEl.transform("translate3d(0," + translate + "px,0)").find('.ptr-arrow').transform("rotate(" + (180 * (Math.abs(touchesDiff) / 66) + 100) + "deg)");
              } else {
                // eslint-disable-next-line
                if (ptr.bottom || isIos) {
                  $el.children().transform("translate3d(0," + translate + "px,0)");
                } else {
                  // eslint-disable-next-line
                  $el.transform("translate3d(0," + translate + "px,0)");
                }

                if (isIos) {
                  $preloaderEl.transform("translate3d(0,0px,0)");
                }
              }
            } else if (isIos && !ptr.bottom) {
              $preloaderEl.transform("translate3d(0," + scrollTop + "px,0)");
            }

            var progress;

            if (isIos && !refresh) {
              progress = useTranslate || forceUseTranslate ? Math.pow(Math.abs(touchesDiff), 0.85) / triggerDistance : Math.abs(touchesDiff) / (triggerDistance * 2);
              setPreloaderProgress(progress);
            }

            if ((useTranslate || forceUseTranslate) && Math.pow(Math.abs(touchesDiff), 0.85) > triggerDistance || !useTranslate && Math.abs(touchesDiff) >= triggerDistance * 2) {
              refresh = true;
              $el.addClass('ptr-pull-up').removeClass('ptr-pull-down');
              unsetPreloaderProgress();
            } else {
              refresh = false;
              $el.removeClass('ptr-pull-up').addClass('ptr-pull-down');
            }

            if (!pullStarted) {
              $el.trigger('ptr:pullstart');
              ptr.emit('local::pullStart ptrPullStart', $el[0]);
              pullStarted = true;
            }

            $el.trigger('ptr:pullmove', {
              event: e,
              scrollTop: scrollTop,
              translate: translate,
              touchesDiff: touchesDiff
            });
            ptr.emit('local::pullMove ptrPullMove', $el[0], {
              event: e,
              scrollTop: scrollTop,
              translate: translate,
              touchesDiff: touchesDiff
            });
          } else {
            pullStarted = false;
            $el.removeClass('ptr-pull-up ptr-pull-down');
            refresh = false;
          }
        }

        function handleTouchEnd(e) {
          if (e.type === 'touchend' && e.changedTouches && e.changedTouches.length > 0 && touchId) {
            if (e.changedTouches[0].identifier !== touchId) {
              isTouched = false;
              isScrolling = false;
              isMoved = false;
              touchId = null;
              return;
            }
          }

          if (!isTouched || !isMoved) {
            isTouched = false;
            isMoved = false;
            return;
          }

          if (translate) {
            $el.addClass('ptr-transitioning');
            translate = 0;
          }

          if (isMaterial) {
            $preloaderEl.transform('').find('.ptr-arrow').transform('');
          } else {
            $preloaderEl.transform('');

            if (ptr.bottom || isIos) {
              $el.children().transform('');
            } else {
              $el.transform('');
            }
          }

          if (!useTranslate && ptr.bottom && !isMaterial) {
            $el.css('-webkit-overflow-scrolling', '');
          }

          if (refresh) {
            $el.addClass('ptr-refreshing');
            $el.trigger('ptr:refresh', ptr.done);
            ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
          } else {
            $el.removeClass('ptr-pull-down');
          }

          isTouched = false;
          isMoved = false;

          if (pullStarted) {
            $el.trigger('ptr:pullend');
            ptr.emit('local::pullEnd ptrPullEnd', $el[0]);
          }
        }

        var mousewheelTimeout;
        var mousewheelMoved;
        var mousewheelAllow = true;
        var mousewheelTranslate = 0;

        function handleMouseWheelRelease() {
          mousewheelAllow = true;
          mousewheelMoved = false;
          mousewheelTranslate = 0;

          if (translate) {
            $el.addClass('ptr-transitioning');
            translate = 0;
          }

          if (isMaterial) {
            $preloaderEl.transform('').find('.ptr-arrow').transform('');
          } else {
            $preloaderEl.transform('');

            if (ptr.bottom) {
              $el.children().transform('');
            } else {
              $el.transform('');
            }
          }

          if (refresh) {
            $el.addClass('ptr-refreshing');
            $el.trigger('ptr:refresh', ptr.done);
            ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
          } else {
            $el.removeClass('ptr-pull-down');
          }

          if (pullStarted) {
            $el.trigger('ptr:pullend');
            ptr.emit('local::pullEnd ptrPullEnd', $el[0]);
          }
        }

        function handleMouseWheel(e) {
          if (!mousewheelAllow) return;
          var deltaX = e.deltaX,
              deltaY = e.deltaY;
          if (Math.abs(deltaX) > Math.abs(deltaY)) return;

          if ($el.hasClass('ptr-refreshing')) {
            return;
          }

          if ($(e.target).closest('.sortable-handler, .ptr-ignore, .card-expandable.card-opened').length) return;
          clearTimeout(mousewheelTimeout);
          scrollTop = $el[0].scrollTop;

          if (!mousewheelMoved) {
            $el.removeClass('ptr-transitioning');

            if (isIos) {
              setPreloaderProgress(0);
            }

            var targetIsScrollable;
            scrollHeight = $el[0].scrollHeight;
            offsetHeight = $el[0].offsetHeight;

            if (ptr.bottom) {
              maxScrollTop = scrollHeight - offsetHeight;
            }

            if (scrollTop > scrollHeight) {
              mousewheelAllow = false;
              return;
            }

            var $ptrWatchScrollable = $(e.target).closest('.ptr-watch-scroll');

            if ($ptrWatchScrollable.length) {
              $ptrWatchScrollable.each(function (ptrScrollableEl) {
                if (ptrScrollableEl === el) return;

                if (ptrScrollableEl.scrollHeight > ptrScrollableEl.offsetHeight && $(ptrScrollableEl).css('overflow') === 'auto' && (!ptr.bottom && ptrScrollableEl.scrollTop > 0 || ptr.bottom && ptrScrollableEl.scrollTop < ptrScrollableEl.scrollHeight - ptrScrollableEl.offsetHeight)) {
                  targetIsScrollable = true;
                }
              });
            }

            if (targetIsScrollable) {
              mousewheelAllow = false;
              return;
            }

            if (dynamicTriggerDistance) {
              triggerDistance = $el.attr('data-ptr-distance');
              if (triggerDistance.indexOf('%') >= 0) triggerDistance = scrollHeight * parseInt(triggerDistance, 10) / 100;
            }
          }

          isMoved = true;
          mousewheelTranslate -= deltaY;
          touchesDiff = mousewheelTranslate; // pageY - touchesStart.y;

          if (typeof wasScrolled === 'undefined' && (ptr.bottom ? scrollTop !== maxScrollTop : scrollTop !== 0)) wasScrolled = true;
          var ptrStarted = ptr.bottom ? touchesDiff < 0 && scrollTop >= maxScrollTop || scrollTop > maxScrollTop : touchesDiff > 0 && scrollTop <= 0 || scrollTop < 0;

          if (ptrStarted) {
            if (e.cancelable) {
              e.preventDefault();
            }

            translate = touchesDiff;

            if (Math.abs(translate) > triggerDistance) {
              translate = triggerDistance + Math.pow(Math.abs(translate) - triggerDistance, 0.7);
              if (ptr.bottom) translate = -translate;
            }

            if (isMaterial) {
              $preloaderEl.transform("translate3d(0," + translate + "px,0)").find('.ptr-arrow').transform("rotate(" + (180 * (Math.abs(touchesDiff) / 66) + 100) + "deg)");
            } else {
              // eslint-disable-next-line
              if (ptr.bottom) {
                $el.children().transform("translate3d(0," + translate + "px,0)");
              } else {
                $el.transform("translate3d(0," + translate + "px,0)");

                if (isIos) {
                  $preloaderEl.transform("translate3d(0," + -translate + "px,0)");
                }
              }
            }

            var progress;

            if (isIos && !refresh) {
              progress = Math.abs(translate) / triggerDistance;
              setPreloaderProgress(progress);
            }

            if (Math.abs(translate) > triggerDistance) {
              refresh = true;
              $el.addClass('ptr-pull-up').removeClass('ptr-pull-down');
              unsetPreloaderProgress();
            } else {
              refresh = false;
              $el.removeClass('ptr-pull-up').addClass('ptr-pull-down');
            }

            if (!pullStarted) {
              $el.trigger('ptr:pullstart');
              ptr.emit('local::pullStart ptrPullStart', $el[0]);
              pullStarted = true;
            }

            $el.trigger('ptr:pullmove', {
              event: e,
              scrollTop: scrollTop,
              translate: translate,
              touchesDiff: touchesDiff
            });
            ptr.emit('local::pullMove ptrPullMove', $el[0], {
              event: e,
              scrollTop: scrollTop,
              translate: translate,
              touchesDiff: touchesDiff
            });
          } else {
            pullStarted = false;
            $el.removeClass('ptr-pull-up ptr-pull-down');
            refresh = false;
          }

          mousewheelTimeout = setTimeout(handleMouseWheelRelease, 300);
        }

        if (!$pageEl.length || !$el.length) return ptr || _assertThisInitialized$a(_this);
        $el[0].f7PullToRefresh = ptr; // Events

        ptr.attachEvents = function attachEvents() {
          var passive = support.passiveListener ? {
            passive: true
          } : false;
          $el.on(app.touchEvents.start, handleTouchStart, passive);
          app.on('touchmove:active', handleTouchMove);
          app.on('touchend:passive', handleTouchEnd);

          if (ptr.mousewheel && !ptr.bottom) {
            $el.on('wheel', handleMouseWheel);
          }
        };

        ptr.detachEvents = function detachEvents() {
          var passive = support.passiveListener ? {
            passive: true
          } : false;
          $el.off(app.touchEvents.start, handleTouchStart, passive);
          app.off('touchmove:active', handleTouchMove);
          app.off('touchend:passive', handleTouchEnd);

          if (ptr.mousewheel && !ptr.bottom) {
            $el.off('wheel', handleMouseWheel);
          }
        }; // Install Modules


        ptr.useModules(); // Init

        ptr.init();
        return ptr || _assertThisInitialized$a(_this);
      }

      var _proto = PullToRefresh.prototype;

      _proto.init = function init() {
        var ptr = this;
        ptr.attachEvents();
      };

      _proto.destroy = function destroy() {
        var ptr = this;
        ptr.emit('local::beforeDestroy ptrBeforeDestroy', ptr);
        ptr.$el.trigger('ptr:beforedestroy');
        delete ptr.el.f7PullToRefresh;
        ptr.detachEvents();
        deleteProps$1(ptr);
        ptr = null;
      };

      return PullToRefresh;
    }(Framework7Class$1);

    var PullToRefresh$2 = PullToRefresh$1;

    var PullToRefresh = {
      name: 'pullToRefresh',
      create: function create() {
        var app = this;
        app.ptr = extend$2(ConstructorMethods({
          defaultSelector: '.ptr-content',
          constructor: PullToRefresh$2,
          app: app,
          domProp: 'f7PullToRefresh'
        }), {
          done: function done(el) {
            var ptr = app.ptr.get(el);
            if (ptr) return ptr.done();
            return undefined;
          },
          refresh: function refresh(el) {
            var ptr = app.ptr.get(el);
            if (ptr) return ptr.refresh();
            return undefined;
          }
        });
      },
      static: {
        PullToRefresh: PullToRefresh$2
      },
      on: {
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          var $tabEl = $(tabEl);
          var $ptrEls = $tabEl.find('.ptr-content');
          if ($tabEl.is('.ptr-content')) $ptrEls.add($tabEl);
          $ptrEls.each(function (el) {
            app.ptr.create(el);
          });
        },
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          var $tabEl = $(tabEl);
          var app = this;
          var $ptrEls = $tabEl.find('.ptr-content');
          if ($tabEl.is('.ptr-content')) $ptrEls.add($tabEl);
          $ptrEls.each(function (el) {
            app.ptr.destroy(el);
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.ptr-content').each(function (el) {
            app.ptr.create(el);
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          var app = this;
          page.$el.find('.ptr-content').each(function (el) {
            app.ptr.destroy(el);
          });
        }
      }
    };

    var Lazy = {
      destroy: function destroy(pageEl) {
        var $pageEl = $(pageEl).closest('.page');
        if (!$pageEl.length) return;

        if ($pageEl[0].f7LazyDestroy) {
          $pageEl[0].f7LazyDestroy();
        }
      },
      create: function create(pageEl) {
        var app = this;
        var window = getWindow();
        var support = getSupport$1();
        var $pageEl = $(pageEl).closest('.page').eq(0); // Lazy images

        var $lazyLoadImages = $pageEl.find('.lazy');
        if ($lazyLoadImages.length === 0 && !$pageEl.hasClass('lazy')) return; // Placeholder

        var placeholderSrc = app.params.lazy.placeholder;

        if (placeholderSrc !== false) {
          $lazyLoadImages.each(function (lazyEl) {
            if ($(lazyEl).attr('data-src') && !$(lazyEl).attr('src')) $(lazyEl).attr('src', placeholderSrc);
          });
        } // load image


        var imagesSequence = [];
        var imageIsLoading = false;

        function onImageComplete(lazyEl) {
          if (imagesSequence.indexOf(lazyEl) >= 0) {
            imagesSequence.splice(imagesSequence.indexOf(lazyEl), 1);
          }

          imageIsLoading = false;

          if (app.params.lazy.sequential && imagesSequence.length > 0) {
            imageIsLoading = true;
            app.lazy.loadImage(imagesSequence[0], onImageComplete);
          }
        }

        function observerCallback(entries, observer) {
          entries.forEach(function (entry) {
            if (entry.isIntersecting) {
              if (app.params.lazy.sequential && imageIsLoading) {
                if (imagesSequence.indexOf(entry.target) < 0) imagesSequence.push(entry.target);
                return;
              } // Load image


              imageIsLoading = true;
              app.lazy.loadImage(entry.target, onImageComplete); // Detach

              observer.unobserve(entry.target);
            }
          });
        }

        if (app.params.lazy.observer && support.intersectionObserver) {
          var observer = $pageEl[0].f7LazyObserver;

          if (!observer) {
            observer = new window.IntersectionObserver(observerCallback, {
              root: $pageEl[0]
            });
          }

          $lazyLoadImages.each(function (el) {
            if (el.f7LazyObserverAdded) return;
            el.f7LazyObserverAdded = true;
            observer.observe(el);
          });

          if (!$pageEl[0].f7LazyDestroy) {
            $pageEl[0].f7LazyDestroy = function () {
              observer.disconnect();
              delete $pageEl[0].f7LazyDestroy;
              delete $pageEl[0].f7LazyObserver;
            };
          }

          return;
        }

        function lazyHandler() {
          app.lazy.load($pageEl, function (lazyEl) {
            if (app.params.lazy.sequential && imageIsLoading) {
              if (imagesSequence.indexOf(lazyEl) < 0) imagesSequence.push(lazyEl);
              return;
            }

            imageIsLoading = true;
            app.lazy.loadImage(lazyEl, onImageComplete);
          });
        }

        function attachEvents() {
          $pageEl[0].f7LazyAttached = true;
          $pageEl.on('lazy', lazyHandler);
          $pageEl.on('scroll', lazyHandler, true);
          $pageEl.find('.tab').on('tab:mounted tab:show', lazyHandler);
          app.on('resize', lazyHandler);
        }

        function detachEvents() {
          $pageEl[0].f7LazyAttached = false;
          delete $pageEl[0].f7LazyAttached;
          $pageEl.off('lazy', lazyHandler);
          $pageEl.off('scroll', lazyHandler, true);
          $pageEl.find('.tab').off('tab:mounted tab:show', lazyHandler);
          app.off('resize', lazyHandler);
        } // Store detach function


        if (!$pageEl[0].f7LazyDestroy) {
          $pageEl[0].f7LazyDestroy = detachEvents;
        } // Attach events


        if (!$pageEl[0].f7LazyAttached) {
          attachEvents();
        } // Run loader on page load/init


        lazyHandler();
      },
      isInViewport: function isInViewport(lazyEl) {
        var app = this;
        var rect = lazyEl.getBoundingClientRect();
        var threshold = app.params.lazy.threshold || 0;
        return rect.top >= 0 - threshold && rect.left >= 0 - threshold && rect.top <= app.height + threshold && rect.left <= app.width + threshold;
      },
      loadImage: function loadImage(imageEl, callback) {
        var app = this;
        var window = getWindow();
        var $imageEl = $(imageEl);
        var bg = $imageEl.attr('data-background');
        var src = bg || $imageEl.attr('data-src');

        function onLoad() {
          $imageEl.removeClass('lazy').addClass('lazy-loaded');

          if (bg) {
            $imageEl.css('background-image', "url(" + src + ")");
          } else if (src) {
            $imageEl.attr('src', src);
          }

          if (callback) callback(imageEl);
          $imageEl.trigger('lazy:loaded');
          app.emit('lazyLoaded', $imageEl[0]);
        }

        if (!src) {
          $imageEl.trigger('lazy:load');
          app.emit('lazyLoad', $imageEl[0]);
          onLoad();
          return;
        }

        function onError() {
          $imageEl.removeClass('lazy').addClass('lazy-loaded');

          if (bg) {
            $imageEl.css('background-image', "url(" + (app.params.lazy.placeholder || '') + ")");
          } else {
            $imageEl.attr('src', app.params.lazy.placeholder || '');
          }

          if (callback) callback(imageEl);
          $imageEl.trigger('lazy:error');
          app.emit('lazyError', $imageEl[0]);
        }

        var image = new window.Image();
        image.onload = onLoad;
        image.onerror = onError;
        image.src = src;
        $imageEl.removeAttr('data-src').removeAttr('data-background'); // Add loaded callback and events

        $imageEl.trigger('lazy:load');
        app.emit('lazyLoad', $imageEl[0]);
      },
      load: function load(pageEl, callback) {
        var app = this;
        var $pageEl = $(pageEl);
        if (!$pageEl.hasClass('page')) $pageEl = $pageEl.parents('.page').eq(0);

        if ($pageEl.length === 0) {
          return;
        }

        $pageEl.find('.lazy').each(function (lazyEl) {
          var $lazyEl = $(lazyEl);

          if ($lazyEl.parents('.tab:not(.tab-active)').length > 0) {
            return;
          }

          if (app.lazy.isInViewport(lazyEl)) {
            if (callback) callback(lazyEl);else app.lazy.loadImage(lazyEl);
          }
        });
      }
    };
    var Lazy$1 = {
      name: 'lazy',
      params: {
        lazy: {
          placeholder: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEXCwsK592mkAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==',
          threshold: 0,
          sequential: true,
          observer: true
        }
      },
      create: function create() {
        var app = this;
        bindMethods(app, {
          lazy: Lazy
        });
      },
      on: {
        pageInit: function pageInit(page) {
          var app = this;

          if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
            app.lazy.create(page.$el);
          }
        },
        pageAfterIn: function pageAfterIn(page) {
          var app = this;
          var support = getSupport$1();
          if (app.params.lazy.observer && support.intersectionObserver) return;

          if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
            app.lazy.create(page.$el);
          }
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          var app = this;

          if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
            app.lazy.destroy(page.$el);
          }
        },
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          var $tabEl = $(tabEl);

          if ($tabEl.find('.lazy').length > 0 || $tabEl.hasClass('lazy')) {
            app.lazy.create($tabEl);
          }
        },
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          var app = this;
          var support = getSupport$1();
          if (app.params.lazy.observer && support.intersectionObserver) return;
          var $tabEl = $(tabEl);

          if ($tabEl.find('.lazy').length > 0 || $tabEl.hasClass('lazy')) {
            app.lazy.destroy($tabEl);
          }
        }
      }
    };

    function _assertThisInitialized$9(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$9(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$9(subClass, superClass); }

    function _setPrototypeOf$9(o, p) { _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$9(o, p); }

    var DataTable$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$9(DataTable, _Framework7Class);

      function DataTable(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params, [app]) || this;

        var table = _assertThisInitialized$9(_this);

        var defaults = {}; // Extend defaults with modules params

        table.useModulesParams(defaults);
        table.params = extend$2(defaults, params); // El

        var $el = $(table.params.el);
        if ($el.length === 0) return _assertThisInitialized$9(_this);
        table.$el = $el;
        table.el = $el[0];

        if (table.$el[0].f7DataTable) {
          var instance = table.$el[0].f7DataTable;
          table.destroy();
          return instance || _assertThisInitialized$9(_this);
        }

        table.$el[0].f7DataTable = table;
        extend$2(table, {
          collapsible: $el.hasClass('data-table-collapsible'),
          // Headers
          $headerEl: $el.find('.data-table-header'),
          $headerSelectedEl: $el.find('.data-table-header-selected')
        }); // Events

        function handleChange(e) {
          if (e.detail && e.detail.sentByF7DataTable) {
            // Scripted event, don't do anything
            return;
          }

          var $inputEl = $(this);
          var checked = $inputEl[0].checked;
          var columnIndex = $inputEl.parents('td,th').index();

          if ($inputEl.parents('thead').length > 0) {
            if (columnIndex === 0) {
              $el.find('tbody tr')[checked ? 'addClass' : 'removeClass']('data-table-row-selected');
            }

            $el.find("tbody tr td:nth-child(" + (columnIndex + 1) + ") input").prop('checked', checked).trigger('change', {
              sentByF7DataTable: true
            });
            $inputEl.prop('indeterminate', false);
          } else {
            if (columnIndex === 0) {
              $inputEl.parents('tr')[checked ? 'addClass' : 'removeClass']('data-table-row-selected');
            }

            var checkedRows = $el.find("tbody .checkbox-cell:nth-child(" + (columnIndex + 1) + ") input[type=\"checkbox\"]:checked").length;
            var totalRows = $el.find('tbody tr').length;
            var $headCheckboxEl = $el.find("thead .checkbox-cell:nth-child(" + (columnIndex + 1) + ") input[type=\"checkbox\"]");

            if (!checked) {
              $headCheckboxEl.prop('checked', false);
            } else if (checkedRows === totalRows) {
              $headCheckboxEl.prop('checked', true).trigger('change', {
                sentByF7DataTable: true
              });
            }

            $headCheckboxEl.prop('indeterminate', checkedRows > 0 && checkedRows < totalRows);
          }

          table.checkSelectedHeader();
        }

        function handleSortableClick() {
          var $cellEl = $(this);
          var isActive = $cellEl.hasClass('sortable-cell-active');
          var currentSort = $cellEl.hasClass('sortable-desc') ? 'desc' : 'asc';
          var newSort;

          if (isActive) {
            newSort = currentSort === 'desc' ? 'asc' : 'desc';
            $cellEl.removeClass('sortable-desc sortable-asc').addClass("sortable-" + newSort);
          } else {
            $el.find('thead .sortable-cell-active').removeClass('sortable-cell-active');
            $cellEl.addClass('sortable-cell-active');
            newSort = currentSort;
          }

          $cellEl.trigger('datatable:sort', newSort);
          table.emit('local::sort dataTableSort', table, newSort);
        }

        table.attachEvents = function attachEvents() {
          table.$el.on('change', '.checkbox-cell input[type="checkbox"]', handleChange);
          table.$el.find('thead .sortable-cell').on('click', handleSortableClick);
        };

        table.detachEvents = function detachEvents() {
          table.$el.off('change', '.checkbox-cell input[type="checkbox"]', handleChange);
          table.$el.find('thead .sortable-cell').off('click', handleSortableClick);
        }; // Install Modules


        table.useModules(); // Init

        table.init();
        return table || _assertThisInitialized$9(_this);
      }

      var _proto = DataTable.prototype;

      _proto.setCollapsibleLabels = function setCollapsibleLabels() {
        var table = this;
        if (!table.collapsible) return;
        table.$el.find('tbody td:not(.checkbox-cell)').each(function (el) {
          var $el = $(el);
          var elIndex = $el.index();
          var collpsibleTitle = $el.attr('data-collapsible-title');

          if (!collpsibleTitle && collpsibleTitle !== '') {
            $el.attr('data-collapsible-title', table.$el.find('thead th').eq(elIndex).text());
          }
        });
      };

      _proto.checkSelectedHeader = function checkSelectedHeader() {
        var table = this;

        if (table.$headerEl.length > 0 && table.$headerSelectedEl.length > 0) {
          var checkedItems = table.$el.find('tbody .checkbox-cell input:checked').length;
          table.$el[checkedItems > 0 ? 'addClass' : 'removeClass']('data-table-has-checked');
          table.$headerSelectedEl.find('.data-table-selected-count').text(checkedItems);
        }
      };

      _proto.init = function init() {
        var table = this;
        table.attachEvents();
        table.setCollapsibleLabels();
        table.checkSelectedHeader();
      };

      _proto.destroy = function destroy() {
        var table = this;
        table.$el.trigger('datatable:beforedestroy');
        table.emit('local::beforeDestroy dataTableBeforeDestroy', table);
        table.attachEvents();

        if (table.$el[0]) {
          table.$el[0].f7DataTable = null;
          delete table.$el[0].f7DataTable;
        }

        deleteProps$1(table);
        table = null;
      };

      return DataTable;
    }(Framework7Class$1);

    var DataTable$2 = DataTable$1;

    var DataTable = {
      name: 'dataTable',
      static: {
        DataTable: DataTable$2
      },
      create: function create() {
        var app = this;
        app.dataTable = ConstructorMethods({
          defaultSelector: '.data-table',
          constructor: DataTable$2,
          app: app,
          domProp: 'f7DataTable'
        });
      },
      on: {
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          var app = this;
          $(tabEl).find('.data-table-init').each(function (tableEl) {
            app.dataTable.destroy(tableEl);
          });
        },
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.data-table-init').each(function (tableEl) {
            app.dataTable.create({
              el: tableEl
            });
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          var app = this;
          page.$el.find('.data-table-init').each(function (tableEl) {
            app.dataTable.destroy(tableEl);
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.data-table-init').each(function (tableEl) {
            app.dataTable.create({
              el: tableEl
            });
          });
        }
      },
      vnode: {
        'data-table-init': {
          insert: function insert(vnode) {
            var app = this;
            var tableEl = vnode.elm;
            app.dataTable.create({
              el: tableEl
            });
          },
          destroy: function destroy(vnode) {
            var app = this;
            var tableEl = vnode.elm;
            app.dataTable.destroy(tableEl);
          }
        }
      }
    };

    function _extends$3() { _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }
    var Fab$1 = {
      morphOpen: function morphOpen(fabEl, targetEl) {
        var app = this;
        var $fabEl = $(fabEl);
        var $targetEl = $(targetEl);
        if ($targetEl.length === 0) return;
        $targetEl.transition(0).addClass('fab-morph-target-visible');
        var target = {
          width: $targetEl[0].offsetWidth,
          height: $targetEl[0].offsetHeight,
          offset: $targetEl.offset(),
          borderRadius: $targetEl.css('border-radius'),
          zIndex: $targetEl.css('z-index')
        };
        var fab = {
          width: $fabEl[0].offsetWidth,
          height: $fabEl[0].offsetHeight,
          offset: $fabEl.offset(),
          translateX: getTranslate$1($fabEl[0], 'x'),
          translateY: getTranslate$1($fabEl[0], 'y')
        };
        $fabEl[0].f7FabMorphData = {
          $targetEl: $targetEl,
          target: target,
          fab: fab
        };
        var diffX = fab.offset.left + fab.width / 2 - (target.offset.left + target.width / 2) - fab.translateX;
        var diffY = fab.offset.top + fab.height / 2 - (target.offset.top + target.height / 2) - fab.translateY;
        var scaleX = target.width / fab.width;
        var scaleY = target.height / fab.height;
        var borderRadius = Math.ceil(parseInt(target.borderRadius, 10) / Math.max(scaleX, scaleY));
        if (borderRadius > 0) borderRadius += 2;

        $fabEl[0].f7FabMorphResizeHandler = function resizeHandler() {
          $fabEl.transition(0).transform('');
          $targetEl.transition(0);
          target.width = $targetEl[0].offsetWidth;
          target.height = $targetEl[0].offsetHeight;
          target.offset = $targetEl.offset();
          fab.offset = $fabEl.offset();
          var diffXNew = fab.offset.left + fab.width / 2 - (target.offset.left + target.width / 2) - fab.translateX;
          var diffYNew = fab.offset.top + fab.height / 2 - (target.offset.top + target.height / 2) - fab.translateY;
          var scaleXNew = target.width / fab.width;
          var scaleYNew = target.height / fab.height;
          $fabEl.transform("translate3d(" + -diffXNew + "px, " + -diffYNew + "px, 0) scale(" + scaleXNew + ", " + scaleYNew + ")");
        };

        $targetEl.css('opacity', 0).transform("scale(" + 1 / scaleX + ", " + 1 / scaleY + ")");
        $fabEl.addClass('fab-opened').css('z-index', target.zIndex - 1).transform("translate3d(" + -diffX + "px, " + -diffY + "px, 0)");
        $fabEl.transitionEnd(function () {
          $targetEl.transition('');
          nextFrame(function () {
            $targetEl.css('opacity', 1).transform('scale(1,1)');
            $fabEl.transform("translate3d(" + -diffX + "px, " + -diffY + "px, 0) scale(" + scaleX + ", " + scaleY + ")").css('border-radius', borderRadius + "px").css('box-shadow', 'none').css('opacity', '0');
          });
          app.on('resize', $fabEl[0].f7FabMorphResizeHandler);

          if ($targetEl.parents('.page-content').length > 0) {
            $targetEl.parents('.page-content').on('scroll', $fabEl[0].f7FabMorphResizeHandler);
          }
        });
      },
      morphClose: function morphClose(fabEl) {
        var app = this;
        var $fabEl = $(fabEl);
        var morphData = $fabEl[0].f7FabMorphData;
        if (!morphData) return;
        var $targetEl = morphData.$targetEl,
            target = morphData.target,
            fab = morphData.fab;
        if ($targetEl.length === 0) return;
        var diffX = fab.offset.left + fab.width / 2 - (target.offset.left + target.width / 2) - fab.translateX;
        var diffY = fab.offset.top + fab.height / 2 - (target.offset.top + target.height / 2) - fab.translateY;
        var scaleX = target.width / fab.width;
        var scaleY = target.height / fab.height;
        app.off('resize', $fabEl[0].f7FabMorphResizeHandler);

        if ($targetEl.parents('.page-content').length > 0) {
          $targetEl.parents('.page-content').off('scroll', $fabEl[0].f7FabMorphResizeHandler);
        }

        $targetEl.css('opacity', 0).transform("scale(" + 1 / scaleX + ", " + 1 / scaleY + ")");
        $fabEl.transition('').css('box-shadow', '').css('border-radius', '').css('opacity', '1').transform("translate3d(" + -diffX + "px, " + -diffY + "px, 0)");
        $fabEl.transitionEnd(function () {
          $fabEl.css('z-index', '').removeClass('fab-opened').transform('');
          nextFrame(function () {
            $fabEl.transitionEnd(function () {
              $targetEl.removeClass('fab-morph-target-visible').css('opacity', '').transform('').transition('');
            });
          });
        });
      },
      open: function open(fabEl, targetEl) {
        var app = this;
        var $fabEl = $(fabEl).eq(0);
        var $buttonsEl = $fabEl.find('.fab-buttons');
        if (!$fabEl.length) return;
        if ($fabEl.hasClass('fab-opened')) return;
        if (!$buttonsEl.length && !$fabEl.hasClass('fab-morph')) return;

        if (app.fab.openedEl) {
          if (app.fab.openedEl === $fabEl[0]) return;
          app.fab.close(app.fab.openedEl);
        }

        app.fab.openedEl = $fabEl[0];

        if ($fabEl.hasClass('fab-morph')) {
          app.fab.morphOpen($fabEl, targetEl || $fabEl.attr('data-morph-to'));
        } else {
          $fabEl.addClass('fab-opened');
        }

        $fabEl.siblings('.fab-backdrop').addClass('backdrop-in');
        $fabEl.trigger('fab:open');
      },
      close: function close(fabEl) {
        if (fabEl === void 0) {
          fabEl = '.fab-opened';
        }

        var app = this;
        var $fabEl = $(fabEl).eq(0);
        var $buttonsEl = $fabEl.find('.fab-buttons');
        if (!$fabEl.length) return;
        if (!$fabEl.hasClass('fab-opened')) return;
        if (!$buttonsEl.length && !$fabEl.hasClass('fab-morph')) return;
        app.fab.openedEl = null;

        if ($fabEl.hasClass('fab-morph')) {
          app.fab.morphClose($fabEl);
        } else {
          $fabEl.removeClass('fab-opened');
        }

        $fabEl.siblings('.fab-backdrop').removeClass('backdrop-in');
        $fabEl.trigger('fab:close');
      },
      toggle: function toggle(fabEl) {
        var app = this;
        var $fabEl = $(fabEl);
        if (!$fabEl.hasClass('fab-opened')) app.fab.open(fabEl);else app.fab.close(fabEl);
      }
    };
    var Fab$2 = {
      name: 'fab',
      create: function create() {
        var app = this;
        bindMethods(app, {
          fab: _extends$3({
            openedEl: null
          }, Fab$1)
        });
      },
      clicks: {
        '.fab > a': function open($clickedEl) {
          var app = this;
          app.fab.toggle($clickedEl.parents('.fab'));
        },
        '.fab-open': function open($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.fab.open(data.fab);
        },
        '.fab-close': function close($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          app.fab.close(data.fab);
        },
        '.fab-backdrop': function close() {
          var app = this;
          app.fab.close();
        }
      }
    };

    /* eslint no-control-regex: "off" */
    var defaultDiacriticsRemovalap = [{
      base: 'A',
      letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
    }, {
      base: 'AA',
      letters: "\uA732"
    }, {
      base: 'AE',
      letters: "\xC6\u01FC\u01E2"
    }, {
      base: 'AO',
      letters: "\uA734"
    }, {
      base: 'AU',
      letters: "\uA736"
    }, {
      base: 'AV',
      letters: "\uA738\uA73A"
    }, {
      base: 'AY',
      letters: "\uA73C"
    }, {
      base: 'B',
      letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
    }, {
      base: 'C',
      letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
    }, {
      base: 'D',
      letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
    }, {
      base: 'DZ',
      letters: "\u01F1\u01C4"
    }, {
      base: 'Dz',
      letters: "\u01F2\u01C5"
    }, {
      base: 'E',
      letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
    }, {
      base: 'F',
      letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B"
    }, {
      base: 'G',
      letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
    }, {
      base: 'H',
      letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
    }, {
      base: 'I',
      letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
    }, {
      base: 'J',
      letters: "J\u24BF\uFF2A\u0134\u0248"
    }, {
      base: 'K',
      letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
    }, {
      base: 'L',
      letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
    }, {
      base: 'LJ',
      letters: "\u01C7"
    }, {
      base: 'Lj',
      letters: "\u01C8"
    }, {
      base: 'M',
      letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
    }, {
      base: 'N',
      letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
    }, {
      base: 'NJ',
      letters: "\u01CA"
    }, {
      base: 'Nj',
      letters: "\u01CB"
    }, {
      base: 'O',
      letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
    }, {
      base: 'OI',
      letters: "\u01A2"
    }, {
      base: 'OO',
      letters: "\uA74E"
    }, {
      base: 'OU',
      letters: "\u0222"
    }, {
      base: 'OE',
      letters: "\x8C\u0152"
    }, {
      base: 'oe',
      letters: "\x9C\u0153"
    }, {
      base: 'P',
      letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
    }, {
      base: 'Q',
      letters: "Q\u24C6\uFF31\uA756\uA758\u024A"
    }, {
      base: 'R',
      letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
    }, {
      base: 'S',
      letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
    }, {
      base: 'T',
      letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
    }, {
      base: 'TZ',
      letters: "\uA728"
    }, {
      base: 'U',
      letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
    }, {
      base: 'V',
      letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
    }, {
      base: 'VY',
      letters: "\uA760"
    }, {
      base: 'W',
      letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
    }, {
      base: 'X',
      letters: "X\u24CD\uFF38\u1E8A\u1E8C"
    }, {
      base: 'Y',
      letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
    }, {
      base: 'Z',
      letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
    }, {
      base: 'a',
      letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
    }, {
      base: 'aa',
      letters: "\uA733"
    }, {
      base: 'ae',
      letters: "\xE6\u01FD\u01E3"
    }, {
      base: 'ao',
      letters: "\uA735"
    }, {
      base: 'au',
      letters: "\uA737"
    }, {
      base: 'av',
      letters: "\uA739\uA73B"
    }, {
      base: 'ay',
      letters: "\uA73D"
    }, {
      base: 'b',
      letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
    }, {
      base: 'c',
      letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
    }, {
      base: 'd',
      letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
    }, {
      base: 'dz',
      letters: "\u01F3\u01C6"
    }, {
      base: 'e',
      letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
    }, {
      base: 'f',
      letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C"
    }, {
      base: 'g',
      letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
    }, {
      base: 'h',
      letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
    }, {
      base: 'hv',
      letters: "\u0195"
    }, {
      base: 'i',
      letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
    }, {
      base: 'j',
      letters: "j\u24D9\uFF4A\u0135\u01F0\u0249"
    }, {
      base: 'k',
      letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
    }, {
      base: 'l',
      letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
    }, {
      base: 'lj',
      letters: "\u01C9"
    }, {
      base: 'm',
      letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
    }, {
      base: 'n',
      letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
    }, {
      base: 'nj',
      letters: "\u01CC"
    }, {
      base: 'o',
      letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
    }, {
      base: 'oi',
      letters: "\u01A3"
    }, {
      base: 'ou',
      letters: "\u0223"
    }, {
      base: 'oo',
      letters: "\uA74F"
    }, {
      base: 'p',
      letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
    }, {
      base: 'q',
      letters: "q\u24E0\uFF51\u024B\uA757\uA759"
    }, {
      base: 'r',
      letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
    }, {
      base: 's',
      letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
    }, {
      base: 't',
      letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
    }, {
      base: 'tz',
      letters: "\uA729"
    }, {
      base: 'u',
      letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
    }, {
      base: 'v',
      letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
    }, {
      base: 'vy',
      letters: "\uA761"
    }, {
      base: 'w',
      letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
    }, {
      base: 'x',
      letters: "x\u24E7\uFF58\u1E8B\u1E8D"
    }, {
      base: 'y',
      letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
    }, {
      base: 'z',
      letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
    }];
    var diacriticsMap = {};

    for (var i = 0; i < defaultDiacriticsRemovalap.length; i += 1) {
      var letters = defaultDiacriticsRemovalap[i].letters;

      for (var j = 0; j < letters.length; j += 1) {
        diacriticsMap[letters[j]] = defaultDiacriticsRemovalap[i].base;
      }
    }

    function removeDiacritics(str) {
      return str.replace(/[^\u0000-\u007E]/g, function (a) {
        return diacriticsMap[a] || a;
      });
    }

    function _assertThisInitialized$8(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$8(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$8(subClass, superClass); }

    function _setPrototypeOf$8(o, p) { _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$8(o, p); }

    var Searchbar$1 = /*#__PURE__*/function (_FrameworkClass) {
      _inheritsLoose$8(Searchbar, _FrameworkClass);

      function Searchbar(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _FrameworkClass.call(this, params, [app]) || this;

        var sb = _assertThisInitialized$8(_this);

        var defaults = {
          el: undefined,
          inputEl: undefined,
          inputEvents: 'change input compositionend',
          disableButton: true,
          disableButtonEl: undefined,
          backdropEl: undefined,
          searchContainer: undefined,
          // container to search, HTMLElement or CSS selector
          searchItem: 'li',
          // single item selector, CSS selector
          searchIn: undefined,
          // where to search in item, CSS selector
          searchGroup: '.list-group',
          searchGroupTitle: '.item-divider, .list-group-title',
          ignore: '.searchbar-ignore',
          foundEl: '.searchbar-found',
          notFoundEl: '.searchbar-not-found',
          hideOnEnableEl: '.searchbar-hide-on-enable',
          hideOnSearchEl: '.searchbar-hide-on-search',
          backdrop: undefined,
          removeDiacritics: true,
          customSearch: false,
          hideDividers: true,
          hideGroups: true,
          disableOnBackdropClick: true,
          expandable: false,
          inline: false
        }; // Extend defaults with modules params

        sb.useModulesParams(defaults);
        sb.params = extend$2(defaults, params);
        var $el = $(sb.params.el);
        if ($el.length === 0) return sb || _assertThisInitialized$8(_this);
        if ($el[0].f7Searchbar) return $el[0].f7Searchbar || _assertThisInitialized$8(_this);
        $el[0].f7Searchbar = sb;
        var $pageEl;
        var $navbarEl = $el.parents('.navbar');

        if ($el.parents('.page').length > 0) {
          $pageEl = $el.parents('.page');
        } else if ($navbarEl.length > 0) {
          $pageEl = $(app.navbar.getPageByEl($navbarEl[0]));

          if (!$pageEl.length) {
            var $currentPageEl = $el.parents('.view').find('.page-current');

            if ($currentPageEl[0] && $currentPageEl[0].f7Page && $currentPageEl[0].f7Page.navbarEl === $navbarEl[0]) {
              $pageEl = $currentPageEl;
            }
          }
        }

        var $foundEl;

        if (params.foundEl) {
          $foundEl = $(params.foundEl);
        } else if (typeof sb.params.foundEl === 'string' && $pageEl) {
          $foundEl = $pageEl.find(sb.params.foundEl);
        }

        var $notFoundEl;

        if (params.notFoundEl) {
          $notFoundEl = $(params.notFoundEl);
        } else if (typeof sb.params.notFoundEl === 'string' && $pageEl) {
          $notFoundEl = $pageEl.find(sb.params.notFoundEl);
        }

        var $hideOnEnableEl;

        if (params.hideOnEnableEl) {
          $hideOnEnableEl = $(params.hideOnEnableEl);
        } else if (typeof sb.params.hideOnEnableEl === 'string' && $pageEl) {
          $hideOnEnableEl = $pageEl.find(sb.params.hideOnEnableEl);
        }

        var $hideOnSearchEl;

        if (params.hideOnSearchEl) {
          $hideOnSearchEl = $(params.hideOnSearchEl);
        } else if (typeof sb.params.hideOnSearchEl === 'string' && $pageEl) {
          $hideOnSearchEl = $pageEl.find(sb.params.hideOnSearchEl);
        }

        var expandable = sb.params.expandable || $el.hasClass('searchbar-expandable');
        var inline = sb.params.inline || $el.hasClass('searchbar-inline');

        if (typeof sb.params.backdrop === 'undefined') {
          if (!inline) sb.params.backdrop = app.theme !== 'aurora';else sb.params.backdrop = false;
        }

        var $backdropEl;

        if (sb.params.backdrop) {
          if (sb.params.backdropEl) {
            $backdropEl = $(sb.params.backdropEl);
          } else if ($pageEl && $pageEl.length > 0) {
            $backdropEl = $pageEl.find('.searchbar-backdrop');
          } else {
            $backdropEl = $el.siblings('.searchbar-backdrop');
          }

          if ($backdropEl.length === 0) {
            $backdropEl = $('<div class="searchbar-backdrop"></div>');

            if ($pageEl && $pageEl.length) {
              if ($el.parents($pageEl).length > 0 && $navbarEl && $el.parents($navbarEl).length === 0) {
                $backdropEl.insertBefore($el);
              } else {
                $backdropEl.insertBefore($pageEl.find('.page-content').eq(0));
              }
            } else {
              $backdropEl.insertBefore($el);
            }
          }
        }

        var $searchContainer;

        if (sb.params.searchContainer) {
          $searchContainer = $(sb.params.searchContainer);
        }

        var $inputEl;

        if (sb.params.inputEl) {
          $inputEl = $(sb.params.inputEl);
        } else {
          $inputEl = $el.find('input[type="search"]').eq(0);
        }

        var $disableButtonEl;

        if (sb.params.disableButton) {
          if (sb.params.disableButtonEl) {
            $disableButtonEl = $(sb.params.disableButtonEl);
          } else {
            $disableButtonEl = $el.find('.searchbar-disable-button');
          }
        }

        extend$2(sb, {
          app: app,
          view: app.views.get($el.parents('.view')),
          $el: $el,
          el: $el[0],
          $backdropEl: $backdropEl,
          backdropEl: $backdropEl && $backdropEl[0],
          $searchContainer: $searchContainer,
          searchContainer: $searchContainer && $searchContainer[0],
          $inputEl: $inputEl,
          inputEl: $inputEl[0],
          $disableButtonEl: $disableButtonEl,
          disableButtonEl: $disableButtonEl && $disableButtonEl[0],
          disableButtonHasMargin: false,
          $pageEl: $pageEl,
          pageEl: $pageEl && $pageEl[0],
          $navbarEl: $navbarEl,
          navbarEl: $navbarEl && $navbarEl[0],
          $foundEl: $foundEl,
          foundEl: $foundEl && $foundEl[0],
          $notFoundEl: $notFoundEl,
          notFoundEl: $notFoundEl && $notFoundEl[0],
          $hideOnEnableEl: $hideOnEnableEl,
          hideOnEnableEl: $hideOnEnableEl && $hideOnEnableEl[0],
          $hideOnSearchEl: $hideOnSearchEl,
          hideOnSearchEl: $hideOnSearchEl && $hideOnSearchEl[0],
          previousQuery: '',
          query: '',
          isVirtualList: $searchContainer && $searchContainer.hasClass('virtual-list'),
          virtualList: undefined,
          enabled: false,
          expandable: expandable,
          inline: inline
        }); // Events

        function preventSubmit(e) {
          e.preventDefault();
        }

        function onInputFocus(e) {
          sb.enable(e);
          sb.$el.addClass('searchbar-focused');
        }

        function onInputBlur() {
          sb.$el.removeClass('searchbar-focused');

          if (app.theme === 'aurora' && (!$disableButtonEl || !$disableButtonEl.length || !sb.params.disableButton) && !sb.query) {
            sb.disable();
          }
        }

        function onInputChange() {
          var value = sb.$inputEl.val().trim();

          if (sb.$searchContainer && sb.$searchContainer.length > 0 && (sb.params.searchIn || sb.isVirtualList || sb.params.searchIn === sb.params.searchItem) || sb.params.customSearch) {
            sb.search(value, true);
          }
        }

        function onInputClear(e, previousValue) {
          sb.$el.trigger('searchbar:clear', previousValue);
          sb.emit('local::clear searchbarClear', sb, previousValue);
        }

        function disableOnClick(e) {
          sb.disable(e);
        }

        function onPageBeforeOut() {
          if (!sb || sb && !sb.$el) return;

          if (sb.enabled) {
            sb.$el.removeClass('searchbar-enabled');

            if (sb.expandable) {
              sb.$el.parents('.navbar').removeClass('with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition');
            }
          }
        }

        function onPageBeforeIn() {
          if (!sb || sb && !sb.$el) return;

          if (sb.enabled) {
            sb.$el.addClass('searchbar-enabled');

            if (sb.expandable) {
              sb.$el.parents('.navbar').addClass('with-searchbar-expandable-enabled-no-transition');
            }
          }
        }

        sb.attachEvents = function attachEvents() {
          $el.on('submit', preventSubmit);

          if (sb.params.disableButton) {
            sb.$disableButtonEl.on('click', disableOnClick);
          }

          if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
            sb.$backdropEl.on('click', disableOnClick);
          }

          if (sb.expandable && app.theme === 'ios' && sb.view && $navbarEl.length && sb.$pageEl) {
            sb.$pageEl.on('page:beforeout', onPageBeforeOut);
            sb.$pageEl.on('page:beforein', onPageBeforeIn);
          }

          sb.$inputEl.on('focus', onInputFocus);
          sb.$inputEl.on('blur', onInputBlur);
          sb.$inputEl.on(sb.params.inputEvents, onInputChange);
          sb.$inputEl.on('input:clear', onInputClear);
        };

        sb.detachEvents = function detachEvents() {
          $el.off('submit', preventSubmit);

          if (sb.params.disableButton) {
            sb.$disableButtonEl.off('click', disableOnClick);
          }

          if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
            sb.$backdropEl.off('click', disableOnClick);
          }

          if (sb.expandable && app.theme === 'ios' && sb.view && $navbarEl.length && sb.$pageEl) {
            sb.$pageEl.off('page:beforeout', onPageBeforeOut);
            sb.$pageEl.off('page:beforein', onPageBeforeIn);
          }

          sb.$inputEl.off('focus', onInputFocus);
          sb.$inputEl.off('blur', onInputBlur);
          sb.$inputEl.off(sb.params.inputEvents, onInputChange);
          sb.$inputEl.off('input:clear', onInputClear);
        }; // Install Modules


        sb.useModules(); // Init

        sb.init();
        return sb || _assertThisInitialized$8(_this);
      }

      var _proto = Searchbar.prototype;

      _proto.clear = function clear(e) {
        var sb = this;

        if (!sb.query && e && $(e.target).hasClass('searchbar-clear')) {
          sb.disable();
          return sb;
        }

        var previousQuery = sb.value;
        sb.$inputEl.val('').trigger('change').focus();
        sb.$el.trigger('searchbar:clear', previousQuery);
        sb.emit('local::clear searchbarClear', sb, previousQuery);
        return sb;
      };

      _proto.setDisableButtonMargin = function setDisableButtonMargin() {
        var sb = this;
        if (sb.expandable) return;
        var app = sb.app;
        sb.$disableButtonEl.transition(0).show();
        sb.$disableButtonEl.css("margin-" + (app.rtl ? 'left' : 'right'), -sb.disableButtonEl.offsetWidth + "px");
        /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */

        sb._clientLeft = sb.$disableButtonEl[0].clientLeft;
        sb.$disableButtonEl.transition('');
        sb.disableButtonHasMargin = true;
      };

      _proto.enable = function enable(setFocus) {
        var sb = this;
        if (sb.enabled) return sb;
        var app = sb.app;
        var document = getDocument();
        var device = getDevice$1();
        sb.enabled = true;

        function enable() {
          if (sb.$backdropEl && (sb.$searchContainer && sb.$searchContainer.length || sb.params.customSearch) && !sb.$el.hasClass('searchbar-enabled') && !sb.query) {
            sb.backdropShow();
          }

          sb.$el.addClass('searchbar-enabled');

          if (!sb.$disableButtonEl || sb.$disableButtonEl && sb.$disableButtonEl.length === 0) {
            sb.$el.addClass('searchbar-enabled-no-disable-button');
          }

          if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme !== 'md') {
            if (!sb.disableButtonHasMargin) {
              sb.setDisableButtonMargin();
            }

            sb.$disableButtonEl.css("margin-" + (app.rtl ? 'left' : 'right'), '0px');
          }

          if (sb.expandable) {
            var $navbarEl = sb.$el.parents('.navbar');

            if ($navbarEl.hasClass('navbar-large') && sb.$pageEl) {
              var $pageContentEl = sb.$pageEl.find('.page-content');
              var $titleLargeEl = $navbarEl.find('.title-large');
              $pageContentEl.addClass('with-searchbar-expandable-enabled');

              if ($navbarEl.hasClass('navbar-large') && $navbarEl.hasClass('navbar-large-collapsed') && $titleLargeEl.length && $pageContentEl.length) {
                $pageContentEl.transition(0);
                $pageContentEl[0].scrollTop -= $titleLargeEl[0].offsetHeight;
                setTimeout(function () {
                  $pageContentEl.transition('');
                }, 200);
              }
            }

            if (app.theme === 'md' && $navbarEl.length) {
              $navbarEl.addClass('with-searchbar-expandable-enabled');
            } else {
              $navbarEl.addClass('with-searchbar-expandable-enabled');

              if ($navbarEl.hasClass('navbar-large')) {
                $navbarEl.addClass('navbar-large-collapsed');
              }
            }
          }

          if (sb.$hideOnEnableEl) sb.$hideOnEnableEl.addClass('hidden-by-searchbar');
          sb.$el.trigger('searchbar:enable');
          sb.emit('local::enable searchbarEnable', sb);
        }

        var needsFocus = false;

        if (setFocus === true) {
          if (document.activeElement !== sb.inputEl) {
            needsFocus = true;
          }
        }

        var isIos = device.ios && app.theme === 'ios';

        if (isIos) {
          if (sb.expandable) {
            if (needsFocus) sb.$inputEl.focus();
            enable();
          } else {
            if (needsFocus) sb.$inputEl.focus();

            if (setFocus && (setFocus.type === 'focus' || setFocus === true)) {
              nextTick$1(function () {
                enable();
              }, 400);
            } else {
              enable();
            }
          }
        } else {
          if (needsFocus) sb.$inputEl.focus();

          if (app.theme === 'md' && sb.expandable) {
            sb.$el.parents('.page, .view, .navbar-inner, .navbar').scrollLeft(app.rtl ? 100 : 0);
          }

          enable();
        }

        return sb;
      };

      _proto.disable = function disable() {
        var sb = this;
        if (!sb.enabled) return sb;
        var app = sb.app;
        sb.$inputEl.val('').trigger('change');
        sb.$el.removeClass('searchbar-enabled searchbar-focused searchbar-enabled-no-disable-button');

        if (sb.expandable) {
          var $navbarEl = sb.$el.parents('.navbar');
          var $pageContentEl = sb.$pageEl && sb.$pageEl.find('.page-content');

          if ($navbarEl.hasClass('navbar-large') && $pageContentEl.length) {
            var $titleLargeEl = $navbarEl.find('.title-large');
            sb.$el.transitionEnd(function () {
              $pageContentEl.removeClass('with-searchbar-expandable-closing');
            });

            if ($navbarEl.hasClass('navbar-large') && $navbarEl.hasClass('navbar-large-collapsed') && $titleLargeEl.length) {
              var scrollTop = $pageContentEl[0].scrollTop;
              var titleLargeHeight = $titleLargeEl[0].offsetHeight;

              if (scrollTop > titleLargeHeight) {
                $pageContentEl.transition(0);
                $pageContentEl[0].scrollTop = scrollTop + titleLargeHeight;
                setTimeout(function () {
                  $pageContentEl.transition('');
                }, 200);
              }
            }

            $pageContentEl.removeClass('with-searchbar-expandable-enabled').addClass('with-searchbar-expandable-closing');
          }

          if (app.theme === 'md' && $navbarEl.length) {
            $navbarEl.removeClass('with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition').addClass('with-searchbar-expandable-closing');
            sb.$el.transitionEnd(function () {
              $navbarEl.removeClass('with-searchbar-expandable-closing');
            });
          } else {
            $navbarEl.removeClass('with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition').addClass('with-searchbar-expandable-closing');
            sb.$el.transitionEnd(function () {
              $navbarEl.removeClass('with-searchbar-expandable-closing');
            });

            if (sb.$pageEl) {
              sb.$pageEl.find('.page-content').trigger('scroll');
            }
          }
        }

        if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme !== 'md') {
          sb.$disableButtonEl.css("margin-" + (app.rtl ? 'left' : 'right'), -sb.disableButtonEl.offsetWidth + "px");
        }

        if (sb.$backdropEl && (sb.$searchContainer && sb.$searchContainer.length || sb.params.customSearch)) {
          sb.backdropHide();
        }

        sb.enabled = false;
        sb.$inputEl.blur();
        if (sb.$hideOnEnableEl) sb.$hideOnEnableEl.removeClass('hidden-by-searchbar');
        sb.$el.trigger('searchbar:disable');
        sb.emit('local::disable searchbarDisable', sb);
        return sb;
      };

      _proto.toggle = function toggle() {
        var sb = this;
        if (sb.enabled) sb.disable();else sb.enable(true);
        return sb;
      };

      _proto.backdropShow = function backdropShow() {
        var sb = this;

        if (sb.$backdropEl) {
          sb.$backdropEl.addClass('searchbar-backdrop-in');
        }

        return sb;
      };

      _proto.backdropHide = function backdropHide() {
        var sb = this;

        if (sb.$backdropEl) {
          sb.$backdropEl.removeClass('searchbar-backdrop-in');
        }

        return sb;
      };

      _proto.search = function search(query, internal) {
        var sb = this;
        sb.previousQuery = sb.query || '';
        if (query === sb.previousQuery) return sb;

        if (!internal) {
          if (!sb.enabled) {
            sb.enable();
          }

          sb.$inputEl.val(query);
          sb.$inputEl.trigger('input');
        }

        sb.query = query;
        sb.value = query;
        var $searchContainer = sb.$searchContainer,
            $el = sb.$el,
            $foundEl = sb.$foundEl,
            $notFoundEl = sb.$notFoundEl,
            $hideOnSearchEl = sb.$hideOnSearchEl,
            isVirtualList = sb.isVirtualList; // Hide on search element

        if (query.length > 0 && $hideOnSearchEl) {
          $hideOnSearchEl.addClass('hidden-by-searchbar');
        } else if ($hideOnSearchEl) {
          $hideOnSearchEl.removeClass('hidden-by-searchbar');
        } // Add active/inactive classes on overlay


        if ($searchContainer && $searchContainer.length && $el.hasClass('searchbar-enabled') || sb.params.customSearch && $el.hasClass('searchbar-enabled')) {
          if (query.length === 0) {
            sb.backdropShow();
          } else {
            sb.backdropHide();
          }
        }

        if (sb.params.customSearch) {
          $el.trigger('searchbar:search', {
            query: query,
            previousQuery: sb.previousQuery
          });
          sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery);
          return sb;
        }

        var foundItems = [];
        var vlQuery;

        if (isVirtualList) {
          sb.virtualList = $searchContainer[0].f7VirtualList;

          if (query.trim() === '') {
            sb.virtualList.resetFilter();
            if ($notFoundEl) $notFoundEl.hide();
            if ($foundEl) $foundEl.show();
            $el.trigger('searchbar:search', {
              query: query,
              previousQuery: sb.previousQuery
            });
            sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery);
            return sb;
          }

          vlQuery = sb.params.removeDiacritics ? removeDiacritics(query) : query;

          if (sb.virtualList.params.searchAll) {
            foundItems = sb.virtualList.params.searchAll(vlQuery, sb.virtualList.items) || [];
          } else if (sb.virtualList.params.searchByItem) {
            for (var i = 0; i < sb.virtualList.items.length; i += 1) {
              if (sb.virtualList.params.searchByItem(vlQuery, sb.virtualList.params.items[i], i)) {
                foundItems.push(i);
              }
            }
          }
        } else {
          var values;
          if (sb.params.removeDiacritics) values = removeDiacritics(query.trim().toLowerCase()).split(' ');else {
            values = query.trim().toLowerCase().split(' ');
          }
          $searchContainer.find(sb.params.searchItem).removeClass('hidden-by-searchbar').each(function (itemEl) {
            var $itemEl = $(itemEl);
            var compareWithText = [];
            var $searchIn = sb.params.searchIn ? $itemEl.find(sb.params.searchIn) : $itemEl;

            if (sb.params.searchIn === sb.params.searchItem) {
              $searchIn = $itemEl;
            }

            $searchIn.each(function (searchInEl) {
              var itemText = $(searchInEl).text().trim().toLowerCase();
              if (sb.params.removeDiacritics) itemText = removeDiacritics(itemText);
              compareWithText.push(itemText);
            });
            compareWithText = compareWithText.join(' ');
            var wordsMatch = 0;

            for (var _i = 0; _i < values.length; _i += 1) {
              if (compareWithText.indexOf(values[_i]) >= 0) wordsMatch += 1;
            }

            if (wordsMatch !== values.length && !(sb.params.ignore && $itemEl.is(sb.params.ignore))) {
              $itemEl.addClass('hidden-by-searchbar');
            } else {
              foundItems.push($itemEl[0]);
            }
          });

          if (sb.params.hideDividers) {
            $searchContainer.find(sb.params.searchGroupTitle).each(function (titleEl) {
              var $titleEl = $(titleEl);
              var $nextElements = $titleEl.nextAll(sb.params.searchItem);
              var hide = true;

              for (var _i2 = 0; _i2 < $nextElements.length; _i2 += 1) {
                var $nextEl = $nextElements.eq(_i2);
                if ($nextEl.is(sb.params.searchGroupTitle)) break;

                if (!$nextEl.hasClass('hidden-by-searchbar')) {
                  hide = false;
                }
              }

              var ignore = sb.params.ignore && $titleEl.is(sb.params.ignore);
              if (hide && !ignore) $titleEl.addClass('hidden-by-searchbar');else $titleEl.removeClass('hidden-by-searchbar');
            });
          }

          if (sb.params.hideGroups) {
            $searchContainer.find(sb.params.searchGroup).each(function (groupEl) {
              var $groupEl = $(groupEl);
              var ignore = sb.params.ignore && $groupEl.is(sb.params.ignore); // eslint-disable-next-line

              var notHidden = $groupEl.find(sb.params.searchItem).filter(function (el) {
                return !$(el).hasClass('hidden-by-searchbar');
              });

              if (notHidden.length === 0 && !ignore) {
                $groupEl.addClass('hidden-by-searchbar');
              } else {
                $groupEl.removeClass('hidden-by-searchbar');
              }
            });
          }
        }

        if (foundItems.length === 0) {
          if ($notFoundEl) $notFoundEl.show();
          if ($foundEl) $foundEl.hide();
        } else {
          if ($notFoundEl) $notFoundEl.hide();
          if ($foundEl) $foundEl.show();
        }

        if (isVirtualList && sb.virtualList) {
          sb.virtualList.filterItems(foundItems);
        }

        $el.trigger('searchbar:search', {
          query: query,
          previousQuery: sb.previousQuery,
          foundItems: foundItems
        });
        sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery, foundItems);
        return sb;
      };

      _proto.init = function init() {
        var sb = this;
        if (sb.expandable && sb.$el) sb.$el.addClass('searchbar-expandable');
        if (sb.inline && sb.$el) sb.$el.addClass('searchbar-inline');
        sb.attachEvents();
      };

      _proto.destroy = function destroy() {
        var sb = this;
        sb.emit('local::beforeDestroy searchbarBeforeDestroy', sb);
        sb.$el.trigger('searchbar:beforedestroy');
        sb.detachEvents();

        if (sb.$el[0]) {
          sb.$el[0].f7Searchbar = null;
          delete sb.$el[0].f7Searchbar;
        }

        deleteProps$1(sb);
      };

      return Searchbar;
    }(Framework7Class$1);

    var Searchbar$2 = Searchbar$1;

    var Searchbar = {
      name: 'searchbar',
      static: {
        Searchbar: Searchbar$2
      },
      create: function create() {
        var app = this;
        app.searchbar = ConstructorMethods({
          defaultSelector: '.searchbar',
          constructor: Searchbar$2,
          app: app,
          domProp: 'f7Searchbar',
          addMethods: 'clear enable disable toggle search'.split(' ')
        });
      },
      on: {
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.searchbar-init').each(function (searchbarEl) {
            var $searchbarEl = $(searchbarEl);
            app.searchbar.create(extend$2($searchbarEl.dataset(), {
              el: searchbarEl
            }));
          });
        },
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          $(tabEl).find('.searchbar-init').each(function (searchbarEl) {
            if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
              searchbarEl.f7Searchbar.destroy();
            }
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.searchbar-init').each(function (searchbarEl) {
            var $searchbarEl = $(searchbarEl);
            app.searchbar.create(extend$2($searchbarEl.dataset(), {
              el: searchbarEl
            }));
          });

          if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
            page.$navbarEl.find('.searchbar-init').each(function (searchbarEl) {
              var $searchbarEl = $(searchbarEl);
              app.searchbar.create(extend$2($searchbarEl.dataset(), {
                el: searchbarEl
              }));
            });
          }
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          var app = this;
          page.$el.find('.searchbar-init').each(function (searchbarEl) {
            if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
              searchbarEl.f7Searchbar.destroy();
            }
          });

          if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
            page.$navbarEl.find('.searchbar-init').each(function (searchbarEl) {
              if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
                searchbarEl.f7Searchbar.destroy();
              }
            });
          }
        }
      },
      clicks: {
        '.searchbar-clear': function clear($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          var sb = app.searchbar.get(data.searchbar);
          if (sb) sb.clear();
        },
        '.searchbar-enable': function enable($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          var sb = app.searchbar.get(data.searchbar);
          if (sb) sb.enable(true);
        },
        '.searchbar-disable': function disable($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          var sb = app.searchbar.get(data.searchbar);
          if (sb) sb.disable();
        },
        '.searchbar-toggle': function toggle($clickedEl, data) {
          if (data === void 0) {
            data = {};
          }

          var app = this;
          var sb = app.searchbar.get(data.searchbar);
          if (sb) sb.toggle();
        }
      },
      vnode: {
        'searchbar-init': {
          insert: function insert(vnode) {
            var app = this;
            var searchbarEl = vnode.elm;
            var $searchbarEl = $(searchbarEl);
            app.searchbar.create(extend$2($searchbarEl.dataset(), {
              el: searchbarEl
            }));
          },
          destroy: function destroy(vnode) {
            var searchbarEl = vnode.elm;

            if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
              searchbarEl.f7Searchbar.destroy();
            }
          }
        }
      }
    };

    function _extends$2() { _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }

    function _assertThisInitialized$7(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$7(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$7(subClass, superClass); }

    function _setPrototypeOf$7(o, p) { _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$7(o, p); }

    var Messages$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$7(Messages, _Framework7Class);

      function Messages(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params, [app]) || this;

        var m = _assertThisInitialized$7(_this);

        var defaults = {
          autoLayout: true,
          messages: [],
          newMessagesFirst: false,
          scrollMessages: true,
          scrollMessagesOnEdge: true,
          firstMessageRule: undefined,
          lastMessageRule: undefined,
          tailMessageRule: undefined,
          sameNameMessageRule: undefined,
          sameHeaderMessageRule: undefined,
          sameFooterMessageRule: undefined,
          sameAvatarMessageRule: undefined,
          customClassMessageRule: undefined,
          renderMessage: undefined
        }; // Extend defaults with modules params

        m.useModulesParams(defaults);
        m.params = extend$2(defaults, params);
        var $el = $(params.el).eq(0);
        if ($el.length === 0) return m || _assertThisInitialized$7(_this);
        if ($el[0].f7Messages) return $el[0].f7Messages || _assertThisInitialized$7(_this);
        $el[0].f7Messages = m;
        var $pageContentEl = $el.closest('.page-content').eq(0);
        extend$2(m, {
          messages: m.params.messages,
          $el: $el,
          el: $el[0],
          $pageContentEl: $pageContentEl,
          pageContentEl: $pageContentEl[0]
        }); // Install Modules

        m.useModules(); // Init

        m.init();
        return m || _assertThisInitialized$7(_this);
      } // eslint-disable-next-line


      var _proto = Messages.prototype;

      _proto.getMessageData = function getMessageData(messageEl) {
        var $messageEl = $(messageEl);
        var data = {
          name: $messageEl.find('.message-name').html(),
          header: $messageEl.find('.message-header').html(),
          textHeader: $messageEl.find('.message-text-header').html(),
          textFooter: $messageEl.find('.message-text-footer').html(),
          footer: $messageEl.find('.message-footer').html(),
          isTitle: $messageEl.hasClass('messages-title'),
          type: $messageEl.hasClass('message-sent') ? 'sent' : 'received',
          text: $messageEl.find('.message-text').html(),
          image: $messageEl.find('.message-image').html(),
          imageSrc: $messageEl.find('.message-image img').attr('src'),
          typing: $messageEl.hasClass('message-typing')
        };

        if (data.isTitle) {
          data.text = $messageEl.html();
        }

        if (data.text && data.textHeader) {
          data.text = data.text.replace("<div class=\"message-text-header\">" + data.textHeader + "</div>", '');
        }

        if (data.text && data.textFooter) {
          data.text = data.text.replace("<div class=\"message-text-footer\">" + data.textFooter + "</div>", '');
        }

        var avatar = $messageEl.find('.message-avatar').css('background-image');
        if (avatar === 'none' || avatar === '') avatar = undefined;

        if (avatar && typeof avatar === 'string') {
          avatar = avatar.replace('url(', '').replace(')', '').replace(/"/g, '').replace(/'/g, '');
        } else {
          avatar = undefined;
        }

        data.avatar = avatar;
        return data;
      };

      _proto.getMessagesData = function getMessagesData() {
        var m = this;
        var data = [];
        m.$el.find('.message, .messages-title').each(function (messageEl) {
          data.push(m.getMessageData(messageEl));
        });
        return data;
      };

      _proto.renderMessage = function renderMessage(messageToRender) {
        var m = this;
        var message = extend$2({
          type: 'sent',
          attrs: {}
        }, messageToRender);

        if (m.params.renderMessage) {
          return m.params.renderMessage.call(m, message);
        }

        if (message.isTitle) {
          return "<div class=\"messages-title\">" + message.text + "</div>";
        }

        return $jsx$1("div", _extends$2({
          class: "message message-" + message.type + " " + (message.isTyping ? 'message-typing' : '') + " " + (message.cssClass || '')
        }, message.attrs), message.avatar && $jsx$1("div", {
          class: "message-avatar",
          style: "background-image:url(" + message.avatar + ")"
        }), $jsx$1("div", {
          class: "message-content"
        }, message.name && $jsx$1("div", {
          class: "message-name"
        }, message.name), message.header && $jsx$1("div", {
          class: "message-header"
        }, message.header), $jsx$1("div", {
          class: "message-bubble"
        }, message.textHeader && $jsx$1("div", {
          class: "message-text-header"
        }, message.textHeader), message.image && $jsx$1("div", {
          class: "message-image"
        }, message.image), message.imageSrc && !message.image && $jsx$1("div", {
          class: "message-image"
        }, $jsx$1("img", {
          src: message.imageSrc
        })), (message.text || message.isTyping) && $jsx$1("div", {
          class: "message-text"
        }, message.text || '', message.isTyping && $jsx$1("div", {
          class: "message-typing-indicator"
        }, $jsx$1("div", null), $jsx$1("div", null), $jsx$1("div", null))), message.textFooter && $jsx$1("div", {
          class: "message-text-footer"
        }, message.textFooter)), message.footer && $jsx$1("div", {
          class: "message-footer"
        }, message.footer)));
      };

      _proto.renderMessages = function renderMessages(messagesToRender, method) {
        if (messagesToRender === void 0) {
          messagesToRender = this.messages;
        }

        if (method === void 0) {
          method = this.params.newMessagesFirst ? 'prepend' : 'append';
        }

        var m = this;
        var html = messagesToRender.map(function (message) {
          return m.renderMessage(message);
        }).join('');
        m.$el[method](html);
      };

      _proto.isFirstMessage = function isFirstMessage() {
        var _m$params;

        var m = this;
        if (m.params.firstMessageRule) return (_m$params = m.params).firstMessageRule.apply(_m$params, arguments);
        return false;
      };

      _proto.isLastMessage = function isLastMessage() {
        var _m$params2;

        var m = this;
        if (m.params.lastMessageRule) return (_m$params2 = m.params).lastMessageRule.apply(_m$params2, arguments);
        return false;
      };

      _proto.isTailMessage = function isTailMessage() {
        var _m$params3;

        var m = this;
        if (m.params.tailMessageRule) return (_m$params3 = m.params).tailMessageRule.apply(_m$params3, arguments);
        return false;
      };

      _proto.isSameNameMessage = function isSameNameMessage() {
        var _m$params4;

        var m = this;
        if (m.params.sameNameMessageRule) return (_m$params4 = m.params).sameNameMessageRule.apply(_m$params4, arguments);
        return false;
      };

      _proto.isSameHeaderMessage = function isSameHeaderMessage() {
        var _m$params5;

        var m = this;
        if (m.params.sameHeaderMessageRule) return (_m$params5 = m.params).sameHeaderMessageRule.apply(_m$params5, arguments);
        return false;
      };

      _proto.isSameFooterMessage = function isSameFooterMessage() {
        var _m$params6;

        var m = this;
        if (m.params.sameFooterMessageRule) return (_m$params6 = m.params).sameFooterMessageRule.apply(_m$params6, arguments);
        return false;
      };

      _proto.isSameAvatarMessage = function isSameAvatarMessage() {
        var _m$params7;

        var m = this;
        if (m.params.sameAvatarMessageRule) return (_m$params7 = m.params).sameAvatarMessageRule.apply(_m$params7, arguments);
        return false;
      };

      _proto.isCustomClassMessage = function isCustomClassMessage() {
        var _m$params8;

        var m = this;
        if (m.params.customClassMessageRule) return (_m$params8 = m.params).customClassMessageRule.apply(_m$params8, arguments);
        return undefined;
      };

      _proto.layout = function layout() {
        var m = this;
        m.$el.find('.message, .messages-title').each(function (messageEl, index) {
          var $messageEl = $(messageEl);

          if (!m.messages) {
            m.messages = m.getMessagesData();
          }

          var classes = [];
          var message = m.messages[index];
          var previousMessage = m.messages[index - 1];
          var nextMessage = m.messages[index + 1];

          if (m.isFirstMessage(message, previousMessage, nextMessage)) {
            classes.push('message-first');
          }

          if (m.isLastMessage(message, previousMessage, nextMessage)) {
            classes.push('message-last');
          }

          if (m.isTailMessage(message, previousMessage, nextMessage)) {
            classes.push('message-tail');
          }

          if (m.isSameNameMessage(message, previousMessage, nextMessage)) {
            classes.push('message-same-name');
          }

          if (m.isSameHeaderMessage(message, previousMessage, nextMessage)) {
            classes.push('message-same-header');
          }

          if (m.isSameFooterMessage(message, previousMessage, nextMessage)) {
            classes.push('message-same-footer');
          }

          if (m.isSameAvatarMessage(message, previousMessage, nextMessage)) {
            classes.push('message-same-avatar');
          }

          var customMessageClasses = m.isCustomClassMessage(message, previousMessage, nextMessage);

          if (customMessageClasses && customMessageClasses.length) {
            if (typeof customMessageClasses === 'string') {
              customMessageClasses = customMessageClasses.split(' ');
            }

            customMessageClasses.forEach(function (customClass) {
              classes.push(customClass);
            });
          }

          $messageEl.removeClass('message-first message-last message-tail message-same-name message-same-header message-same-footer message-same-avatar');
          classes.forEach(function (className) {
            $messageEl.addClass(className);
          });
        });
      };

      _proto.clear = function clear() {
        var m = this;
        m.messages = [];
        m.$el.html('');
      };

      _proto.removeMessage = function removeMessage(messageToRemove, layout) {
        if (layout === void 0) {
          layout = true;
        }

        var m = this; // Index or El

        var index;
        var $el;

        if (typeof messageToRemove === 'number') {
          index = messageToRemove;
          $el = m.$el.find('.message, .messages-title').eq(index);
        } else if (m.messages && m.messages.indexOf(messageToRemove) >= 0) {
          index = m.messages.indexOf(messageToRemove);
          $el = m.$el.children().eq(index);
        } else {
          $el = $(messageToRemove);
          index = $el.index();
        }

        if ($el.length === 0) {
          return m;
        }

        $el.remove();
        m.messages.splice(index, 1);
        if (m.params.autoLayout && layout) m.layout();
        return m;
      };

      _proto.removeMessages = function removeMessages(messagesToRemove, layout) {
        if (layout === void 0) {
          layout = true;
        }

        var m = this;

        if (Array.isArray(messagesToRemove)) {
          var messagesToRemoveEls = [];
          messagesToRemove.forEach(function (messageToRemoveIndex) {
            messagesToRemoveEls.push(m.$el.find('.message, .messages-title').eq(messageToRemoveIndex));
          });
          messagesToRemoveEls.forEach(function (messageToRemove) {
            m.removeMessage(messageToRemove, false);
          });
        } else {
          $(messagesToRemove).each(function (messageToRemove) {
            m.removeMessage(messageToRemove, false);
          });
        }

        if (m.params.autoLayout && layout) m.layout();
        return m;
      };

      _proto.addMessage = function addMessage() {
        var m = this;
        var messageToAdd;
        var animate;
        var method;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (typeof args[1] === 'boolean') {
          messageToAdd = args[0];
          animate = args[1];
          method = args[2];
        } else {
          messageToAdd = args[0];
          method = args[1];
          animate = args[2];
        }

        if (typeof animate === 'undefined') {
          animate = true;
        }

        if (typeof method === 'undefined') {
          method = m.params.newMessagesFirst ? 'prepend' : 'append';
        }

        return m.addMessages([messageToAdd], animate, method);
      };

      _proto.setScrollData = function setScrollData() {
        var m = this; // Define scroll positions before new messages added

        var scrollHeightBefore = m.pageContentEl.scrollHeight;
        var heightBefore = m.pageContentEl.offsetHeight;
        var scrollBefore = m.pageContentEl.scrollTop;
        m.scrollData = {
          scrollHeightBefore: scrollHeightBefore,
          heightBefore: heightBefore,
          scrollBefore: scrollBefore
        };
        return {
          scrollHeightBefore: scrollHeightBefore,
          heightBefore: heightBefore,
          scrollBefore: scrollBefore
        };
      };

      _proto.addMessages = function addMessages() {
        var m = this;
        var messagesToAdd;
        var animate;
        var method;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        if (typeof args[1] === 'boolean') {
          messagesToAdd = args[0];
          animate = args[1];
          method = args[2];
        } else {
          messagesToAdd = args[0];
          method = args[1];
          animate = args[2];
        }

        if (typeof animate === 'undefined') {
          animate = true;
        }

        if (typeof method === 'undefined') {
          method = m.params.newMessagesFirst ? 'prepend' : 'append';
        }

        var _m$setScrollData = m.setScrollData(),
            scrollHeightBefore = _m$setScrollData.scrollHeightBefore,
            scrollBefore = _m$setScrollData.scrollBefore; // Add message to DOM and data


        var messagesHTML = '';
        var typingMessage = m.messages.filter(function (el) {
          return el.isTyping;
        })[0];
        messagesToAdd.forEach(function (messageToAdd) {
          if (typingMessage) {
            if (method === 'append') {
              m.messages.splice(m.messages.indexOf(typingMessage), 0, messageToAdd);
            } else {
              m.messages.splice(m.messages.indexOf(typingMessage) + 1, 0, messageToAdd);
            }
          } else {
            m.messages[method === 'append' ? 'push' : 'unshift'](messageToAdd);
          }

          messagesHTML += m.renderMessage(messageToAdd);
        });
        var $messagesEls = $(messagesHTML);

        if (animate) {
          if (method === 'append' && !m.params.newMessagesFirst) {
            $messagesEls.addClass('message-appear-from-bottom');
          }

          if (method === 'prepend' && m.params.newMessagesFirst) {
            $messagesEls.addClass('message-appear-from-top');
          }
        }

        if (typingMessage) {
          if (method === 'append') {
            $messagesEls.insertBefore(m.$el.find('.message-typing'));
          } else {
            $messagesEls.insertAfter(m.$el.find('.message-typing'));
          }
        } else {
          m.$el[method]($messagesEls);
        } // Layout


        if (m.params.autoLayout) m.layout();

        if (method === 'prepend' && !typingMessage) {
          m.pageContentEl.scrollTop = scrollBefore + (m.pageContentEl.scrollHeight - scrollHeightBefore);
        }

        if (m.params.scrollMessages && (method === 'append' && !m.params.newMessagesFirst || method === 'prepend' && m.params.newMessagesFirst && !typingMessage)) {
          m.scrollWithEdgeCheck(animate);
        }

        return m;
      };

      _proto.showTyping = function showTyping(message) {
        if (message === void 0) {
          message = {};
        }

        var m = this;
        var typingMessage = m.messages.filter(function (el) {
          return el.isTyping;
        })[0];

        if (typingMessage) {
          m.removeMessage(m.messages.indexOf(typingMessage));
        }

        m.addMessage(extend$2({
          type: 'received',
          isTyping: true
        }, message));
        return m;
      };

      _proto.hideTyping = function hideTyping() {
        var m = this;
        var typingMessageIndex;
        var typingFound;
        m.messages.forEach(function (message, index) {
          if (message.isTyping) typingMessageIndex = index;
        });

        if (typeof typingMessageIndex !== 'undefined') {
          if (m.$el.find('.message').eq(typingMessageIndex).hasClass('message-typing')) {
            typingFound = true;
            m.removeMessage(typingMessageIndex);
          }
        }

        if (!typingFound) {
          var $typingMessageEl = m.$el.find('.message-typing');

          if ($typingMessageEl.length) {
            m.removeMessage($typingMessageEl);
          }
        }

        return m;
      };

      _proto.scrollWithEdgeCheck = function scrollWithEdgeCheck(animate) {
        var m = this;
        var _m$scrollData = m.scrollData,
            scrollBefore = _m$scrollData.scrollBefore,
            scrollHeightBefore = _m$scrollData.scrollHeightBefore,
            heightBefore = _m$scrollData.heightBefore;

        if (m.params.scrollMessagesOnEdge) {
          var onEdge = false;

          if (m.params.newMessagesFirst && scrollBefore === 0) {
            onEdge = true;
          }

          if (!m.params.newMessagesFirst && scrollBefore - (scrollHeightBefore - heightBefore) >= -10) {
            onEdge = true;
          }

          if (onEdge) m.scroll(animate ? undefined : 0);
        } else {
          m.scroll(animate ? undefined : 0);
        }
      };

      _proto.scroll = function scroll(duration, scrollTop) {
        if (duration === void 0) {
          duration = 300;
        }

        var m = this;
        var currentScroll = m.pageContentEl.scrollTop;
        var newScrollTop;
        if (typeof scrollTop !== 'undefined') newScrollTop = scrollTop;else {
          newScrollTop = m.params.newMessagesFirst ? 0 : m.pageContentEl.scrollHeight - m.pageContentEl.offsetHeight;
          if (newScrollTop === currentScroll) return m;
        }
        m.$pageContentEl.scrollTop(newScrollTop, duration);
        return m;
      };

      _proto.init = function init() {
        var m = this;

        if (!m.messages || m.messages.length === 0) {
          m.messages = m.getMessagesData();
        }

        if (m.params.messages && m.params.messages.length) {
          m.renderMessages();
        }

        if (m.params.autoLayout) m.layout();
        if (m.params.scrollMessages) m.scroll(0);
      };

      _proto.destroy = function destroy() {
        var m = this;
        m.emit('local::beforeDestroy messagesBeforeDestroy', m);
        m.$el.trigger('messages:beforedestroy');

        if (m.$el[0]) {
          m.$el[0].f7Messages = null;
          delete m.$el[0].f7Messages;
        }

        deleteProps$1(m);
      };

      return Messages;
    }(Framework7Class$1);

    var Messages$2 = Messages$1;

    var Messages = {
      name: 'messages',
      static: {
        Messages: Messages$2
      },
      create: function create() {
        var app = this;
        app.messages = ConstructorMethods({
          defaultSelector: '.messages',
          constructor: Messages$2,
          app: app,
          domProp: 'f7Messages',
          addMethods: 'renderMessages layout scroll clear removeMessage removeMessages addMessage addMessages'.split(' ')
        });
      },
      on: {
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          var app = this;
          $(tabEl).find('.messages-init').each(function (messagesEl) {
            app.messages.destroy(messagesEl);
          });
        },
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.messages-init').each(function (messagesEl) {
            app.messages.create({
              el: messagesEl
            });
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          var app = this;
          page.$el.find('.messages-init').each(function (messagesEl) {
            app.messages.destroy(messagesEl);
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.messages-init').each(function (messagesEl) {
            app.messages.create({
              el: messagesEl
            });
          });
        }
      },
      vnode: {
        'messages-init': {
          insert: function insert(vnode) {
            var app = this;
            var messagesEl = vnode.elm;
            app.messages.create({
              el: messagesEl
            });
          },
          destroy: function destroy(vnode) {
            var app = this;
            var messagesEl = vnode.elm;
            app.messages.destroy(messagesEl);
          }
        }
      }
    };

    function _assertThisInitialized$6(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$6(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$6(subClass, superClass); }

    function _setPrototypeOf$6(o, p) { _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$6(o, p); }

    var Messagebar$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$6(Messagebar, _Framework7Class);

      function Messagebar(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params, [app]) || this;

        var messagebar = _assertThisInitialized$6(_this);

        var defaults = {
          top: false,
          topOffset: 0,
          bottomOffset: 0,
          attachments: [],
          renderAttachments: undefined,
          renderAttachment: undefined,
          maxHeight: null,
          resizePage: true
        }; // Extend defaults with modules params

        messagebar.useModulesParams(defaults);
        messagebar.params = extend$2(defaults, params); // El

        var $el = $(messagebar.params.el);
        if ($el.length === 0) return messagebar || _assertThisInitialized$6(_this);
        if ($el[0].f7Messagebar) return $el[0].f7Messagebar || _assertThisInitialized$6(_this);
        $el[0].f7Messagebar = messagebar; // Page and PageContent

        var $pageEl = $el.parents('.page').eq(0);
        var $pageContentEl = $pageEl.find('.page-content').eq(0); // Area

        var $areaEl = $el.find('.messagebar-area'); // Textarea

        var $textareaEl;

        if (messagebar.params.textareaEl) {
          $textareaEl = $(messagebar.params.textareaEl);
        } else {
          $textareaEl = $el.find('textarea');
        } // Attachments & Library


        var $attachmentsEl = $el.find('.messagebar-attachments');
        var $sheetEl = $el.find('.messagebar-sheet');

        if (messagebar.params.top) {
          $el.addClass('messagebar-top');
        }

        extend$2(messagebar, {
          $el: $el,
          el: $el[0],
          $areaEl: $areaEl,
          areaEl: $areaEl[0],
          $textareaEl: $textareaEl,
          textareaEl: $textareaEl[0],
          $attachmentsEl: $attachmentsEl,
          attachmentsEl: $attachmentsEl[0],
          attachmentsVisible: $attachmentsEl.hasClass('messagebar-attachments-visible'),
          $sheetEl: $sheetEl,
          sheetEl: $sheetEl[0],
          sheetVisible: $sheetEl.hasClass('messagebar-sheet-visible'),
          $pageEl: $pageEl,
          pageEl: $pageEl[0],
          $pageContentEl: $pageContentEl,
          pageContentEl: $pageContentEl,
          top: $el.hasClass('messagebar-top') || messagebar.params.top,
          attachments: []
        }); // Events

        function onAppResize() {
          if (messagebar.params.resizePage) {
            messagebar.resizePage();
          }
        }

        function onSubmit(e) {
          e.preventDefault();
        }

        function onAttachmentClick(e) {
          var index = $(this).index();

          if ($(e.target).closest('.messagebar-attachment-delete').length) {
            $(this).trigger('messagebar:attachmentdelete', index);
            messagebar.emit('local::attachmentDelete messagebarAttachmentDelete', messagebar, this, index);
          } else {
            $(this).trigger('messagebar:attachmentclick', index);
            messagebar.emit('local::attachmentClick messagebarAttachmentClick', messagebar, this, index);
          }
        }

        function onTextareaChange() {
          messagebar.checkEmptyState();
          messagebar.$el.trigger('messagebar:change');
          messagebar.emit('local::change messagebarChange', messagebar);
        }

        function onTextareaFocus() {
          messagebar.sheetHide();
          messagebar.$el.addClass('messagebar-focused');
          messagebar.$el.trigger('messagebar:focus');
          messagebar.emit('local::focus messagebarFocus', messagebar);
        }

        function onTextareaBlur() {
          messagebar.$el.removeClass('messagebar-focused');
          messagebar.$el.trigger('messagebar:blur');
          messagebar.emit('local::blur messagebarBlur', messagebar);
        }

        messagebar.attachEvents = function attachEvents() {
          $el.on('textarea:resize', onAppResize);
          $el.on('submit', onSubmit);
          $el.on('click', '.messagebar-attachment', onAttachmentClick);
          $textareaEl.on('change input', onTextareaChange);
          $textareaEl.on('focus', onTextareaFocus);
          $textareaEl.on('blur', onTextareaBlur);
          app.on('resize', onAppResize);
        };

        messagebar.detachEvents = function detachEvents() {
          $el.off('textarea:resize', onAppResize);
          $el.off('submit', onSubmit);
          $el.off('click', '.messagebar-attachment', onAttachmentClick);
          $textareaEl.off('change input', onTextareaChange);
          $textareaEl.off('focus', onTextareaFocus);
          $textareaEl.off('blur', onTextareaBlur);
          app.off('resize', onAppResize);
        }; // Install Modules


        messagebar.useModules(); // Init

        messagebar.init();
        return messagebar || _assertThisInitialized$6(_this);
      }

      var _proto = Messagebar.prototype;

      _proto.focus = function focus() {
        var messagebar = this;
        messagebar.$textareaEl.focus();
        return messagebar;
      };

      _proto.blur = function blur() {
        var messagebar = this;
        messagebar.$textareaEl.blur();
        return messagebar;
      };

      _proto.clear = function clear() {
        var messagebar = this;
        messagebar.$textareaEl.val('').trigger('change');
        return messagebar;
      };

      _proto.getValue = function getValue() {
        var messagebar = this;
        return messagebar.$textareaEl.val().trim();
      };

      _proto.setValue = function setValue(value) {
        var messagebar = this;
        messagebar.$textareaEl.val(value).trigger('change');
        return messagebar;
      };

      _proto.setPlaceholder = function setPlaceholder(placeholder) {
        var messagebar = this;
        messagebar.$textareaEl.attr('placeholder', placeholder);
        return messagebar;
      };

      _proto.resizePage = function resizePage() {
        var messagebar = this;
        var params = messagebar.params,
            $el = messagebar.$el,
            top = messagebar.top,
            $pageEl = messagebar.$pageEl,
            $pageContentEl = messagebar.$pageContentEl,
            $areaEl = messagebar.$areaEl,
            $textareaEl = messagebar.$textareaEl,
            $sheetEl = messagebar.$sheetEl,
            $attachmentsEl = messagebar.$attachmentsEl;
        var elHeight = $el[0].offsetHeight;
        var maxHeight = params.maxHeight;

        if (top) ; else {
          var currentPaddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
          var requiredPaddingBottom = elHeight + params.bottomOffset;

          if (requiredPaddingBottom !== currentPaddingBottom && $pageContentEl.length) {
            var currentPaddingTop = parseInt($pageContentEl.css('padding-top'), 10);
            var pageScrollHeight = $pageContentEl[0].scrollHeight;
            var pageOffsetHeight = $pageContentEl[0].offsetHeight;
            var pageScrollTop = $pageContentEl[0].scrollTop;
            var scrollOnBottom = pageScrollTop === pageScrollHeight - pageOffsetHeight;

            if (!maxHeight) {
              maxHeight = $pageEl[0].offsetHeight - currentPaddingTop - $sheetEl.outerHeight() - $attachmentsEl.outerHeight() - parseInt($areaEl.css('margin-top'), 10) - parseInt($areaEl.css('margin-bottom'), 10);
            }

            $textareaEl.css('max-height', maxHeight + "px");
            $pageContentEl.css('padding-bottom', requiredPaddingBottom + "px");

            if (scrollOnBottom) {
              $pageContentEl.scrollTop($pageContentEl[0].scrollHeight - pageOffsetHeight);
            }

            $el.trigger('messagebar:resizepage');
            messagebar.emit('local::resizePage messagebarResizePage', messagebar);
          }
        }
      };

      _proto.checkEmptyState = function checkEmptyState() {
        var messagebar = this;
        var $el = messagebar.$el,
            $textareaEl = messagebar.$textareaEl;
        var value = $textareaEl.val().trim();

        if (value && value.length) {
          $el.addClass('messagebar-with-value');
        } else {
          $el.removeClass('messagebar-with-value');
        }
      };

      _proto.attachmentsCreate = function attachmentsCreate(innerHTML) {
        if (innerHTML === void 0) {
          innerHTML = '';
        }

        var messagebar = this;
        var $attachmentsEl = $("<div class=\"messagebar-attachments\">" + innerHTML + "</div>");
        $attachmentsEl.insertBefore(messagebar.$textareaEl);
        extend$2(messagebar, {
          $attachmentsEl: $attachmentsEl,
          attachmentsEl: $attachmentsEl[0]
        });
        return messagebar;
      };

      _proto.attachmentsShow = function attachmentsShow(innerHTML) {
        if (innerHTML === void 0) {
          innerHTML = '';
        }

        var messagebar = this;
        messagebar.$attachmentsEl = messagebar.$el.find('.messagebar-attachments');

        if (messagebar.$attachmentsEl.length === 0) {
          messagebar.attachmentsCreate(innerHTML);
        }

        messagebar.$el.addClass('messagebar-attachments-visible');
        messagebar.attachmentsVisible = true;

        if (messagebar.params.resizePage) {
          messagebar.resizePage();
        }

        return messagebar;
      };

      _proto.attachmentsHide = function attachmentsHide() {
        var messagebar = this;
        messagebar.$el.removeClass('messagebar-attachments-visible');
        messagebar.attachmentsVisible = false;

        if (messagebar.params.resizePage) {
          messagebar.resizePage();
        }

        return messagebar;
      };

      _proto.attachmentsToggle = function attachmentsToggle() {
        var messagebar = this;

        if (messagebar.attachmentsVisible) {
          messagebar.attachmentsHide();
        } else {
          messagebar.attachmentsShow();
        }

        return messagebar;
      };

      _proto.renderAttachment = function renderAttachment(attachment) {
        var messagebar = this;

        if (messagebar.params.renderAttachment) {
          return messagebar.params.renderAttachment.call(messagebar, attachment);
        }

        return "\n      <div class=\"messagebar-attachment\">\n        <img src=\"" + attachment + "\">\n        <span class=\"messagebar-attachment-delete\"></span>\n      </div>\n    ";
      };

      _proto.renderAttachments = function renderAttachments() {
        var messagebar = this;
        var html;

        if (messagebar.params.renderAttachments) {
          html = messagebar.params.renderAttachments.call(messagebar, messagebar.attachments);
        } else {
          html = "" + messagebar.attachments.map(function (attachment) {
            return messagebar.renderAttachment(attachment);
          }).join('');
        }

        if (messagebar.$attachmentsEl.length === 0) {
          messagebar.attachmentsCreate(html);
        } else {
          messagebar.$attachmentsEl.html(html);
        }
      };

      _proto.sheetCreate = function sheetCreate(innerHTML) {
        if (innerHTML === void 0) {
          innerHTML = '';
        }

        var messagebar = this;
        var $sheetEl = $("<div class=\"messagebar-sheet\">" + innerHTML + "</div>");
        messagebar.$el.append($sheetEl);
        extend$2(messagebar, {
          $sheetEl: $sheetEl,
          sheetEl: $sheetEl[0]
        });
        return messagebar;
      };

      _proto.sheetShow = function sheetShow(innerHTML) {
        if (innerHTML === void 0) {
          innerHTML = '';
        }

        var messagebar = this;
        messagebar.$sheetEl = messagebar.$el.find('.messagebar-sheet');

        if (messagebar.$sheetEl.length === 0) {
          messagebar.sheetCreate(innerHTML);
        }

        messagebar.$el.addClass('messagebar-sheet-visible');
        messagebar.sheetVisible = true;

        if (messagebar.params.resizePage) {
          messagebar.resizePage();
        }

        return messagebar;
      };

      _proto.sheetHide = function sheetHide() {
        var messagebar = this;
        messagebar.$el.removeClass('messagebar-sheet-visible');
        messagebar.sheetVisible = false;

        if (messagebar.params.resizePage) {
          messagebar.resizePage();
        }

        return messagebar;
      };

      _proto.sheetToggle = function sheetToggle() {
        var messagebar = this;

        if (messagebar.sheetVisible) {
          messagebar.sheetHide();
        } else {
          messagebar.sheetShow();
        }

        return messagebar;
      };

      _proto.init = function init() {
        var messagebar = this;
        messagebar.attachEvents();
        messagebar.checkEmptyState();
        return messagebar;
      };

      _proto.destroy = function destroy() {
        var messagebar = this;
        messagebar.emit('local::beforeDestroy messagebarBeforeDestroy', messagebar);
        messagebar.$el.trigger('messagebar:beforedestroy');
        messagebar.detachEvents();

        if (messagebar.$el[0]) {
          messagebar.$el[0].f7Messagebar = null;
          delete messagebar.$el[0].f7Messagebar;
        }

        deleteProps$1(messagebar);
      };

      return Messagebar;
    }(Framework7Class$1);

    var Messagebar$2 = Messagebar$1;

    var Messagebar = {
      name: 'messagebar',
      static: {
        Messagebar: Messagebar$2
      },
      create: function create() {
        var app = this;
        app.messagebar = ConstructorMethods({
          defaultSelector: '.messagebar',
          constructor: Messagebar$2,
          app: app,
          domProp: 'f7Messagebar',
          addMethods: 'clear getValue setValue setPlaceholder resizePage focus blur attachmentsCreate attachmentsShow attachmentsHide attachmentsToggle renderAttachments sheetCreate sheetShow sheetHide sheetToggle'.split(' ')
        });
      },
      on: {
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          var app = this;
          $(tabEl).find('.messagebar-init').each(function (messagebarEl) {
            app.messagebar.destroy(messagebarEl);
          });
        },
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.messagebar-init').each(function (messagebarEl) {
            app.messagebar.create(extend$2({
              el: messagebarEl
            }, $(messagebarEl).dataset()));
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          var app = this;
          page.$el.find('.messagebar-init').each(function (messagebarEl) {
            app.messagebar.destroy(messagebarEl);
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.messagebar-init').each(function (messagebarEl) {
            app.messagebar.create(extend$2({
              el: messagebarEl
            }, $(messagebarEl).dataset()));
          });
        }
      },
      vnode: {
        'messagebar-init': {
          insert: function insert(vnode) {
            var app = this;
            var messagebarEl = vnode.elm;
            app.messagebar.create(extend$2({
              el: messagebarEl
            }, $(messagebarEl).dataset()));
          },
          destroy: function destroy(vnode) {
            var app = this;
            var messagebarEl = vnode.elm;
            app.messagebar.destroy(messagebarEl);
          }
        }
      }
    };

    var Methods = {
      addClass: addClass,
      removeClass: removeClass,
      hasClass: hasClass,
      toggleClass: toggleClass,
      attr: attr$1,
      removeAttr: removeAttr,
      transform: transform,
      transition: transition$1,
      on: on,
      off: off,
      trigger: trigger,
      transitionEnd: transitionEnd$1,
      outerWidth: outerWidth,
      outerHeight: outerHeight,
      styles: styles,
      offset: offset,
      css: css,
      each: each,
      html: html,
      text: text$2,
      is: is,
      index: index,
      eq: eq,
      append: append$1,
      prepend: prepend,
      next: next,
      nextAll: nextAll,
      prev: prev,
      prevAll: prevAll,
      parent: parent,
      parents: parents,
      closest: closest,
      find: find,
      children: children$1,
      filter: filter,
      remove: remove
    };
    Object.keys(Methods).forEach(function (methodName) {
      Object.defineProperty($$1.fn, methodName, {
        value: Methods[methodName],
        writable: true
      });
    });

    function deleteProps(obj) {
      var object = obj;
      Object.keys(object).forEach(function (key) {
        try {
          object[key] = null;
        } catch (e) {// no getter for object
        }

        try {
          delete object[key];
        } catch (e) {// something got wrong
        }
      });
    }

    function nextTick(callback, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      return setTimeout(callback, delay);
    }

    function now$1() {
      return Date.now();
    }

    function getComputedStyle$1(el) {
      var window = getWindow();
      var style;

      if (window.getComputedStyle) {
        style = window.getComputedStyle(el, null);
      }

      if (!style && el.currentStyle) {
        style = el.currentStyle;
      }

      if (!style) {
        style = el.style;
      }

      return style;
    }

    function getTranslate(el, axis) {
      if (axis === void 0) {
        axis = 'x';
      }

      var window = getWindow();
      var matrix;
      var curTransform;
      var transformMatrix;
      var curStyle = getComputedStyle$1(el);

      if (window.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;

        if (curTransform.split(',').length > 6) {
          curTransform = curTransform.split(', ').map(function (a) {
            return a.replace(',', '.');
          }).join(', ');
        } // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case


        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }

      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
          else curTransform = parseFloat(matrix[4]);
      }

      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
          else curTransform = parseFloat(matrix[5]);
      }

      return curTransform || 0;
    }

    function isObject$1(o) {
      return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
    }

    function isNode(node) {
      // eslint-disable-next-line
      if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
        return node instanceof HTMLElement;
      }

      return node && (node.nodeType === 1 || node.nodeType === 11);
    }

    function extend$1() {
      var to = Object(arguments.length <= 0 ? undefined : arguments[0]);
      var noExtend = ['__proto__', 'constructor', 'prototype'];

      for (var i = 1; i < arguments.length; i += 1) {
        var nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];

        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
          var keysArray = Object.keys(Object(nextSource)).filter(function (key) {
            return noExtend.indexOf(key) < 0;
          });

          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              if (isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend$1(to[nextKey], nextSource[nextKey]);
                }
              } else if (!isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
                to[nextKey] = {};

                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend$1(to[nextKey], nextSource[nextKey]);
                }
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }

      return to;
    }

    function bindModuleMethods(instance, obj) {
      Object.keys(obj).forEach(function (key) {
        if (isObject$1(obj[key])) {
          Object.keys(obj[key]).forEach(function (subKey) {
            if (typeof obj[key][subKey] === 'function') {
              obj[key][subKey] = obj[key][subKey].bind(instance);
            }
          });
        }

        instance[key] = obj[key];
      });
    }

    var support;

    function calcSupport() {
      var window = getWindow();
      var document = getDocument();
      return {
        touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
        pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,
        observer: function checkObserver() {
          return 'MutationObserver' in window || 'WebkitMutationObserver' in window;
        }(),
        passiveListener: function checkPassiveListener() {
          var supportsPassive = false;

          try {
            var opts = Object.defineProperty({}, 'passive', {
              // eslint-disable-next-line
              get: function get() {
                supportsPassive = true;
              }
            });
            window.addEventListener('testPassiveListener', null, opts);
          } catch (e) {// No support
          }

          return supportsPassive;
        }(),
        gestures: function checkGestures() {
          return 'ongesturestart' in window;
        }()
      };
    }

    function getSupport() {
      if (!support) {
        support = calcSupport();
      }

      return support;
    }

    var device;

    function calcDevice(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          userAgent = _ref.userAgent;

      var support = getSupport();
      var window = getWindow();
      var platform = window.navigator.platform;
      var ua = userAgent || window.navigator.userAgent;
      var device = {
        ios: false,
        android: false
      };
      var screenWidth = window.screen.width;
      var screenHeight = window.screen.height;
      var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

      var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
      var windows = platform === 'Win32';
      var macos = platform === 'MacIntel'; // iPadOs 13 fix

      var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

      if (!ipad && macos && support.touch && iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [0, 1, '13_0_0'];
        macos = false;
      } // Android


      if (android && !windows) {
        device.os = 'android';
        device.android = true;
      }

      if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
      } // Export object


      return device;
    }

    function getDevice(overrides) {
      if (overrides === void 0) {
        overrides = {};
      }

      if (!device) {
        device = calcDevice(overrides);
      }

      return device;
    }

    var browser;

    function calcBrowser() {
      var window = getWindow();

      function isSafari() {
        var ua = window.navigator.userAgent.toLowerCase();
        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
      }

      return {
        isEdge: !!window.navigator.userAgent.match(/Edge/g),
        isSafari: isSafari(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
      };
    }

    function getBrowser() {
      if (!browser) {
        browser = calcBrowser();
      }

      return browser;
    }

    var supportsResizeObserver = function supportsResizeObserver() {
      var window = getWindow();
      return typeof window.ResizeObserver !== 'undefined';
    };

    var Resize = {
      name: 'resize',
      create: function create() {
        var swiper = this;
        extend$1(swiper, {
          resize: {
            observer: null,
            createObserver: function createObserver() {
              if (!swiper || swiper.destroyed || !swiper.initialized) return;
              swiper.resize.observer = new ResizeObserver(function (entries) {
                var width = swiper.width,
                    height = swiper.height;
                var newWidth = width;
                var newHeight = height;
                entries.forEach(function (_ref) {
                  var contentBoxSize = _ref.contentBoxSize,
                      contentRect = _ref.contentRect,
                      target = _ref.target;
                  if (target && target !== swiper.el) return;
                  newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                  newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                });

                if (newWidth !== width || newHeight !== height) {
                  swiper.resize.resizeHandler();
                }
              });
              swiper.resize.observer.observe(swiper.el);
            },
            removeObserver: function removeObserver() {
              if (swiper.resize.observer && swiper.resize.observer.unobserve && swiper.el) {
                swiper.resize.observer.unobserve(swiper.el);
                swiper.resize.observer = null;
              }
            },
            resizeHandler: function resizeHandler() {
              if (!swiper || swiper.destroyed || !swiper.initialized) return;
              swiper.emit('beforeResize');
              swiper.emit('resize');
            },
            orientationChangeHandler: function orientationChangeHandler() {
              if (!swiper || swiper.destroyed || !swiper.initialized) return;
              swiper.emit('orientationchange');
            }
          }
        });
      },
      on: {
        init: function init(swiper) {
          var window = getWindow();

          if (swiper.params.resizeObserver && supportsResizeObserver()) {
            swiper.resize.createObserver();
            return;
          } // Emit resize


          window.addEventListener('resize', swiper.resize.resizeHandler); // Emit orientationchange

          window.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
        },
        destroy: function destroy(swiper) {
          var window = getWindow();
          swiper.resize.removeObserver();
          window.removeEventListener('resize', swiper.resize.resizeHandler);
          window.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
        }
      }
    };

    function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }
    var Observer = {
      attach: function attach(target, options) {
        if (options === void 0) {
          options = {};
        }

        var window = getWindow();
        var swiper = this;
        var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
        var observer = new ObserverFunc(function (mutations) {
          // The observerUpdate event should only be triggered
          // once despite the number of mutations.  Additional
          // triggers are redundant and are very costly
          if (mutations.length === 1) {
            swiper.emit('observerUpdate', mutations[0]);
            return;
          }

          var observerUpdate = function observerUpdate() {
            swiper.emit('observerUpdate', mutations[0]);
          };

          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(observerUpdate);
          } else {
            window.setTimeout(observerUpdate, 0);
          }
        });
        observer.observe(target, {
          attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
          childList: typeof options.childList === 'undefined' ? true : options.childList,
          characterData: typeof options.characterData === 'undefined' ? true : options.characterData
        });
        swiper.observer.observers.push(observer);
      },
      init: function init() {
        var swiper = this;
        if (!swiper.support.observer || !swiper.params.observer) return;

        if (swiper.params.observeParents) {
          var containerParents = swiper.$el.parents();

          for (var i = 0; i < containerParents.length; i += 1) {
            swiper.observer.attach(containerParents[i]);
          }
        } // Observe container


        swiper.observer.attach(swiper.$el[0], {
          childList: swiper.params.observeSlideChildren
        }); // Observe wrapper

        swiper.observer.attach(swiper.$wrapperEl[0], {
          attributes: false
        });
      },
      destroy: function destroy() {
        var swiper = this;
        swiper.observer.observers.forEach(function (observer) {
          observer.disconnect();
        });
        swiper.observer.observers = [];
      }
    };
    var Observer$1 = {
      name: 'observer',
      params: {
        observer: false,
        observeParents: false,
        observeSlideChildren: false
      },
      create: function create() {
        var swiper = this;
        bindModuleMethods(swiper, {
          observer: _extends$1({}, Observer, {
            observers: []
          })
        });
      },
      on: {
        init: function init(swiper) {
          swiper.observer.init();
        },
        destroy: function destroy(swiper) {
          swiper.observer.destroy();
        }
      }
    };

    var modular = {
      useParams: function useParams(instanceParams) {
        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function (moduleName) {
          var module = instance.modules[moduleName]; // Extend params

          if (module.params) {
            extend$1(instanceParams, module.params);
          }
        });
      },
      useModules: function useModules(modulesParams) {
        if (modulesParams === void 0) {
          modulesParams = {};
        }

        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function (moduleName) {
          var module = instance.modules[moduleName];
          var moduleParams = modulesParams[moduleName] || {}; // Add event listeners

          if (module.on && instance.on) {
            Object.keys(module.on).forEach(function (moduleEventName) {
              instance.on(moduleEventName, module.on[moduleEventName]);
            });
          } // Module create callback


          if (module.create) {
            module.create.bind(instance)(moduleParams);
          }
        });
      }
    };

    /* eslint-disable no-underscore-dangle */
    var eventsEmitter = {
      on: function on(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;
        var method = priority ? 'unshift' : 'push';
        events.split(' ').forEach(function (event) {
          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
          self.eventsListeners[event][method](handler);
        });
        return self;
      },
      once: function once(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;

        function onceHandler() {
          self.off(events, onceHandler);

          if (onceHandler.__emitterProxy) {
            delete onceHandler.__emitterProxy;
          }

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          handler.apply(self, args);
        }

        onceHandler.__emitterProxy = handler;
        return self.on(events, onceHandler, priority);
      },
      onAny: function onAny(handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;
        var method = priority ? 'unshift' : 'push';

        if (self.eventsAnyListeners.indexOf(handler) < 0) {
          self.eventsAnyListeners[method](handler);
        }

        return self;
      },
      offAny: function offAny(handler) {
        var self = this;
        if (!self.eventsAnyListeners) return self;
        var index = self.eventsAnyListeners.indexOf(handler);

        if (index >= 0) {
          self.eventsAnyListeners.splice(index, 1);
        }

        return self;
      },
      off: function off(events, handler) {
        var self = this;
        if (!self.eventsListeners) return self;
        events.split(' ').forEach(function (event) {
          if (typeof handler === 'undefined') {
            self.eventsListeners[event] = [];
          } else if (self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(function (eventHandler, index) {
              if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                self.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self;
      },
      emit: function emit() {
        var self = this;
        if (!self.eventsListeners) return self;
        var events;
        var data;
        var context;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          events = args[0];
          data = args.slice(1, args.length);
          context = self;
        } else {
          events = args[0].events;
          data = args[0].data;
          context = args[0].context || self;
        }

        data.unshift(context);
        var eventsArray = Array.isArray(events) ? events : events.split(' ');
        eventsArray.forEach(function (event) {
          if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
            self.eventsAnyListeners.forEach(function (eventHandler) {
              eventHandler.apply(context, [event].concat(data));
            });
          }

          if (self.eventsListeners && self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(function (eventHandler) {
              eventHandler.apply(context, data);
            });
          }
        });
        return self;
      }
    };

    function updateSize() {
      var swiper = this;
      var width;
      var height;
      var $el = swiper.$el;

      if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
        width = swiper.params.width;
      } else {
        width = $el[0].clientWidth;
      }

      if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
        height = swiper.params.height;
      } else {
        height = $el[0].clientHeight;
      }

      if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
        return;
      } // Subtract paddings


      width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
      height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
      if (Number.isNaN(width)) width = 0;
      if (Number.isNaN(height)) height = 0;
      extend$1(swiper, {
        width: width,
        height: height,
        size: swiper.isHorizontal() ? width : height
      });
    }

    function updateSlides() {
      var swiper = this;

      function getDirectionLabel(property) {
        if (swiper.isHorizontal()) {
          return property;
        } // prettier-ignore


        return {
          'width': 'height',
          'margin-top': 'margin-left',
          'margin-bottom ': 'margin-right',
          'margin-left': 'margin-top',
          'margin-right': 'margin-bottom',
          'padding-left': 'padding-top',
          'padding-right': 'padding-bottom',
          'marginRight': 'marginBottom'
        }[property];
      }

      function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
      }

      var params = swiper.params;
      var $wrapperEl = swiper.$wrapperEl,
          swiperSize = swiper.size,
          rtl = swiper.rtlTranslate,
          wrongRTL = swiper.wrongRTL;
      var isVirtual = swiper.virtual && params.virtual.enabled;
      var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
      var slides = $wrapperEl.children("." + swiper.params.slideClass);
      var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
      var snapGrid = [];
      var slidesGrid = [];
      var slidesSizesGrid = [];
      var offsetBefore = params.slidesOffsetBefore;

      if (typeof offsetBefore === 'function') {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
      }

      var offsetAfter = params.slidesOffsetAfter;

      if (typeof offsetAfter === 'function') {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
      }

      var previousSnapGridLength = swiper.snapGrid.length;
      var previousSlidesGridLength = swiper.slidesGrid.length;
      var spaceBetween = params.spaceBetween;
      var slidePosition = -offsetBefore;
      var prevSlideSize = 0;
      var index = 0;

      if (typeof swiperSize === 'undefined') {
        return;
      }

      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
      }

      swiper.virtualSize = -spaceBetween; // reset margins

      if (rtl) slides.css({
        marginLeft: '',
        marginBottom: '',
        marginTop: ''
      });else slides.css({
        marginRight: '',
        marginBottom: '',
        marginTop: ''
      });
      var slidesNumberEvenToRows;

      if (params.slidesPerColumn > 1) {
        if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
          slidesNumberEvenToRows = slidesLength;
        } else {
          slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
        }

        if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
          slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
        }
      } // Calc slides


      var slideSize;
      var slidesPerColumn = params.slidesPerColumn;
      var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
      var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);

      for (var i = 0; i < slidesLength; i += 1) {
        slideSize = 0;
        var slide = slides.eq(i);

        if (params.slidesPerColumn > 1) {
          // Set slides order
          var newSlideOrderIndex = void 0;
          var column = void 0;
          var row = void 0;

          if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
            var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
            var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
            var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
            row = Math.floor(slideIndexInGroup / columnsInGroup);
            column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
            newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
            slide.css({
              '-webkit-box-ordinal-group': newSlideOrderIndex,
              '-moz-box-ordinal-group': newSlideOrderIndex,
              '-ms-flex-order': newSlideOrderIndex,
              '-webkit-order': newSlideOrderIndex,
              order: newSlideOrderIndex
            });
          } else if (params.slidesPerColumnFill === 'column') {
            column = Math.floor(i / slidesPerColumn);
            row = i - column * slidesPerColumn;

            if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
              row += 1;

              if (row >= slidesPerColumn) {
                row = 0;
                column += 1;
              }
            }
          } else {
            row = Math.floor(i / slidesPerRow);
            column = i - row * slidesPerRow;
          }

          slide.css(getDirectionLabel('margin-top'), row !== 0 ? params.spaceBetween && params.spaceBetween + "px" : '');
        }

        if (slide.css('display') === 'none') continue; // eslint-disable-line

        if (params.slidesPerView === 'auto') {
          var slideStyles = getComputedStyle(slide[0]);
          var currentTransform = slide[0].style.transform;
          var currentWebKitTransform = slide[0].style.webkitTransform;

          if (currentTransform) {
            slide[0].style.transform = 'none';
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = 'none';
          }

          if (params.roundLengths) {
            slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
          } else {
            // eslint-disable-next-line
            var width = getDirectionPropertyValue(slideStyles, 'width');
            var paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
            var paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
            var marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
            var marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
            var boxSizing = slideStyles.getPropertyValue('box-sizing');

            if (boxSizing && boxSizing === 'border-box') {
              slideSize = width + marginLeft + marginRight;
            } else {
              var _slide$ = slide[0],
                  clientWidth = _slide$.clientWidth,
                  offsetWidth = _slide$.offsetWidth;
              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
            }
          }

          if (currentTransform) {
            slide[0].style.transform = currentTransform;
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = currentWebKitTransform;
          }

          if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
          if (params.roundLengths) slideSize = Math.floor(slideSize);

          if (slides[i]) {
            slides[i].style[getDirectionLabel('width')] = slideSize + "px";
          }
        }

        if (slides[i]) {
          slides[i].swiperSlideSize = slideSize;
        }

        slidesSizesGrid.push(slideSize);

        if (params.centeredSlides) {
          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
          if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
        } else {
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
          slidePosition = slidePosition + slideSize + spaceBetween;
        }

        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index += 1;
      }

      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
      var newSlidesGrid;

      if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
        $wrapperEl.css({
          width: swiper.virtualSize + params.spaceBetween + "px"
        });
      }

      if (params.setWrapperSize) {
        var _$wrapperEl$css;

        $wrapperEl.css((_$wrapperEl$css = {}, _$wrapperEl$css[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css));
      }

      if (params.slidesPerColumn > 1) {
        var _$wrapperEl$css2;

        swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
        swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
        $wrapperEl.css((_$wrapperEl$css2 = {}, _$wrapperEl$css2[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css2));

        if (params.centeredSlides) {
          newSlidesGrid = [];

          for (var _i = 0; _i < snapGrid.length; _i += 1) {
            var slidesGridItem = snapGrid[_i];
            if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
            if (snapGrid[_i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
          }

          snapGrid = newSlidesGrid;
        }
      } // Remove last grid elements depending on width


      if (!params.centeredSlides) {
        newSlidesGrid = [];

        for (var _i2 = 0; _i2 < snapGrid.length; _i2 += 1) {
          var _slidesGridItem = snapGrid[_i2];
          if (params.roundLengths) _slidesGridItem = Math.floor(_slidesGridItem);

          if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
            newSlidesGrid.push(_slidesGridItem);
          }
        }

        snapGrid = newSlidesGrid;

        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
          snapGrid.push(swiper.virtualSize - swiperSize);
        }
      }

      if (snapGrid.length === 0) snapGrid = [0];

      if (params.spaceBetween !== 0) {
        var _slides$filter$css;

        var key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
        slides.filter(function (_, slideIndex) {
          if (!params.cssMode) return true;

          if (slideIndex === slides.length - 1) {
            return false;
          }

          return true;
        }).css((_slides$filter$css = {}, _slides$filter$css[key] = spaceBetween + "px", _slides$filter$css));
      }

      if (params.centeredSlides && params.centeredSlidesBounds) {
        var allSlidesSize = 0;
        slidesSizesGrid.forEach(function (slideSizeValue) {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        var maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map(function (snap) {
          if (snap < 0) return -offsetBefore;
          if (snap > maxSnap) return maxSnap + offsetAfter;
          return snap;
        });
      }

      if (params.centerInsufficientSlides) {
        var _allSlidesSize = 0;
        slidesSizesGrid.forEach(function (slideSizeValue) {
          _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        _allSlidesSize -= params.spaceBetween;

        if (_allSlidesSize < swiperSize) {
          var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
          snapGrid.forEach(function (snap, snapIndex) {
            snapGrid[snapIndex] = snap - allSlidesOffset;
          });
          slidesGrid.forEach(function (snap, snapIndex) {
            slidesGrid[snapIndex] = snap + allSlidesOffset;
          });
        }
      }

      extend$1(swiper, {
        slides: slides,
        snapGrid: snapGrid,
        slidesGrid: slidesGrid,
        slidesSizesGrid: slidesSizesGrid
      });

      if (slidesLength !== previousSlidesLength) {
        swiper.emit('slidesLengthChange');
      }

      if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit('snapGridLengthChange');
      }

      if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit('slidesGridLengthChange');
      }

      if (params.watchSlidesProgress || params.watchSlidesVisibility) {
        swiper.updateSlidesOffset();
      }
    }

    function updateAutoHeight(speed) {
      var swiper = this;
      var activeSlides = [];
      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      var newHeight = 0;
      var i;

      if (typeof speed === 'number') {
        swiper.setTransition(speed);
      } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
      }

      var getSlideByIndex = function getSlideByIndex(index) {
        if (isVirtual) {
          return swiper.slides.filter(function (el) {
            return parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index;
          })[0];
        }

        return swiper.slides.eq(index)[0];
      }; // Find slides currently in view


      if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
          swiper.visibleSlides.each(function (slide) {
            activeSlides.push(slide);
          });
        } else {
          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
            var index = swiper.activeIndex + i;
            if (index > swiper.slides.length && !isVirtual) break;
            activeSlides.push(getSlideByIndex(index));
          }
        }
      } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
      } // Find new height from highest slide in view


      for (i = 0; i < activeSlides.length; i += 1) {
        if (typeof activeSlides[i] !== 'undefined') {
          var height = activeSlides[i].offsetHeight;
          newHeight = height > newHeight ? height : newHeight;
        }
      } // Update Height


      if (newHeight) swiper.$wrapperEl.css('height', newHeight + "px");
    }

    function updateSlidesOffset() {
      var swiper = this;
      var slides = swiper.slides;

      for (var i = 0; i < slides.length; i += 1) {
        slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
      }
    }

    function updateSlidesProgress(translate) {
      if (translate === void 0) {
        translate = this && this.translate || 0;
      }

      var swiper = this;
      var params = swiper.params;
      var slides = swiper.slides,
          rtl = swiper.rtlTranslate;
      if (slides.length === 0) return;
      if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
      var offsetCenter = -translate;
      if (rtl) offsetCenter = translate; // Visible Slides

      slides.removeClass(params.slideVisibleClass);
      swiper.visibleSlidesIndexes = [];
      swiper.visibleSlides = [];

      for (var i = 0; i < slides.length; i += 1) {
        var slide = slides[i];
        var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);

        if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
          var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
          var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
          var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

          if (isVisible) {
            swiper.visibleSlides.push(slide);
            swiper.visibleSlidesIndexes.push(i);
            slides.eq(i).addClass(params.slideVisibleClass);
          }
        }

        slide.progress = rtl ? -slideProgress : slideProgress;
      }

      swiper.visibleSlides = $$1(swiper.visibleSlides);
    }

    function updateProgress(translate) {
      var swiper = this;

      if (typeof translate === 'undefined') {
        var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
      }

      var params = swiper.params;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      var progress = swiper.progress,
          isBeginning = swiper.isBeginning,
          isEnd = swiper.isEnd;
      var wasBeginning = isBeginning;
      var wasEnd = isEnd;

      if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
      } else {
        progress = (translate - swiper.minTranslate()) / translatesDiff;
        isBeginning = progress <= 0;
        isEnd = progress >= 1;
      }

      extend$1(swiper, {
        progress: progress,
        isBeginning: isBeginning,
        isEnd: isEnd
      });
      if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

      if (isBeginning && !wasBeginning) {
        swiper.emit('reachBeginning toEdge');
      }

      if (isEnd && !wasEnd) {
        swiper.emit('reachEnd toEdge');
      }

      if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
        swiper.emit('fromEdge');
      }

      swiper.emit('progress', progress);
    }

    function updateSlidesClasses() {
      var swiper = this;
      var slides = swiper.slides,
          params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          activeIndex = swiper.activeIndex,
          realIndex = swiper.realIndex;
      var isVirtual = swiper.virtual && params.virtual.enabled;
      slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
      var activeSlide;

      if (isVirtual) {
        activeSlide = swiper.$wrapperEl.find("." + params.slideClass + "[data-swiper-slide-index=\"" + activeIndex + "\"]");
      } else {
        activeSlide = slides.eq(activeIndex);
      } // Active classes


      activeSlide.addClass(params.slideActiveClass);

      if (params.loop) {
        // Duplicate to all looped slides
        if (activeSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
        } else {
          $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
        }
      } // Next Slide


      var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);

      if (params.loop && nextSlide.length === 0) {
        nextSlide = slides.eq(0);
        nextSlide.addClass(params.slideNextClass);
      } // Prev Slide


      var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);

      if (params.loop && prevSlide.length === 0) {
        prevSlide = slides.eq(-1);
        prevSlide.addClass(params.slidePrevClass);
      }

      if (params.loop) {
        // Duplicate to all looped slides
        if (nextSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
        } else {
          $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
        }

        if (prevSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
        } else {
          $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
        }
      }

      swiper.emitSlidesClasses();
    }

    function updateActiveIndex(newActiveIndex) {
      var swiper = this;
      var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      var slidesGrid = swiper.slidesGrid,
          snapGrid = swiper.snapGrid,
          params = swiper.params,
          previousIndex = swiper.activeIndex,
          previousRealIndex = swiper.realIndex,
          previousSnapIndex = swiper.snapIndex;
      var activeIndex = newActiveIndex;
      var snapIndex;

      if (typeof activeIndex === 'undefined') {
        for (var i = 0; i < slidesGrid.length; i += 1) {
          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
              activeIndex = i;
            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
              activeIndex = i + 1;
            }
          } else if (translate >= slidesGrid[i]) {
            activeIndex = i;
          }
        } // Normalize slideIndex


        if (params.normalizeSlideIndex) {
          if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
        }
      }

      if (snapGrid.indexOf(translate) >= 0) {
        snapIndex = snapGrid.indexOf(translate);
      } else {
        var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
      }

      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
          swiper.snapIndex = snapIndex;
          swiper.emit('snapIndexChange');
        }

        return;
      } // Get real index


      var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
      extend$1(swiper, {
        snapIndex: snapIndex,
        realIndex: realIndex,
        previousIndex: previousIndex,
        activeIndex: activeIndex
      });
      swiper.emit('activeIndexChange');
      swiper.emit('snapIndexChange');

      if (previousRealIndex !== realIndex) {
        swiper.emit('realIndexChange');
      }

      if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        swiper.emit('slideChange');
      }
    }

    function updateClickedSlide(e) {
      var swiper = this;
      var params = swiper.params;
      var slide = $$1(e.target).closest("." + params.slideClass)[0];
      var slideFound = false;
      var slideIndex;

      if (slide) {
        for (var i = 0; i < swiper.slides.length; i += 1) {
          if (swiper.slides[i] === slide) {
            slideFound = true;
            slideIndex = i;
            break;
          }
        }
      }

      if (slide && slideFound) {
        swiper.clickedSlide = slide;

        if (swiper.virtual && swiper.params.virtual.enabled) {
          swiper.clickedIndex = parseInt($$1(slide).attr('data-swiper-slide-index'), 10);
        } else {
          swiper.clickedIndex = slideIndex;
        }
      } else {
        swiper.clickedSlide = undefined;
        swiper.clickedIndex = undefined;
        return;
      }

      if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
      }
    }

    var update$1 = {
      updateSize: updateSize,
      updateSlides: updateSlides,
      updateAutoHeight: updateAutoHeight,
      updateSlidesOffset: updateSlidesOffset,
      updateSlidesProgress: updateSlidesProgress,
      updateProgress: updateProgress,
      updateSlidesClasses: updateSlidesClasses,
      updateActiveIndex: updateActiveIndex,
      updateClickedSlide: updateClickedSlide
    };

    function getSwiperTranslate(axis) {
      if (axis === void 0) {
        axis = this.isHorizontal() ? 'x' : 'y';
      }

      var swiper = this;
      var params = swiper.params,
          rtl = swiper.rtlTranslate,
          translate = swiper.translate,
          $wrapperEl = swiper.$wrapperEl;

      if (params.virtualTranslate) {
        return rtl ? -translate : translate;
      }

      if (params.cssMode) {
        return translate;
      }

      var currentTranslate = getTranslate($wrapperEl[0], axis);
      if (rtl) currentTranslate = -currentTranslate;
      return currentTranslate || 0;
    }

    function setTranslate(translate, byController) {
      var swiper = this;
      var rtl = swiper.rtlTranslate,
          params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          wrapperEl = swiper.wrapperEl,
          progress = swiper.progress;
      var x = 0;
      var y = 0;
      var z = 0;

      if (swiper.isHorizontal()) {
        x = rtl ? -translate : translate;
      } else {
        y = translate;
      }

      if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
      }

      if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
      } else if (!params.virtualTranslate) {
        $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
      }

      swiper.previousTranslate = swiper.translate;
      swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

      var newProgress;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== progress) {
        swiper.updateProgress(translate);
      }

      swiper.emit('setTranslate', swiper.translate, byController);
    }

    function minTranslate() {
      return -this.snapGrid[0];
    }

    function maxTranslate() {
      return -this.snapGrid[this.snapGrid.length - 1];
    }

    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
      if (translate === void 0) {
        translate = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (translateBounds === void 0) {
        translateBounds = true;
      }

      var swiper = this;
      var params = swiper.params,
          wrapperEl = swiper.wrapperEl;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
      }

      var minTranslate = swiper.minTranslate();
      var maxTranslate = swiper.maxTranslate();
      var newTranslate;
      if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

      swiper.updateProgress(newTranslate);

      if (params.cssMode) {
        var isH = swiper.isHorizontal();

        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        } else {
          // eslint-disable-next-line
          if (wrapperEl.scrollTo) {
            var _wrapperEl$scrollTo;

            wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = -newTranslate, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
          } else {
            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
          }
        }

        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionEnd');
        }
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionStart');
        }

        if (!swiper.animating) {
          swiper.animating = true;

          if (!swiper.onTranslateToWrapperTransitionEnd) {
            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
              swiper.onTranslateToWrapperTransitionEnd = null;
              delete swiper.onTranslateToWrapperTransitionEnd;

              if (runCallbacks) {
                swiper.emit('transitionEnd');
              }
            };
          }

          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
        }
      }

      return true;
    }

    var translate = {
      getTranslate: getSwiperTranslate,
      setTranslate: setTranslate,
      minTranslate: minTranslate,
      maxTranslate: maxTranslate,
      translateTo: translateTo
    };

    function setTransition(duration, byController) {
      var swiper = this;

      if (!swiper.params.cssMode) {
        swiper.$wrapperEl.transition(duration);
      }

      swiper.emit('setTransition', duration, byController);
    }

    function transitionStart(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var activeIndex = swiper.activeIndex,
          params = swiper.params,
          previousIndex = swiper.previousIndex;
      if (params.cssMode) return;

      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }

      var dir = direction;

      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
      }

      swiper.emit('transitionStart');

      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit('slideResetTransitionStart');
          return;
        }

        swiper.emit('slideChangeTransitionStart');

        if (dir === 'next') {
          swiper.emit('slideNextTransitionStart');
        } else {
          swiper.emit('slidePrevTransitionStart');
        }
      }
    }

    function transitionEnd(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var activeIndex = swiper.activeIndex,
          previousIndex = swiper.previousIndex,
          params = swiper.params;
      swiper.animating = false;
      if (params.cssMode) return;
      swiper.setTransition(0);
      var dir = direction;

      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
      }

      swiper.emit('transitionEnd');

      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit('slideResetTransitionEnd');
          return;
        }

        swiper.emit('slideChangeTransitionEnd');

        if (dir === 'next') {
          swiper.emit('slideNextTransitionEnd');
        } else {
          swiper.emit('slidePrevTransitionEnd');
        }
      }
    }

    var transition = {
      setTransition: setTransition,
      transitionStart: transitionStart,
      transitionEnd: transitionEnd
    };

    function slideTo(index, speed, runCallbacks, internal, initial) {
      if (index === void 0) {
        index = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (typeof index !== 'number' && typeof index !== 'string') {
        throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [" + typeof index + "] given.");
      }

      if (typeof index === 'string') {
        /**
         * The `index` argument converted from `string` to `number`.
         * @type {number}
         */
        var indexAsNumber = parseInt(index, 10);
        /**
         * Determines whether the `index` argument is a valid `number`
         * after being converted from the `string` type.
         * @type {boolean}
         */

        var isValidNumber = isFinite(indexAsNumber);

        if (!isValidNumber) {
          throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [" + index + "] given.");
        } // Knowing that the converted `index` is a valid number,
        // we can update the original argument's value.


        index = indexAsNumber;
      }

      var swiper = this;
      var slideIndex = index;
      if (slideIndex < 0) slideIndex = 0;
      var params = swiper.params,
          snapGrid = swiper.snapGrid,
          slidesGrid = swiper.slidesGrid,
          previousIndex = swiper.previousIndex,
          activeIndex = swiper.activeIndex,
          rtl = swiper.rtlTranslate,
          wrapperEl = swiper.wrapperEl,
          enabled = swiper.enabled;

      if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
        return false;
      }

      var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
      var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
        swiper.emit('beforeSlideChangeStart');
      }

      var translate = -snapGrid[snapIndex]; // Update progress

      swiper.updateProgress(translate); // Normalize slideIndex

      if (params.normalizeSlideIndex) {
        for (var i = 0; i < slidesGrid.length; i += 1) {
          var normalizedTranslate = -Math.floor(translate * 100);
          var normalizedGird = Math.floor(slidesGrid[i] * 100);
          var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {
              slideIndex = i;
            } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {
              slideIndex = i + 1;
            }
          } else if (normalizedTranslate >= normalizedGird) {
            slideIndex = i;
          }
        }
      } // Directions locks


      if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
          return false;
        }

        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
          if ((activeIndex || 0) !== slideIndex) return false;
        }
      }

      var direction;
      if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

      if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
        swiper.updateActiveIndex(slideIndex); // Update Height

        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }

        swiper.updateSlidesClasses();

        if (params.effect !== 'slide') {
          swiper.setTranslate(translate);
        }

        if (direction !== 'reset') {
          swiper.transitionStart(runCallbacks, direction);
          swiper.transitionEnd(runCallbacks, direction);
        }

        return false;
      }

      if (params.cssMode) {
        var isH = swiper.isHorizontal();
        var t = -translate;

        if (rtl) {
          t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
        }

        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        } else {
          // eslint-disable-next-line
          if (wrapperEl.scrollTo) {
            var _wrapperEl$scrollTo;

            wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = t, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
          } else {
            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
          }
        }

        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);

        if (!swiper.animating) {
          swiper.animating = true;

          if (!swiper.onSlideToWrapperTransitionEnd) {
            swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
              swiper.onSlideToWrapperTransitionEnd = null;
              delete swiper.onSlideToWrapperTransitionEnd;
              swiper.transitionEnd(runCallbacks, direction);
            };
          }

          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
        }
      }

      return true;
    }

    function slideToLoop(index, speed, runCallbacks, internal) {
      if (index === void 0) {
        index = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var newIndex = index;

      if (swiper.params.loop) {
        newIndex += swiper.loopedSlides;
      }

      return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideNext(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var params = swiper.params,
          animating = swiper.animating,
          enabled = swiper.enabled;
      if (!enabled) return swiper;
      var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slidePrev(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var params = swiper.params,
          animating = swiper.animating,
          snapGrid = swiper.snapGrid,
          slidesGrid = swiper.slidesGrid,
          rtlTranslate = swiper.rtlTranslate,
          enabled = swiper.enabled;
      if (!enabled) return swiper;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      var translate = rtlTranslate ? swiper.translate : -swiper.translate;

      function normalize(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
      }

      var normalizedTranslate = normalize(translate);
      var normalizedSnapGrid = snapGrid.map(function (val) {
        return normalize(val);
      });
      var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

      if (typeof prevSnap === 'undefined' && params.cssMode) {
        snapGrid.forEach(function (snap) {
          if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
        });
      }

      var prevIndex;

      if (typeof prevSnap !== 'undefined') {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
      }

      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideReset(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideToClosest(speed, runCallbacks, internal, threshold) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (threshold === void 0) {
        threshold = 0.5;
      }

      var swiper = this;
      var index = swiper.activeIndex;
      var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
      var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
      var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

      if (translate >= swiper.snapGrid[snapIndex]) {
        // The current translate is on or after the current snap index, so the choice
        // is between the current index and the one after it.
        var currentSnap = swiper.snapGrid[snapIndex];
        var nextSnap = swiper.snapGrid[snapIndex + 1];

        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
          index += swiper.params.slidesPerGroup;
        }
      } else {
        // The current translate is before the current snap index, so the choice
        // is between the current index and the one before it.
        var prevSnap = swiper.snapGrid[snapIndex - 1];
        var _currentSnap = swiper.snapGrid[snapIndex];

        if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
          index -= swiper.params.slidesPerGroup;
        }
      }

      index = Math.max(index, 0);
      index = Math.min(index, swiper.slidesGrid.length - 1);
      return swiper.slideTo(index, speed, runCallbacks, internal);
    }

    function slideToClickedSlide() {
      var swiper = this;
      var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl;
      var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
      var slideToIndex = swiper.clickedIndex;
      var realIndex;

      if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt($$1(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

        if (params.centeredSlides) {
          if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
            swiper.loopFix();
            slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
            nextTick(function () {
              swiper.slideTo(slideToIndex);
            });
          } else {
            swiper.slideTo(slideToIndex);
          }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
          nextTick(function () {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else {
        swiper.slideTo(slideToIndex);
      }
    }

    var slide = {
      slideTo: slideTo,
      slideToLoop: slideToLoop,
      slideNext: slideNext,
      slidePrev: slidePrev,
      slideReset: slideReset,
      slideToClosest: slideToClosest,
      slideToClickedSlide: slideToClickedSlide
    };

    function loopCreate() {
      var swiper = this;
      var document = getDocument();
      var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
      var slides = $wrapperEl.children("." + params.slideClass);

      if (params.loopFillGroupWithBlank) {
        var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

        if (blankSlidesNum !== params.slidesPerGroup) {
          for (var i = 0; i < blankSlidesNum; i += 1) {
            var blankNode = $$1(document.createElement('div')).addClass(params.slideClass + " " + params.slideBlankClass);
            $wrapperEl.append(blankNode);
          }

          slides = $wrapperEl.children("." + params.slideClass);
        }
      }

      if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
      swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
      swiper.loopedSlides += params.loopAdditionalSlides;

      if (swiper.loopedSlides > slides.length) {
        swiper.loopedSlides = slides.length;
      }

      var prependSlides = [];
      var appendSlides = [];
      slides.each(function (el, index) {
        var slide = $$1(el);

        if (index < swiper.loopedSlides) {
          appendSlides.push(el);
        }

        if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
          prependSlides.push(el);
        }

        slide.attr('data-swiper-slide-index', index);
      });

      for (var _i = 0; _i < appendSlides.length; _i += 1) {
        $wrapperEl.append($$1(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }

      for (var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1) {
        $wrapperEl.prepend($$1(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
    }

    function loopFix() {
      var swiper = this;
      swiper.emit('beforeLoopFix');
      var activeIndex = swiper.activeIndex,
          slides = swiper.slides,
          loopedSlides = swiper.loopedSlides,
          allowSlidePrev = swiper.allowSlidePrev,
          allowSlideNext = swiper.allowSlideNext,
          snapGrid = swiper.snapGrid,
          rtl = swiper.rtlTranslate;
      var newIndex;
      swiper.allowSlidePrev = true;
      swiper.allowSlideNext = true;
      var snapTranslate = -snapGrid[activeIndex];
      var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

      if (activeIndex < loopedSlides) {
        newIndex = slides.length - loopedSlides * 3 + activeIndex;
        newIndex += loopedSlides;
        var slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      } else if (activeIndex >= slides.length - loopedSlides) {
        // Fix For Positive Oversliding
        newIndex = -slides.length + activeIndex + loopedSlides;
        newIndex += loopedSlides;

        var _slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (_slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      }

      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit('loopFix');
    }

    function loopDestroy() {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
          params = swiper.params,
          slides = swiper.slides;
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
      slides.removeAttr('data-swiper-slide-index');
    }

    var loop = {
      loopCreate: loopCreate,
      loopFix: loopFix,
      loopDestroy: loopDestroy
    };

    function setGrabCursor(moving) {
      var swiper = this;
      if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
      var el = swiper.el;
      el.style.cursor = 'move';
      el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
      el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
      el.style.cursor = moving ? 'grabbing' : 'grab';
    }

    function unsetGrabCursor() {
      var swiper = this;

      if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
        return;
      }

      swiper.el.style.cursor = '';
    }

    var grabCursor = {
      setGrabCursor: setGrabCursor,
      unsetGrabCursor: unsetGrabCursor
    };

    function appendSlide(slides) {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
          params = swiper.params;

      if (params.loop) {
        swiper.loopDestroy();
      }

      if (typeof slides === 'object' && 'length' in slides) {
        for (var i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.append(slides[i]);
        }
      } else {
        $wrapperEl.append(slides);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }
    }

    function prependSlide(slides) {
      var swiper = this;
      var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          activeIndex = swiper.activeIndex;

      if (params.loop) {
        swiper.loopDestroy();
      }

      var newActiveIndex = activeIndex + 1;

      if (typeof slides === 'object' && 'length' in slides) {
        for (var i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.prepend(slides[i]);
        }

        newActiveIndex = activeIndex + slides.length;
      } else {
        $wrapperEl.prepend(slides);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }

      swiper.slideTo(newActiveIndex, 0, false);
    }

    function addSlide(index, slides) {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
          params = swiper.params,
          activeIndex = swiper.activeIndex;
      var activeIndexBuffer = activeIndex;

      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children("." + params.slideClass);
      }

      var baseLength = swiper.slides.length;

      if (index <= 0) {
        swiper.prependSlide(slides);
        return;
      }

      if (index >= baseLength) {
        swiper.appendSlide(slides);
        return;
      }

      var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
      var slidesBuffer = [];

      for (var i = baseLength - 1; i >= index; i -= 1) {
        var currentSlide = swiper.slides.eq(i);
        currentSlide.remove();
        slidesBuffer.unshift(currentSlide);
      }

      if (typeof slides === 'object' && 'length' in slides) {
        for (var _i = 0; _i < slides.length; _i += 1) {
          if (slides[_i]) $wrapperEl.append(slides[_i]);
        }

        newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
      } else {
        $wrapperEl.append(slides);
      }

      for (var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1) {
        $wrapperEl.append(slidesBuffer[_i2]);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }

      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }

    function removeSlide(slidesIndexes) {
      var swiper = this;
      var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          activeIndex = swiper.activeIndex;
      var activeIndexBuffer = activeIndex;

      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children("." + params.slideClass);
      }

      var newActiveIndex = activeIndexBuffer;
      var indexToRemove;

      if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
        for (var i = 0; i < slidesIndexes.length; i += 1) {
          indexToRemove = slidesIndexes[i];
          if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
          if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        }

        newActiveIndex = Math.max(newActiveIndex, 0);
      } else {
        indexToRemove = slidesIndexes;
        if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        newActiveIndex = Math.max(newActiveIndex, 0);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }

      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }

    function removeAllSlides() {
      var swiper = this;
      var slidesIndexes = [];

      for (var i = 0; i < swiper.slides.length; i += 1) {
        slidesIndexes.push(i);
      }

      swiper.removeSlide(slidesIndexes);
    }

    var manipulation = {
      appendSlide: appendSlide,
      prependSlide: prependSlide,
      addSlide: addSlide,
      removeSlide: removeSlide,
      removeAllSlides: removeAllSlides
    };

    function closestElement(selector, base) {
      if (base === void 0) {
        base = this;
      }

      function __closestFrom(el) {
        if (!el || el === getDocument() || el === getWindow()) return null;
        if (el.assignedSlot) el = el.assignedSlot;
        var found = el.closest(selector);
        return found || __closestFrom(el.getRootNode().host);
      }

      return __closestFrom(base);
    }

    function onTouchStart(event) {
      var swiper = this;
      var document = getDocument();
      var window = getWindow();
      var data = swiper.touchEventsData;
      var params = swiper.params,
          touches = swiper.touches,
          enabled = swiper.enabled;
      if (!enabled) return;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return;
      }

      var e = event;
      if (e.originalEvent) e = e.originalEvent;
      var $targetEl = $$1(e.target);

      if (params.touchEventsTarget === 'wrapper') {
        if (!$targetEl.closest(swiper.wrapperEl).length) return;
      }

      data.isTouchEvent = e.type === 'touchstart';
      if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
      if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
      if (data.isTouched && data.isMoved) return; // change target el for shadow root component

      var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

      if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
        $targetEl = $$1(event.path[0]);
      }

      var noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass;
      var isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
        swiper.allowClick = true;
        return;
      }

      if (params.swipeHandler) {
        if (!$targetEl.closest(params.swipeHandler)[0]) return;
      }

      touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      var startX = touches.currentX;
      var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

      var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
      var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === 'prevent') {
          event.preventDefault();
        } else {
          return;
        }
      }

      extend$1(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: undefined,
        startMoving: undefined
      });
      touches.startX = startX;
      touches.startY = startY;
      data.touchStartTime = now$1();
      swiper.allowClick = true;
      swiper.updateSize();
      swiper.swipeDirection = undefined;
      if (params.threshold > 0) data.allowThresholdMove = false;

      if (e.type !== 'touchstart') {
        var preventDefault = true;
        if ($targetEl.is(data.focusableElements)) preventDefault = false;

        if (document.activeElement && $$1(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
          document.activeElement.blur();
        }

        var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
          e.preventDefault();
        }
      }

      swiper.emit('touchStart', e);
    }

    function onTouchMove(event) {
      var document = getDocument();
      var swiper = this;
      var data = swiper.touchEventsData;
      var params = swiper.params,
          touches = swiper.touches,
          rtl = swiper.rtlTranslate,
          enabled = swiper.enabled;
      if (!enabled) return;
      var e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
          swiper.emit('touchMoveOpposite', e);
        }

        return;
      }

      if (data.isTouchEvent && e.type !== 'touchmove') return;
      var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
      var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
      var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

      if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
      }

      if (!swiper.allowTouchMove) {
        // isMoved = true;
        swiper.allowClick = false;

        if (data.isTouched) {
          extend$1(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY
          });
          data.touchStartTime = now$1();
        }

        return;
      }

      if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
          // Vertical
          if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
            data.isTouched = false;
            data.isMoved = false;
            return;
          }
        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
          return;
        }
      }

      if (data.isTouchEvent && document.activeElement) {
        if (e.target === document.activeElement && $$1(e.target).is(data.focusableElements)) {
          data.isMoved = true;
          swiper.allowClick = false;
          return;
        }
      }

      if (data.allowTouchCallbacks) {
        swiper.emit('touchMove', e);
      }

      if (e.targetTouches && e.targetTouches.length > 1) return;
      touches.currentX = pageX;
      touches.currentY = pageY;
      var diffX = touches.currentX - touches.startX;
      var diffY = touches.currentY - touches.startY;
      if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;

      if (typeof data.isScrolling === 'undefined') {
        var touchAngle;

        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
          data.isScrolling = false;
        } else {
          // eslint-disable-next-line
          if (diffX * diffX + diffY * diffY >= 25) {
            touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
          }
        }
      }

      if (data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }

      if (typeof data.startMoving === 'undefined') {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
          data.startMoving = true;
        }
      }

      if (data.isScrolling) {
        data.isTouched = false;
        return;
      }

      if (!data.startMoving) {
        return;
      }

      swiper.allowClick = false;

      if (!params.cssMode && e.cancelable) {
        e.preventDefault();
      }

      if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
      }

      if (!data.isMoved) {
        if (params.loop) {
          swiper.loopFix();
        }

        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);

        if (swiper.animating) {
          swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
        }

        data.allowMomentumBounce = false; // Grab Cursor

        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
          swiper.setGrabCursor(true);
        }

        swiper.emit('sliderFirstMove', e);
      }

      swiper.emit('sliderMove', e);
      data.isMoved = true;
      var diff = swiper.isHorizontal() ? diffX : diffY;
      touches.diff = diff;
      diff *= params.touchRatio;
      if (rtl) diff = -diff;
      swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
      data.currentTranslate = diff + data.startTranslate;
      var disableParentSwiper = true;
      var resistanceRatio = params.resistanceRatio;

      if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
      }

      if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
      } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
      }

      if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
      } // Directions locks


      if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
      } // Threshold


      if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
          if (!data.allowThresholdMove) {
            data.allowThresholdMove = true;
            touches.startX = touches.currentX;
            touches.startY = touches.currentY;
            data.currentTranslate = data.startTranslate;
            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
            return;
          }
        } else {
          data.currentTranslate = data.startTranslate;
          return;
        }
      }

      if (!params.followFinger || params.cssMode) return; // Update active index in free mode

      if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      if (params.freeMode) {
        // Velocity
        if (data.velocities.length === 0) {
          data.velocities.push({
            position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
            time: data.touchStartTime
          });
        }

        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
          time: now$1()
        });
      } // Update progress


      swiper.updateProgress(data.currentTranslate); // Update translate

      swiper.setTranslate(data.currentTranslate);
    }

    function onTouchEnd(event) {
      var swiper = this;
      var data = swiper.touchEventsData;
      var params = swiper.params,
          touches = swiper.touches,
          rtl = swiper.rtlTranslate,
          $wrapperEl = swiper.$wrapperEl,
          slidesGrid = swiper.slidesGrid,
          snapGrid = swiper.snapGrid,
          enabled = swiper.enabled;
      if (!enabled) return;
      var e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (data.allowTouchCallbacks) {
        swiper.emit('touchEnd', e);
      }

      data.allowTouchCallbacks = false;

      if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
          swiper.setGrabCursor(false);
        }

        data.isMoved = false;
        data.startMoving = false;
        return;
      } // Return Grab Cursor


      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
      } // Time diff


      var touchEndTime = now$1();
      var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

      if (swiper.allowClick) {
        swiper.updateClickedSlide(e);
        swiper.emit('tap click', e);

        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
          swiper.emit('doubleTap doubleClick', e);
        }
      }

      data.lastClickTime = now$1();
      nextTick(function () {
        if (!swiper.destroyed) swiper.allowClick = true;
      });

      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
      }

      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      var currentPos;

      if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
      } else {
        currentPos = -data.currentTranslate;
      }

      if (params.cssMode) {
        return;
      }

      if (params.freeMode) {
        if (currentPos < -swiper.minTranslate()) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (currentPos > -swiper.maxTranslate()) {
          if (swiper.slides.length < snapGrid.length) {
            swiper.slideTo(snapGrid.length - 1);
          } else {
            swiper.slideTo(swiper.slides.length - 1);
          }

          return;
        }

        if (params.freeModeMomentum) {
          if (data.velocities.length > 1) {
            var lastMoveEvent = data.velocities.pop();
            var velocityEvent = data.velocities.pop();
            var distance = lastMoveEvent.position - velocityEvent.position;
            var time = lastMoveEvent.time - velocityEvent.time;
            swiper.velocity = distance / time;
            swiper.velocity /= 2;

            if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
              swiper.velocity = 0;
            } // this implies that the user stopped moving a finger then released.
            // There would be no events with distance zero, so the last event is stale.


            if (time > 150 || now$1() - lastMoveEvent.time > 300) {
              swiper.velocity = 0;
            }
          } else {
            swiper.velocity = 0;
          }

          swiper.velocity *= params.freeModeMomentumVelocityRatio;
          data.velocities.length = 0;
          var momentumDuration = 1000 * params.freeModeMomentumRatio;
          var momentumDistance = swiper.velocity * momentumDuration;
          var newPosition = swiper.translate + momentumDistance;
          if (rtl) newPosition = -newPosition;
          var doBounce = false;
          var afterBouncePosition;
          var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
          var needsLoopFix;

          if (newPosition < swiper.maxTranslate()) {
            if (params.freeModeMomentumBounce) {
              if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                newPosition = swiper.maxTranslate() - bounceAmount;
              }

              afterBouncePosition = swiper.maxTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.maxTranslate();
            }

            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (newPosition > swiper.minTranslate()) {
            if (params.freeModeMomentumBounce) {
              if (newPosition - swiper.minTranslate() > bounceAmount) {
                newPosition = swiper.minTranslate() + bounceAmount;
              }

              afterBouncePosition = swiper.minTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.minTranslate();
            }

            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (params.freeModeSticky) {
            var nextSlide;

            for (var j = 0; j < snapGrid.length; j += 1) {
              if (snapGrid[j] > -newPosition) {
                nextSlide = j;
                break;
              }
            }

            if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
              newPosition = snapGrid[nextSlide];
            } else {
              newPosition = snapGrid[nextSlide - 1];
            }

            newPosition = -newPosition;
          }

          if (needsLoopFix) {
            swiper.once('transitionEnd', function () {
              swiper.loopFix();
            });
          } // Fix duration


          if (swiper.velocity !== 0) {
            if (rtl) {
              momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
            } else {
              momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
            }

            if (params.freeModeSticky) {
              // If freeModeSticky is active and the user ends a swipe with a slow-velocity
              // event, then durations can be 20+ seconds to slide one (or zero!) slides.
              // It's easy to see this when simulating touch with mouse events. To fix this,
              // limit single-slide swipes to the default slide duration. This also has the
              // nice side effect of matching slide speed if the user stopped moving before
              // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
              // For faster swipes, also apply limits (albeit higher ones).
              var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
              var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

              if (moveDistance < currentSlideSize) {
                momentumDuration = params.speed;
              } else if (moveDistance < 2 * currentSlideSize) {
                momentumDuration = params.speed * 1.5;
              } else {
                momentumDuration = params.speed * 2.5;
              }
            }
          } else if (params.freeModeSticky) {
            swiper.slideToClosest();
            return;
          }

          if (params.freeModeMomentumBounce && doBounce) {
            swiper.updateProgress(afterBouncePosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);
            swiper.animating = true;
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
              swiper.emit('momentumBounce');
              swiper.setTransition(params.speed);
              setTimeout(function () {
                swiper.setTranslate(afterBouncePosition);
                $wrapperEl.transitionEnd(function () {
                  if (!swiper || swiper.destroyed) return;
                  swiper.transitionEnd();
                });
              }, 0);
            });
          } else if (swiper.velocity) {
            swiper.updateProgress(newPosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);

            if (!swiper.animating) {
              swiper.animating = true;
              $wrapperEl.transitionEnd(function () {
                if (!swiper || swiper.destroyed) return;
                swiper.transitionEnd();
              });
            }
          } else {
            swiper.emit('_freeModeNoMomentumRelease');
            swiper.updateProgress(newPosition);
          }

          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        } else if (params.freeModeSticky) {
          swiper.slideToClosest();
          return;
        } else if (params.freeMode) {
          swiper.emit('_freeModeNoMomentumRelease');
        }

        if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }

        return;
      } // Find current slide


      var stopIndex = 0;
      var groupSize = swiper.slidesSizesGrid[0];

      for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
        var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

        if (typeof slidesGrid[i + _increment] !== 'undefined') {
          if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {
            stopIndex = i;
            groupSize = slidesGrid[i + _increment] - slidesGrid[i];
          }
        } else if (currentPos >= slidesGrid[i]) {
          stopIndex = i;
          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
      } // Find current slide size


      var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
      var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

      if (timeDiff > params.longSwipesMs) {
        // Long touches
        if (!params.longSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (swiper.swipeDirection === 'next') {
          if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
        }

        if (swiper.swipeDirection === 'prev') {
          if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
        }
      } else {
        // Short swipes
        if (!params.shortSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

        if (!isNavButtonTarget) {
          if (swiper.swipeDirection === 'next') {
            swiper.slideTo(stopIndex + increment);
          }

          if (swiper.swipeDirection === 'prev') {
            swiper.slideTo(stopIndex);
          }
        } else if (e.target === swiper.navigation.nextEl) {
          swiper.slideTo(stopIndex + increment);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    }

    function onResize() {
      var swiper = this;
      var params = swiper.params,
          el = swiper.el;
      if (el && el.offsetWidth === 0) return; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      } // Save locks


      var allowSlideNext = swiper.allowSlideNext,
          allowSlidePrev = swiper.allowSlidePrev,
          snapGrid = swiper.snapGrid; // Disable locks on resize

      swiper.allowSlideNext = true;
      swiper.allowSlidePrev = true;
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateSlidesClasses();

      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.run();
      } // Return locks after resize


      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;

      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
    }

    function onClick(e) {
      var swiper = this;
      if (!swiper.enabled) return;

      if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();

        if (swiper.params.preventClicksPropagation && swiper.animating) {
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }
    }

    function onScroll() {
      var swiper = this;
      var wrapperEl = swiper.wrapperEl,
          rtlTranslate = swiper.rtlTranslate,
          enabled = swiper.enabled;
      if (!enabled) return;
      swiper.previousTranslate = swiper.translate;

      if (swiper.isHorizontal()) {
        if (rtlTranslate) {
          swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
        } else {
          swiper.translate = -wrapperEl.scrollLeft;
        }
      } else {
        swiper.translate = -wrapperEl.scrollTop;
      } // eslint-disable-next-line


      if (swiper.translate === -0) swiper.translate = 0;
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
      var newProgress;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
      }

      swiper.emit('setTranslate', swiper.translate, false);
    }

    var dummyEventAttached = false;

    function dummyEventListener() {}

    function attachEvents() {
      var swiper = this;
      var document = getDocument();
      var params = swiper.params,
          touchEvents = swiper.touchEvents,
          el = swiper.el,
          wrapperEl = swiper.wrapperEl,
          device = swiper.device,
          support = swiper.support;
      swiper.onTouchStart = onTouchStart.bind(swiper);
      swiper.onTouchMove = onTouchMove.bind(swiper);
      swiper.onTouchEnd = onTouchEnd.bind(swiper);

      if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
      }

      swiper.onClick = onClick.bind(swiper);
      var capture = !!params.nested; // Touch Events

      if (!support.touch && support.pointerEvents) {
        el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
        document.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
        document.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
      } else {
        if (support.touch) {
          var passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
            passive: true,
            capture: false
          } : false;
          el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
          el.addEventListener(touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
            passive: false,
            capture: capture
          } : capture);
          el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

          if (touchEvents.cancel) {
            el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
          }

          if (!dummyEventAttached) {
            document.addEventListener('touchstart', dummyEventListener);
            dummyEventAttached = true;
          }
        }

        if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
          el.addEventListener('mousedown', swiper.onTouchStart, false);
          document.addEventListener('mousemove', swiper.onTouchMove, capture);
          document.addEventListener('mouseup', swiper.onTouchEnd, false);
        }
      } // Prevent Links Clicks


      if (params.preventClicks || params.preventClicksPropagation) {
        el.addEventListener('click', swiper.onClick, true);
      }

      if (params.cssMode) {
        wrapperEl.addEventListener('scroll', swiper.onScroll);
      } // Resize handler


      if (params.updateOnWindowResize) {
        swiper.on(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
      } else {
        swiper.on('observerUpdate', onResize, true);
      }
    }

    function detachEvents() {
      var swiper = this;
      var document = getDocument();
      var params = swiper.params,
          touchEvents = swiper.touchEvents,
          el = swiper.el,
          wrapperEl = swiper.wrapperEl,
          device = swiper.device,
          support = swiper.support;
      var capture = !!params.nested; // Touch Events

      if (!support.touch && support.pointerEvents) {
        el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
        document.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        document.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
      } else {
        if (support.touch) {
          var passiveListener = touchEvents.start === 'onTouchStart' && support.passiveListener && params.passiveListeners ? {
            passive: true,
            capture: false
          } : false;
          el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
          el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
          el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

          if (touchEvents.cancel) {
            el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
          }
        }

        if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
          el.removeEventListener('mousedown', swiper.onTouchStart, false);
          document.removeEventListener('mousemove', swiper.onTouchMove, capture);
          document.removeEventListener('mouseup', swiper.onTouchEnd, false);
        }
      } // Prevent Links Clicks


      if (params.preventClicks || params.preventClicksPropagation) {
        el.removeEventListener('click', swiper.onClick, true);
      }

      if (params.cssMode) {
        wrapperEl.removeEventListener('scroll', swiper.onScroll);
      } // Resize handler


      swiper.off(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize);
    }

    var events = {
      attachEvents: attachEvents,
      detachEvents: detachEvents
    };

    function setBreakpoint() {
      var swiper = this;
      var activeIndex = swiper.activeIndex,
          initialized = swiper.initialized,
          _swiper$loopedSlides = swiper.loopedSlides,
          loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides,
          params = swiper.params,
          $el = swiper.$el;
      var breakpoints = params.breakpoints;
      if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

      var breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
      if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
      var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;

      if (breakpointOnlyParams) {
        ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (param) {
          var paramValue = breakpointOnlyParams[param];
          if (typeof paramValue === 'undefined') return;

          if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
            breakpointOnlyParams[param] = 'auto';
          } else if (param === 'slidesPerView') {
            breakpointOnlyParams[param] = parseFloat(paramValue);
          } else {
            breakpointOnlyParams[param] = parseInt(paramValue, 10);
          }
        });
      }

      var breakpointParams = breakpointOnlyParams || swiper.originalParams;
      var wasMultiRow = params.slidesPerColumn > 1;
      var isMultiRow = breakpointParams.slidesPerColumn > 1;
      var wasEnabled = params.enabled;

      if (wasMultiRow && !isMultiRow) {
        $el.removeClass(params.containerModifierClass + "multirow " + params.containerModifierClass + "multirow-column");
        swiper.emitContainerClasses();
      } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(params.containerModifierClass + "multirow");

        if (breakpointParams.slidesPerColumnFill && breakpointParams.slidesPerColumnFill === 'column' || !breakpointParams.slidesPerColumnFill && params.slidesPerColumnFill === 'column') {
          $el.addClass(params.containerModifierClass + "multirow-column");
        }

        swiper.emitContainerClasses();
      }

      var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

      if (directionChanged && initialized) {
        swiper.changeDirection();
      }

      extend$1(swiper.params, breakpointParams);
      var isEnabled = swiper.params.enabled;
      extend$1(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
      });

      if (wasEnabled && !isEnabled) {
        swiper.disable();
      } else if (!wasEnabled && isEnabled) {
        swiper.enable();
      }

      swiper.currentBreakpoint = breakpoint;
      swiper.emit('_beforeBreakpoint', breakpointParams);

      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
      }

      swiper.emit('breakpoint', breakpointParams);
    }

    function getBreakpoint(breakpoints, base, containerEl) {
      if (base === void 0) {
        base = 'window';
      }

      if (!breakpoints || base === 'container' && !containerEl) return undefined;
      var breakpoint = false;
      var window = getWindow();
      var currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
      var points = Object.keys(breakpoints).map(function (point) {
        if (typeof point === 'string' && point.indexOf('@') === 0) {
          var minRatio = parseFloat(point.substr(1));
          var value = currentHeight * minRatio;
          return {
            value: value,
            point: point
          };
        }

        return {
          value: point,
          point: point
        };
      });
      points.sort(function (a, b) {
        return parseInt(a.value, 10) - parseInt(b.value, 10);
      });

      for (var i = 0; i < points.length; i += 1) {
        var _points$i = points[i],
            point = _points$i.point,
            value = _points$i.value;

        if (base === 'window') {
          if (window.matchMedia("(min-width: " + value + "px)").matches) {
            breakpoint = point;
          }
        } else if (value <= containerEl.clientWidth) {
          breakpoint = point;
        }
      }

      return breakpoint || 'max';
    }

    var breakpoints = {
      setBreakpoint: setBreakpoint,
      getBreakpoint: getBreakpoint
    };

    function prepareClasses(entries, prefix) {
      var resultClasses = [];
      entries.forEach(function (item) {
        if (typeof item === 'object') {
          Object.keys(item).forEach(function (classNames) {
            if (item[classNames]) {
              resultClasses.push(prefix + classNames);
            }
          });
        } else if (typeof item === 'string') {
          resultClasses.push(prefix + item);
        }
      });
      return resultClasses;
    }

    function addClasses() {
      var swiper = this;
      var classNames = swiper.classNames,
          params = swiper.params,
          rtl = swiper.rtl,
          $el = swiper.$el,
          device = swiper.device,
          support = swiper.support; // prettier-ignore

      var suffixes = prepareClasses(['initialized', params.direction, {
        'pointer-events': support.pointerEvents && !support.touch
      }, {
        'free-mode': params.freeMode
      }, {
        'autoheight': params.autoHeight
      }, {
        'rtl': rtl
      }, {
        'multirow': params.slidesPerColumn > 1
      }, {
        'multirow-column': params.slidesPerColumn > 1 && params.slidesPerColumnFill === 'column'
      }, {
        'android': device.android
      }, {
        'ios': device.ios
      }, {
        'css-mode': params.cssMode
      }], params.containerModifierClass);
      classNames.push.apply(classNames, suffixes);
      $el.addClass([].concat(classNames).join(' '));
      swiper.emitContainerClasses();
    }

    function removeClasses() {
      var swiper = this;
      var $el = swiper.$el,
          classNames = swiper.classNames;
      $el.removeClass(classNames.join(' '));
      swiper.emitContainerClasses();
    }

    var classes = {
      addClasses: addClasses,
      removeClasses: removeClasses
    };

    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
      var window = getWindow();
      var image;

      function onReady() {
        if (callback) callback();
      }

      var isPicture = $$1(imageEl).parent('picture')[0];

      if (!isPicture && (!imageEl.complete || !checkForComplete)) {
        if (src) {
          image = new window.Image();
          image.onload = onReady;
          image.onerror = onReady;

          if (sizes) {
            image.sizes = sizes;
          }

          if (srcset) {
            image.srcset = srcset;
          }

          if (src) {
            image.src = src;
          }
        } else {
          onReady();
        }
      } else {
        // image already loaded...
        onReady();
      }
    }

    function preloadImages() {
      var swiper = this;
      swiper.imagesToLoad = swiper.$el.find('img');

      function onReady() {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
        if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

        if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
          if (swiper.params.updateOnImagesReady) swiper.update();
          swiper.emit('imagesReady');
        }
      }

      for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
        var imageEl = swiper.imagesToLoad[i];
        swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
      }
    }

    var images = {
      loadImage: loadImage,
      preloadImages: preloadImages
    };

    function checkOverflow() {
      var swiper = this;
      var params = swiper.params;
      var wasLocked = swiper.isLocked;
      var lastSlidePosition = swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;

      if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
        swiper.isLocked = lastSlidePosition <= swiper.size;
      } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
      }

      swiper.allowSlideNext = !swiper.isLocked;
      swiper.allowSlidePrev = !swiper.isLocked; // events

      if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

      if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
        if (swiper.navigation) swiper.navigation.update();
      }
    }

    var checkOverflow$1 = {
      checkOverflow: checkOverflow
    };

    var defaults = {
      init: true,
      direction: 'horizontal',
      touchEventsTarget: 'container',
      initialSlide: 0,
      speed: 300,
      cssMode: false,
      updateOnWindowResize: true,
      resizeObserver: false,
      nested: false,
      createElements: false,
      enabled: true,
      focusableElements: 'input, select, option, textarea, button, video, label',
      // Overrides
      width: null,
      height: null,
      //
      preventInteractionOnTransition: false,
      // ssr
      userAgent: null,
      url: null,
      // To support iOS's swipe-to-go-back gesture (when being used in-app).
      edgeSwipeDetection: false,
      edgeSwipeThreshold: 20,
      // Free mode
      freeMode: false,
      freeModeMomentum: true,
      freeModeMomentumRatio: 1,
      freeModeMomentumBounce: true,
      freeModeMomentumBounceRatio: 1,
      freeModeMomentumVelocityRatio: 1,
      freeModeSticky: false,
      freeModeMinimumVelocity: 0.02,
      // Autoheight
      autoHeight: false,
      // Set wrapper width
      setWrapperSize: false,
      // Virtual Translate
      virtualTranslate: false,
      // Effects
      effect: 'slide',
      // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
      // Breakpoints
      breakpoints: undefined,
      breakpointsBase: 'window',
      // Slides grid
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerColumn: 1,
      slidesPerColumnFill: 'column',
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      centeredSlides: false,
      centeredSlidesBounds: false,
      slidesOffsetBefore: 0,
      // in px
      slidesOffsetAfter: 0,
      // in px
      normalizeSlideIndex: true,
      centerInsufficientSlides: false,
      // Disable swiper and hide navigation when container not overflow
      watchOverflow: false,
      // Round length
      roundLengths: false,
      // Touches
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: true,
      shortSwipes: true,
      longSwipes: true,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: true,
      allowTouchMove: true,
      threshold: 0,
      touchMoveStopPropagation: false,
      touchStartPreventDefault: true,
      touchStartForcePreventDefault: false,
      touchReleaseOnEdges: false,
      // Unique Navigation Elements
      uniqueNavElements: true,
      // Resistance
      resistance: true,
      resistanceRatio: 0.85,
      // Progress
      watchSlidesProgress: false,
      watchSlidesVisibility: false,
      // Cursor
      grabCursor: false,
      // Clicks
      preventClicks: true,
      preventClicksPropagation: true,
      slideToClickedSlide: false,
      // Images
      preloadImages: true,
      updateOnImagesReady: true,
      // loop
      loop: false,
      loopAdditionalSlides: 0,
      loopedSlides: null,
      loopFillGroupWithBlank: false,
      loopPreventsSlide: true,
      // Swiping/no swiping
      allowSlidePrev: true,
      allowSlideNext: true,
      swipeHandler: null,
      // '.swipe-handler',
      noSwiping: true,
      noSwipingClass: 'swiper-no-swiping',
      noSwipingSelector: null,
      // Passive Listeners
      passiveListeners: true,
      // NS
      containerModifierClass: 'swiper-container-',
      // NEW
      slideClass: 'swiper-slide',
      slideBlankClass: 'swiper-slide-invisible-blank',
      slideActiveClass: 'swiper-slide-active',
      slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
      slideVisibleClass: 'swiper-slide-visible',
      slideDuplicateClass: 'swiper-slide-duplicate',
      slideNextClass: 'swiper-slide-next',
      slideDuplicateNextClass: 'swiper-slide-duplicate-next',
      slidePrevClass: 'swiper-slide-prev',
      slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
      wrapperClass: 'swiper-wrapper',
      // Callbacks
      runCallbacksOnInit: true,
      // Internals
      _emitClasses: false
    };

    function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$3(Constructor.prototype, protoProps); if (staticProps) _defineProperties$3(Constructor, staticProps); return Constructor; }
    var prototypes = {
      modular: modular,
      eventsEmitter: eventsEmitter,
      update: update$1,
      translate: translate,
      transition: transition,
      slide: slide,
      loop: loop,
      grabCursor: grabCursor,
      manipulation: manipulation,
      events: events,
      breakpoints: breakpoints,
      checkOverflow: checkOverflow$1,
      classes: classes,
      images: images
    };
    var extendedDefaults = {};

    var Swiper$1 = /*#__PURE__*/function () {
      function Swiper() {
        var el;
        var params;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
          params = args[0];
        } else {
          el = args[0];
          params = args[1];
        }

        if (!params) params = {};
        params = extend$1({}, params);
        if (el && !params.el) params.el = el;

        if (params.el && $$1(params.el).length > 1) {
          var swipers = [];
          $$1(params.el).each(function (containerEl) {
            var newParams = extend$1({}, params, {
              el: containerEl
            });
            swipers.push(new Swiper(newParams));
          });
          return swipers;
        } // Swiper Instance


        var swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
          userAgent: params.userAgent
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];

        if (typeof swiper.modules === 'undefined') {
          swiper.modules = {};
        }

        Object.keys(swiper.modules).forEach(function (moduleName) {
          var module = swiper.modules[moduleName];

          if (module.params) {
            var moduleParamName = Object.keys(module.params)[0];
            var moduleParams = module.params[moduleParamName];
            if (typeof moduleParams !== 'object' || moduleParams === null) return;

            if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
              params[moduleParamName] = {
                auto: true
              };
            }

            if (!(moduleParamName in params && 'enabled' in moduleParams)) return;

            if (params[moduleParamName] === true) {
              params[moduleParamName] = {
                enabled: true
              };
            }

            if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
              params[moduleParamName].enabled = true;
            }

            if (!params[moduleParamName]) params[moduleParamName] = {
              enabled: false
            };
          }
        }); // Extend defaults with modules params

        var swiperParams = extend$1({}, defaults);
        swiper.useParams(swiperParams); // Extend defaults with passed params

        swiper.params = extend$1({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = extend$1({}, swiper.params);
        swiper.passedParams = extend$1({}, params); // add event listeners

        if (swiper.params && swiper.params.on) {
          Object.keys(swiper.params.on).forEach(function (eventName) {
            swiper.on(eventName, swiper.params.on[eventName]);
          });
        }

        if (swiper.params && swiper.params.onAny) {
          swiper.onAny(swiper.params.onAny);
        } // Save Dom lib


        swiper.$ = $$1; // Extend Swiper

        extend$1(swiper, {
          enabled: swiper.params.enabled,
          el: el,
          // Classes
          classNames: [],
          // Slides
          slides: $$1(),
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],
          // isDirection
          isHorizontal: function isHorizontal() {
            return swiper.params.direction === 'horizontal';
          },
          isVertical: function isVertical() {
            return swiper.params.direction === 'vertical';
          },
          // Indexes
          activeIndex: 0,
          realIndex: 0,
          //
          isBeginning: true,
          isEnd: false,
          // Props
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: false,
          // Locks
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev,
          // Touch Events
          touchEvents: function touchEvents() {
            var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
            var desktop = ['mousedown', 'mousemove', 'mouseup'];

            if (swiper.support.pointerEvents) {
              desktop = ['pointerdown', 'pointermove', 'pointerup'];
            }

            swiper.touchEventsTouch = {
              start: touch[0],
              move: touch[1],
              end: touch[2],
              cancel: touch[3]
            };
            swiper.touchEventsDesktop = {
              start: desktop[0],
              move: desktop[1],
              end: desktop[2]
            };
            return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
          }(),
          touchEventsData: {
            isTouched: undefined,
            isMoved: undefined,
            allowTouchCallbacks: undefined,
            touchStartTime: undefined,
            isScrolling: undefined,
            currentTranslate: undefined,
            startTranslate: undefined,
            allowThresholdMove: undefined,
            // Form elements to match
            focusableElements: swiper.params.focusableElements,
            // Last click time
            lastClickTime: now$1(),
            clickTimeout: undefined,
            // Velocities
            velocities: [],
            allowMomentumBounce: undefined,
            isTouchEvent: undefined,
            startMoving: undefined
          },
          // Clicks
          allowClick: true,
          // Touches
          allowTouchMove: swiper.params.allowTouchMove,
          touches: {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
          },
          // Images
          imagesToLoad: [],
          imagesLoaded: 0
        }); // Install Modules

        swiper.useModules();
        swiper.emit('_swiper'); // Init

        if (swiper.params.init) {
          swiper.init();
        } // Return app instance


        return swiper;
      }

      var _proto = Swiper.prototype;

      _proto.enable = function enable() {
        var swiper = this;
        if (swiper.enabled) return;
        swiper.enabled = true;

        if (swiper.params.grabCursor) {
          swiper.setGrabCursor();
        }

        swiper.emit('enable');
      };

      _proto.disable = function disable() {
        var swiper = this;
        if (!swiper.enabled) return;
        swiper.enabled = false;

        if (swiper.params.grabCursor) {
          swiper.unsetGrabCursor();
        }

        swiper.emit('disable');
      };

      _proto.setProgress = function setProgress(progress, speed) {
        var swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        var min = swiper.minTranslate();
        var max = swiper.maxTranslate();
        var current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      };

      _proto.emitContainerClasses = function emitContainerClasses() {
        var swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        var classes = swiper.el.className.split(' ').filter(function (className) {
          return className.indexOf('swiper-container') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
        });
        swiper.emit('_containerClasses', classes.join(' '));
      };

      _proto.getSlideClasses = function getSlideClasses(slideEl) {
        var swiper = this;
        return slideEl.className.split(' ').filter(function (className) {
          return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
        }).join(' ');
      };

      _proto.emitSlidesClasses = function emitSlidesClasses() {
        var swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        var updates = [];
        swiper.slides.each(function (slideEl) {
          var classNames = swiper.getSlideClasses(slideEl);
          updates.push({
            slideEl: slideEl,
            classNames: classNames
          });
          swiper.emit('_slideClass', slideEl, classNames);
        });
        swiper.emit('_slideClasses', updates);
      };

      _proto.slidesPerViewDynamic = function slidesPerViewDynamic() {
        var swiper = this;
        var params = swiper.params,
            slides = swiper.slides,
            slidesGrid = swiper.slidesGrid,
            swiperSize = swiper.size,
            activeIndex = swiper.activeIndex;
        var spv = 1;

        if (params.centeredSlides) {
          var slideSize = slides[activeIndex].swiperSlideSize;
          var breakLoop;

          for (var i = activeIndex + 1; i < slides.length; i += 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }

          for (var _i = activeIndex - 1; _i >= 0; _i -= 1) {
            if (slides[_i] && !breakLoop) {
              slideSize += slides[_i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }
        } else {
          for (var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1) {
            if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {
              spv += 1;
            }
          }
        }

        return spv;
      };

      _proto.update = function update() {
        var swiper = this;
        if (!swiper || swiper.destroyed) return;
        var snapGrid = swiper.snapGrid,
            params = swiper.params; // Breakpoints

        if (params.breakpoints) {
          swiper.setBreakpoint();
        }

        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();

        function setTranslate() {
          var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
          var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
          swiper.setTranslate(newTranslate);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }

        var translated;

        if (swiper.params.freeMode) {
          setTranslate();

          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        } else {
          if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
            translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
          } else {
            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
          }

          if (!translated) {
            setTranslate();
          }
        }

        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
          swiper.checkOverflow();
        }

        swiper.emit('update');
      };

      _proto.changeDirection = function changeDirection(newDirection, needUpdate) {
        if (needUpdate === void 0) {
          needUpdate = true;
        }

        var swiper = this;
        var currentDirection = swiper.params.direction;

        if (!newDirection) {
          // eslint-disable-next-line
          newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
        }

        if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
          return swiper;
        }

        swiper.$el.removeClass("" + swiper.params.containerModifierClass + currentDirection).addClass("" + swiper.params.containerModifierClass + newDirection);
        swiper.emitContainerClasses();
        swiper.params.direction = newDirection;
        swiper.slides.each(function (slideEl) {
          if (newDirection === 'vertical') {
            slideEl.style.width = '';
          } else {
            slideEl.style.height = '';
          }
        });
        swiper.emit('changeDirection');
        if (needUpdate) swiper.update();
        return swiper;
      };

      _proto.mount = function mount(el) {
        var swiper = this;
        if (swiper.mounted) return true; // Find el

        var $el = $$1(el || swiper.params.el);
        el = $el[0];

        if (!el) {
          return false;
        }

        el.swiper = swiper;

        var getWrapperSelector = function getWrapperSelector() {
          return "." + (swiper.params.wrapperClass || '').trim().split(' ').join('.');
        };

        var getWrapper = function getWrapper() {
          if (el && el.shadowRoot && el.shadowRoot.querySelector) {
            var res = $$1(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

            res.children = function (options) {
              return $el.children(options);
            };

            return res;
          }

          return $el.children(getWrapperSelector());
        }; // Find Wrapper


        var $wrapperEl = getWrapper();

        if ($wrapperEl.length === 0 && swiper.params.createElements) {
          var document = getDocument();
          var wrapper = document.createElement('div');
          $wrapperEl = $$1(wrapper);
          wrapper.className = swiper.params.wrapperClass;
          $el.append(wrapper);
          $el.children("." + swiper.params.slideClass).each(function (slideEl) {
            $wrapperEl.append(slideEl);
          });
        }

        extend$1(swiper, {
          $el: $el,
          el: el,
          $wrapperEl: $wrapperEl,
          wrapperEl: $wrapperEl[0],
          mounted: true,
          // RTL
          rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
          rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
          wrongRTL: $wrapperEl.css('display') === '-webkit-box'
        });
        return true;
      };

      _proto.init = function init(el) {
        var swiper = this;
        if (swiper.initialized) return swiper;
        var mounted = swiper.mount(el);
        if (mounted === false) return swiper;
        swiper.emit('beforeInit'); // Set breakpoint

        if (swiper.params.breakpoints) {
          swiper.setBreakpoint();
        } // Add Classes


        swiper.addClasses(); // Create loop

        if (swiper.params.loop) {
          swiper.loopCreate();
        } // Update size


        swiper.updateSize(); // Update slides

        swiper.updateSlides();

        if (swiper.params.watchOverflow) {
          swiper.checkOverflow();
        } // Set Grab Cursor


        if (swiper.params.grabCursor && swiper.enabled) {
          swiper.setGrabCursor();
        }

        if (swiper.params.preloadImages) {
          swiper.preloadImages();
        } // Slide To Initial Slide


        if (swiper.params.loop) {
          swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
        } else {
          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        } // Attach events


        swiper.attachEvents(); // Init Flag

        swiper.initialized = true; // Emit

        swiper.emit('init');
        swiper.emit('afterInit');
        return swiper;
      };

      _proto.destroy = function destroy(deleteInstance, cleanStyles) {
        if (deleteInstance === void 0) {
          deleteInstance = true;
        }

        if (cleanStyles === void 0) {
          cleanStyles = true;
        }

        var swiper = this;
        var params = swiper.params,
            $el = swiper.$el,
            $wrapperEl = swiper.$wrapperEl,
            slides = swiper.slides;

        if (typeof swiper.params === 'undefined' || swiper.destroyed) {
          return null;
        }

        swiper.emit('beforeDestroy'); // Init Flag

        swiper.initialized = false; // Detach events

        swiper.detachEvents(); // Destroy loop

        if (params.loop) {
          swiper.loopDestroy();
        } // Cleanup styles


        if (cleanStyles) {
          swiper.removeClasses();
          $el.removeAttr('style');
          $wrapperEl.removeAttr('style');

          if (slides && slides.length) {
            slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
          }
        }

        swiper.emit('destroy'); // Detach emitter events

        Object.keys(swiper.eventsListeners).forEach(function (eventName) {
          swiper.off(eventName);
        });

        if (deleteInstance !== false) {
          swiper.$el[0].swiper = null;
          deleteProps(swiper);
        }

        swiper.destroyed = true;
        return null;
      };

      Swiper.extendDefaults = function extendDefaults(newDefaults) {
        extend$1(extendedDefaults, newDefaults);
      };

      Swiper.installModule = function installModule(module) {
        if (!Swiper.prototype.modules) Swiper.prototype.modules = {};
        var name = module.name || Object.keys(Swiper.prototype.modules).length + "_" + now$1();
        Swiper.prototype.modules[name] = module;
      };

      Swiper.use = function use(module) {
        if (Array.isArray(module)) {
          module.forEach(function (m) {
            return Swiper.installModule(m);
          });
          return Swiper;
        }

        Swiper.installModule(module);
        return Swiper;
      };

      _createClass$3(Swiper, null, [{
        key: "extendedDefaults",
        get: function get() {
          return extendedDefaults;
        }
      }, {
        key: "defaults",
        get: function get() {
          return defaults;
        }
      }]);

      return Swiper;
    }();

    Object.keys(prototypes).forEach(function (prototypeGroup) {
      Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
        Swiper$1.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
      });
    });
    Swiper$1.use([Resize, Observer$1]);
    var Swiper$2 = Swiper$1;

    function initSwiper(swiperEl) {
      var app = this;
      var $swiperEl = $(swiperEl);
      if ($swiperEl.length === 0) return;
      if ($swiperEl[0].swiper) return;
      var initialSlide;
      var params = {};
      var isTabs;
      var isRoutableTabs;

      if ($swiperEl.hasClass('tabs-swipeable-wrap')) {
        $swiperEl.addClass('swiper-container').children('.tabs').addClass('swiper-wrapper').children('.tab').addClass('swiper-slide');
        initialSlide = $swiperEl.children('.tabs').children('.tab-active').index();
        isTabs = true;
        isRoutableTabs = $swiperEl.find('.tabs-routable').length > 0;
      }

      if ($swiperEl.attr('data-swiper')) {
        params = JSON.parse($swiperEl.attr('data-swiper'));
      } else if ($swiperEl[0].f7SwiperParams) {
        params = $swiperEl[0].f7SwiperParams;
      } else {
        params = $swiperEl.dataset();
        Object.keys(params).forEach(function (key) {
          var value = params[key];

          if (typeof value === 'string' && value.indexOf('{') === 0 && value.indexOf('}') > 0) {
            try {
              params[key] = JSON.parse(value);
            } catch (e) {// not JSON
            }
          }
        });
      }

      if (typeof params.initialSlide === 'undefined' && typeof initialSlide !== 'undefined') {
        params.initialSlide = initialSlide;
      }

      var swiper = app.swiper.create($swiperEl[0], params);

      function updateSwiper() {
        swiper.update();
      }

      var $tabEl = $swiperEl.parents('.tab').filter(function (tabEl) {
        return $(tabEl).parent('.tabs').parent('.tabs-animated-wrap, .tabs-swipeable-wrap').length === 0;
      }).eq(0);
      $swiperEl.parents('.popup, .login-screen, .sheet-modal, .popover').on('modal:open', updateSwiper);
      $swiperEl.parents('.panel').on('panel:open', updateSwiper);

      if ($tabEl && $tabEl.length) {
        $tabEl.on('tab:show', updateSwiper);
      }

      swiper.on('beforeDestroy', function () {
        $swiperEl.parents('.popup, .login-screen, .sheet-modal, .popover').off('modal:open', updateSwiper);
        $swiperEl.parents('.panel').off('panel:open', updateSwiper);

        if ($tabEl && $tabEl.length) {
          $tabEl.off('tab:show', updateSwiper);
        }
      });

      if (isTabs) {
        swiper.on('slideChange', function () {
          if (isRoutableTabs) {
            var view = app.views.get($swiperEl.parents('.view'));
            if (!view) view = app.views.main;
            var router = view.router;
            var tabRouteUrl = router.findTabRouteUrl(swiper.slides.eq(swiper.activeIndex)[0]);

            if (tabRouteUrl) {
              setTimeout(function () {
                router.navigate(tabRouteUrl);
              }, 0);
            }
          } else {
            app.tab.show({
              tabEl: swiper.slides.eq(swiper.activeIndex)
            });
          }
        });
      }
    }

    var Swiper = {
      name: 'swiper',
      static: {
        Swiper: Swiper$2
      },
      create: function create() {
        var app = this;
        app.swiper = ConstructorMethods({
          defaultSelector: '.swiper-container',
          constructor: Swiper$2,
          domProp: 'swiper'
        });
      },
      on: {
        pageBeforeRemove: function pageBeforeRemove(page) {
          var app = this;
          page.$el.find('.swiper-init, .tabs-swipeable-wrap').each(function (swiperEl) {
            app.swiper.destroy(swiperEl);
          });
        },
        pageMounted: function pageMounted(page) {
          var app = this;
          page.$el.find('.tabs-swipeable-wrap').each(function (swiperEl) {
            initSwiper.call(app, swiperEl);
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.swiper-init, .tabs-swipeable-wrap').each(function (swiperEl) {
            initSwiper.call(app, swiperEl);
          });
        },
        pageReinit: function pageReinit(page) {
          var app = this;
          page.$el.find('.swiper-init, .tabs-swipeable-wrap').each(function (swiperEl) {
            var swiper = app.swiper.get(swiperEl);
            if (swiper && swiper.update) swiper.update();
          });
        },
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each(function (swiperEl) {
            initSwiper.call(app, swiperEl);
          });
        },
        tabShow: function tabShow(tabEl) {
          var app = this;
          $(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each(function (swiperEl) {
            var swiper = app.swiper.get(swiperEl);
            if (swiper && swiper.update) swiper.update();
          });
        },
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          var app = this;
          $(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each(function (swiperEl) {
            app.swiper.destroy(swiperEl);
          });
        }
      },
      vnode: {
        'swiper-init': {
          insert: function insert(vnode) {
            var app = this;
            var swiperEl = vnode.elm;
            initSwiper.call(app, swiperEl);
          },
          destroy: function destroy(vnode) {
            var app = this;
            var swiperEl = vnode.elm;
            app.swiper.destroy(swiperEl);
          }
        },
        'tabs-swipeable-wrap': {
          insert: function insert(vnode) {
            var app = this;
            var swiperEl = vnode.elm;
            initSwiper.call(app, swiperEl);
          },
          destroy: function destroy(vnode) {
            var app = this;
            var swiperEl = vnode.elm;
            app.swiper.destroy(swiperEl);
          }
        }
      }
    };

    function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }

    function _assertThisInitialized$5(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$5(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$5(subClass, superClass); }

    function _setPrototypeOf$5(o, p) { _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$5(o, p); }

    var PhotoBrowser$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$5(PhotoBrowser, _Framework7Class);

      function PhotoBrowser(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params, [app]) || this;

        var pb = _assertThisInitialized$5(_this);

        pb.app = app;
        var defaults = extend$2({
          on: {}
        }, app.params.photoBrowser); // Extend defaults with modules params

        pb.useModulesParams(defaults);
        pb.params = extend$2(defaults, params);
        extend$2(pb, {
          exposed: false,
          opened: false,
          activeIndex: pb.params.swiper.initialSlide,
          url: pb.params.url,
          swipeToClose: {
            allow: true,
            isTouched: false,
            diff: undefined,
            start: undefined,
            current: undefined,
            started: false,
            activeSlide: undefined,
            timeStart: undefined
          }
        }); // Install Modules

        pb.useModules(); // Init

        pb.init();
        return _this;
      }

      var _proto = PhotoBrowser.prototype;

      _proto.onSlideChange = function onSlideChange(swiper) {
        var pb = this;
        pb.activeIndex = swiper.activeIndex;
        var current = swiper.activeIndex + 1;
        var total = pb.params.virtualSlides ? pb.params.photos.length : swiper.slides.length;

        if (swiper.params.loop) {
          total -= 2;
          current -= swiper.loopedSlides;
          if (current < 1) current = total + current;
          if (current > total) current -= total;
        }

        var $activeSlideEl = pb.params.virtualSlides ? swiper.$wrapperEl.find(".swiper-slide[data-swiper-slide-index=\"" + swiper.activeIndex + "\"]") : swiper.slides.eq(swiper.activeIndex);
        var $previousSlideEl = pb.params.virtualSlides ? swiper.$wrapperEl.find(".swiper-slide[data-swiper-slide-index=\"" + swiper.previousIndex + "\"]") : swiper.slides.eq(swiper.previousIndex);
        var $currentEl = pb.$el.find('.photo-browser-current');
        var $totalEl = pb.$el.find('.photo-browser-total');
        var navbarEl;

        if (pb.params.type === 'page' && pb.params.navbar && $currentEl.length === 0 && pb.app.theme === 'ios') {
          navbarEl = pb.app.navbar.getElByPage(pb.$el);

          if (navbarEl) {
            $currentEl = $(navbarEl).find('.photo-browser-current');
            $totalEl = $(navbarEl).find('.photo-browser-total');
          }
        }

        if ($currentEl.length && $totalEl.length) {
          $currentEl.text(current);
          $totalEl.text(total);
          if (!navbarEl) navbarEl = $currentEl.parents('.navbar')[0];

          if (navbarEl) {
            pb.app.navbar.size(navbarEl);
          }
        } // Update captions


        if (pb.captions.length > 0) {
          var captionIndex = swiper.params.loop ? $activeSlideEl.attr('data-swiper-slide-index') : pb.activeIndex;
          pb.$captionsContainerEl.find('.photo-browser-caption-active').removeClass('photo-browser-caption-active');
          pb.$captionsContainerEl.find("[data-caption-index=\"" + captionIndex + "\"]").addClass('photo-browser-caption-active');
        } // Stop Video


        var previousSlideVideo = $previousSlideEl.find('video');

        if (previousSlideVideo.length > 0) {
          if ('pause' in previousSlideVideo[0]) previousSlideVideo[0].pause();
        }
      };

      _proto.onTouchStart = function onTouchStart() {
        var pb = this;
        var swipeToClose = pb.swipeToClose;
        if (!swipeToClose.allow) return;
        swipeToClose.isTouched = true;
      };

      _proto.onTouchMove = function onTouchMove(e) {
        var pb = this;
        var swipeToClose = pb.swipeToClose;
        if (!swipeToClose.isTouched) return;

        if (!swipeToClose.started) {
          swipeToClose.started = true;
          swipeToClose.start = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

          if (pb.params.virtualSlides) {
            swipeToClose.activeSlide = pb.swiper.$wrapperEl.children('.swiper-slide-active');
          } else {
            swipeToClose.activeSlide = pb.swiper.slides.eq(pb.swiper.activeIndex);
          }

          swipeToClose.timeStart = now$2();
        }

        e.preventDefault();
        swipeToClose.current = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        swipeToClose.diff = swipeToClose.start - swipeToClose.current;
        pb.$el.transition(0).transform("translate3d(0," + -swipeToClose.diff + "px,0)");
      };

      _proto.onTouchEnd = function onTouchEnd() {
        var pb = this;
        var swipeToClose = pb.swipeToClose;
        swipeToClose.isTouched = false;

        if (!swipeToClose.started) {
          swipeToClose.started = false;
          return;
        }

        swipeToClose.started = false;
        swipeToClose.allow = false;
        var diff = Math.abs(swipeToClose.diff);
        var timeDiff = new Date().getTime() - swipeToClose.timeStart;

        if (timeDiff < 300 && diff > 20 || timeDiff >= 300 && diff > 100) {
          nextTick$1(function () {
            if (pb.$el) {
              if (swipeToClose.diff < 0) pb.$el.addClass('swipe-close-to-bottom');else pb.$el.addClass('swipe-close-to-top');
            }

            pb.emit('local::swipeToClose', pb);
            pb.$el.transform('').transition('');
            pb.close();
            swipeToClose.allow = true;
          });
          return;
        }

        if (diff !== 0) {
          pb.$el.addClass('photo-browser-transitioning').transitionEnd(function () {
            swipeToClose.allow = true;
            pb.$el.removeClass('photo-browser-transitioning');
          });
        } else {
          swipeToClose.allow = true;
        }

        nextTick$1(function () {
          pb.$el.transform('').transition('');
        });
      } // Render Functions
      ;

      _proto.renderNavbar = function renderNavbar() {
        var pb = this;
        if (pb.params.renderNavbar) return pb.params.renderNavbar.call(pb);
        var iconsColor = pb.params.iconsColor;
        if (!pb.params.iconsColor && pb.params.theme === 'dark') iconsColor = 'white';
        var pageBackLinkText = (pb.app.theme === 'ios' || pb.app.theme === 'aurora') && pb.params.pageBackLinkText ? pb.params.pageBackLinkText : '';
        var renderNavbarCount = typeof pb.params.navbarShowCount === 'undefined' ? pb.params.photos.length > 1 : pb.params.navbarShowCount;
        var isPopup = pb.params.type !== 'page';
        return $jsx$1("div", {
          class: "navbar navbar-photo-browser " + (pb.params.theme === 'dark' ? 'navbar-photo-browser-dark' : '')
        }, $jsx$1("div", {
          class: "navbar-bg"
        }), $jsx$1("div", {
          class: "navbar-inner navbar-inner-centered-title sliding"
        }, !isPopup && $jsx$1("div", {
          class: "left"
        }, $jsx$1("a", {
          class: "link " + (!pageBackLinkText ? 'icon-only' : '') + " back"
        }, $jsx$1("i", {
          class: "icon icon-back " + (iconsColor ? "color-" + iconsColor : '')
        }), pageBackLinkText && $jsx$1("span", null, pageBackLinkText))), renderNavbarCount && $jsx$1("div", {
          class: "title"
        }, $jsx$1("span", {
          class: "photo-browser-current"
        }), $jsx$1("span", {
          class: "photo-browser-of"
        }, pb.params.navbarOfText), $jsx$1("span", {
          class: "photo-browser-total"
        })), isPopup && $jsx$1("div", {
          class: "right"
        }, $jsx$1("a", {
          class: "link popup-close",
          "data-popup": ".photo-browser-popup"
        }, $jsx$1("span", null, pb.params.popupCloseLinkText)))));
      };

      _proto.renderToolbar = function renderToolbar() {
        var pb = this;
        if (pb.params.renderToolbar) return pb.params.renderToolbar.call(pb);
        var iconsColor = pb.params.iconsColor;
        if (!pb.params.iconsColor && pb.params.theme === 'dark') iconsColor = 'white';
        return $jsx$1("div", {
          class: "toolbar toolbar-bottom tabbar"
        }, $jsx$1("div", {
          class: "toolbar-inner"
        }, $jsx$1("a", {
          class: "link photo-browser-prev"
        }, $jsx$1("i", {
          class: "icon icon-back " + (iconsColor ? "color-" + iconsColor : '')
        })), $jsx$1("a", {
          class: "link photo-browser-next"
        }, $jsx$1("i", {
          class: "icon icon-forward " + (iconsColor ? "color-" + iconsColor : '')
        }))));
      };

      _proto.renderCaption = function renderCaption(caption, index) {
        var pb = this;
        if (pb.params.renderCaption) return pb.params.renderCaption.call(pb, caption, index);
        return $jsx$1("div", {
          class: "photo-browser-caption",
          "data-caption-index": index
        }, caption);
      };

      _proto.renderObject = function renderObject(photo, index) {
        var pb = this;
        if (pb.params.renderObject) return pb.params.renderObject.call(pb, photo, index);
        return $jsx$1("div", {
          class: "photo-browser-slide photo-browser-object-slide swiper-slide",
          "data-swiper-slide-index": index
        }, photo.html ? photo.html : photo);
      };

      _proto.renderLazyPhoto = function renderLazyPhoto(photo, index) {
        var pb = this;
        if (pb.params.renderLazyPhoto) return pb.params.renderLazyPhoto.call(pb, photo, index);
        return $jsx$1("div", {
          class: "photo-browser-slide photo-browser-slide-lazy swiper-slide",
          "data-swiper-slide-index": index
        }, $jsx$1("div", {
          class: "swiper-lazy-preloader"
        }), $jsx$1("span", {
          class: "swiper-zoom-container"
        }, $jsx$1("img", {
          "data-src": photo.url ? photo.url : photo,
          class: "swiper-lazy"
        })));
      };

      _proto.renderPhoto = function renderPhoto(photo, index) {
        var pb = this;
        if (pb.params.renderPhoto) return pb.params.renderPhoto.call(pb, photo, index);
        return $jsx$1("div", {
          class: "photo-browser-slide swiper-slide",
          "data-swiper-slide-index": index
        }, $jsx$1("span", {
          class: "swiper-zoom-container"
        }, $jsx$1("img", {
          src: photo.url ? photo.url : photo
        })));
      };

      _proto.render = function render() {
        var pb = this;
        if (pb.params.render) return pb.params.render.call(pb, pb.params);
        return $jsx$1("div", {
          class: "photo-browser photo-browser-" + pb.params.theme
        }, $jsx$1("div", {
          class: "view"
        }, $jsx$1("div", {
          class: "page photo-browser-page photo-browser-page-" + pb.params.theme + " no-toolbar " + (!pb.params.navbar ? 'no-navbar' : ''),
          "data-name": "photo-browser-page"
        }, pb.params.navbar && pb.renderNavbar(), pb.params.toolbar && pb.renderToolbar(), $jsx$1("div", {
          class: "photo-browser-captions photo-browser-captions-" + (pb.params.captionsTheme || pb.params.theme)
        }, pb.params.photos.map(function (photo, index) {
          if (photo.caption) return pb.renderCaption(photo.caption, index);
          return '';
        })), $jsx$1("div", {
          class: "photo-browser-swiper-container swiper-container"
        }, $jsx$1("div", {
          class: "photo-browser-swiper-wrapper swiper-wrapper"
        }, !pb.params.virtualSlides && pb.params.photos.map(function (photo, index) {
          if (photo.html || (typeof photo === 'string' || photo instanceof String) && photo.indexOf('<') >= 0 && photo.indexOf('>') >= 0) {
            return pb.renderObject(photo, index);
          }

          if (pb.params.swiper.lazy === true || pb.params.swiper.lazy && pb.params.swiper.lazy.enabled) {
            return pb.renderLazyPhoto(photo, index);
          }

          return pb.renderPhoto(photo, index);
        }))))));
      };

      _proto.renderStandalone = function renderStandalone() {
        var pb = this;
        if (pb.params.renderStandalone) return pb.params.renderStandalone.call(pb);
        var standaloneHtml = "<div class=\"popup photo-browser-popup photo-browser-standalone popup-tablet-fullscreen\">" + pb.render() + "</div>";
        return standaloneHtml;
      };

      _proto.renderPage = function renderPage() {
        var pb = this;
        if (pb.params.renderPage) return pb.params.renderPage.call(pb);
        var pageHtml = pb.render();
        return pageHtml;
      };

      _proto.renderPopup = function renderPopup() {
        var pb = this;
        if (pb.params.renderPopup) return pb.params.renderPopup.call(pb);
        var popupHtml = "<div class=\"popup photo-browser-popup\">" + pb.render() + "</div>";
        return popupHtml;
      } // Callbacks
      ;

      _proto.onOpen = function onOpen(type, el) {
        var pb = this;
        var app = pb.app;
        var $el = $(el);
        $el[0].f7PhotoBrowser = pb;
        pb.$el = $el;
        pb.el = $el[0];
        pb.openedIn = type;
        pb.opened = true;
        pb.$swiperContainerEl = pb.$el.find('.photo-browser-swiper-container');
        pb.$swiperWrapperEl = pb.$el.find('.photo-browser-swiper-wrapper');
        pb.slides = pb.$el.find('.photo-browser-slide');
        pb.$captionsContainerEl = pb.$el.find('.photo-browser-captions');
        pb.captions = pb.$el.find('.photo-browser-caption'); // Init Swiper

        var clickTimeout;
        var swiperParams = extend$2({}, pb.params.swiper, {
          initialSlide: pb.activeIndex,
          on: {
            click: function click(e) {
              clearTimeout(clickTimeout);

              if (pb.params.exposition) {
                clickTimeout = setTimeout(function () {
                  pb.expositionToggle();
                }, 350);
              }

              pb.emit('local::tap', e);
              pb.emit('local::click', e);
            },
            doubleClick: function doubleClick(e) {
              clearTimeout(clickTimeout);
              pb.emit('local::doubleTap', e);
              pb.emit('local::doubleClick', e);
            },
            slideChange: function slideChange() {
              var swiper = this;
              pb.onSlideChange(swiper);

              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              pb.emit.apply(pb, ['local::slideChange'].concat(args));
            },
            transitionStart: function transitionStart() {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }

              pb.emit.apply(pb, ['local::transitionStart'].concat(args));
            },
            transitionEnd: function transitionEnd() {
              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
              }

              pb.emit.apply(pb, ['local::transitionEnd'].concat(args));
            },
            slideChangeTransitionStart: function slideChangeTransitionStart() {
              var swiper = this;
              pb.onSlideChange(swiper);

              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
              }

              pb.emit.apply(pb, ['local::slideChangeTransitionStart'].concat(args));
            },
            slideChangeTransitionEnd: function slideChangeTransitionEnd() {
              for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                args[_key5] = arguments[_key5];
              }

              pb.emit.apply(pb, ['local::slideChangeTransitionEnd'].concat(args));
            },
            lazyImageLoad: function lazyImageLoad() {
              for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                args[_key6] = arguments[_key6];
              }

              pb.emit.apply(pb, ['local::lazyImageLoad'].concat(args));
            },
            lazyImageReady: function lazyImageReady() {
              for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
                args[_key7] = arguments[_key7];
              }

              var slideEl = args[0];
              $(slideEl).removeClass('photo-browser-slide-lazy');
              pb.emit.apply(pb, ['local::lazyImageReady'].concat(args));
            }
          }
        });

        if (pb.params.swipeToClose && pb.params.type !== 'page') {
          extend$2(swiperParams.on, {
            touchStart: function touchStart(swiper, e) {
              pb.onTouchStart(e);
              pb.emit('local::touchStart', e);
            },
            touchMoveOpposite: function touchMoveOpposite(swiper, e) {
              pb.onTouchMove(e);
              pb.emit('local::touchMoveOpposite', e);
            },
            touchEnd: function touchEnd(swiper, e) {
              pb.onTouchEnd(e);
              pb.emit('local::touchEnd', e);
            }
          });
        }

        if (pb.params.virtualSlides) {
          extend$2(swiperParams, {
            virtual: {
              slides: pb.params.photos,
              renderSlide: function renderSlide(photo, index) {
                if (photo.html || (typeof photo === 'string' || photo instanceof String) && photo.indexOf('<') >= 0 && photo.indexOf('>') >= 0) {
                  return pb.renderObject(photo, index);
                }

                if (pb.params.swiper.lazy === true || pb.params.swiper.lazy && pb.params.swiper.lazy.enabled) {
                  return pb.renderLazyPhoto(photo, index);
                }

                return pb.renderPhoto(photo, index);
              }
            }
          });
        }

        var window = getWindow();
        pb.swiper = app.swiper ? app.swiper.create(pb.$swiperContainerEl, swiperParams) : new window.Swiper(pb.$swiperContainerEl, swiperParams);

        if (pb.activeIndex === 0) {
          pb.onSlideChange(pb.swiper);
        }

        if (pb.$el) {
          pb.$el.trigger('photobrowser:open');
        }

        pb.emit('local::open photoBrowserOpen', pb);
      };

      _proto.onOpened = function onOpened() {
        var pb = this;

        if (pb.$el && pb.params.type === 'standalone') {
          pb.$el.css('animation', 'none');
        }

        if (pb.$el) {
          pb.$el.trigger('photobrowser:opened');
        }

        pb.emit('local::opened photoBrowserOpened', pb);
      };

      _proto.onClose = function onClose() {
        var pb = this;
        if (pb.destroyed) return; // Destroy Swiper

        if (pb.swiper && pb.swiper.destroy) {
          pb.swiper.destroy(true, false);
          pb.swiper = null;
          delete pb.swiper;
        }

        if (pb.$el) {
          pb.$el.trigger('photobrowser:close');
        }

        pb.emit('local::close photoBrowserClose', pb);
      };

      _proto.onClosed = function onClosed() {
        var pb = this;
        if (pb.destroyed) return;
        pb.opened = false;
        pb.$el = null;
        pb.el = null;
        delete pb.$el;
        delete pb.el;

        if (pb.$el) {
          pb.$el.trigger('photobrowser:closed');
        }

        pb.emit('local::closed photoBrowserClosed', pb);
      } // Open
      ;

      _proto.openPage = function openPage() {
        var pb = this;
        if (pb.opened) return pb;
        var pageHtml = pb.renderPage();
        pb.view.router.navigate({
          url: pb.url,
          route: {
            content: pageHtml,
            path: pb.url,
            on: {
              pageBeforeIn: function pageBeforeIn(e, page) {
                pb.view.$el.addClass("with-photo-browser-page with-photo-browser-page-" + pb.params.theme);
                pb.onOpen('page', page.el);
              },
              pageAfterIn: function pageAfterIn(e, page) {
                pb.onOpened('page', page.el);
              },
              pageBeforeOut: function pageBeforeOut(e, page) {
                pb.view.$el.removeClass("with-photo-browser-page with-photo-browser-page-exposed with-photo-browser-page-" + pb.params.theme);
                pb.onClose('page', page.el);
              },
              pageAfterOut: function pageAfterOut(e, page) {
                pb.onClosed('page', page.el);
              }
            }
          }
        });
        return pb;
      };

      _proto.openStandalone = function openStandalone() {
        var pb = this;
        if (pb.opened) return pb;
        var standaloneHtml = pb.renderStandalone();
        var popupParams = {
          backdrop: false,
          content: standaloneHtml,
          on: {
            popupOpen: function popupOpen(popup) {
              pb.onOpen('popup', popup.el);
            },
            popupOpened: function popupOpened(popup) {
              pb.onOpened('popup', popup.el);
            },
            popupClose: function popupClose(popup) {
              pb.onClose('popup', popup.el);
            },
            popupClosed: function popupClosed(popup) {
              pb.onClosed('popup', popup.el);
            }
          }
        };

        if (pb.params.routableModals && pb.view) {
          pb.view.router.navigate({
            url: pb.url,
            route: {
              path: pb.url,
              popup: popupParams
            }
          });
        } else {
          pb.modal = pb.app.popup.create(popupParams).open();
        }

        return pb;
      };

      _proto.openPopup = function openPopup() {
        var pb = this;
        if (pb.opened) return pb;
        var popupHtml = pb.renderPopup();
        var popupParams = {
          content: popupHtml,
          push: pb.params.popupPush,
          on: {
            popupOpen: function popupOpen(popup) {
              pb.onOpen('popup', popup.el);
            },
            popupOpened: function popupOpened(popup) {
              pb.onOpened('popup', popup.el);
            },
            popupClose: function popupClose(popup) {
              pb.onClose('popup', popup.el);
            },
            popupClosed: function popupClosed(popup) {
              pb.onClosed('popup', popup.el);
            }
          }
        };

        if (pb.params.routableModals && pb.view) {
          pb.view.router.navigate({
            url: pb.url,
            route: {
              path: pb.url,
              popup: popupParams
            }
          });
        } else {
          pb.modal = pb.app.popup.create(popupParams).open();
        }

        return pb;
      } // Exposition
      ;

      _proto.expositionEnable = function expositionEnable() {
        var pb = this;

        if (pb.params.type === 'page') {
          pb.view.$el.addClass('with-photo-browser-page-exposed');
        }

        if (pb.$el) pb.$el.addClass('photo-browser-exposed');
        if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.addClass('photo-browser-captions-exposed');
        pb.exposed = true;
        return pb;
      };

      _proto.expositionDisable = function expositionDisable() {
        var pb = this;

        if (pb.params.type === 'page') {
          pb.view.$el.removeClass('with-photo-browser-page-exposed');
        }

        if (pb.$el) pb.$el.removeClass('photo-browser-exposed');
        if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.removeClass('photo-browser-captions-exposed');
        pb.exposed = false;
        return pb;
      };

      _proto.expositionToggle = function expositionToggle() {
        var pb = this;

        if (pb.params.type === 'page') {
          pb.view.$el.toggleClass('with-photo-browser-page-exposed');
        }

        if (pb.$el) pb.$el.toggleClass('photo-browser-exposed');
        if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.toggleClass('photo-browser-captions-exposed');
        pb.exposed = !pb.exposed;
        return pb;
      };

      _proto.open = function open(index) {
        var pb = this;
        var type = pb.params.type;

        if (pb.opened) {
          if (pb.swiper && typeof index !== 'undefined') {
            pb.swiper.slideTo(parseInt(index, 10));
          }

          return pb;
        }

        if (typeof index !== 'undefined') {
          pb.activeIndex = index;
        }

        if (type === 'standalone') {
          pb.openStandalone();
        }

        if (type === 'page') {
          pb.openPage();
        }

        if (type === 'popup') {
          pb.openPopup();
        }

        return pb;
      };

      _proto.close = function close() {
        var pb = this;
        if (!pb.opened) return pb;

        if (pb.params.routableModals && pb.view || pb.openedIn === 'page') {
          pb.view.router.back();
        } else {
          pb.modal.once('modalClosed', function () {
            nextTick$1(function () {
              if (pb.destroyed) return;
              pb.modal.destroy();
              delete pb.modal;
            });
          });
          pb.modal.close();
        }

        return pb;
      } // eslint-disable-next-line
      ;

      _proto.init = function init() {};

      _proto.destroy = function destroy() {
        var pb = this;
        pb.emit('local::beforeDestroy photoBrowserBeforeDestroy', pb);

        if (pb.$el) {
          pb.$el.trigger('photobrowser:beforedestroy');
          pb.$el[0].f7PhotoBrowser = null;
          delete pb.$el[0].f7PhotoBrowser;
        }

        deleteProps$1(pb);
        pb.destroyed = true;
        pb = null;
      };

      _createClass$2(PhotoBrowser, [{
        key: "view",
        get: function get() {
          var params = this.params,
              app = this.app;
          return params.view || app.views.main;
        }
      }]);

      return PhotoBrowser;
    }(Framework7Class$1);

    var PhotoBrowser$2 = PhotoBrowser$1;

    var PhotoBrowser = {
      name: 'photoBrowser',
      params: {
        photoBrowser: {
          photos: [],
          exposition: true,
          expositionHideCaptions: false,
          type: 'standalone',
          navbar: true,
          toolbar: true,
          theme: 'light',
          captionsTheme: undefined,
          iconsColor: undefined,
          popupPush: false,
          swipeToClose: true,
          pageBackLinkText: 'Back',
          popupCloseLinkText: 'Close',
          navbarOfText: 'of',
          navbarShowCount: undefined,
          view: undefined,
          url: 'photos/',
          routableModals: false,
          virtualSlides: true,
          renderNavbar: undefined,
          renderToolbar: undefined,
          renderCaption: undefined,
          renderObject: undefined,
          renderLazyPhoto: undefined,
          renderPhoto: undefined,
          renderPage: undefined,
          renderPopup: undefined,
          renderStandalone: undefined,
          swiper: {
            initialSlide: 0,
            spaceBetween: 20,
            speed: 300,
            loop: false,
            preloadImages: true,
            navigation: {
              nextEl: '.photo-browser-next',
              prevEl: '.photo-browser-prev'
            },
            zoom: {
              enabled: true,
              maxRatio: 3,
              minRatio: 1
            },
            lazy: {
              enabled: true
            }
          }
        }
      },
      create: function create() {
        var app = this;
        app.photoBrowser = ConstructorMethods({
          defaultSelector: '.photo-browser-popup, .photo-browser-page',
          constructor: PhotoBrowser$2,
          app: app,
          domProp: 'f7PhotoBrowser'
        });
      },
      static: {
        PhotoBrowser: PhotoBrowser$2
      }
    };

    function _assertThisInitialized$4(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$4(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$4(subClass, superClass); }

    function _setPrototypeOf$4(o, p) { _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$4(o, p); }

    var Notification$1 = /*#__PURE__*/function (_Modal) {
      _inheritsLoose$4(Notification, _Modal);

      function Notification(app, params) {
        var _this;

        var extendedParams = extend$2({
          on: {}
        }, app.params.notification, params); // Extends with open/close Modal methods;

        _this = _Modal.call(this, app, extendedParams) || this;

        var notification = _assertThisInitialized$4(_this);

        notification.app = app;
        notification.params = extendedParams;
        var _notification$params = notification.params,
            icon = _notification$params.icon,
            title = _notification$params.title,
            titleRightText = _notification$params.titleRightText,
            subtitle = _notification$params.subtitle,
            text = _notification$params.text,
            closeButton = _notification$params.closeButton,
            closeTimeout = _notification$params.closeTimeout,
            cssClass = _notification$params.cssClass,
            closeOnClick = _notification$params.closeOnClick;
        var $el;

        if (!notification.params.el) {
          // Find Element
          var notificationHtml = notification.render({
            icon: icon,
            title: title,
            titleRightText: titleRightText,
            subtitle: subtitle,
            text: text,
            closeButton: closeButton,
            cssClass: cssClass
          });
          $el = $(notificationHtml);
        } else {
          $el = $(notification.params.el);
        }

        if ($el && $el.length > 0 && $el[0].f7Modal) {
          return $el[0].f7Modal || _assertThisInitialized$4(_this);
        }

        if ($el.length === 0) {
          return notification.destroy() || _assertThisInitialized$4(_this);
        }

        extend$2(notification, {
          $el: $el,
          el: $el[0],
          type: 'notification'
        });
        $el[0].f7Modal = notification;

        if (closeButton) {
          $el.find('.notification-close-button').on('click', function () {
            notification.close();
          });
        }

        $el.on('click', function (e) {
          if (closeButton && $(e.target).closest('.notification-close-button').length) {
            return;
          }

          notification.emit('local::click notificationClick', notification);
          if (closeOnClick) notification.close();
        });
        notification.on('beforeDestroy', function () {
          $el.off('click');
        });
        /* Touch Events */

        var isTouched;
        var isMoved;
        var isScrolling;
        var touchesDiff;
        var touchStartTime;
        var notificationHeight;
        var touchesStart = {};

        function handleTouchStart(e) {
          if (isTouched) return;
          isTouched = true;
          isMoved = false;
          isScrolling = undefined;
          touchStartTime = now$2();
          touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        }

        function handleTouchMove(e) {
          if (!isTouched) return;
          var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
          var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

          if (typeof isScrolling === 'undefined') {
            isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) < Math.abs(pageX - touchesStart.x));
          }

          if (isScrolling) {
            isTouched = false;
            return;
          }

          e.preventDefault();

          if (!isMoved) {
            notification.$el.removeClass('notification-transitioning');
            notification.$el.transition(0);
            notificationHeight = notification.$el[0].offsetHeight / 2;
          }

          isMoved = true;
          touchesDiff = pageY - touchesStart.y;
          var newTranslate = touchesDiff;

          if (touchesDiff > 0) {
            newTranslate = Math.pow(touchesDiff, 0.8);
          }

          notification.$el.transform("translate3d(0, " + newTranslate + "px, 0)");
        }

        function handleTouchEnd() {
          if (!isTouched || !isMoved) {
            isTouched = false;
            isMoved = false;
            return;
          }

          isTouched = false;
          isMoved = false;

          if (touchesDiff === 0) {
            return;
          }

          var timeDiff = now$2() - touchStartTime;
          notification.$el.transition('');
          notification.$el.addClass('notification-transitioning');
          notification.$el.transform('');

          if (touchesDiff < -10 && timeDiff < 300 || -touchesDiff >= notificationHeight / 1) {
            notification.close();
          }
        }

        function attachTouchEvents() {
          notification.$el.on(app.touchEvents.start, handleTouchStart, {
            passive: true
          });
          app.on('touchmove:active', handleTouchMove);
          app.on('touchend:passive', handleTouchEnd);
        }

        function detachTouchEvents() {
          notification.$el.off(app.touchEvents.start, handleTouchStart, {
            passive: true
          });
          app.off('touchmove:active', handleTouchMove);
          app.off('touchend:passive', handleTouchEnd);
        }

        var timeoutId;

        function closeOnTimeout() {
          timeoutId = nextTick$1(function () {
            if (isTouched && isMoved) {
              closeOnTimeout();
              return;
            }

            notification.close();
          }, closeTimeout);
        }

        notification.on('open', function () {
          if (notification.params.swipeToClose) {
            attachTouchEvents();
          }

          $('.notification.modal-in').each(function (openedEl) {
            var notificationInstance = app.notification.get(openedEl);

            if (openedEl !== notification.el && notificationInstance) {
              notificationInstance.close();
            }
          });

          if (closeTimeout) {
            closeOnTimeout();
          }
        });
        notification.on('close beforeDestroy', function () {
          if (notification.params.swipeToClose) {
            detachTouchEvents();
          }

          clearTimeout(timeoutId);
        });
        return notification || _assertThisInitialized$4(_this);
      }

      var _proto = Notification.prototype;

      _proto.render = function render() {
        var notification = this;
        if (notification.params.render) return notification.params.render.call(notification, notification);
        var _notification$params2 = notification.params,
            icon = _notification$params2.icon,
            title = _notification$params2.title,
            titleRightText = _notification$params2.titleRightText,
            subtitle = _notification$params2.subtitle,
            text = _notification$params2.text,
            closeButton = _notification$params2.closeButton,
            cssClass = _notification$params2.cssClass;
        return $jsx$1("div", {
          class: "notification " + (cssClass || '')
        }, $jsx$1("div", {
          class: "notification-header"
        }, icon && $jsx$1("div", {
          class: "notification-icon"
        }, icon), title && $jsx$1("div", {
          class: "notification-title"
        }, title), titleRightText && $jsx$1("div", {
          class: "notification-title-right-text"
        }, titleRightText), closeButton && $jsx$1("span", {
          class: "notification-close-button"
        })), $jsx$1("div", {
          class: "notification-content"
        }, subtitle && $jsx$1("div", {
          class: "notification-subtitle"
        }, subtitle), text && $jsx$1("div", {
          class: "notification-text"
        }, text)));
      };

      return Notification;
    }(Modal$2);

    var Notification$2 = Notification$1;

    var Notification = {
      name: 'notification',
      static: {
        Notification: Notification$2
      },
      create: function create() {
        var app = this;
        app.notification = extend$2({}, ModalMethods({
          app: app,
          constructor: Notification$2,
          defaultSelector: '.notification.modal-in'
        }));
      },
      params: {
        notification: {
          icon: null,
          title: null,
          titleRightText: null,
          subtitle: null,
          text: null,
          closeButton: false,
          closeTimeout: null,
          closeOnClick: false,
          swipeToClose: true,
          cssClass: null,
          render: null,
          containerEl: null
        }
      }
    };

    function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }

    function _assertThisInitialized$3(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$3(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$3(subClass, superClass); }

    function _setPrototypeOf$3(o, p) { _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$3(o, p); }

    var Autocomplete$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$3(Autocomplete, _Framework7Class);

      function Autocomplete(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params, [app]) || this;

        var ac = _assertThisInitialized$3(_this);

        ac.app = app;
        var device = getDevice$1();
        var defaults = extend$2({
          on: {}
        }, app.params.autocomplete);

        if (typeof defaults.searchbarDisableButton === 'undefined') {
          defaults.searchbarDisableButton = app.theme !== 'aurora';
        } // Extend defaults with modules params


        ac.useModulesParams(defaults);
        ac.params = extend$2(defaults, params);
        var $openerEl;

        if (ac.params.openerEl) {
          $openerEl = $(ac.params.openerEl);
          if ($openerEl.length) $openerEl[0].f7Autocomplete = ac;
        }

        var $inputEl;

        if (ac.params.inputEl) {
          $inputEl = $(ac.params.inputEl);
          if ($inputEl.length) $inputEl[0].f7Autocomplete = ac;
        }

        var uniqueId = id();
        var url = params.url;

        if (!url && $openerEl && $openerEl.length) {
          if ($openerEl.attr('href')) url = $openerEl.attr('href');else if ($openerEl.find('a').length > 0) {
            url = $openerEl.find('a').attr('href');
          }
        }

        if (!url || url === '#' || url === '') url = ac.params.url;
        var inputType = ac.params.multiple ? 'checkbox' : 'radio';
        extend$2(ac, {
          $openerEl: $openerEl,
          openerEl: $openerEl && $openerEl[0],
          $inputEl: $inputEl,
          inputEl: $inputEl && $inputEl[0],
          id: uniqueId,
          url: url,
          value: ac.params.value || [],
          inputType: inputType,
          inputName: inputType + "-" + uniqueId,
          $modalEl: undefined,
          $dropdownEl: undefined
        });
        var previousQuery = '';

        function onInputChange() {
          var query = ac.$inputEl.val().trim();
          if (!ac.params.source) return;
          ac.params.source.call(ac, query, function (items) {
            var itemsHTML = '';
            var limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
            ac.items = items;
            var regExp;

            if (ac.params.highlightMatches) {
              query = query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
              regExp = new RegExp("(" + query + ")", 'i');
            }

            var firstValue;
            var firstItem;

            for (var i = 0; i < limit; i += 1) {
              var itemValue = typeof items[i] === 'object' ? items[i][ac.params.valueProperty] : items[i];
              var itemText = typeof items[i] === 'object' ? items[i][ac.params.textProperty] : items[i];

              if (i === 0) {
                firstValue = itemValue;
                firstItem = ac.items[i];
              }

              itemsHTML += ac.renderItem({
                value: itemValue,
                text: ac.params.highlightMatches ? itemText.replace(regExp, '<b>$1</b>') : itemText
              }, i);
            }

            if (itemsHTML === '' && query === '' && ac.params.dropdownPlaceholderText) {
              itemsHTML += ac.renderItem({
                placeholder: true,
                text: ac.params.dropdownPlaceholderText
              });
            }

            ac.$dropdownEl.find('ul').html(itemsHTML);

            if (ac.params.typeahead) {
              if (!firstValue || !firstItem) {
                return;
              }

              if (firstValue.toLowerCase().indexOf(query.toLowerCase()) !== 0) {
                return;
              }

              if (previousQuery.toLowerCase() === query.toLowerCase()) {
                ac.value = [];
                return;
              }

              if (previousQuery.toLowerCase().indexOf(query.toLowerCase()) === 0) {
                previousQuery = query;
                ac.value = [];
                return;
              }

              $inputEl.val(firstValue);
              $inputEl[0].setSelectionRange(query.length, firstValue.length);
              var previousValue = typeof ac.value[0] === 'object' ? ac.value[0][ac.params.valueProperty] : ac.value[0];

              if (!previousValue || firstValue.toLowerCase() !== previousValue.toLowerCase()) {
                ac.value = [firstItem];
                ac.emit('local::change autocompleteChange', [firstItem]);
              }
            }

            previousQuery = query;
          });
        }

        function onPageInputChange() {
          var inputEl = this;
          var value = inputEl.value;
          var isValues = $(inputEl).parents('.autocomplete-values').length > 0;
          var item;
          var itemValue;
          var aValue;

          if (isValues) {
            if (ac.inputType === 'checkbox' && !inputEl.checked) {
              for (var i = 0; i < ac.value.length; i += 1) {
                aValue = typeof ac.value[i] === 'string' ? ac.value[i] : ac.value[i][ac.params.valueProperty];

                if (aValue === value || aValue * 1 === value * 1) {
                  ac.value.splice(i, 1);
                }
              }

              ac.updateValues();
              ac.emit('local::change autocompleteChange', ac.value);
            }

            return;
          } // Find Related Item


          for (var _i = 0; _i < ac.items.length; _i += 1) {
            itemValue = typeof ac.items[_i] === 'object' ? ac.items[_i][ac.params.valueProperty] : ac.items[_i];
            if (itemValue === value || itemValue * 1 === value * 1) item = ac.items[_i];
          }

          if (ac.inputType === 'radio') {
            ac.value = [item];
          } else if (inputEl.checked) {
            ac.value.push(item);
          } else {
            for (var _i2 = 0; _i2 < ac.value.length; _i2 += 1) {
              aValue = typeof ac.value[_i2] === 'object' ? ac.value[_i2][ac.params.valueProperty] : ac.value[_i2];

              if (aValue === value || aValue * 1 === value * 1) {
                ac.value.splice(_i2, 1);
              }
            }
          } // Update Values Block


          ac.updateValues(); // On Select Callback

          if (ac.inputType === 'radio' && inputEl.checked || ac.inputType === 'checkbox') {
            ac.emit('local::change autocompleteChange', ac.value);
          }
        }

        function onHtmlClick(e) {
          var $targetEl = $(e.target);
          if ($targetEl.is(ac.$inputEl[0]) || ac.$dropdownEl && $targetEl.closest(ac.$dropdownEl[0]).length) return;
          ac.close();
        }

        function onOpenerClick() {
          ac.open();
        }

        function onInputFocus() {
          ac.open();
        }

        function onInputBlur() {
          if (ac.$dropdownEl.find('label.active-state').length > 0) return;
          setTimeout(function () {
            ac.close();
          }, 0);
        }

        function onResize() {
          ac.positionDropdown();
        }

        function onKeyDown(e) {
          if (!ac.opened) return;

          if (e.keyCode === 27) {
            // ESC
            e.preventDefault();
            ac.$inputEl.blur();
            return;
          }

          if (e.keyCode === 13) {
            // Enter
            var $selectedItemLabel = ac.$dropdownEl.find('.autocomplete-dropdown-selected label');

            if ($selectedItemLabel.length) {
              e.preventDefault();
              $selectedItemLabel.trigger('click');
              ac.$inputEl.blur();
              return;
            }

            if (ac.params.typeahead) {
              e.preventDefault();
              ac.$inputEl.blur();
            }

            return;
          }

          if (e.keyCode !== 40 && e.keyCode !== 38) return;
          e.preventDefault();
          var $selectedItem = ac.$dropdownEl.find('.autocomplete-dropdown-selected');
          var $newItem;

          if ($selectedItem.length) {
            $newItem = $selectedItem[e.keyCode === 40 ? 'next' : 'prev']('li');

            if (!$newItem.length) {
              $newItem = ac.$dropdownEl.find('li').eq(e.keyCode === 40 ? 0 : ac.$dropdownEl.find('li').length - 1);
            }
          } else {
            $newItem = ac.$dropdownEl.find('li').eq(e.keyCode === 40 ? 0 : ac.$dropdownEl.find('li').length - 1);
          }

          if ($newItem.hasClass('autocomplete-dropdown-placeholder')) return;
          $selectedItem.removeClass('autocomplete-dropdown-selected');
          $newItem.addClass('autocomplete-dropdown-selected');
        }

        function onDropdownClick() {
          var $clickedEl = $(this);
          var clickedItem;

          for (var i = 0; i < ac.items.length; i += 1) {
            var itemValue = typeof ac.items[i] === 'object' ? ac.items[i][ac.params.valueProperty] : ac.items[i];
            var value = $clickedEl.attr('data-value');

            if (itemValue === value || itemValue * 1 === value * 1) {
              clickedItem = ac.items[i];
            }
          }

          if (ac.params.updateInputValueOnSelect) {
            ac.$inputEl.val(typeof clickedItem === 'object' ? clickedItem[ac.params.valueProperty] : clickedItem);
            ac.$inputEl.trigger('input change');
          }

          ac.value = [clickedItem];
          ac.emit('local::change autocompleteChange', [clickedItem]);
          ac.close();
        }

        ac.attachEvents = function attachEvents() {
          if (ac.params.openIn !== 'dropdown' && ac.$openerEl) {
            ac.$openerEl.on('click', onOpenerClick);
          }

          if (ac.params.openIn === 'dropdown' && ac.$inputEl) {
            ac.$inputEl.on('focus', onInputFocus);
            ac.$inputEl.on(ac.params.inputEvents, onInputChange);

            if (device.android) {
              $('html').on('click', onHtmlClick);
            } else {
              ac.$inputEl.on('blur', onInputBlur);
            }

            ac.$inputEl.on('keydown', onKeyDown);
          }
        };

        ac.detachEvents = function attachEvents() {
          if (ac.params.openIn !== 'dropdown' && ac.$openerEl) {
            ac.$openerEl.off('click', onOpenerClick);
          }

          if (ac.params.openIn === 'dropdown' && ac.$inputEl) {
            ac.$inputEl.off('focus', onInputFocus);
            ac.$inputEl.off(ac.params.inputEvents, onInputChange);

            if (device.android) {
              $('html').off('click', onHtmlClick);
            } else {
              ac.$inputEl.off('blur', onInputBlur);
            }

            ac.$inputEl.off('keydown', onKeyDown);
          }
        };

        ac.attachDropdownEvents = function attachDropdownEvents() {
          ac.$dropdownEl.on('click', 'label', onDropdownClick);
          app.on('resize', onResize);
        };

        ac.detachDropdownEvents = function detachDropdownEvents() {
          ac.$dropdownEl.off('click', 'label', onDropdownClick);
          app.off('resize', onResize);
        };

        ac.attachPageEvents = function attachPageEvents() {
          ac.$el.on('change', 'input[type="radio"], input[type="checkbox"]', onPageInputChange);

          if (ac.params.closeOnSelect && !ac.params.multiple) {
            ac.$el.once('click', '.list label', function () {
              nextTick$1(function () {
                ac.close();
              });
            });
          }
        };

        ac.detachPageEvents = function detachPageEvents() {
          ac.$el.off('change', 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
        }; // Install Modules


        ac.useModules(); // Init

        ac.init();
        return ac || _assertThisInitialized$3(_this);
      }

      var _proto = Autocomplete.prototype;

      _proto.positionDropdown = function positionDropdown() {
        var _$dropdownEl$children;

        var ac = this;
        var $inputEl = ac.$inputEl,
            app = ac.app,
            $dropdownEl = ac.$dropdownEl;
        var $pageContentEl = $inputEl.parents('.page-content');
        if ($pageContentEl.length === 0) return;
        var inputOffset = $inputEl.offset();
        var inputOffsetWidth = $inputEl[0].offsetWidth;
        var inputOffsetHeight = $inputEl[0].offsetHeight;
        var $listEl = $inputEl.parents('.list');
        var $listParent;
        $listEl.parents().each(function (parentEl) {
          if ($listParent) return;
          var $parentEl = $(parentEl);
          if ($parentEl.parent($pageContentEl).length) $listParent = $parentEl;
        });
        var listOffset = $listEl.offset();
        var paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
        var listOffsetLeft = $listEl.length > 0 ? listOffset.left - $pageContentEl.offset().left : 0;
        var inputOffsetLeft = inputOffset.left - ($listEl.length > 0 ? listOffset.left : 0) - (app.rtl ? 0 : 0);
        var inputOffsetTop = inputOffset.top - ($pageContentEl.offset().top - $pageContentEl[0].scrollTop);
        var maxHeight = $pageContentEl[0].scrollHeight - paddingBottom - (inputOffsetTop + $pageContentEl[0].scrollTop) - $inputEl[0].offsetHeight;
        var paddingProp = app.rtl ? 'padding-right' : 'padding-left';
        var paddingValue;

        if ($listEl.length && !ac.params.expandInput) {
          paddingValue = (app.rtl ? $listEl[0].offsetWidth - inputOffsetLeft - inputOffsetWidth : inputOffsetLeft) - (app.theme === 'md' ? 16 : 15);
        }

        $dropdownEl.css({
          left: ($listEl.length > 0 ? listOffsetLeft : inputOffsetLeft) + "px",
          top: inputOffsetTop + $pageContentEl[0].scrollTop + inputOffsetHeight + "px",
          width: ($listEl.length > 0 ? $listEl[0].offsetWidth : inputOffsetWidth) + "px"
        });
        $dropdownEl.children('.autocomplete-dropdown-inner').css((_$dropdownEl$children = {
          maxHeight: maxHeight + "px"
        }, _$dropdownEl$children[paddingProp] = $listEl.length > 0 && !ac.params.expandInput ? paddingValue + "px" : '', _$dropdownEl$children));
      };

      _proto.focus = function focus() {
        var ac = this;
        ac.$el.find('input[type=search]').focus();
      };

      _proto.source = function source(query) {
        var ac = this;
        if (!ac.params.source) return;
        var $el = ac.$el;
        ac.params.source.call(ac, query, function (items) {
          var itemsHTML = '';
          var limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
          ac.items = items;

          for (var i = 0; i < limit; i += 1) {
            var selected = false;
            var itemValue = typeof items[i] === 'object' ? items[i][ac.params.valueProperty] : items[i];

            for (var j = 0; j < ac.value.length; j += 1) {
              var aValue = typeof ac.value[j] === 'object' ? ac.value[j][ac.params.valueProperty] : ac.value[j];
              if (aValue === itemValue || aValue * 1 === itemValue * 1) selected = true;
            }

            itemsHTML += ac.renderItem({
              value: itemValue,
              text: typeof items[i] === 'object' ? items[i][ac.params.textProperty] : items[i],
              inputType: ac.inputType,
              id: ac.id,
              inputName: ac.inputName,
              selected: selected
            }, i);
          }

          $el.find('.autocomplete-found ul').html(itemsHTML);

          if (items.length === 0) {
            if (query.length !== 0) {
              $el.find('.autocomplete-not-found').show();
              $el.find('.autocomplete-found, .autocomplete-values').hide();
            } else {
              $el.find('.autocomplete-values').show();
              $el.find('.autocomplete-found, .autocomplete-not-found').hide();
            }
          } else {
            $el.find('.autocomplete-found').show();
            $el.find('.autocomplete-not-found, .autocomplete-values').hide();
          }
        });
      };

      _proto.updateValues = function updateValues() {
        var ac = this;
        var valuesHTML = '';

        for (var i = 0; i < ac.value.length; i += 1) {
          valuesHTML += ac.renderItem({
            value: typeof ac.value[i] === 'object' ? ac.value[i][ac.params.valueProperty] : ac.value[i],
            text: typeof ac.value[i] === 'object' ? ac.value[i][ac.params.textProperty] : ac.value[i],
            inputType: ac.inputType,
            id: ac.id,
            inputName: ac.inputName + "-checked}",
            selected: true
          }, i);
        }

        ac.$el.find('.autocomplete-values ul').html(valuesHTML);
      };

      _proto.preloaderHide = function preloaderHide() {
        var ac = this;

        if (ac.params.openIn === 'dropdown' && ac.$dropdownEl) {
          ac.$dropdownEl.find('.autocomplete-preloader').removeClass('autocomplete-preloader-visible');
        } else {
          $('.autocomplete-preloader').removeClass('autocomplete-preloader-visible');
        }
      };

      _proto.preloaderShow = function preloaderShow() {
        var ac = this;

        if (ac.params.openIn === 'dropdown' && ac.$dropdownEl) {
          ac.$dropdownEl.find('.autocomplete-preloader').addClass('autocomplete-preloader-visible');
        } else {
          $('.autocomplete-preloader').addClass('autocomplete-preloader-visible');
        }
      };

      _proto.renderPreloader = function renderPreloader() {
        var ac = this;
        var preloaders = {
          iosPreloaderContent: iosPreloaderContent,
          mdPreloaderContent: mdPreloaderContent,
          auroraPreloaderContent: auroraPreloaderContent
        };
        return $jsx$1("div", {
          class: "autocomplete-preloader preloader " + (ac.params.preloaderColor ? "color-" + ac.params.preloaderColor : '')
        }, preloaders[ac.app.theme + "PreloaderContent"] || '');
      };

      _proto.renderSearchbar = function renderSearchbar() {
        var ac = this;
        if (ac.params.renderSearchbar) return ac.params.renderSearchbar.call(ac);
        return $jsx$1("form", {
          class: "searchbar"
        }, $jsx$1("div", {
          class: "searchbar-inner"
        }, $jsx$1("div", {
          class: "searchbar-input-wrap"
        }, $jsx$1("input", {
          type: "search",
          spellcheck: ac.params.searchbarSpellcheck || 'false',
          placeholder: ac.params.searchbarPlaceholder
        }), $jsx$1("i", {
          class: "searchbar-icon"
        }), $jsx$1("span", {
          class: "input-clear-button"
        })), ac.params.searchbarDisableButton && $jsx$1("span", {
          class: "searchbar-disable-button"
        }, ac.params.searchbarDisableText)));
      };

      _proto.renderItem = function renderItem(item, index) {
        var ac = this;
        if (ac.params.renderItem) return ac.params.renderItem.call(ac, item, index);
        var itemValue = item.value && typeof item.value === 'string' ? item.value.replace(/"/g, '&quot;') : item.value;

        if (ac.params.openIn !== 'dropdown') {
          return $jsx$1("li", null, $jsx$1("label", {
            class: "item-" + item.inputType + " item-content"
          }, $jsx$1("input", {
            type: item.inputType,
            name: item.inputName,
            value: itemValue,
            _checked: item.selected
          }), $jsx$1("i", {
            class: "icon icon-" + item.inputType
          }), $jsx$1("div", {
            class: "item-inner"
          }, $jsx$1("div", {
            class: "item-title"
          }, item.text))));
        } // Dropdown


        if (!item.placeholder) {
          return $jsx$1("li", null, $jsx$1("label", {
            class: "item-radio item-content",
            "data-value": itemValue
          }, $jsx$1("div", {
            class: "item-inner"
          }, $jsx$1("div", {
            class: "item-title"
          }, item.text))));
        } // Dropwdown placeholder


        return $jsx$1("li", {
          class: "autocomplete-dropdown-placeholder"
        }, $jsx$1("label", {
          class: "item-content"
        }, $jsx$1("div", {
          class: "item-inner"
        }, $jsx$1("div", {
          class: "item-title"
        }, item.text))));
      };

      _proto.renderNavbar = function renderNavbar() {
        var ac = this;
        if (ac.params.renderNavbar) return ac.params.renderNavbar.call(ac);
        var pageTitle = ac.params.pageTitle;

        if (typeof pageTitle === 'undefined' && ac.$openerEl && ac.$openerEl.length) {
          pageTitle = ac.$openerEl.find('.item-title').text().trim();
        }

        var inPopup = ac.params.openIn === 'popup'; // eslint-disable-next-line

        var navbarLeft = inPopup ? ac.params.preloader && $jsx$1("div", {
          class: "left"
        }, ac.renderPreloader()) : $jsx$1("div", {
          class: "left sliding"
        }, $jsx$1("a", {
          class: "link back"
        }, $jsx$1("i", {
          class: "icon icon-back"
        }), $jsx$1("span", {
          class: "if-not-md"
        }, ac.params.pageBackLinkText)));
        var navbarRight = inPopup ? $jsx$1("div", {
          class: "right"
        }, $jsx$1("a", {
          class: "link popup-close",
          "data-popup": ".autocomplete-popup"
        }, ac.params.popupCloseLinkText)) : ac.params.preloader && $jsx$1("div", {
          class: "right"
        }, ac.renderPreloader());
        return $jsx$1("div", {
          class: "navbar " + (ac.params.navbarColorTheme ? "color-" + ac.params.navbarColorTheme : '')
        }, $jsx$1("div", {
          class: "navbar-bg"
        }), $jsx$1("div", {
          class: "navbar-inner " + (ac.params.navbarColorTheme ? "color-" + ac.params.navbarColorTheme : '')
        }, navbarLeft, pageTitle && $jsx$1("div", {
          class: "title sliding"
        }, pageTitle), navbarRight, $jsx$1("div", {
          class: "subnavbar sliding"
        }, ac.renderSearchbar())));
      };

      _proto.renderDropdown = function renderDropdown() {
        var ac = this;
        if (ac.params.renderDropdown) return ac.params.renderDropdown.call(ac, ac.items);
        return $jsx$1("div", {
          class: "autocomplete-dropdown"
        }, $jsx$1("div", {
          class: "autocomplete-dropdown-inner"
        }, $jsx$1("div", {
          class: "list " + (!ac.params.expandInput ? 'no-safe-areas' : '')
        }, $jsx$1("ul", null))), ac.params.preloader && ac.renderPreloader());
      };

      _proto.renderPage = function renderPage(inPopup) {
        var ac = this;
        if (ac.params.renderPage) return ac.params.renderPage.call(ac, ac.items);
        return $jsx$1("div", {
          class: "page page-with-subnavbar autocomplete-page",
          "data-name": "autocomplete-page"
        }, ac.renderNavbar(inPopup), $jsx$1("div", {
          class: "searchbar-backdrop"
        }), $jsx$1("div", {
          class: "page-content"
        }, $jsx$1("div", {
          class: "list autocomplete-list autocomplete-found autocomplete-list-" + ac.id + " " + (ac.params.formColorTheme ? "color-" + ac.params.formColorTheme : '')
        }, $jsx$1("ul", null)), $jsx$1("div", {
          class: "list autocomplete-not-found"
        }, $jsx$1("ul", null, $jsx$1("li", {
          class: "item-content"
        }, $jsx$1("div", {
          class: "item-inner"
        }, $jsx$1("div", {
          class: "item-title"
        }, ac.params.notFoundText))))), $jsx$1("div", {
          class: "list autocomplete-values"
        }, $jsx$1("ul", null))));
      };

      _proto.renderPopup = function renderPopup() {
        var ac = this;
        if (ac.params.renderPopup) return ac.params.renderPopup.call(ac, ac.items);
        return $jsx$1("div", {
          class: "popup autocomplete-popup"
        }, $jsx$1("div", {
          class: "view"
        }, ac.renderPage(true), ";"));
      };

      _proto.onOpen = function onOpen(type, el) {
        var ac = this;
        var app = ac.app;
        var $el = $(el);
        ac.$el = $el;
        ac.el = $el[0];
        ac.openedIn = type;
        ac.opened = true;

        if (ac.params.openIn === 'dropdown') {
          ac.attachDropdownEvents();
          ac.$dropdownEl.addClass('autocomplete-dropdown-in');
          ac.$inputEl.trigger('input');
        } else {
          // Init SB
          var $searchbarEl = $el.find('.searchbar');

          if (ac.params.openIn === 'page' && app.theme === 'ios' && $searchbarEl.length === 0) {
            $searchbarEl = $(app.navbar.getElByPage($el)).find('.searchbar');
          }

          ac.searchbar = app.searchbar.create({
            el: $searchbarEl,
            backdropEl: $el.find('.searchbar-backdrop'),
            customSearch: true,
            on: {
              search: function search(sb, query) {
                if (query.length === 0 && ac.searchbar.enabled) {
                  ac.searchbar.backdropShow();
                } else {
                  ac.searchbar.backdropHide();
                }

                ac.source(query);
              }
            }
          }); // Attach page events

          ac.attachPageEvents(); // Update Values On Page Init

          ac.updateValues(); // Source on load

          if (ac.params.requestSourceOnOpen) ac.source('');
        }

        ac.emit('local::open autocompleteOpen', ac);
      };

      _proto.autoFocus = function autoFocus() {
        var ac = this;

        if (ac.searchbar && ac.searchbar.$inputEl) {
          ac.searchbar.$inputEl.focus();
        }

        return ac;
      };

      _proto.onOpened = function onOpened() {
        var ac = this;

        if (ac.params.openIn !== 'dropdown' && ac.params.autoFocus) {
          ac.autoFocus();
        }

        ac.emit('local::opened autocompleteOpened', ac);
      };

      _proto.onClose = function onClose() {
        var ac = this;
        if (ac.destroyed) return; // Destroy SB

        if (ac.searchbar && ac.searchbar.destroy) {
          ac.searchbar.destroy();
          ac.searchbar = null;
          delete ac.searchbar;
        }

        if (ac.params.openIn === 'dropdown') {
          ac.detachDropdownEvents();
          ac.$dropdownEl.removeClass('autocomplete-dropdown-in').remove();
          ac.$inputEl.parents('.item-content-dropdown-expanded').removeClass('item-content-dropdown-expanded');
        } else {
          ac.detachPageEvents();
        }

        ac.emit('local::close autocompleteClose', ac);
      };

      _proto.onClosed = function onClosed() {
        var ac = this;
        if (ac.destroyed) return;
        ac.opened = false;
        ac.$el = null;
        ac.el = null;
        delete ac.$el;
        delete ac.el;
        ac.emit('local::closed autocompleteClosed', ac);
      };

      _proto.openPage = function openPage() {
        var ac = this;
        if (ac.opened) return ac;
        var pageHtml = ac.renderPage();
        ac.view.router.navigate({
          url: ac.url,
          route: {
            content: pageHtml,
            path: ac.url,
            on: {
              pageBeforeIn: function pageBeforeIn(e, page) {
                ac.onOpen('page', page.el);
              },
              pageAfterIn: function pageAfterIn(e, page) {
                ac.onOpened('page', page.el);
              },
              pageBeforeOut: function pageBeforeOut(e, page) {
                ac.onClose('page', page.el);
              },
              pageAfterOut: function pageAfterOut(e, page) {
                ac.onClosed('page', page.el);
              }
            },
            options: {
              animate: ac.params.animate
            }
          }
        });
        return ac;
      };

      _proto.openPopup = function openPopup() {
        var ac = this;
        if (ac.opened) return ac;
        var popupHtml = ac.renderPopup();
        var popupParams = {
          content: popupHtml,
          animate: ac.params.animate,
          push: ac.params.popupPush,
          swipeToClose: ac.params.popupSwipeToClose,
          on: {
            popupOpen: function popupOpen(popup) {
              ac.onOpen('popup', popup.el);
            },
            popupOpened: function popupOpened(popup) {
              ac.onOpened('popup', popup.el);
            },
            popupClose: function popupClose(popup) {
              ac.onClose('popup', popup.el);
            },
            popupClosed: function popupClosed(popup) {
              ac.onClosed('popup', popup.el);
            }
          }
        };

        if (ac.params.routableModals && ac.view) {
          ac.view.router.navigate({
            url: ac.url,
            route: {
              path: ac.url,
              popup: popupParams
            }
          });
        } else {
          ac.modal = ac.app.popup.create(popupParams).open(ac.params.animate);
        }

        return ac;
      };

      _proto.openDropdown = function openDropdown() {
        var ac = this;

        if (!ac.$dropdownEl) {
          ac.$dropdownEl = $(ac.renderDropdown());
        }

        var $listEl = ac.$inputEl.parents('.list');

        if ($listEl.length && ac.$inputEl.parents('.item-content').length > 0 && ac.params.expandInput) {
          ac.$inputEl.parents('.item-content').addClass('item-content-dropdown-expanded');
        }

        var $pageContentEl = ac.$inputEl.parents('.page-content');

        if (ac.params.dropdownContainerEl) {
          $(ac.params.dropdownContainerEl).append(ac.$dropdownEl);
        } else if ($pageContentEl.length === 0) {
          ac.$dropdownEl.insertAfter(ac.$inputEl);
        } else {
          ac.positionDropdown();
          $pageContentEl.append(ac.$dropdownEl);
        }

        ac.onOpen('dropdown', ac.$dropdownEl);
        ac.onOpened('dropdown', ac.$dropdownEl);
      };

      _proto.open = function open() {
        var ac = this;
        if (ac.opened) return ac;
        var openIn = ac.params.openIn;
        ac["open" + openIn.split('').map(function (el, index) {
          if (index === 0) return el.toUpperCase();
          return el;
        }).join('')]();
        return ac;
      };

      _proto.close = function close() {
        var ac = this;
        if (!ac.opened) return ac;

        if (ac.params.openIn === 'dropdown') {
          ac.onClose();
          ac.onClosed();
        } else if (ac.params.routableModals && ac.view || ac.openedIn === 'page') {
          ac.view.router.back({
            animate: ac.params.animate
          });
        } else {
          ac.modal.once('modalClosed', function () {
            nextTick$1(function () {
              if (ac.destroyed) return;
              ac.modal.destroy();
              delete ac.modal;
            });
          });
          ac.modal.close();
        }

        return ac;
      };

      _proto.init = function init() {
        var ac = this;
        ac.attachEvents();
      };

      _proto.destroy = function destroy() {
        var ac = this;
        ac.emit('local::beforeDestroy autocompleteBeforeDestroy', ac);
        ac.detachEvents();

        if (ac.$inputEl && ac.$inputEl[0]) {
          delete ac.$inputEl[0].f7Autocomplete;
        }

        if (ac.$openerEl && ac.$openerEl[0]) {
          delete ac.$openerEl[0].f7Autocomplete;
        }

        deleteProps$1(ac);
        ac.destroyed = true;
      };

      _createClass$1(Autocomplete, [{
        key: "view",
        get: function get() {
          var ac = this;
          var $openerEl = ac.$openerEl,
              $inputEl = ac.$inputEl,
              app = ac.app;
          var view;

          if (ac.params.view) {
            view = ac.params.view;
          } else if ($openerEl || $inputEl) {
            var $el = $openerEl || $inputEl;
            view = $el.closest('.view').length && $el.closest('.view')[0].f7View;
          }

          if (!view) view = app.views.main;
          return view;
        }
      }]);

      return Autocomplete;
    }(Framework7Class$1);

    var Autocomplete$2 = Autocomplete$1;

    var Autocomplete = {
      name: 'autocomplete',
      params: {
        autocomplete: {
          openerEl: undefined,
          inputEl: undefined,
          view: undefined,
          // DropDown
          dropdownContainerEl: undefined,
          dropdownPlaceholderText: undefined,
          typeahead: false,
          highlightMatches: true,
          expandInput: false,
          updateInputValueOnSelect: true,
          inputEvents: 'input',
          value: undefined,
          multiple: false,
          source: undefined,
          limit: undefined,
          valueProperty: 'id',
          textProperty: 'text',
          openIn: 'page',
          // or 'popup' or 'dropdown'
          pageBackLinkText: 'Back',
          popupCloseLinkText: 'Close',
          pageTitle: undefined,
          searchbarPlaceholder: 'Search...',
          searchbarDisableText: 'Cancel',
          searchbarDisableButton: undefined,
          searchbarSpellcheck: false,
          popupPush: false,
          popupSwipeToClose: undefined,
          animate: true,
          autoFocus: false,
          closeOnSelect: false,
          notFoundText: 'Nothing found',
          requestSourceOnOpen: false,
          // Preloader
          preloaderColor: undefined,
          preloader: false,
          // Colors
          formColorTheme: undefined,
          navbarColorTheme: undefined,
          // Routing
          routableModals: false,
          url: 'select/',
          // Custom render functions
          renderDropdown: undefined,
          renderPage: undefined,
          renderPopup: undefined,
          renderItem: undefined,
          renderSearchbar: undefined,
          renderNavbar: undefined
        }
      },
      static: {
        Autocomplete: Autocomplete$2
      },
      create: function create() {
        var app = this;
        app.autocomplete = extend$2(ConstructorMethods({
          defaultSelector: undefined,
          constructor: Autocomplete$2,
          app: app,
          domProp: 'f7Autocomplete'
        }), {
          open: function open(autocompleteEl) {
            var ac = app.autocomplete.get(autocompleteEl);
            if (ac && ac.open) return ac.open();
            return undefined;
          },
          close: function close(autocompleteEl) {
            var ac = app.autocomplete.get(autocompleteEl);
            if (ac && ac.close) return ac.close();
            return undefined;
          }
        });
      }
    };

    function _assertThisInitialized$2(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$2(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$2(subClass, superClass); }

    function _setPrototypeOf$2(o, p) { _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$2(o, p); }

    var Tooltip$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$2(Tooltip, _Framework7Class);

      function Tooltip(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params, [app]) || this;

        var tooltip = _assertThisInitialized$2(_this);

        var support = getSupport$1();
        var defaults = extend$2({}, app.params.tooltip);
        var document = getDocument(); // Extend defaults with modules params

        tooltip.useModulesParams(defaults);
        tooltip.params = extend$2(defaults, params);

        if (typeof params.offset === 'undefined' && support.touch && tooltip.params.trigger === 'hover') {
          tooltip.params.offset = 10;
        }

        var _tooltip$params = tooltip.params,
            targetEl = _tooltip$params.targetEl,
            containerEl = _tooltip$params.containerEl;
        if (!targetEl && !tooltip.params.delegated) return tooltip || _assertThisInitialized$2(_this);
        var $targetEl = $(targetEl);
        if ($targetEl.length === 0 && !tooltip.params.delegated) return tooltip || _assertThisInitialized$2(_this);
        if ($targetEl[0] && $targetEl[0].f7Tooltip && !tooltip.params.delegated) return $targetEl[0].f7Tooltip || _assertThisInitialized$2(_this);
        var $containerEl = $(containerEl || app.$el).eq(0);

        if ($containerEl.length === 0) {
          $containerEl = app.$el;
        }

        var $el = $(tooltip.render()).eq(0);
        extend$2(tooltip, {
          app: app,
          $targetEl: $targetEl,
          targetEl: $targetEl && $targetEl[0],
          $containerEl: $containerEl,
          containerEl: $containerEl && $containerEl[0],
          $el: $el,
          el: $el && $el[0],
          text: tooltip.params.text || '',
          visible: false,
          opened: false
        });
        if ($targetEl[0]) $targetEl[0].f7Tooltip = tooltip;
        var touchesStart = {};
        var isTouched;

        function handleClick() {
          if (tooltip.opened) tooltip.hide();else tooltip.show(this);
        }

        function handleClickOut(e) {
          if (tooltip.opened && ($(e.target).closest($targetEl).length || $(e.target).closest(tooltip.$el).length)) return;
          tooltip.hide();
        }

        function handleTouchStart(e) {
          if (isTouched) return;
          isTouched = true;
          touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
          tooltip.show(this);
        }

        function handleTouchMove(e) {
          if (!isTouched) return;
          var x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
          var y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
          var distance = Math.pow(Math.pow(x - touchesStart.x, 2) + Math.pow(y - touchesStart.y, 2), 0.5);

          if (distance > 50) {
            isTouched = false;
            tooltip.hide();
          }
        }

        function handleTouchEnd() {
          if (!isTouched) return;
          isTouched = false;
          tooltip.hide();
        }

        function handleMouseEnter() {
          tooltip.show(this);
        }

        function handleMouseLeave() {
          tooltip.hide();
        }

        function handleTransitionEnd() {
          if (!$el.hasClass('tooltip-in')) {
            $el.removeClass('tooltip-out').remove();
          }
        }

        tooltip.attachEvents = function attachEvents() {
          $el.on('transitionend', handleTransitionEnd);

          if (tooltip.params.trigger === 'click') {
            if (tooltip.params.delegated) {
              $(document).on('click', tooltip.params.targetEl, handleClick);
            } else {
              tooltip.$targetEl.on('click', handleClick);
            }

            $('html').on('click', handleClickOut);
            return;
          }

          if (tooltip.params.trigger === 'manual') return;

          if (support.touch) {
            var passive = support.passiveListener ? {
              passive: true
            } : false;

            if (tooltip.params.delegated) {
              $(document).on(app.touchEvents.start, tooltip.params.targetEl, handleTouchStart, passive);
            } else {
              tooltip.$targetEl.on(app.touchEvents.start, handleTouchStart, passive);
            }

            app.on('touchmove', handleTouchMove);
            app.on('touchend:passive', handleTouchEnd);
          } else {
            // eslint-disable-next-line
            if (tooltip.params.delegated) {
              $(document).on(support.pointerEvents ? 'pointerenter' : 'mouseenter', tooltip.params.targetEl, handleMouseEnter, true);
              $(document).on(support.pointerEvents ? 'pointerleave' : 'mouseleave', tooltip.params.targetEl, handleMouseLeave, true);
            } else {
              tooltip.$targetEl.on(support.pointerEvents ? 'pointerenter' : 'mouseenter', handleMouseEnter);
              tooltip.$targetEl.on(support.pointerEvents ? 'pointerleave' : 'mouseleave', handleMouseLeave);
            }
          }
        };

        tooltip.detachEvents = function detachEvents() {
          $el.off('transitionend', handleTransitionEnd);

          if (tooltip.params.trigger === 'click') {
            if (tooltip.params.delegated) {
              $(document).on('click', tooltip.params.targetEl, handleClick);
            } else {
              tooltip.$targetEl.off('click', handleClick);
            }

            $('html').off('click', handleClickOut);
            return;
          }

          if (tooltip.params.trigger === 'manual') return;

          if (support.touch) {
            var passive = support.passiveListener ? {
              passive: true
            } : false;

            if (tooltip.params.delegated) {
              $(document).off(app.touchEvents.start, tooltip.params.targetEl, handleTouchStart, passive);
            } else {
              tooltip.$targetEl.off(app.touchEvents.start, handleTouchStart, passive);
            }

            app.off('touchmove', handleTouchMove);
            app.off('touchend:passive', handleTouchEnd);
          } else {
            // eslint-disable-next-line
            if (tooltip.params.delegated) {
              $(document).off(support.pointerEvents ? 'pointerenter' : 'mouseenter', tooltip.params.targetEl, handleMouseEnter, true);
              $(document).off(support.pointerEvents ? 'pointerleave' : 'mouseleave', tooltip.params.targetEl, handleMouseLeave, true);
            } else {
              tooltip.$targetEl.off(support.pointerEvents ? 'pointerenter' : 'mouseenter', handleMouseEnter);
              tooltip.$targetEl.off(support.pointerEvents ? 'pointerleave' : 'mouseleave', handleMouseLeave);
            }
          }
        }; // Install Modules


        tooltip.useModules();
        tooltip.init();
        return tooltip || _assertThisInitialized$2(_this);
      }

      var _proto = Tooltip.prototype;

      _proto.setTargetEl = function setTargetEl(targetEl) {
        var tooltip = this;
        tooltip.detachEvents();
        tooltip.$targetEl = $(targetEl);
        tooltip.targetEl = tooltip.$targetEl[0];
        tooltip.attachEvents();
        return tooltip;
      };

      _proto.position = function position(targetEl) {
        var tooltip = this;
        var $el = tooltip.$el,
            app = tooltip.app,
            $containerEl = tooltip.$containerEl;
        var hasContainerEl = !!tooltip.params.containerEl;
        var tooltipOffset = tooltip.params.offset || 0;
        $el.css({
          left: '',
          top: ''
        });
        var $targetEl = $(targetEl || tooltip.targetEl);
        var _ref = [$el.width(), $el.height()],
            width = _ref[0],
            height = _ref[1];
        $el.css({
          left: '',
          top: ''
        });
        var targetWidth;
        var targetHeight;
        var targetOffsetLeft;
        var targetOffsetTop;
        var boundaries = hasContainerEl && $containerEl.length ? $containerEl[0].getBoundingClientRect() : app;

        if ($targetEl && $targetEl.length > 0) {
          targetWidth = $targetEl.outerWidth();
          targetHeight = $targetEl.outerHeight();

          if (typeof targetWidth === 'undefined' && typeof targetHeight === 'undefined') {
            var clientRect = $targetEl[0].getBoundingClientRect();
            targetWidth = clientRect.width;
            targetHeight = clientRect.height;
          }

          var targetOffset = $targetEl.offset();
          targetOffsetLeft = targetOffset.left - boundaries.left;
          targetOffsetTop = targetOffset.top - boundaries.top;
          var targetParentPage = $targetEl.parents('.page');

          if (targetParentPage.length > 0) {
            targetOffsetTop -= targetParentPage[0].scrollTop;
          }
        }

        var _ref2 = [0, 0, 0],
            left = _ref2[0],
            top = _ref2[1]; // Top Position

        var position = 'top';

        if (height + tooltipOffset < targetOffsetTop) {
          // On top
          top = targetOffsetTop - height - tooltipOffset;
        } else if (height < boundaries.height - targetOffsetTop - targetHeight) {
          // On bottom
          position = 'bottom';
          top = targetOffsetTop + targetHeight + tooltipOffset;
        } else {
          // On middle
          position = 'middle';
          top = targetHeight / 2 + targetOffsetTop - height / 2;

          if (top <= 0) {
            top = 8;
          } else if (top + height >= boundaries.height) {
            top = boundaries.height - height - 8;
          }
        } // Horizontal Position


        if (position === 'top' || position === 'bottom') {
          left = targetWidth / 2 + targetOffsetLeft - width / 2;
          if (left < 8) left = 8;
          if (left + width > boundaries.width) left = boundaries.width - width - 8;
          if (left < 0) left = 0;
        } else if (position === 'middle') {
          left = targetOffsetLeft - width;

          if (left < 8 || left + width > boundaries.width) {
            if (left < 8) left = targetOffsetLeft + targetWidth;
            if (left + width > boundaries.width) left = boundaries.width - width - 8;
          }
        } // Apply Styles


        $el.css({
          top: top + "px",
          left: left + "px"
        });
      };

      _proto.show = function show(aroundEl) {
        var tooltip = this;
        var $el = tooltip.$el,
            $targetEl = tooltip.$targetEl,
            $containerEl = tooltip.$containerEl;

        if ($containerEl[0] && $el[0] && !$containerEl[0].contains($el[0])) {
          $containerEl.append($el);
        }

        tooltip.position(aroundEl);
        var $aroundEl = $(aroundEl);
        tooltip.visible = true;
        tooltip.opened = true;
        $targetEl.trigger('tooltip:show');
        $el.trigger('tooltip:show');

        if ($aroundEl.length && $aroundEl[0] !== $targetEl[0]) {
          $aroundEl.trigger('tooltip:show');
        }

        tooltip.emit('local::show tooltipShow', tooltip);
        $el.removeClass('tooltip-out').addClass('tooltip-in');
        return tooltip;
      };

      _proto.hide = function hide() {
        var tooltip = this;
        var $el = tooltip.$el,
            $targetEl = tooltip.$targetEl;
        tooltip.visible = false;
        tooltip.opened = false;
        $targetEl.trigger('tooltip:hide');
        $el.trigger('tooltip:hide');
        tooltip.emit('local::hide tooltipHide', tooltip);
        $el.addClass('tooltip-out').removeClass('tooltip-in');
        return tooltip;
      };

      _proto.render = function render() {
        var tooltip = this;
        if (tooltip.params.render) return tooltip.params.render.call(tooltip, tooltip);
        var _tooltip$params2 = tooltip.params,
            cssClass = _tooltip$params2.cssClass,
            text = _tooltip$params2.text;
        return ("\n      <div class=\"tooltip " + (cssClass || '') + "\">\n        <div class=\"tooltip-content\">" + (text || '') + "</div>\n      </div>\n    ").trim();
      };

      _proto.setText = function setText(newText) {
        var tooltip = this;

        if (typeof newText === 'undefined') {
          return tooltip;
        }

        tooltip.params.text = newText;
        tooltip.text = newText;

        if (tooltip.$el) {
          tooltip.$el.children('.tooltip-content').html(newText);
        }

        if (tooltip.opened) {
          tooltip.position();
        }

        return tooltip;
      };

      _proto.init = function init() {
        var tooltip = this;
        tooltip.attachEvents();
      };

      _proto.destroy = function destroy() {
        var tooltip = this;
        if (!tooltip.$targetEl || tooltip.destroyed) return;
        tooltip.$targetEl.trigger('tooltip:beforedestroy');
        tooltip.emit('local::beforeDestroy tooltipBeforeDestroy', tooltip);
        tooltip.$el.remove();
        if (tooltip.$targetEl[0]) delete tooltip.$targetEl[0].f7Tooltip;
        tooltip.detachEvents();
        deleteProps$1(tooltip);
        tooltip.destroyed = true;
      };

      return Tooltip;
    }(Framework7Class$1);

    var Tooltip$2 = Tooltip$1;

    var Tooltip = {
      name: 'tooltip',
      static: {
        Tooltip: Tooltip$2
      },
      create: function create() {
        var app = this;
        app.tooltip = ConstructorMethods({
          defaultSelector: '.tooltip',
          constructor: Tooltip$2,
          app: app,
          domProp: 'f7Tooltip'
        });

        app.tooltip.show = function show(el) {
          var $el = $(el);
          if ($el.length === 0) return undefined;
          var tooltip = $el[0].f7Tooltip;
          if (!tooltip) return undefined;
          tooltip.show($el[0]);
          return tooltip;
        };

        app.tooltip.hide = function hide(el) {
          var $el = $(el);
          if ($el.length === 0) return undefined;
          var tooltip = $el[0].f7Tooltip;
          if (!tooltip) return undefined;
          tooltip.hide();
          return tooltip;
        };

        app.tooltip.setText = function text(el, newText) {
          var $el = $(el);
          if ($el.length === 0) return undefined;
          var tooltip = $el[0].f7Tooltip;
          if (!tooltip) return undefined;
          tooltip.setText(newText);
          return tooltip;
        };
      },
      params: {
        tooltip: {
          targetEl: null,
          delegated: false,
          text: null,
          cssClass: null,
          render: null,
          offset: 0,
          trigger: 'hover',
          containerEl: undefined
        }
      },
      on: {
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.tooltip-init').each(function (el) {
            var text = $(el).attr('data-tooltip');
            if (!text) return;
            app.tooltip.create({
              targetEl: el,
              text: text
            });
          });
        },
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          $(tabEl).find('.tooltip-init').each(function (el) {
            if (el.f7Tooltip) el.f7Tooltip.destroy();
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.tooltip-init').each(function (el) {
            var text = $(el).attr('data-tooltip');
            if (!text) return;
            app.tooltip.create({
              targetEl: el,
              text: text
            });
          });

          if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
            page.$navbarEl.find('.tooltip-init').each(function (el) {
              var text = $(el).attr('data-tooltip');
              if (!text) return;
              app.tooltip.create({
                targetEl: el,
                text: text
              });
            });
          }
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          var app = this;
          page.$el.find('.tooltip-init').each(function (el) {
            if (el.f7Tooltip) el.f7Tooltip.destroy();
          });

          if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
            page.$navbarEl.find('.tooltip-init').each(function (el) {
              if (el.f7Tooltip) el.f7Tooltip.destroy();
            });
          }
        }
      },
      vnode: {
        'tooltip-init': {
          insert: function insert(vnode) {
            var app = this;
            var el = vnode.elm;
            var text = $(el).attr('data-tooltip');
            if (!text) return;
            app.tooltip.create({
              targetEl: el,
              text: text
            });
          },
          update: function update(vnode) {
            var el = vnode.elm;
            if (!el.f7Tooltip) return;

            if (vnode && vnode.data && vnode.data.attrs && vnode.data.attrs['data-tooltip']) {
              el.f7Tooltip.setText(vnode.data.attrs['data-tooltip']);
            }
          },
          destroy: function destroy(vnode) {
            var el = vnode.elm;
            if (el.f7Tooltip) el.f7Tooltip.destroy();
          }
        }
      }
    };

    var Skeleton = {
      name: 'skeleton'
    };

    var Menu = {
      open: function open(el) {
        if (el === void 0) {
          el = '.menu-item-dropdown';
        }

        var app = this;
        if (!el) return;
        var $el = $(el).closest('.menu-item-dropdown');
        if (!$el.length) return;
        var $menuEl = $el.closest('.menu').eq(0);

        if ($menuEl.length) {
          var zIndex = $menuEl.css('z-index');
          var originalZIndex = $menuEl[0].style.zIndex;
          $menuEl.css('z-index', parseInt(zIndex || 0, 10) + 1);
          $menuEl[0].f7MenuZIndex = originalZIndex;
        }

        $el.eq(0).addClass('menu-item-dropdown-opened').trigger('menu:opened');
        app.emit('menuOpened', $el.eq(0)[0]);
      },
      close: function close(el) {
        if (el === void 0) {
          el = '.menu-item-dropdown-opened';
        }

        var app = this;
        if (!el) return;
        var $el = $(el).closest('.menu-item-dropdown-opened');
        if (!$el.length) return;
        var $menuEl = $el.closest('.menu').eq(0);

        if ($menuEl.length) {
          var zIndex = $menuEl[0].f7MenuZIndex;
          $menuEl.css('z-index', zIndex);
          delete $menuEl[0].f7MenuZIndex;
        }

        $el.eq(0).removeClass('menu-item-dropdown-opened').trigger('menu:closed');
        app.emit('menuClosed', $el.eq(0)[0]);
      }
    };
    var Menu$1 = {
      name: 'menu',
      create: function create() {
        var app = this;
        bindMethods(app, {
          menu: Menu
        });
      },
      on: {
        click: function click(e) {
          var app = this;
          var openedMenus = $('.menu-item-dropdown-opened');
          if (!openedMenus.length) return;
          openedMenus.each(function (el) {
            if (!$(e.target).closest('.menu-item-dropdown-opened').length) {
              app.menu.close(el);
            }
          });
        }
      },
      clicks: {
        '.menu-item-dropdown': function onClick($clickedEl, dataset, e) {
          var app = this;

          if ($clickedEl.hasClass('menu-item-dropdown-opened')) {
            if ($(e.target).closest('.menu-dropdown').length) return;
            app.menu.close($clickedEl);
          } else {
            app.menu.open($clickedEl);
          }
        },
        '.menu-close': function onClick() {
          var app = this;
          app.menu.close();
        }
      }
    };

    /** @jsx $jsx */
    var moduleAlphaSlider = {
      render: function render(self) {
        var _self$params = self.params,
            sliderLabel = _self$params.sliderLabel,
            sliderValue = _self$params.sliderValue,
            sliderValueEditable = _self$params.sliderValueEditable,
            alphaLabelText = _self$params.alphaLabelText;
        return $jsx$1("div", {
          class: "color-picker-module color-picker-module-alpha-slider"
        }, $jsx$1("div", {
          class: "color-picker-slider-wrap"
        }, sliderLabel && $jsx$1("div", {
          class: "color-picker-slider-label"
        }, alphaLabelText), $jsx$1("div", {
          class: "range-slider color-picker-slider color-picker-slider-alpha"
        }), sliderValue && $jsx$1("div", {
          class: "color-picker-slider-value"
        }, sliderValueEditable ? $jsx$1("input", {
          type: "number",
          step: "0.01",
          min: "0",
          max: "1",
          class: "color-picker-value-alpha"
        }) : $jsx$1("span", {
          class: "color-picker-value-alpha"
        }))));
      },
      init: function init(self) {
        self.alphaRangeSlider = self.app.range.create({
          el: self.$el.find('.color-picker-slider-alpha'),
          min: 0,
          max: 1,
          step: 0.01,
          value: 1,
          on: {
            change: function change(range, value) {
              var alpha = Math.floor(value * 100) / 100;
              self.setValue({
                alpha: alpha
              });
            }
          }
        });

        function handleInputChange(e) {
          var alpha = self.value.alpha;
          var value = parseFloat(e.target.value);

          if (Number.isNaN(value)) {
            e.target.value = alpha;
            return;
          }

          value = Math.max(0, Math.min(1, value));
          self.setValue({
            alpha: value
          });
        }

        self.$el.on('change', '.color-picker-module-alpha-slider input', handleInputChange);

        self.destroyAlphaSliderEvents = function destroyAlphaSliderEvents() {
          self.$el.off('change', '.color-picker-module-alpha-slider input', handleInputChange);
        };
      },
      update: function update(self) {
        var value = self.value;
        var _self$params2 = self.params,
            sliderValue = _self$params2.sliderValue,
            sliderValueEditable = _self$params2.sliderValueEditable;
        var alpha = value.alpha;
        self.alphaRangeSlider.value = alpha;
        self.alphaRangeSlider.layout();

        if (sliderValue && sliderValueEditable) {
          self.$el.find('input.color-picker-value-alpha').val(alpha);
        } else {
          self.$el.find('span.color-picker-value-alpha').text(alpha);
        }
      },
      destroy: function destroy(self) {
        if (self.alphaRangeSlider && self.alphaRangeSlider.destroy) {
          self.alphaRangeSlider.destroy();
        }

        delete self.alphaRangeSlider;
        if (self.destroyAlphaSliderEvents) self.destroyAlphaSliderEvents();
        delete self.destroyAlphaSliderEvents;
      }
    };

    /** @jsx $jsx */
    var moduleCurrentColor = {
      render: function render() {
        return $jsx$1("div", {
          class: "color-picker-module color-picker-module-current-color"
        }, $jsx$1("div", {
          class: "color-picker-current-color"
        }));
      },
      update: function update(self) {
        self.$el.find('.color-picker-module-current-color .color-picker-current-color').css('background-color', self.value.hex);
      }
    };

    /** @jsx $jsx */
    var moduleHex = {
      render: function render(self) {
        var _self$params = self.params,
            hexLabel = _self$params.hexLabel,
            hexLabelText = _self$params.hexLabelText,
            hexValueEditable = _self$params.hexValueEditable;
        return $jsx$1("div", {
          class: "color-picker-module color-picker-module-hex"
        }, $jsx$1("div", {
          class: "color-picker-hex-wrap"
        }, hexLabel && $jsx$1("div", {
          class: "color-picker-hex-label"
        }, hexLabelText), $jsx$1("div", {
          class: "color-picker-hex-value"
        }, hexValueEditable ? $jsx$1("input", {
          type: "text",
          class: "color-picker-value-hex"
        }) : $jsx$1("span", {
          class: "color-picker-value-hex"
        }))));
      },
      init: function init(self) {
        function handleInputChange(e) {
          var hex = self.value.hex;
          var value = e.target.value.replace(/#/g, '');

          if (Number.isNaN(value) || !value || value.length !== 3 && value.length !== 6) {
            e.target.value = hex;
            return;
          }

          var min = 0;
          var current = parseInt(value, 16);
          var max = parseInt('ffffff', 16); // eslint-disable-line

          if (current > max) {
            value = 'fff';
          }

          if (current < min) {
            value = '000';
          }

          self.setValue({
            hex: value
          });
        }

        self.$el.on('change', '.color-picker-module-hex input', handleInputChange);

        self.destroyHexEvents = function destroyHexEvents() {
          self.$el.off('change', '.color-picker-module-hex input', handleInputChange);
        };
      },
      update: function update(self) {
        var value = self.value;
        var hexValueEditable = self.params.hexValueEditable;
        var hex = value.hex;

        if (hexValueEditable) {
          self.$el.find('input.color-picker-value-hex').val(hex);
        } else {
          self.$el.find('span.color-picker-value-hex').text(hex);
        }
      },
      destroy: function destroy(self) {
        if (self.destroyHexEvents) self.destroyHexEvents();
        delete self.destroyHexEvents;
      }
    };

    var moduleHsbSliders = {
      render: function render(self) {
        var _self$params = self.params,
            sliderLabel = _self$params.sliderLabel,
            sliderValue = _self$params.sliderValue,
            sliderValueEditable = _self$params.sliderValueEditable,
            hueLabelText = _self$params.hueLabelText,
            saturationLabelText = _self$params.saturationLabelText,
            brightnessLabelText = _self$params.brightnessLabelText;
        return $jsx$1("div", {
          class: "color-picker-module color-picker-module-hsb-sliders"
        }, $jsx$1("div", {
          class: "color-picker-slider-wrap"
        }, sliderLabel && $jsx$1("div", {
          class: "color-picker-slider-label"
        }, hueLabelText), $jsx$1("div", {
          class: "range-slider color-picker-slider color-picker-slider-hue"
        }), sliderValue && $jsx$1("div", {
          class: "color-picker-slider-value"
        }, sliderValueEditable ? $jsx$1("input", {
          type: "number",
          step: "0.1",
          min: "0",
          max: "360",
          class: "color-picker-value-hue",
          "data-color-index": "0"
        }) : $jsx$1("span", {
          class: "color-picker-value-hue"
        }))), $jsx$1("div", {
          class: "color-picker-slider-wrap"
        }, sliderLabel && $jsx$1("div", {
          class: "color-picker-slider-label"
        }, saturationLabelText), $jsx$1("div", {
          class: "range-slider color-picker-slider color-picker-slider-saturation"
        }), sliderValue && $jsx$1("div", {
          class: "color-picker-slider-value"
        }, sliderValueEditable ? $jsx$1("input", {
          type: "number",
          step: "0.1",
          min: "0",
          max: "100",
          class: "color-picker-value-saturation",
          "data-color-index": "1"
        }) : $jsx$1("span", {
          class: "color-picker-value-saturation"
        }))), $jsx$1("div", {
          class: "color-picker-slider-wrap"
        }, sliderLabel && $jsx$1("div", {
          class: "color-picker-slider-label"
        }, brightnessLabelText), $jsx$1("div", {
          class: "range-slider color-picker-slider color-picker-slider-brightness"
        }), sliderValue && $jsx$1("div", {
          class: "color-picker-slider-value"
        }, sliderValueEditable ? $jsx$1("input", {
          type: "number",
          step: "0.1",
          min: "0",
          max: "100",
          class: "color-picker-value-brightness",
          "data-color-index": "2"
        }) : $jsx$1("span", {
          class: "color-picker-value-brightness"
        }))));
      },
      init: function init(self) {
        self.hueRangeSlider = self.app.range.create({
          el: self.$el.find('.color-picker-slider-hue'),
          min: 0,
          max: 360,
          step: 0.1,
          value: 0,
          on: {
            change: function change(range, value) {
              self.setValue({
                hue: value
              });
            }
          }
        });
        self.saturationRangeSlider = self.app.range.create({
          el: self.$el.find('.color-picker-slider-saturation'),
          min: 0,
          max: 1,
          step: 0.001,
          value: 0,
          on: {
            change: function change(range, value) {
              var s = Math.floor(value * 1000) / 1000;
              self.setValue({
                hsb: [self.value.hsb[0], s, self.value.hsb[2]]
              });
            }
          }
        });
        self.brightnessRangeSlider = self.app.range.create({
          el: self.$el.find('.color-picker-slider-brightness'),
          min: 0,
          max: 1,
          step: 0.001,
          value: 0,
          on: {
            change: function change(range, value) {
              var b = Math.floor(value * 1000) / 1000;
              self.setValue({
                hsb: [self.value.hsb[0], self.value.hsb[1], b]
              });
            }
          }
        });

        function handleInputChange(e) {
          var hsb = [].concat(self.value.hsb);
          var index = parseInt($(e.target).attr('data-color-index'), 10);
          var value = parseFloat(e.target.value);

          if (Number.isNaN(value)) {
            e.target.value = hsb[index];
            return;
          }

          if (index === 0) {
            value = Math.max(0, Math.min(360, value));
          } else {
            value = Math.max(0, Math.min(100, value)) / 100;
          }

          hsb[index] = value;
          self.setValue({
            hsb: hsb
          });
        }

        self.$el.on('change', '.color-picker-module-hsb-sliders input', handleInputChange);

        self.destroyHsbSlidersEvents = function destroyHsbSlidersEvents() {
          self.$el.off('change', '.color-picker-module-hsb-sliders input', handleInputChange);
        };
      },
      update: function update(self) {
        var app = self.app,
            value = self.value;
        var _self$params2 = self.params,
            sliderValue = _self$params2.sliderValue,
            sliderValueEditable = _self$params2.sliderValueEditable;
        var hsb = value.hsb,
            hue = value.hue;
        self.hueRangeSlider.value = hue;
        self.saturationRangeSlider.value = hsb[1];
        self.brightnessRangeSlider.value = hsb[2];
        self.hueRangeSlider.layout();
        self.saturationRangeSlider.layout();
        self.brightnessRangeSlider.layout();
        var hslCurrent = colorHsbToHsl(hsb[0], hsb[1], 1);
        var hslLeft = colorHsbToHsl(hsb[0], 0, 1);
        var hslRight = colorHsbToHsl(hsb[0], 1, 1);
        var brightness = hsb[2];
        self.hueRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', "hsl(" + hue + ", 100%, 50%)");
        self.saturationRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', "hsl(" + hslCurrent[0] + ", " + hslCurrent[1] * 100 + "%, " + hslCurrent[2] * 100 + "%)");
        self.brightnessRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', "rgb(" + brightness * 255 + ", " + brightness * 255 + ", " + brightness * 255 + ")");
        self.saturationRangeSlider.$el.find('.range-bar').css('background-image', "linear-gradient(" + (app.rtl ? 'to left' : 'to right') + ", hsl(" + hslLeft[0] + ", " + hslLeft[1] * 100 + "%, " + hslLeft[2] * 100 + "%), hsl(" + hslRight[0] + ", " + hslRight[1] * 100 + "%, " + hslRight[2] * 100 + "%))");

        if (sliderValue && sliderValueEditable) {
          self.$el.find('input.color-picker-value-hue').val("" + hue);
          self.$el.find('input.color-picker-value-saturation').val("" + hsb[1] * 1000 / 10);
          self.$el.find('input.color-picker-value-brightness').val("" + hsb[2] * 1000 / 10);
        } else if (sliderValue) {
          self.$el.find('span.color-picker-value-hue').text("" + hue);
          self.$el.find('span.color-picker-value-saturation').text("" + hsb[1] * 1000 / 10);
          self.$el.find('span.color-picker-value-brightness').text("" + hsb[2] * 1000 / 10);
        }
      },
      destroy: function destroy(self) {
        if (self.hueRangeSlider && self.hueRangeSlider.destroy) {
          self.hueRangeSlider.destroy();
        }

        if (self.saturationRangeSlider && self.saturationRangeSlider.destroy) {
          self.saturationRangeSlider.destroy();
        }

        if (self.brightnessRangeSlider && self.brightnessRangeSlider.destroy) {
          self.brightnessRangeSlider.destroy();
        }

        delete self.hueRangeSlider;
        delete self.saturationRangeSlider;
        delete self.brightnessRangeSlider;
        if (self.destroyHsbSlidersEvents) self.destroyHsbSlidersEvents();
        delete self.destroyHsbSlidersEvents;
      }
    };

    /** @jsx $jsx */
    var moduleHueSlider = {
      render: function render(self) {
        var _self$params = self.params,
            sliderLabel = _self$params.sliderLabel,
            sliderValue = _self$params.sliderValue,
            sliderValueEditable = _self$params.sliderValueEditable,
            hueLabelText = _self$params.hueLabelText;
        return $jsx$1("div", {
          class: "color-picker-module color-picker-module-hue-slider"
        }, $jsx$1("div", {
          class: "color-picker-slider-wrap"
        }, sliderLabel && $jsx$1("div", {
          class: "color-picker-slider-label"
        }, hueLabelText), $jsx$1("div", {
          class: "range-slider color-picker-slider color-picker-slider-hue"
        }), sliderValue && $jsx$1("div", {
          class: "color-picker-slider-value"
        }, sliderValueEditable ? $jsx$1("input", {
          type: "number",
          step: "0.1",
          min: "0",
          max: "360",
          class: "color-picker-value-hue"
        }) : $jsx$1("span", {
          class: "color-picker-value-hue"
        }))));
      },
      init: function init(self) {
        self.hueRangeSlider = self.app.range.create({
          el: self.$el.find('.color-picker-slider-hue'),
          min: 0,
          max: 360,
          step: 0.1,
          value: 0,
          on: {
            change: function change(range, value) {
              self.setValue({
                hue: value
              });
            }
          }
        });
      },
      update: function update(self) {
        var value = self.value;
        var _self$params2 = self.params,
            sliderValue = _self$params2.sliderValue,
            sliderValueEditable = _self$params2.sliderValueEditable;
        var hue = value.hue;
        self.hueRangeSlider.value = hue;
        self.hueRangeSlider.layout();
        self.hueRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', "hsl(" + hue + ", 100%, 50%)");

        if (sliderValue && sliderValueEditable) {
          self.$el.find('input.color-picker-value-hue').val("" + hue);
        } else if (sliderValue) {
          self.$el.find('span.color-picker-value-hue').text("" + hue);
        }
      },
      destroy: function destroy(self) {
        if (self.hueRangeSlider && self.hueRangeSlider.destroy) {
          self.hueRangeSlider.destroy();
        }

        delete self.hueRangeSlider;
      }
    };

    var moduleBrightnessSlider = {
      render: function render(self) {
        var _self$params = self.params,
            sliderLabel = _self$params.sliderLabel,
            sliderValue = _self$params.sliderValue,
            sliderValueEditable = _self$params.sliderValueEditable,
            brightnessLabelText = _self$params.brightnessLabelText;
        return $jsx$1("div", {
          class: "color-picker-module color-picker-module-brightness-slider"
        }, $jsx$1("div", {
          class: "color-picker-slider-wrap"
        }, sliderLabel && $jsx$1("div", {
          class: "color-picker-slider-label"
        }, brightnessLabelText), $jsx$1("div", {
          class: "range-slider color-picker-slider color-picker-slider-brightness"
        }), sliderValue && $jsx$1("div", {
          class: "color-picker-slider-value"
        }, sliderValueEditable ? $jsx$1("input", {
          type: "number",
          step: "0.1",
          min: "0",
          max: "100",
          class: "color-picker-value-brightness"
        }) : $jsx$1("span", {
          class: "color-picker-value-brightness"
        }))));
      },
      init: function init(self) {
        self.brightnessRangeSlider = self.app.range.create({
          el: self.$el.find('.color-picker-slider-brightness'),
          min: 0,
          max: 1,
          step: 0.001,
          value: 0,
          on: {
            change: function change(range, value) {
              var b = Math.floor(value * 1000) / 1000;
              self.setValue({
                hsb: [self.value.hsb[0], self.value.hsb[1], b]
              });
            }
          }
        });
      },
      update: function update(self) {
        var value = self.value,
            app = self.app;
        var _self$params2 = self.params,
            sliderValue = _self$params2.sliderValue,
            sliderValueEditable = _self$params2.sliderValueEditable;
        var hsb = value.hsb;
        self.brightnessRangeSlider.value = hsb[2];
        self.brightnessRangeSlider.layout();
        var hslCurrent = colorHsbToHsl(hsb[0], hsb[1], hsb[2]);
        var hslLeft = colorHsbToHsl(hsb[0], hsb[1], 0);
        var hslRight = colorHsbToHsl(hsb[0], hsb[1], 1);
        self.brightnessRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', "hsl(" + hslCurrent[0] + ", " + hslCurrent[1] * 100 + "%, " + hslCurrent[2] * 100 + "%)");
        self.brightnessRangeSlider.$el.find('.range-bar').css('background-image', "linear-gradient(" + (app.rtl ? 'to left' : 'to right') + ", hsl(" + hslLeft[0] + ", " + hslLeft[1] * 100 + "%, " + hslLeft[2] * 100 + "%), hsl(" + hslRight[0] + ", " + hslRight[1] * 100 + "%, " + hslRight[2] * 100 + "%))");

        if (sliderValue && sliderValueEditable) {
          self.$el.find('input.color-picker-value-brightness').val("" + hsb[2] * 1000 / 10);
        } else if (sliderValue) {
          self.$el.find('span.color-picker-value-brightness').text("" + hsb[2] * 1000 / 10);
        }
      },
      destroy: function destroy(self) {
        if (self.brightnessRangeSlider && self.brightnessRangeSlider.destroy) {
          self.brightnessRangeSlider.destroy();
        }

        delete self.brightnessRangeSlider;
      }
    };

    /* eslint indent: ["off"] */
    var modulePalette = {
      render: function render(self) {
        return $jsx$1("div", {
          class: "color-picker-module color-picker-module-palette"
        }, $jsx$1("div", {
          class: "color-picker-palette"
        }, self.params.palette.map(function (p) {
          if (Array.isArray(p)) {
            var row = '<div class="color-picker-palette-row">'; // prettier-ignore

            row += p.map(function (c) {
              return "\n                <div class=\"color-picker-palette-value\" data-palette-color=\"" + c + "\" style=\"background-color: " + c + "\"></div>\n              ";
            }).join('');
            row += '</div>';
            return row;
          }

          return $jsx$1("div", {
            class: "color-picker-palette-value",
            "data-palette-color": p,
            style: "background-color: " + p
          });
        })));
      },
      init: function init(self) {
        function handlePaletteClick(e) {
          var hex = $(e.target).attr('data-palette-color');
          self.setValue({
            hex: hex
          });
        }

        self.$el.on('click', '.color-picker-module-palette .color-picker-palette-value', handlePaletteClick);

        self.destroyPaletteEvents = function destroyPaletteEvents() {
          self.$el.off('click', '.color-picker-module-hex input', handlePaletteClick);
        };
      },
      destroy: function destroy(self) {
        if (self.destroyPaletteEvents) {
          self.destroyPaletteEvents();
        }

        delete self.destroyPaletteEvents;
      }
    };

    /** @jsx $jsx */
    var moduleInitialCurrentColors = {
      render: function render() {
        return $jsx$1("div", {
          class: "color-picker-module color-picker-module-initial-current-colors"
        }, $jsx$1("div", {
          class: "color-picker-initial-current-colors"
        }, $jsx$1("div", {
          class: "color-picker-initial-color"
        }), $jsx$1("div", {
          class: "color-picker-current-color"
        })));
      },
      init: function init(self) {
        function handleInitialColorClick() {
          if (self.initialValue) {
            var _self$initialValue = self.initialValue,
                hex = _self$initialValue.hex,
                alpha = _self$initialValue.alpha;
            self.setValue({
              hex: hex,
              alpha: alpha
            });
          }
        }

        self.$el.on('click', '.color-picker-initial-color', handleInitialColorClick);

        self.destroyInitialCurrentEvents = function destroyInitialCurrentEvents() {
          self.$el.off('click', '.color-picker-initial-color', handleInitialColorClick);
        };
      },
      update: function update(self) {
        self.$el.find('.color-picker-module-initial-current-colors .color-picker-initial-color').css('background-color', self.initialValue.hex);
        self.$el.find('.color-picker-module-initial-current-colors .color-picker-current-color').css('background-color', self.value.hex);
      },
      destroy: function destroy(self) {
        if (self.destroyInitialCurrentEvents) {
          self.destroyInitialCurrentEvents();
        }

        delete self.destroyInitialCurrentEvents;
      }
    };

    var moduleRgbBars = {
      render: function render(self) {
        var _self$params = self.params,
            barLabel = _self$params.barLabel,
            barValue = _self$params.barValue,
            barValueEditable = _self$params.barValueEditable,
            redLabelText = _self$params.redLabelText,
            greenLabelText = _self$params.greenLabelText,
            blueLabelText = _self$params.blueLabelText;
        return $jsx$1("div", {
          class: "color-picker-module color-picker-module-rgb-bars"
        }, $jsx$1("div", {
          class: "color-picker-bar-wrap"
        }, barLabel && $jsx$1("div", {
          class: "color-picker-bar-label"
        }, redLabelText), $jsx$1("div", {
          class: "range-slider color-picker-bar color-picker-bar-red"
        }), barValue && $jsx$1("div", {
          class: "color-picker-bar-value"
        }, barValueEditable ? $jsx$1("input", {
          type: "number",
          step: "1",
          min: "0",
          max: "255",
          class: "color-picker-value-bar-red",
          "data-color-index": "0"
        }) : $jsx$1("span", {
          class: "color-picker-value-bar-red"
        }))), $jsx$1("div", {
          class: "color-picker-bar-wrap"
        }, barLabel && $jsx$1("div", {
          class: "color-picker-bar-label"
        }, greenLabelText), $jsx$1("div", {
          class: "range-slider color-picker-bar color-picker-bar-green"
        }), barValue && $jsx$1("div", {
          class: "color-picker-bar-value"
        }, barValueEditable ? $jsx$1("input", {
          type: "number",
          step: "1",
          min: "0",
          max: "255",
          class: "color-picker-value-bar-green",
          "data-color-index": "1"
        }) : $jsx$1("span", {
          class: "color-picker-value-bar-green"
        }))), $jsx$1("div", {
          class: "color-picker-bar-wrap"
        }, barLabel && $jsx$1("div", {
          class: "color-picker-bar-label"
        }, blueLabelText), $jsx$1("div", {
          class: "range-slider color-picker-bar color-picker-bar-blue"
        }), barValue && $jsx$1("div", {
          class: "color-picker-bar-value"
        }, barValueEditable ? $jsx$1("input", {
          type: "number",
          step: "1",
          min: "0",
          max: "255",
          class: "color-picker-value-bar-blue",
          "data-color-index": "2"
        }) : $jsx$1("span", {
          class: "color-picker-value-bar-blue"
        }))));
      },
      init: function init(self) {
        self.redBar = self.app.range.create({
          el: self.$el.find('.color-picker-bar-red'),
          min: 0,
          max: 255,
          step: 1,
          value: 0,
          vertical: true,
          on: {
            change: function change(range, value) {
              self.setValue({
                rgb: [value, self.value.rgb[1], self.value.rgb[2]]
              });
            }
          }
        });
        self.greenBar = self.app.range.create({
          el: self.$el.find('.color-picker-bar-green'),
          min: 0,
          max: 255,
          step: 1,
          value: 0,
          vertical: true,
          on: {
            change: function change(range, value) {
              self.setValue({
                rgb: [self.value.rgb[0], value, self.value.rgb[2]]
              });
            }
          }
        });
        self.blueBar = self.app.range.create({
          el: self.$el.find('.color-picker-bar-blue'),
          min: 0,
          max: 255,
          step: 1,
          value: 0,
          vertical: true,
          on: {
            change: function change(range, value) {
              self.setValue({
                rgb: [self.value.rgb[0], self.value.rgb[1], value]
              });
            }
          }
        });

        function handleInputChange(e) {
          var rgb = [].concat(self.value.rgb);
          var index = parseInt($(e.target).attr('data-color-index'), 10);
          var value = parseInt(e.target.value, 10);

          if (Number.isNaN(value)) {
            e.target.value = rgb[index];
            return;
          }

          value = Math.max(0, Math.min(255, value));
          rgb[index] = value;
          self.setValue({
            rgb: rgb
          });
        }

        self.$el.on('change', '.color-picker-module-rgb-bars input', handleInputChange);

        self.destroyRgbBarsEvents = function destroyRgbBarsEvents() {
          self.$el.off('change', '.color-picker-module-rgb-bars input', handleInputChange);
        };
      },
      update: function update(self) {
        var value = self.value,
            redBar = self.redBar,
            greenBar = self.greenBar,
            blueBar = self.blueBar;
        var _self$params2 = self.params,
            barValue = _self$params2.barValue,
            barValueEditable = _self$params2.barValueEditable;
        var rgb = value.rgb;
        redBar.value = rgb[0];
        greenBar.value = rgb[1];
        blueBar.value = rgb[2];
        redBar.layout();
        greenBar.layout();
        blueBar.layout();
        redBar.$el.find('.range-bar').css('background-image', "linear-gradient(to top, rgb(0, " + rgb[1] + ", " + rgb[2] + "), rgb(255, " + rgb[1] + ", " + rgb[2] + "))");
        greenBar.$el.find('.range-bar').css('background-image', "linear-gradient(to top, rgb(" + rgb[0] + ", 0, " + rgb[2] + "), rgb(" + rgb[0] + ", 255, " + rgb[2] + "))");
        blueBar.$el.find('.range-bar').css('background-image', "linear-gradient(to top, rgb(" + rgb[0] + ", " + rgb[1] + ", 0), rgb(" + rgb[0] + ", " + rgb[1] + ", 255))");

        if (barValue && barValueEditable) {
          self.$el.find('input.color-picker-value-bar-red').val(rgb[0]);
          self.$el.find('input.color-picker-value-bar-green').val(rgb[1]);
          self.$el.find('input.color-picker-value-bar-blue').val(rgb[2]);
        } else if (barValue) {
          self.$el.find('span.color-picker-value-bar-red').text(rgb[0]);
          self.$el.find('span.color-picker-value-bar-green').text(rgb[1]);
          self.$el.find('span.color-picker-value-bar-blue').text(rgb[2]);
        }
      },
      destroy: function destroy(self) {
        if (self.redBar && self.redBar.destroy) {
          self.redBar.destroy();
        }

        if (self.greenBar && self.greenBar.destroy) {
          self.greenBar.destroy();
        }

        if (self.blueBar && self.blueBar.destroy) {
          self.blueBar.destroy();
        }

        delete self.redBar;
        delete self.greenBar;
        delete self.blueBar;
        if (self.destroyRgbBarsEvents) self.destroyRgbBarsEvents();
        delete self.destroyRgbBarsEvents;
      }
    };

    var moduleRgbSliders = {
      render: function render(self) {
        var _self$params = self.params,
            sliderLabel = _self$params.sliderLabel,
            sliderValue = _self$params.sliderValue,
            sliderValueEditable = _self$params.sliderValueEditable,
            redLabelText = _self$params.redLabelText,
            greenLabelText = _self$params.greenLabelText,
            blueLabelText = _self$params.blueLabelText;
        return $jsx$1("div", {
          class: "color-picker-module color-picker-module-rgb-sliders"
        }, $jsx$1("div", {
          class: "color-picker-slider-wrap"
        }, sliderLabel && $jsx$1("div", {
          class: "color-picker-slider-label"
        }, redLabelText), $jsx$1("div", {
          class: "range-slider color-picker-slider color-picker-slider-red"
        }), sliderValue && $jsx$1("div", {
          class: "color-picker-slider-value"
        }, sliderValueEditable ? $jsx$1("input", {
          type: "number",
          step: "1",
          min: "0",
          max: "255",
          class: "color-picker-value-red",
          "data-color-index": "0"
        }) : $jsx$1("span", {
          class: "color-picker-value-red"
        }))), $jsx$1("div", {
          class: "color-picker-slider-wrap"
        }, sliderLabel && $jsx$1("div", {
          class: "color-picker-slider-label"
        }, greenLabelText), $jsx$1("div", {
          class: "range-slider color-picker-slider color-picker-slider-green"
        }), sliderValue && $jsx$1("div", {
          class: "color-picker-slider-value"
        }, sliderValueEditable ? $jsx$1("input", {
          type: "number",
          step: "1",
          min: "0",
          max: "255",
          class: "color-picker-value-green",
          "data-color-index": "1"
        }) : $jsx$1("span", {
          class: "color-picker-value-green"
        }))), $jsx$1("div", {
          class: "color-picker-slider-wrap"
        }, sliderLabel && $jsx$1("div", {
          class: "color-picker-slider-label"
        }, blueLabelText), $jsx$1("div", {
          class: "range-slider color-picker-slider color-picker-slider-blue"
        }), sliderValue && $jsx$1("div", {
          class: "color-picker-slider-value"
        }, sliderValueEditable ? $jsx$1("input", {
          type: "number",
          step: "1",
          min: "0",
          max: "255",
          class: "color-picker-value-blue",
          "data-color-index": "2"
        }) : $jsx$1("span", {
          class: "color-picker-value-blue"
        }))));
      },
      init: function init(self) {
        self.redRangeSlider = self.app.range.create({
          el: self.$el.find('.color-picker-slider-red'),
          min: 0,
          max: 255,
          step: 1,
          value: 0,
          on: {
            change: function change(range, value) {
              self.setValue({
                rgb: [value, self.value.rgb[1], self.value.rgb[2]]
              });
            }
          }
        });
        self.greenRangeSlider = self.app.range.create({
          el: self.$el.find('.color-picker-slider-green'),
          min: 0,
          max: 255,
          step: 1,
          value: 0,
          on: {
            change: function change(range, value) {
              self.setValue({
                rgb: [self.value.rgb[0], value, self.value.rgb[2]]
              });
            }
          }
        });
        self.blueRangeSlider = self.app.range.create({
          el: self.$el.find('.color-picker-slider-blue'),
          min: 0,
          max: 255,
          step: 1,
          value: 0,
          on: {
            change: function change(range, value) {
              self.setValue({
                rgb: [self.value.rgb[0], self.value.rgb[1], value]
              });
            }
          }
        });

        function handleInputChange(e) {
          var rgb = [].concat(self.value.rgb);
          var index = parseInt($(e.target).attr('data-color-index'), 10);
          var value = parseInt(e.target.value, 10);

          if (Number.isNaN(value)) {
            e.target.value = rgb[index];
            return;
          }

          value = Math.max(0, Math.min(255, value));
          rgb[index] = value;
          self.setValue({
            rgb: rgb
          });
        }

        self.$el.on('change', '.color-picker-module-rgb-sliders input', handleInputChange);

        self.destroyRgbSlidersEvents = function destroyRgbSlidersEvents() {
          self.$el.off('change', '.color-picker-module-rgb-sliders input', handleInputChange);
        };
      },
      update: function update(self) {
        var app = self.app,
            value = self.value,
            redRangeSlider = self.redRangeSlider,
            greenRangeSlider = self.greenRangeSlider,
            blueRangeSlider = self.blueRangeSlider;
        var _self$params2 = self.params,
            sliderValue = _self$params2.sliderValue,
            sliderValueEditable = _self$params2.sliderValueEditable;
        var rgb = value.rgb;
        redRangeSlider.value = rgb[0];
        greenRangeSlider.value = rgb[1];
        blueRangeSlider.value = rgb[2];
        redRangeSlider.layout();
        greenRangeSlider.layout();
        blueRangeSlider.layout();
        redRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', "rgb(" + rgb[0] + ", " + rgb[1] + ", " + rgb[2] + ")");
        greenRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', "rgb(" + rgb[0] + ", " + rgb[1] + ", " + rgb[2] + ")");
        blueRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', "rgb(" + rgb[0] + ", " + rgb[1] + ", " + rgb[2] + ")");
        var direction = app.rtl ? 'to left' : 'to right';
        redRangeSlider.$el.find('.range-bar').css('background-image', "linear-gradient(" + direction + ", rgb(0, " + rgb[1] + ", " + rgb[2] + "), rgb(255, " + rgb[1] + ", " + rgb[2] + "))");
        greenRangeSlider.$el.find('.range-bar').css('background-image', "linear-gradient(" + direction + ", rgb(" + rgb[0] + ", 0, " + rgb[2] + "), rgb(" + rgb[0] + ", 255, " + rgb[2] + "))");
        blueRangeSlider.$el.find('.range-bar').css('background-image', "linear-gradient(" + direction + ", rgb(" + rgb[0] + ", " + rgb[1] + ", 0), rgb(" + rgb[0] + ", " + rgb[1] + ", 255))");

        if (sliderValue && sliderValueEditable) {
          self.$el.find('input.color-picker-value-red').val(rgb[0]);
          self.$el.find('input.color-picker-value-green').val(rgb[1]);
          self.$el.find('input.color-picker-value-blue').val(rgb[2]);
        } else if (sliderValue) {
          self.$el.find('span.color-picker-value-red').text(rgb[0]);
          self.$el.find('span.color-picker-value-green').text(rgb[1]);
          self.$el.find('span.color-picker-value-blue').text(rgb[2]);
        }
      },
      destroy: function destroy(self) {
        if (self.redRangeSlider && self.redRangeSlider.destroy) {
          self.redRangeSlider.destroy();
        }

        if (self.greenRangeSlider && self.greenRangeSlider.destroy) {
          self.greenRangeSlider.destroy();
        }

        if (self.blueRangeSlider && self.blueRangeSlider.destroy) {
          self.blueRangeSlider.destroy();
        }

        delete self.redRangeSlider;
        delete self.greenRangeSlider;
        delete self.blueRangeSlider;
        if (self.destroyRgbSlidersEvents) self.destroyRgbSlidersEvents();
        delete self.destroyRgbSlidersEvents;
      }
    };

    var moduleSbSpectrum = {
      render: function render() {
        return $jsx$1("div", {
          class: "color-picker-module color-picker-module-sb-spectrum"
        }, $jsx$1("div", {
          class: "color-picker-sb-spectrum",
          style: "background-color: hsl(0, 100%, 50%)"
        }, $jsx$1("div", {
          class: "color-picker-sb-spectrum-handle"
        })));
      },
      init: function init(self) {
        var app = self.app;
        var isTouched;
        var isMoved;
        var touchStartX;
        var touchStartY;
        var touchCurrentX;
        var touchCurrentY;
        var specterRect;
        var specterIsTouched;
        var specterHandleIsTouched;
        var $el = self.$el;

        function setSBFromSpecterCoords(x, y) {
          var s = (x - specterRect.left) / specterRect.width;
          var b = (y - specterRect.top) / specterRect.height;
          s = Math.max(0, Math.min(1, s));
          b = 1 - Math.max(0, Math.min(1, b));
          self.setValue({
            hsb: [self.value.hue, s, b]
          });
        }

        function handleTouchStart(e) {
          if (isMoved || isTouched) return;
          touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          touchCurrentX = touchStartX;
          touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
          touchCurrentY = touchStartY;
          var $targetEl = $(e.target);
          specterHandleIsTouched = $targetEl.closest('.color-picker-sb-spectrum-handle').length > 0;

          if (!specterHandleIsTouched) {
            specterIsTouched = $targetEl.closest('.color-picker-sb-spectrum').length > 0;
          }

          if (specterIsTouched) {
            specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
            setSBFromSpecterCoords(touchStartX, touchStartY);
          }

          if (specterHandleIsTouched || specterIsTouched) {
            $el.find('.color-picker-sb-spectrum-handle').addClass('color-picker-sb-spectrum-handle-pressed');
          }
        }

        function handleTouchMove(e) {
          if (!(specterIsTouched || specterHandleIsTouched)) return;
          touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
          touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
          e.preventDefault();

          if (!isMoved) {
            // First move
            isMoved = true;

            if (specterHandleIsTouched) {
              specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
            }
          }

          if (specterIsTouched || specterHandleIsTouched) {
            setSBFromSpecterCoords(touchCurrentX, touchCurrentY);
          }
        }

        function handleTouchEnd() {
          isMoved = false;

          if (specterIsTouched || specterHandleIsTouched) {
            $el.find('.color-picker-sb-spectrum-handle').removeClass('color-picker-sb-spectrum-handle-pressed');
          }

          specterIsTouched = false;
          specterHandleIsTouched = false;
        }

        function handleResize() {
          self.modules['sb-spectrum'].update(self);
        }

        var passiveListener = app.touchEvents.start === 'touchstart' && getSupport$1().passiveListener ? {
          passive: true,
          capture: false
        } : false;
        self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
        app.on('touchmove:active', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
        app.on('resize', handleResize);

        self.destroySpectrumEvents = function destroySpectrumEvents() {
          self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
          app.off('touchmove:active', handleTouchMove);
          app.off('touchend:passive', handleTouchEnd);
          app.off('resize', handleResize);
        };
      },
      update: function update(self) {
        var value = self.value;
        var hsl = value.hsl,
            hsb = value.hsb;
        var specterWidth = self.$el.find('.color-picker-sb-spectrum')[0].offsetWidth;
        var specterHeight = self.$el.find('.color-picker-sb-spectrum')[0].offsetHeight;
        self.$el.find('.color-picker-sb-spectrum').css('background-color', "hsl(" + hsl[0] + ", 100%, 50%)");
        self.$el.find('.color-picker-sb-spectrum-handle').css('background-color', "hsl(" + hsl[0] + ", " + hsl[1] * 100 + "%, " + hsl[2] * 100 + "%)").transform("translate(" + specterWidth * hsb[1] + "px, " + specterHeight * (1 - hsb[2]) + "px)");
      },
      destroy: function destroy(self) {
        if (self.destroySpectrumEvents) self.destroySpectrumEvents();
        delete self.destroySpectrumEvents;
      }
    };

    var moduleHsSpectrum = {
      render: function render() {
        return $jsx$1("div", {
          class: "color-picker-module color-picker-module-hs-spectrum"
        }, $jsx$1("div", {
          class: "color-picker-hs-spectrum"
        }, $jsx$1("div", {
          class: "color-picker-hs-spectrum-handle"
        })));
      },
      init: function init(self) {
        var app = self.app;
        var isTouched;
        var isMoved;
        var touchStartX;
        var touchStartY;
        var touchCurrentX;
        var touchCurrentY;
        var specterRect;
        var specterIsTouched;
        var specterHandleIsTouched;
        var $el = self.$el;

        function setHSFromSpecterCoords(x, y) {
          var h = (x - specterRect.left) / specterRect.width * 360;
          var s = (y - specterRect.top) / specterRect.height;
          h = Math.max(0, Math.min(360, h));
          s = 1 - Math.max(0, Math.min(1, s));
          self.setValue({
            hsb: [h, s, self.value.hsb[2]]
          });
        }

        function handleTouchStart(e) {
          if (isMoved || isTouched) return;
          touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          touchCurrentX = touchStartX;
          touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
          touchCurrentY = touchStartY;
          var $targetEl = $(e.target);
          specterHandleIsTouched = $targetEl.closest('.color-picker-hs-spectrum-handle').length > 0;

          if (!specterHandleIsTouched) {
            specterIsTouched = $targetEl.closest('.color-picker-hs-spectrum').length > 0;
          }

          if (specterIsTouched) {
            specterRect = $el.find('.color-picker-hs-spectrum')[0].getBoundingClientRect();
            setHSFromSpecterCoords(touchStartX, touchStartY);
          }

          if (specterHandleIsTouched || specterIsTouched) {
            $el.find('.color-picker-hs-spectrum-handle').addClass('color-picker-hs-spectrum-handle-pressed');
          }
        }

        function handleTouchMove(e) {
          if (!(specterIsTouched || specterHandleIsTouched)) return;
          touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
          touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
          e.preventDefault();

          if (!isMoved) {
            // First move
            isMoved = true;

            if (specterHandleIsTouched) {
              specterRect = $el.find('.color-picker-hs-spectrum')[0].getBoundingClientRect();
            }
          }

          if (specterIsTouched || specterHandleIsTouched) {
            setHSFromSpecterCoords(touchCurrentX, touchCurrentY);
          }
        }

        function handleTouchEnd() {
          isMoved = false;

          if (specterIsTouched || specterHandleIsTouched) {
            $el.find('.color-picker-hs-spectrum-handle').removeClass('color-picker-hs-spectrum-handle-pressed');
          }

          specterIsTouched = false;
          specterHandleIsTouched = false;
        }

        function handleResize() {
          self.modules['hs-spectrum'].update(self);
        }

        var passiveListener = app.touchEvents.start === 'touchstart' && getSupport$1().passiveListener ? {
          passive: true,
          capture: false
        } : false;
        self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
        app.on('touchmove:active', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
        app.on('resize', handleResize);

        self.destroySpectrumEvents = function destroySpectrumEvents() {
          self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
          app.off('touchmove:active', handleTouchMove);
          app.off('touchend:passive', handleTouchEnd);
          app.off('resize', handleResize);
        };
      },
      update: function update(self) {
        var value = self.value;
        var hsb = value.hsb;
        var specterWidth = self.$el.find('.color-picker-hs-spectrum')[0].offsetWidth;
        var specterHeight = self.$el.find('.color-picker-hs-spectrum')[0].offsetHeight;
        var hslBright = colorHsbToHsl(hsb[0], hsb[1], 1);
        self.$el.find('.color-picker-hs-spectrum-handle').css('background-color', "hsl(" + hslBright[0] + ", " + hslBright[1] * 100 + "%, " + hslBright[2] * 100 + "%)").transform("translate(" + specterWidth * (hsb[0] / 360) + "px, " + specterHeight * (1 - hsb[1]) + "px)");
      },
      destroy: function destroy(self) {
        if (self.destroySpectrumEvents) self.destroySpectrumEvents();
        delete self.destroySpectrumEvents;
      }
    };

    function svgWheelCircles() {
      var total = 256;
      var circles = '';

      for (var i = total; i > 0; i -= 1) {
        var angle = i * Math.PI / (total / 2);
        var hue = 360 / total * i;
        circles += "<circle cx=\"" + (150 - Math.sin(angle) * 125) + "\" cy=\"" + (150 - Math.cos(angle) * 125) + "\" r=\"25\" fill=\"hsl(" + hue + ", 100%, 50%)\"></circle>";
      }

      return circles;
    }

    var moduleWheel = {
      render: function render() {
        return $jsx$1("div", {
          class: "color-picker-module color-picker-module-wheel"
        }, $jsx$1("div", {
          class: "color-picker-wheel"
        }, $jsx$1("svg", {
          viewBox: "0 0 300 300",
          width: "300",
          height: "300"
        }, svgWheelCircles()), $jsx$1("div", {
          class: "color-picker-wheel-handle"
        }), $jsx$1("div", {
          class: "color-picker-sb-spectrum",
          style: "background-color: hsl(0, 100%, 50%)"
        }, $jsx$1("div", {
          class: "color-picker-sb-spectrum-handle"
        }))));
      },
      init: function init(self) {
        var app = self.app;
        var isTouched;
        var isMoved;
        var touchStartX;
        var touchStartY;
        var touchCurrentX;
        var touchCurrentY;
        var wheelRect;
        var wheelIsTouched;
        var wheelHandleIsTouched;
        var specterRect;
        var specterIsTouched;
        var specterHandleIsTouched;
        var $el = self.$el;

        function setHueFromWheelCoords(x, y) {
          var wheelCenterX = wheelRect.left + wheelRect.width / 2;
          var wheelCenterY = wheelRect.top + wheelRect.height / 2;
          var angleRad = Math.atan2(y - wheelCenterY, x - wheelCenterX);
          var angleDeg = angleRad * 180 / Math.PI + 90;
          if (angleDeg < 0) angleDeg += 360;
          angleDeg = 360 - angleDeg;
          self.setValue({
            hue: angleDeg
          });
        }

        function setSBFromSpecterCoords(x, y) {
          var s = (x - specterRect.left) / specterRect.width;
          var b = (y - specterRect.top) / specterRect.height;
          s = Math.max(0, Math.min(1, s));
          b = 1 - Math.max(0, Math.min(1, b));
          self.setValue({
            hsb: [self.value.hue, s, b]
          });
        }

        function handleTouchStart(e) {
          if (isMoved || isTouched) return;
          touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          touchCurrentX = touchStartX;
          touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
          touchCurrentY = touchStartY;
          var $targetEl = $(e.target);
          wheelHandleIsTouched = $targetEl.closest('.color-picker-wheel-handle').length > 0;
          wheelIsTouched = $targetEl.closest('circle').length > 0;
          specterHandleIsTouched = $targetEl.closest('.color-picker-sb-spectrum-handle').length > 0;

          if (!specterHandleIsTouched) {
            specterIsTouched = $targetEl.closest('.color-picker-sb-spectrum').length > 0;
          }

          if (wheelIsTouched) {
            wheelRect = $el.find('.color-picker-wheel')[0].getBoundingClientRect();
            setHueFromWheelCoords(touchStartX, touchStartY);
          }

          if (specterIsTouched) {
            specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
            setSBFromSpecterCoords(touchStartX, touchStartY);
          }

          if (specterHandleIsTouched || specterIsTouched) {
            $el.find('.color-picker-sb-spectrum-handle').addClass('color-picker-sb-spectrum-handle-pressed');
          }
        }

        function handleTouchMove(e) {
          if (!(wheelIsTouched || wheelHandleIsTouched) && !(specterIsTouched || specterHandleIsTouched)) return;
          touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
          touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
          e.preventDefault();

          if (!isMoved) {
            // First move
            isMoved = true;

            if (wheelHandleIsTouched) {
              wheelRect = $el.find('.color-picker-wheel')[0].getBoundingClientRect();
            }

            if (specterHandleIsTouched) {
              specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
            }
          }

          if (wheelIsTouched || wheelHandleIsTouched) {
            setHueFromWheelCoords(touchCurrentX, touchCurrentY);
          }

          if (specterIsTouched || specterHandleIsTouched) {
            setSBFromSpecterCoords(touchCurrentX, touchCurrentY);
          }
        }

        function handleTouchEnd() {
          isMoved = false;

          if (specterIsTouched || specterHandleIsTouched) {
            $el.find('.color-picker-sb-spectrum-handle').removeClass('color-picker-sb-spectrum-handle-pressed');
          }

          wheelIsTouched = false;
          wheelHandleIsTouched = false;
          specterIsTouched = false;
          specterHandleIsTouched = false;
        }

        function handleResize() {
          self.modules.wheel.update(self);
        }

        var passiveListener = app.touchEvents.start === 'touchstart' && getSupport$1().passiveListener ? {
          passive: true,
          capture: false
        } : false;
        self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
        app.on('touchmove:active', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
        app.on('resize', handleResize);

        self.destroyWheelEvents = function destroyWheelEvents() {
          self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
          app.off('touchmove:active', handleTouchMove);
          app.off('touchend:passive', handleTouchEnd);
          app.off('resize', handleResize);
        };
      },
      update: function update(self) {
        var value = self.value;
        var hsl = value.hsl,
            hsb = value.hsb;
        var specterWidth = self.$el.find('.color-picker-sb-spectrum')[0].offsetWidth;
        var specterHeight = self.$el.find('.color-picker-sb-spectrum')[0].offsetHeight;
        var wheelSize = self.$el.find('.color-picker-wheel')[0].offsetWidth;
        var wheelHalfSize = wheelSize / 2;
        var angleRad = value.hue * Math.PI / 180;
        var handleSize = wheelSize / 6;
        var handleHalfSize = handleSize / 2;
        var tX = wheelHalfSize - Math.sin(angleRad) * (wheelHalfSize - handleHalfSize) - handleHalfSize;
        var tY = wheelHalfSize - Math.cos(angleRad) * (wheelHalfSize - handleHalfSize) - handleHalfSize;
        self.$el.find('.color-picker-wheel-handle').css('background-color', "hsl(" + hsl[0] + ", 100%, 50%)").transform("translate(" + tX + "px, " + tY + "px)");
        self.$el.find('.color-picker-sb-spectrum').css('background-color', "hsl(" + hsl[0] + ", 100%, 50%)");
        self.$el.find('.color-picker-sb-spectrum-handle').css('background-color', "hsl(" + hsl[0] + ", " + hsl[1] * 100 + "%, " + hsl[2] * 100 + "%)").transform("translate(" + specterWidth * hsb[1] + "px, " + specterHeight * (1 - hsb[2]) + "px)");
      },
      destroy: function destroy(self) {
        if (self.destroyWheelEvents) self.destroyWheelEvents();
        delete self.destroyWheelEvents;
      }
    };

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    function _assertThisInitialized$1(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$1(subClass, superClass); }

    function _setPrototypeOf$1(o, p) { _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$1(o, p); }

    var ColorPicker$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$1(ColorPicker, _Framework7Class);

      function ColorPicker(app, params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params, [app]) || this;

        var self = _assertThisInitialized$1(_this);

        self.params = extend$2({}, app.params.colorPicker, params);
        var $containerEl;

        if (self.params.containerEl) {
          $containerEl = $(self.params.containerEl);
          if ($containerEl.length === 0) return self || _assertThisInitialized$1(_this);
        }

        var $inputEl;

        if (self.params.inputEl) {
          $inputEl = $(self.params.inputEl);
        }

        var $targetEl;

        if (self.params.targetEl) {
          $targetEl = $(self.params.targetEl);
        }

        extend$2(self, {
          app: app,
          $containerEl: $containerEl,
          containerEl: $containerEl && $containerEl[0],
          inline: $containerEl && $containerEl.length > 0,
          $inputEl: $inputEl,
          inputEl: $inputEl && $inputEl[0],
          $targetEl: $targetEl,
          targetEl: $targetEl && $targetEl[0],
          initialized: false,
          opened: false,
          url: self.params.url,
          modules: {
            'alpha-slider': moduleAlphaSlider,
            'current-color': moduleCurrentColor,
            hex: moduleHex,
            // eslint-disable-line
            'hsb-sliders': moduleHsbSliders,
            'hue-slider': moduleHueSlider,
            'brightness-slider': moduleBrightnessSlider,
            palette: modulePalette,
            // eslint-disable-line
            'initial-current-colors': moduleInitialCurrentColors,
            'rgb-bars': moduleRgbBars,
            'rgb-sliders': moduleRgbSliders,
            'sb-spectrum': moduleSbSpectrum,
            'hs-spectrum': moduleHsSpectrum,
            wheel: moduleWheel // eslint-disable-line

          }
        });

        function onInputClick() {
          self.open();
        }

        function onInputFocus(e) {
          e.preventDefault();
        }

        function onTargetClick() {
          self.open();
        }

        function onHtmlClick(e) {
          if (self.destroyed || !self.params) return;
          if (self.params.openIn === 'page') return;
          var $clickTargetEl = $(e.target);
          if (!self.opened || self.closing) return;
          if ($clickTargetEl.closest('[class*="backdrop"]').length) return;
          if ($clickTargetEl.closest('.color-picker-popup, .color-picker-popover').length) return;

          if ($inputEl && $inputEl.length > 0) {
            if ($clickTargetEl[0] !== $inputEl[0] && $clickTargetEl.closest('.sheet-modal').length === 0) {
              self.close();
            }
          } else if ($(e.target).closest('.sheet-modal').length === 0) {
            self.close();
          }
        } // Events


        extend$2(self, {
          attachInputEvents: function attachInputEvents() {
            self.$inputEl.on('click', onInputClick);

            if (self.params.inputReadOnly) {
              self.$inputEl.on('focus mousedown', onInputFocus);

              if (self.$inputEl[0]) {
                self.$inputEl[0].f7ValidateReadonly = true;
              }
            }
          },
          detachInputEvents: function detachInputEvents() {
            self.$inputEl.off('click', onInputClick);

            if (self.params.inputReadOnly) {
              self.$inputEl.off('focus mousedown', onInputFocus);

              if (self.$inputEl[0]) {
                delete self.$inputEl[0].f7ValidateReadonly;
              }
            }
          },
          attachTargetEvents: function attachTargetEvents() {
            self.$targetEl.on('click', onTargetClick);
          },
          detachTargetEvents: function detachTargetEvents() {
            self.$targetEl.off('click', onTargetClick);
          },
          attachHtmlEvents: function attachHtmlEvents() {
            app.on('click', onHtmlClick);
          },
          detachHtmlEvents: function detachHtmlEvents() {
            app.off('click', onHtmlClick);
          }
        });
        self.init();
        return self || _assertThisInitialized$1(_this);
      }

      var _proto = ColorPicker.prototype;

      _proto.attachEvents = function attachEvents() {
        var self = this;
        self.centerModules = self.centerModules.bind(self);

        if (self.params.centerModules) {
          self.app.on('resize', self.centerModules);
        }
      };

      _proto.detachEvents = function detachEvents() {
        var self = this;

        if (self.params.centerModules) {
          self.app.off('resize', self.centerModules);
        }
      };

      _proto.centerModules = function centerModules() {
        var self = this;
        if (!self.opened || !self.$el || self.inline) return;
        var $pageContentEl = self.$el.find('.page-content');
        if (!$pageContentEl.length) return;
        var _$pageContentEl$ = $pageContentEl[0],
            scrollHeight = _$pageContentEl$.scrollHeight,
            offsetHeight = _$pageContentEl$.offsetHeight;

        if (scrollHeight <= offsetHeight) {
          $pageContentEl.addClass('justify-content-center');
        } else {
          $pageContentEl.removeClass('justify-content-center');
        }
      };

      _proto.initInput = function initInput() {
        var self = this;
        if (!self.$inputEl) return;
        if (self.params.inputReadOnly) self.$inputEl.prop('readOnly', true);
      };

      _proto.getModalType = function getModalType() {
        var self = this;
        var app = self.app,
            modal = self.modal,
            params = self.params;
        var openIn = params.openIn,
            openInPhone = params.openInPhone;
        var device = getDevice$1();
        if (modal && modal.type) return modal.type;
        if (openIn !== 'auto') return openIn;
        if (self.inline) return null;

        if (device.ios) {
          return device.ipad ? 'popover' : openInPhone;
        }

        if (app.width >= 768 || device.desktop && app.theme === 'aurora') {
          return 'popover';
        }

        return openInPhone;
      };

      _proto.formatValue = function formatValue() {
        var self = this;
        var value = self.value;

        if (self.params.formatValue) {
          return self.params.formatValue.call(self, value);
        }

        return value.hex;
      } // eslint-disable-next-line
      ;

      _proto.normalizeHsValues = function normalizeHsValues(arr) {
        return [Math.floor(arr[0] * 10) / 10, Math.floor(arr[1] * 1000) / 1000, Math.floor(arr[2] * 1000) / 1000];
      };

      _proto.setValue = function setValue(value, updateModules) {
        if (value === void 0) {
          value = {};
        }

        if (updateModules === void 0) {
          updateModules = true;
        }

        var self = this;
        if (typeof value === 'undefined') return;

        var _ref = self.value || {},
            hex = _ref.hex,
            rgb = _ref.rgb,
            hsl = _ref.hsl,
            hsb = _ref.hsb,
            _ref$alpha = _ref.alpha,
            alpha = _ref$alpha === void 0 ? 1 : _ref$alpha,
            hue = _ref.hue,
            rgba = _ref.rgba,
            hsla = _ref.hsla;

        var needChangeEvent = self.value || !self.value && !self.params.value;
        var valueChanged;
        Object.keys(value).forEach(function (k) {
          if (!self.value || typeof self.value[k] === 'undefined') {
            valueChanged = true;
            return;
          }

          var v = value[k];

          if (Array.isArray(v)) {
            v.forEach(function (subV, subIndex) {
              if (subV !== self.value[k][subIndex]) {
                valueChanged = true;
              }
            });
          } else if (v !== self.value[k]) {
            valueChanged = true;
          }
        });
        if (!valueChanged) return;

        if (value.rgb || value.rgba) {
          var _ref2 = value.rgb || value.rgba,
              r = _ref2[0],
              g = _ref2[1],
              b = _ref2[2],
              _ref2$ = _ref2[3],
              a = _ref2$ === void 0 ? alpha : _ref2$;

          rgb = [r, g, b];
          hex = colorRgbToHex.apply(void 0, rgb);
          hsl = colorRgbToHsl.apply(void 0, rgb);
          hsb = colorHslToHsb.apply(void 0, hsl);
          hsl = self.normalizeHsValues(hsl);
          hsb = self.normalizeHsValues(hsb);
          hue = hsb[0];
          alpha = a;
          rgba = [rgb[0], rgb[1], rgb[2], a];
          hsla = [hsl[0], hsl[1], hsl[2], a];
        }

        if (value.hsl || value.hsla) {
          var _ref3 = value.hsl || value.hsla,
              h = _ref3[0],
              s = _ref3[1],
              l = _ref3[2],
              _ref3$ = _ref3[3],
              _a = _ref3$ === void 0 ? alpha : _ref3$;

          hsl = [h, s, l];
          rgb = colorHslToRgb.apply(void 0, hsl);
          hex = colorRgbToHex.apply(void 0, rgb);
          hsb = colorHslToHsb.apply(void 0, hsl);
          hsl = self.normalizeHsValues(hsl);
          hsb = self.normalizeHsValues(hsb);
          hue = hsb[0];
          alpha = _a;
          rgba = [rgb[0], rgb[1], rgb[2], _a];
          hsla = [hsl[0], hsl[1], hsl[2], _a];
        }

        if (value.hsb) {
          var _value$hsb = value.hsb,
              _h = _value$hsb[0],
              _s = _value$hsb[1],
              _b = _value$hsb[2],
              _value$hsb$ = _value$hsb[3],
              _a2 = _value$hsb$ === void 0 ? alpha : _value$hsb$;

          hsb = [_h, _s, _b];
          hsl = colorHsbToHsl.apply(void 0, hsb);
          rgb = colorHslToRgb.apply(void 0, hsl);
          hex = colorRgbToHex.apply(void 0, rgb);
          hsl = self.normalizeHsValues(hsl);
          hsb = self.normalizeHsValues(hsb);
          hue = hsb[0];
          alpha = _a2;
          rgba = [rgb[0], rgb[1], rgb[2], _a2];
          hsla = [hsl[0], hsl[1], hsl[2], _a2];
        }

        if (value.hex) {
          rgb = colorHexToRgb(value.hex);
          hex = colorRgbToHex.apply(void 0, rgb);
          hsl = colorRgbToHsl.apply(void 0, rgb);
          hsb = colorHslToHsb.apply(void 0, hsl);
          hsl = self.normalizeHsValues(hsl);
          hsb = self.normalizeHsValues(hsb);
          hue = hsb[0];
          rgba = [rgb[0], rgb[1], rgb[2], alpha];
          hsla = [hsl[0], hsl[1], hsl[2], alpha];
        }

        if (typeof value.alpha !== 'undefined') {
          alpha = value.alpha;

          if (typeof rgb !== 'undefined') {
            rgba = [rgb[0], rgb[1], rgb[2], alpha];
          }

          if (typeof hsl !== 'undefined') {
            hsla = [hsl[0], hsl[1], hsl[2], alpha];
          }
        }

        if (typeof value.hue !== 'undefined') {
          var _hsl = hsl;
              _hsl[0];
              var _s2 = _hsl[1],
              _l = _hsl[2]; // eslint-disable-line

          hsl = [value.hue, _s2, _l];
          hsb = colorHslToHsb.apply(void 0, hsl);
          rgb = colorHslToRgb.apply(void 0, hsl);
          hex = colorRgbToHex.apply(void 0, rgb);
          hsl = self.normalizeHsValues(hsl);
          hsb = self.normalizeHsValues(hsb);
          hue = hsb[0];
          rgba = [rgb[0], rgb[1], rgb[2], alpha];
          hsla = [hsl[0], hsl[1], hsl[2], alpha];
        }

        self.value = {
          hex: hex,
          alpha: alpha,
          hue: hue,
          rgb: rgb,
          hsl: hsl,
          hsb: hsb,
          rgba: rgba,
          hsla: hsla
        };
        if (!self.initialValue) self.initialValue = extend$2({}, self.value);
        self.updateValue(needChangeEvent);

        if (self.opened && updateModules) {
          self.updateModules();
        }
      };

      _proto.getValue = function getValue() {
        var self = this;
        return self.value;
      };

      _proto.updateValue = function updateValue(fireEvents) {
        if (fireEvents === void 0) {
          fireEvents = true;
        }

        var self = this;
        var $inputEl = self.$inputEl,
            value = self.value,
            $targetEl = self.$targetEl;

        if ($targetEl && self.params.targetElSetBackgroundColor) {
          var rgba = value.rgba;
          $targetEl.css('background-color', "rgba(" + rgba.join(', ') + ")");
        }

        if (fireEvents) {
          self.emit('local::change colorPickerChange', self, value);
        }

        if ($inputEl && $inputEl.length) {
          var inputValue = self.formatValue(value);

          if ($inputEl && $inputEl.length) {
            $inputEl.val(inputValue);

            if (fireEvents) {
              $inputEl.trigger('change');
            }
          }
        }
      };

      _proto.updateModules = function updateModules() {
        var self = this;
        var modules = self.modules;
        self.params.modules.forEach(function (m) {
          if (typeof m === 'string' && modules[m] && modules[m].update) {
            modules[m].update(self);
          } else if (m && m.update) {
            m.update(self);
          }
        });
      };

      _proto.update = function update() {
        var self = this;
        self.updateModules();
      };

      _proto.renderPicker = function renderPicker() {
        var self = this;
        var params = self.params,
            modules = self.modules;
        var html = '';
        params.modules.forEach(function (m) {
          if (typeof m === 'string' && modules[m] && modules[m].render) {
            html += modules[m].render(self);
          } else if (m && m.render) {
            html += m.render(self);
          }
        });
        return html;
      };

      _proto.renderNavbar = function renderNavbar() {
        var self = this;

        if (self.params.renderNavbar) {
          return self.params.renderNavbar.call(self, self);
        }

        var _self$params = self.params,
            openIn = _self$params.openIn,
            navbarTitleText = _self$params.navbarTitleText,
            navbarBackLinkText = _self$params.navbarBackLinkText,
            navbarCloseText = _self$params.navbarCloseText;
        return $jsx$1("div", {
          class: "navbar"
        }, $jsx$1("div", {
          class: "navbar-bg"
        }), $jsx$1("div", {
          class: "navbar-inner sliding"
        }, openIn === 'page' && $jsx$1("div", {
          class: "left"
        }, $jsx$1("a", {
          class: "link back"
        }, $jsx$1("i", {
          class: "icon icon-back"
        }), $jsx$1("span", {
          class: "if-not-md"
        }, navbarBackLinkText))), $jsx$1("div", {
          class: "title"
        }, navbarTitleText), openIn !== 'page' && $jsx$1("div", {
          class: "right"
        }, $jsx$1("a", {
          class: "link popup-close",
          "data-popup": ".color-picker-popup"
        }, navbarCloseText))));
      };

      _proto.renderToolbar = function renderToolbar() {
        var self = this;

        if (self.params.renderToolbar) {
          return self.params.renderToolbar.call(self, self);
        }

        return $jsx$1("div", {
          class: "toolbar toolbar-top no-shadow"
        }, $jsx$1("div", {
          class: "toolbar-inner"
        }, $jsx$1("div", {
          class: "left"
        }), $jsx$1("div", {
          class: "right"
        }, $jsx$1("a", {
          class: "link sheet-close popover-close",
          "data-sheet": ".color-picker-sheet-modal",
          "data-popover": ".color-picker-popover"
        }, self.params.toolbarCloseText))));
      };

      _proto.renderInline = function renderInline() {
        var self = this;
        var _self$params2 = self.params,
            cssClass = _self$params2.cssClass,
            groupedModules = _self$params2.groupedModules;
        return $jsx$1("div", {
          class: "color-picker color-picker-inline " + (groupedModules ? 'color-picker-grouped-modules' : '') + " " + (cssClass || '')
        }, self.renderPicker());
      };

      _proto.renderSheet = function renderSheet() {
        var self = this;
        var _self$params3 = self.params,
            cssClass = _self$params3.cssClass,
            toolbarSheet = _self$params3.toolbarSheet,
            groupedModules = _self$params3.groupedModules;
        return $jsx$1("div", {
          class: "sheet-modal color-picker color-picker-sheet-modal " + (groupedModules ? 'color-picker-grouped-modules' : '') + " " + (cssClass || '')
        }, toolbarSheet && self.renderToolbar(), $jsx$1("div", {
          class: "sheet-modal-inner"
        }, $jsx$1("div", {
          class: "page-content"
        }, self.renderPicker())));
      };

      _proto.renderPopover = function renderPopover() {
        var self = this;
        var _self$params4 = self.params,
            cssClass = _self$params4.cssClass,
            toolbarPopover = _self$params4.toolbarPopover,
            groupedModules = _self$params4.groupedModules;
        return $jsx$1("div", {
          class: "popover color-picker-popover " + (cssClass || '')
        }, $jsx$1("div", {
          class: "popover-inner"
        }, $jsx$1("div", {
          class: "color-picker " + (groupedModules ? 'color-picker-grouped-modules' : '')
        }, toolbarPopover && self.renderToolbar(), $jsx$1("div", {
          class: "page-content"
        }, self.renderPicker()))));
      };

      _proto.renderPopup = function renderPopup() {
        var self = this;
        var _self$params5 = self.params,
            cssClass = _self$params5.cssClass,
            navbarPopup = _self$params5.navbarPopup,
            groupedModules = _self$params5.groupedModules;
        return $jsx$1("div", {
          class: "popup color-picker-popup " + (cssClass || '')
        }, $jsx$1("div", {
          class: "page"
        }, navbarPopup && self.renderNavbar(), $jsx$1("div", {
          class: "color-picker " + (groupedModules ? 'color-picker-grouped-modules' : '')
        }, $jsx$1("div", {
          class: "page-content"
        }, self.renderPicker()))));
      };

      _proto.renderPage = function renderPage() {
        var self = this;
        var _self$params6 = self.params,
            cssClass = _self$params6.cssClass,
            groupedModules = _self$params6.groupedModules;
        return $jsx$1("div", {
          class: "page color-picker-page " + (cssClass || ''),
          "data-name": "color-picker-page"
        }, self.renderNavbar(), $jsx$1("div", {
          class: "color-picker " + (groupedModules ? 'color-picker-grouped-modules' : '')
        }, $jsx$1("div", {
          class: "page-content"
        }, self.renderPicker())));
      } // eslint-disable-next-line
      ;

      _proto.render = function render() {
        var self = this;
        var params = self.params;
        if (params.render) return params.render.call(self);
        if (self.inline) return self.renderInline();

        if (params.openIn === 'page') {
          return self.renderPage();
        }

        var modalType = self.getModalType();
        if (modalType === 'popover') return self.renderPopover();
        if (modalType === 'sheet') return self.renderSheet();
        if (modalType === 'popup') return self.renderPopup();
      };

      _proto.onOpen = function onOpen() {
        var self = this;
        var initialized = self.initialized,
            $el = self.$el,
            app = self.app,
            $inputEl = self.$inputEl,
            inline = self.inline,
            value = self.value,
            params = self.params,
            modules = self.modules;
        self.closing = false;
        self.opened = true;
        self.opening = true; // Init main events

        self.attachEvents();
        params.modules.forEach(function (m) {
          if (typeof m === 'string' && modules[m] && modules[m].init) {
            modules[m].init(self);
          } else if (m && m.init) {
            m.init(self);
          }
        });
        var updateValue = !value && params.value; // Set value

        if (!initialized) {
          if (value) self.setValue(value);else if (params.value) {
            self.setValue(params.value, false);
          } else if (!params.value) {
            self.setValue({
              hex: '#ff0000'
            }, false);
          }
        } else if (value) {
          self.initialValue = extend$2({}, value);
          self.setValue(value, false);
        } // Update input value


        if (updateValue) self.updateValue();
        self.updateModules(); // Center modules

        if (params.centerModules) {
          self.centerModules();
        } // Extra focus


        if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
          $inputEl.trigger('focus');
        }

        self.initialized = true; // Trigger events

        if ($el) {
          $el.trigger('colorpicker:open');
        }

        if ($inputEl) {
          $inputEl.trigger('colorpicker:open');
        }

        self.emit('local::open colorPickerOpen', self);
      };

      _proto.onOpened = function onOpened() {
        var self = this;
        self.opening = false;

        if (self.$el) {
          self.$el.trigger('colorpicker:opened');
        }

        if (self.$inputEl) {
          self.$inputEl.trigger('colorpicker:opened');
        }

        self.emit('local::opened colorPickerOpened', self);
      };

      _proto.onClose = function onClose() {
        var self = this;
        var app = self.app,
            params = self.params,
            modules = self.modules;
        self.opening = false;
        self.closing = true; // Detach events

        self.detachEvents();

        if (self.$inputEl) {
          if (app.theme === 'md') {
            self.$inputEl.trigger('blur');
          } else {
            var validate = self.$inputEl.attr('validate');
            var required = self.$inputEl.attr('required');

            if (validate && required) {
              app.input.validate(self.$inputEl);
            }
          }
        }

        params.modules.forEach(function (m) {
          if (typeof m === 'string' && modules[m] && modules[m].destroy) {
            modules[m].destroy(self);
          } else if (m && m.destroy) {
            m.destroy(self);
          }
        });

        if (self.$el) {
          self.$el.trigger('colorpicker:close');
        }

        if (self.$inputEl) {
          self.$inputEl.trigger('colorpicker:close');
        }

        self.emit('local::close colorPickerClose', self);
      };

      _proto.onClosed = function onClosed() {
        var self = this;
        self.opened = false;
        self.closing = false;

        if (!self.inline) {
          nextTick$1(function () {
            if (self.modal && self.modal.el && self.modal.destroy) {
              if (!self.params.routableModals) {
                self.modal.destroy();
              }
            }

            delete self.modal;
          });
        }

        if (self.$el) {
          self.$el.trigger('colorpicker:closed');
        }

        if (self.$inputEl) {
          self.$inputEl.trigger('colorpicker:closed');
        }

        self.emit('local::closed colorPickerClosed', self);
      };

      _proto.open = function open() {
        var self = this;
        var app = self.app,
            opened = self.opened,
            inline = self.inline,
            $inputEl = self.$inputEl,
            $targetEl = self.$targetEl,
            params = self.params;
        if (opened) return;

        if (inline) {
          self.$el = $(self.render());
          self.$el[0].f7ColorPicker = self;
          self.$containerEl.append(self.$el);
          self.onOpen();
          self.onOpened();
          return;
        }

        var colorPickerContent = self.render();

        if (params.openIn === 'page') {
          self.view.router.navigate({
            url: self.url,
            route: {
              content: colorPickerContent,
              path: self.url,
              on: {
                pageBeforeIn: function pageBeforeIn(e, page) {
                  self.$el = page.$el.find('.color-picker');
                  self.$el[0].f7ColorPicker = self;
                  self.onOpen();
                },
                pageAfterIn: function pageAfterIn() {
                  self.onOpened();
                },
                pageBeforeOut: function pageBeforeOut() {
                  self.onClose();
                },
                pageAfterOut: function pageAfterOut() {
                  self.onClosed();

                  if (self.$el && self.$el[0]) {
                    self.$el[0].f7ColorPicker = null;
                    delete self.$el[0].f7ColorPicker;
                  }
                }
              }
            }
          });
        } else {
          var modalType = self.getModalType();
          var backdrop = params.backdrop;

          if (backdrop === null || typeof backdrop === 'undefined') {
            if (modalType === 'popover' && app.params.popover.backdrop !== false) backdrop = true;
            if (modalType === 'popup') backdrop = true;
          }

          var modalParams = {
            targetEl: $targetEl || $inputEl,
            scrollToEl: params.scrollToInput ? $targetEl || $inputEl : undefined,
            content: colorPickerContent,
            backdrop: backdrop,
            closeByBackdropClick: params.closeByBackdropClick,
            on: {
              open: function open() {
                var modal = this;
                self.modal = modal;
                self.$el = modalType === 'popover' || modalType === 'popup' ? modal.$el.find('.color-picker') : modal.$el;
                self.$el[0].f7ColorPicker = self;
                self.onOpen();
              },
              opened: function opened() {
                self.onOpened();
              },
              close: function close() {
                self.onClose();
              },
              closed: function closed() {
                self.onClosed();

                if (self.$el && self.$el[0]) {
                  self.$el[0].f7ColorPicker = null;
                  delete self.$el[0].f7ColorPicker;
                }
              }
            }
          };

          if (modalType === 'popup') {
            modalParams.push = params.popupPush;
            modalParams.swipeToClose = params.popupSwipeToClose;
          }

          if (modalType === 'sheet') {
            modalParams.push = params.sheetPush;
            modalParams.swipeToClose = params.sheetSwipeToClose;
          }

          if (params.routableModals && self.view) {
            var _route;

            self.view.router.navigate({
              url: self.url,
              route: (_route = {
                path: self.url
              }, _route[modalType] = modalParams, _route)
            });
          } else {
            self.modal = app[modalType].create(modalParams);
            self.modal.open();
          }
        }
      };

      _proto.close = function close() {
        var self = this;
        var opened = self.opened,
            inline = self.inline;
        if (!opened) return;

        if (inline) {
          self.onClose();
          self.onClosed();
          return;
        }

        if (self.params.routableModals && self.view || self.params.openIn === 'page') {
          self.view.router.back();
        } else {
          self.modal.close();
        }
      };

      _proto.init = function init() {
        var self = this;
        self.initInput();

        if (self.inline) {
          self.open();
          self.emit('local::init colorPickerInit', self);
          return;
        }

        if (!self.initialized && self.params.value) {
          self.setValue(self.params.value);
        } // Attach input Events


        if (self.$inputEl) {
          self.attachInputEvents();
        }

        if (self.$targetEl) {
          self.attachTargetEvents();
        }

        if (self.params.closeByOutsideClick) {
          self.attachHtmlEvents();
        }

        self.emit('local::init colorPickerInit', self);
      };

      _proto.destroy = function destroy() {
        var self = this;
        if (self.destroyed) return;
        var $el = self.$el;
        self.emit('local::beforeDestroy colorPickerBeforeDestroy', self);
        if ($el) $el.trigger('colorpicker:beforedestroy');
        self.close(); // Detach Events

        self.detachEvents();

        if (self.$inputEl) {
          self.detachInputEvents();
        }

        if (self.$targetEl) {
          self.detachTargetEvents();
        }

        if (self.params.closeByOutsideClick) {
          self.detachHtmlEvents();
        }

        if ($el && $el.length) delete self.$el[0].f7ColorPicker;
        deleteProps$1(self);
        self.destroyed = true;
      };

      _createClass(ColorPicker, [{
        key: "view",
        get: function get() {
          var $inputEl = this.$inputEl,
              $targetEl = this.$targetEl,
              app = this.app,
              params = this.params;
          var view;

          if (params.view) {
            view = params.view;
          } else {
            if ($inputEl) {
              view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
            }

            if (!view && $targetEl) {
              view = $targetEl.parents('.view').length && $targetEl.parents('.view')[0].f7View;
            }
          }

          if (!view) view = app.views.main;
          return view;
        }
      }]);

      return ColorPicker;
    }(Framework7Class$1);

    var ColorPicker$2 = ColorPicker$1;

    var ColorPicker = {
      name: 'colorPicker',
      static: {
        ColorPicker: ColorPicker$2
      },
      create: function create() {
        var app = this;
        app.colorPicker = ConstructorMethods({
          defaultSelector: '.color-picker',
          constructor: ColorPicker$2,
          app: app,
          domProp: 'f7ColorPicker'
        });

        app.colorPicker.close = function close(el) {
          if (el === void 0) {
            el = '.color-picker';
          }

          var $el = $(el);
          if ($el.length === 0) return;
          var colorPicker = $el[0].f7ColorPicker;
          if (!colorPicker || colorPicker && !colorPicker.opened) return;
          colorPicker.close();
        };
      },
      params: {
        colorPicker: {
          // Color picker settings
          value: null,
          modules: ['wheel'],
          palette: [['#FFEBEE', '#FFCDD2', '#EF9A9A', '#E57373', '#EF5350', '#F44336', '#E53935', '#D32F2F', '#C62828', '#B71C1C'], ['#F3E5F5', '#E1BEE7', '#CE93D8', '#BA68C8', '#AB47BC', '#9C27B0', '#8E24AA', '#7B1FA2', '#6A1B9A', '#4A148C'], ['#E8EAF6', '#C5CAE9', '#9FA8DA', '#7986CB', '#5C6BC0', '#3F51B5', '#3949AB', '#303F9F', '#283593', '#1A237E'], ['#E1F5FE', '#B3E5FC', '#81D4FA', '#4FC3F7', '#29B6F6', '#03A9F4', '#039BE5', '#0288D1', '#0277BD', '#01579B'], ['#E0F2F1', '#B2DFDB', '#80CBC4', '#4DB6AC', '#26A69A', '#009688', '#00897B', '#00796B', '#00695C', '#004D40'], ['#F1F8E9', '#DCEDC8', '#C5E1A5', '#AED581', '#9CCC65', '#8BC34A', '#7CB342', '#689F38', '#558B2F', '#33691E'], ['#FFFDE7', '#FFF9C4', '#FFF59D', '#FFF176', '#FFEE58', '#FFEB3B', '#FDD835', '#FBC02D', '#F9A825', '#F57F17'], ['#FFF3E0', '#FFE0B2', '#FFCC80', '#FFB74D', '#FFA726', '#FF9800', '#FB8C00', '#F57C00', '#EF6C00', '#E65100']],
          groupedModules: false,
          centerModules: true,
          sliderLabel: false,
          sliderValue: false,
          sliderValueEdiable: false,
          barLabel: false,
          barValue: false,
          barValueEdiable: false,
          hexLabel: false,
          hexValueEditable: false,
          redLabelText: 'R',
          greenLabelText: 'G',
          blueLabelText: 'B',
          hueLabelText: 'H',
          saturationLabelText: 'S',
          brightnessLabelText: 'B',
          hexLabelText: 'HEX',
          alphaLabelText: 'A',
          // Common opener settings
          containerEl: null,
          openIn: 'popover',
          // or 'popover' or 'sheet' or 'popup' or 'page' or 'auto'
          openInPhone: 'popup',
          // or 'popover' or 'sheet' or 'popup' or 'page'
          popupPush: false,
          popupSwipeToClose: undefined,
          sheetPush: false,
          sheetSwipeToClose: undefined,
          formatValue: null,
          targetEl: null,
          targetElSetBackgroundColor: false,
          inputEl: null,
          inputReadOnly: true,
          closeByOutsideClick: true,
          scrollToInput: true,
          toolbarSheet: true,
          toolbarPopover: false,
          toolbarCloseText: 'Done',
          navbarPopup: true,
          navbarCloseText: 'Done',
          navbarTitleText: 'Color',
          navbarBackLinkText: 'Back',
          cssClass: null,
          routableModals: false,
          view: null,
          url: 'color/',
          backdrop: null,
          closeByBackdropClick: true,
          // Render functions
          renderToolbar: null,
          renderNavbar: null,
          renderInline: null,
          renderPopover: null,
          renderSheet: null,
          renderPopup: null,
          render: null
        }
      }
    };

    var Treeview = {
      open: function open(itemEl) {
        var app = this;
        var $itemEl = $(itemEl).eq(0);
        if (!$itemEl.length) return;
        $itemEl.addClass('treeview-item-opened');
        $itemEl.trigger('treeview:open');
        app.emit('treeviewOpen', $itemEl[0]);

        function done(cancel) {
          if (cancel) {
            $itemEl.removeClass('treeview-item-opened');
            $itemEl.trigger('treeview:close');
            app.emit('treeviewClose', $itemEl[0]);
          } else {
            $itemEl[0].f7TreeviewChildrenLoaded = true;
          }

          $itemEl.find('.treeview-toggle').removeClass('treeview-toggle-hidden');
          $itemEl.find('.treeview-preloader').remove();
        }

        if ($itemEl.hasClass('treeview-load-children') && !$itemEl[0].f7TreeviewChildrenLoaded) {
          var preloaders = {
            iosPreloaderContent: iosPreloaderContent,
            mdPreloaderContent: mdPreloaderContent,
            auroraPreloaderContent: auroraPreloaderContent
          };
          $itemEl.trigger('treeview:loadchildren', done);
          app.emit('treeviewLoadChildren', $itemEl[0], done);
          $itemEl.find('.treeview-toggle').addClass('treeview-toggle-hidden');
          $itemEl.find('.treeview-item-root').prepend("<div class=\"preloader treeview-preloader\">" + preloaders[app.theme + "PreloaderContent"] + "</div>");
        }
      },
      close: function close(itemEl) {
        var app = this;
        var $itemEl = $(itemEl).eq(0);
        if (!$itemEl.length) return;
        $itemEl.removeClass('treeview-item-opened');
        $itemEl.trigger('treeview:close');
        app.emit('treeviewClose', $itemEl[0]);
      },
      toggle: function toggle(itemEl) {
        var app = this;
        var $itemEl = $(itemEl).eq(0);
        if (!$itemEl.length) return;
        var wasOpened = $itemEl.hasClass('treeview-item-opened');
        app.treeview[wasOpened ? 'close' : 'open']($itemEl);
      }
    };
    var Treeview$1 = {
      name: 'treeview',
      create: function create() {
        var app = this;
        bindMethods(app, {
          treeview: Treeview
        });
      },
      clicks: {
        '.treeview-toggle': function toggle($clickedEl, clickedData, e) {
          var app = this;
          if ($clickedEl.parents('.treeview-item-toggle').length) return;
          var $treeviewItemEl = $clickedEl.parents('.treeview-item').eq(0);
          if (!$treeviewItemEl.length) return;
          e.preventF7Router = true;
          app.treeview.toggle($treeviewItemEl[0]);
        },
        '.treeview-item-toggle': function toggle($clickedEl, clickedData, e) {
          var app = this;
          var $treeviewItemEl = $clickedEl.closest('.treeview-item').eq(0);
          if (!$treeviewItemEl.length) return;
          e.preventF7Router = true;
          app.treeview.toggle($treeviewItemEl[0]);
        }
      }
    };

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
    var textEditorButtonsMap = {
      // f7-icon, material-icon, command
      bold: ['bold', 'format_bold', 'bold'],
      italic: ['italic', 'format_italic', 'italic'],
      underline: ['underline', 'format_underlined', 'underline'],
      strikeThrough: ['strikethrough', 'strikethrough_s', 'strikeThrough'],
      orderedList: ['list_number', 'format_list_numbered', 'insertOrderedList'],
      unorderedList: ['list_bullet', 'format_list_bulleted', 'insertUnorderedList'],
      link: ['link', 'link', 'createLink'],
      image: ['photo', 'image', 'insertImage'],
      paragraph: ['paragraph', '<i class="icon"></i>', 'formatBlock.P'],
      h1: ['<i class="icon">H<sub>1</sub></i>', '<i class="icon">H<sub>1</sub></i>', 'formatBlock.H1'],
      h2: ['<i class="icon">H<sub>2</sub></i>', '<i class="icon">H<sub>2</sub></i>', 'formatBlock.H2'],
      h3: ['<i class="icon">H<sub>3</sub></i>', '<i class="icon">H<sub>3</sub></i>', 'formatBlock.H3'],
      alignLeft: ['text_alignleft', 'format_align_left', 'justifyLeft'],
      alignCenter: ['text_aligncenter', 'format_align_center', 'justifyCenter'],
      alignRight: ['text_alignright', 'format_align_right', 'justifyRight'],
      alignJustify: ['text_justify', 'format_align_justify', 'justifyFull'],
      subscript: ['textformat_subscript', '<i class="icon">A<sub>1</sub></i>', 'subscript'],
      superscript: ['textformat_superscript', '<i class="icon">A<sup>1</sup></i>', 'superscript'],
      indent: ['increase_indent', 'format_indent_increase', 'indent'],
      outdent: ['decrease_indent', 'format_indent_decrease', 'outdent']
    };

    var TextEditor$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose(TextEditor, _Framework7Class);

      function TextEditor(app, params) {
        var _this;

        _this = _Framework7Class.call(this, params, [app]) || this;

        var self = _assertThisInitialized(_this);

        var document = getDocument();
        var device = getDevice$1();
        var defaults = extend$2({}, app.params.textEditor); // Extend defaults with modules params

        self.useModulesParams(defaults);
        self.params = extend$2(defaults, params);
        var el = self.params.el;
        if (!el) return self || _assertThisInitialized(_this);
        var $el = $(el);
        if ($el.length === 0) return self || _assertThisInitialized(_this);
        if ($el[0].f7TextEditor) return $el[0].f7TextEditor || _assertThisInitialized(_this);
        var $contentEl = $el.children('.text-editor-content');

        if (!$contentEl.length) {
          $el.append('<div class="text-editor-content" contenteditable></div>');
          $contentEl = $el.children('.text-editor-content');
        }

        extend$2(self, {
          app: app,
          $el: $el,
          el: $el[0],
          $contentEl: $contentEl,
          contentEl: $contentEl[0]
        });

        if ('value' in params) {
          self.value = self.params.value;
        }

        if (self.params.mode === 'keyboard-toolbar') {
          if (!(device.cordova || device.capacitor) && !device.android) {
            self.params.mode = 'popover';
          }
        }

        if (typeof self.params.buttons === 'string') {
          try {
            self.params.buttons = JSON.parse(self.params.buttons);
          } catch (err) {
            throw new Error('Framework7: TextEditor: wrong "buttons" parameter format');
          }
        }

        $el[0].f7TextEditor = self; // Bind

        self.onButtonClick = self.onButtonClick.bind(self);
        self.onFocus = self.onFocus.bind(self);
        self.onBlur = self.onBlur.bind(self);
        self.onInput = self.onInput.bind(self);
        self.onPaste = self.onPaste.bind(self);
        self.onSelectionChange = self.onSelectionChange.bind(self);
        self.closeKeyboardToolbar = self.closeKeyboardToolbar.bind(self); // Handle Events

        self.attachEvents = function attachEvents() {
          if (self.params.mode === 'toolbar') {
            self.$el.find('.text-editor-toolbar').on('click', 'button', self.onButtonClick);
          }

          if (self.params.mode === 'keyboard-toolbar') {
            self.$keyboardToolbarEl.on('click', 'button', self.onButtonClick);
            self.$el.parents('.page').on('page:beforeout', self.closeKeyboardToolbar);
          }

          if (self.params.mode === 'popover' && self.popover) {
            self.popover.$el.on('click', 'button', self.onButtonClick);
          }

          self.$contentEl.on('paste', self.onPaste);
          self.$contentEl.on('focus', self.onFocus);
          self.$contentEl.on('blur', self.onBlur);
          self.$contentEl.on('input', self.onInput, true);
          $(document).on('selectionchange', self.onSelectionChange);
        };

        self.detachEvents = function detachEvents() {
          if (self.params.mode === 'toolbar') {
            self.$el.find('.text-editor-toolbar').off('click', 'button', self.onButtonClick);
          }

          if (self.params.mode === 'keyboard-toolbar') {
            self.$keyboardToolbarEl.off('click', 'button', self.onButtonClick);
            self.$el.parents('.page').off('page:beforeout', self.closeKeyboardToolbar);
          }

          if (self.params.mode === 'popover' && self.popover) {
            self.popover.$el.off('click', 'button', self.onButtonClick);
          }

          self.$contentEl.off('paste', self.onPaste);
          self.$contentEl.off('focus', self.onFocus);
          self.$contentEl.off('blur', self.onBlur);
          self.$contentEl.off('input', self.onInput, true);
          $(document).off('selectionchange', self.onSelectionChange);
        }; // Install Modules


        self.useModules(); // Init

        self.init();
        return self || _assertThisInitialized(_this);
      }

      var _proto = TextEditor.prototype;

      _proto.setValue = function setValue(newValue) {
        var self = this;
        var currentValue = self.value;
        if (currentValue === newValue) return self;
        self.value = newValue;
        self.$contentEl.html(newValue);
        self.$el.trigger('texteditor:change', self.value);
        self.emit('local::change textEditorChange', self, self.value);
        return self;
      };

      _proto.getValue = function getValue() {
        var self = this;
        return self.value;
      };

      _proto.clearValue = function clearValue() {
        var self = this;
        self.setValue('');

        if (self.params.placeholder && !self.$contentEl.html()) {
          self.insertPlaceholder();
        }

        return self;
      };

      _proto.createLink = function createLink() {
        var self = this;
        var window = getWindow();
        var document = getDocument();
        var currentSelection = window.getSelection();
        var selectedNodes = [];
        var $selectedLinks;

        if (currentSelection && currentSelection.anchorNode && $(currentSelection.anchorNode).parents(self.$el).length) {
          var anchorNode = currentSelection.anchorNode;

          while (anchorNode) {
            selectedNodes.push(anchorNode);

            if (!anchorNode.nextSibling || anchorNode === currentSelection.focusNode) {
              anchorNode = null;
            }

            if (anchorNode) {
              anchorNode = anchorNode.nextSibling;
            }
          }

          var selectedNodesLinks = [];
          var $selectedNodes = $(selectedNodes);

          for (var i = 0; i < $selectedNodes.length; i += 1) {
            var childNodes = $selectedNodes[i].children;

            if (childNodes) {
              for (var j = 0; j < childNodes.length; j += 1) {
                if ($(childNodes[j]).is('a')) {
                  selectedNodesLinks.push(childNodes[j]);
                }
              }
            }
          }

          $selectedLinks = $selectedNodes.closest('a').add($(selectedNodesLinks));
        }

        if ($selectedLinks && $selectedLinks.length) {
          $selectedLinks.each(function (linkNode) {
            var selection = window.getSelection();
            var range = document.createRange();
            range.selectNodeContents(linkNode);
            selection.removeAllRanges();
            selection.addRange(range);
            document.execCommand('unlink', false);
            selection.removeAllRanges();
          });
          return self;
        }

        var currentRange = self.getSelectionRange();
        if (!currentRange) return self;
        var dialog = self.app.dialog.prompt(self.params.linkUrlText, '', function (link) {
          if (link && link.trim().length) {
            self.setSelectionRange(currentRange);
            document.execCommand('createLink', false, link.trim());
            self.$el.trigger('texteditor:insertlink', {
              url: link.trim()
            });
            self.emit('local:insertLink textEditorInsertLink', self, link.trim());
          }
        });
        dialog.$el.find('input').focus();
        return self;
      };

      _proto.insertImage = function insertImage() {
        var self = this;
        var document = getDocument();
        var currentRange = self.getSelectionRange();
        if (!currentRange) return self;
        var dialog = self.app.dialog.prompt(self.params.imageUrlText, '', function (imageUrl) {
          if (imageUrl && imageUrl.trim().length) {
            self.setSelectionRange(currentRange);
            document.execCommand('insertImage', false, imageUrl.trim());
            self.$el.trigger('texteditor:insertimage', {
              url: imageUrl.trim()
            });
            self.emit('local:insertImage textEditorInsertImage', self, imageUrl.trim());
          }
        });
        dialog.$el.find('input').focus();
        return self;
      };

      _proto.removePlaceholder = function removePlaceholder() {
        var self = this;
        self.$contentEl.find('.text-editor-placeholder').remove();
      };

      _proto.insertPlaceholder = function insertPlaceholder() {
        var self = this;
        self.$contentEl.append("<div class=\"text-editor-placeholder\">" + self.params.placeholder + "</div>");
      };

      _proto.onSelectionChange = function onSelectionChange() {
        var self = this;
        var window = getWindow();
        var document = getDocument();
        if (self.params.mode === 'toolbar') return;
        var selection = window.getSelection();
        var selectionIsInContent = $(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;

        if (self.params.mode === 'keyboard-toolbar') {
          if (!selectionIsInContent) {
            self.closeKeyboardToolbar();
          } else {
            self.openKeyboardToolbar();
          }

          return;
        }

        if (self.params.mode === 'popover') {
          var selectionIsInPopover = $(selection.anchorNode).parents(self.popover.el).length || selection.anchorNode === self.popover.el;

          if (!selectionIsInContent && !selectionIsInPopover) {
            self.closePopover();
            return;
          }

          if (!selection.isCollapsed && selection.rangeCount) {
            var range = selection.getRangeAt(0);
            var rect = range.getBoundingClientRect();
            var rootEl = self.app.$el[0] || document.body;
            self.openPopover(rect.x + (window.scrollX || 0) - rootEl.offsetLeft, rect.y + (window.scrollY || 0) - rootEl.offsetTop, rect.width, rect.height);
          } else if (selection.isCollapsed) {
            self.closePopover();
          }
        }
      };

      _proto.onPaste = function onPaste(e) {
        var self = this;
        var document = getDocument();

        if (self.params.clearFormattingOnPaste && e.clipboardData && e.clipboardData.getData) {
          var text = e.clipboardData.getData('text/plain');
          e.preventDefault();
          document.execCommand('insertText', false, text);
        }
      };

      _proto.onInput = function onInput() {
        var self = this;
        var value = self.$contentEl.html();
        self.value = value;
        self.$el.trigger('texteditor:input');
        self.emit('local:input textEditorInput', self, self.value);
        self.$el.trigger('texteditor:change', self.value);
        self.emit('local::change textEditorChange', self, self.value);
      };

      _proto.onFocus = function onFocus() {
        var self = this;
        self.removePlaceholder();
        self.$contentEl.focus();
        self.$el.trigger('texteditor:focus');
        self.emit('local::focus textEditorFocus', self);
      };

      _proto.onBlur = function onBlur() {
        var self = this;
        var window = getWindow();
        var document = getDocument();

        if (self.params.placeholder && self.$contentEl.html() === '') {
          self.insertPlaceholder();
        }

        if (self.params.mode === 'popover') {
          var selection = window.getSelection();
          var selectionIsInContent = $(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
          var inPopover = document.activeElement && self.popover && $(document.activeElement).closest(self.popover.$el).length;

          if (!inPopover && !selectionIsInContent) {
            self.closePopover();
          }
        }

        if (self.params.mode === 'keyboard-toolbar') {
          var _selection = window.getSelection();

          var _selectionIsInContent = $(_selection.anchorNode).parents(self.contentEl).length || _selection.anchorNode === self.contentEl;

          if (!_selectionIsInContent) {
            self.closeKeyboardToolbar();
          }
        }

        self.$el.trigger('texteditor:blur');
        self.emit('local::blur textEditorBlur', self);
      };

      _proto.onButtonClick = function onButtonClick(e) {
        var self = this;
        var window = getWindow();
        var document = getDocument();
        var selection = window.getSelection();
        var selectionIsInContent = $(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
        if (!selectionIsInContent) return;
        var $buttonEl = $(e.target).closest('button');

        if ($buttonEl.parents('form').length) {
          e.preventDefault();
        }

        var button = $buttonEl.attr('data-button');
        var buttonData = self.params.customButtons && self.params.customButtons[button];
        if (!button || !(textEditorButtonsMap[button] || buttonData)) return;
        $buttonEl.trigger('texteditor:buttonclick', button);
        self.emit('local::buttonClick textEditorButtonClick', self, button);

        if (buttonData) {
          if (buttonData.onClick) buttonData.onClick(self, $buttonEl[0]);
          return;
        }

        var command = textEditorButtonsMap[button][2];

        if (command === 'createLink') {
          self.createLink();
          return;
        }

        if (command === 'insertImage') {
          self.insertImage();
          return;
        }

        if (command.indexOf('formatBlock') === 0) {
          var tagName = command.split('.')[1];
          var $anchorNode = $(selection.anchorNode);

          if ($anchorNode.parents(tagName.toLowerCase()).length || $anchorNode.is(tagName)) {
            document.execCommand('formatBlock', false, 'div');
          } else {
            document.execCommand('formatBlock', false, tagName);
          }

          return;
        }

        document.execCommand(command, false);
      } // eslint-disable-next-line
      ;

      _proto.getSelectionRange = function getSelectionRange() {
        var window = getWindow();
        var document = getDocument();

        if (window.getSelection) {
          var sel = window.getSelection();

          if (sel.getRangeAt && sel.rangeCount) {
            return sel.getRangeAt(0);
          }
        } else if (document.selection && document.selection.createRange) {
          return document.selection.createRange();
        }

        return null;
      } // eslint-disable-next-line
      ;

      _proto.setSelectionRange = function setSelectionRange(range) {
        var window = getWindow();
        var document = getDocument();

        if (range) {
          if (window.getSelection) {
            var sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          } else if (document.selection && range.select) {
            range.select();
          }
        }
      };

      _proto.renderButtons = function renderButtons() {
        var self = this;
        var html = '';

        function renderButton(button) {
          var iconClass = self.app.theme === 'md' ? 'material-icons' : 'f7-icons';

          if (self.params.customButtons && self.params.customButtons[button]) {
            var buttonData = self.params.customButtons[button];
            return "<button type=\"button\" class=\"text-editor-button\" data-button=\"" + button + "\">" + (buttonData.content || '') + "</button>";
          }

          if (!textEditorButtonsMap[button]) return '';
          var iconContent = textEditorButtonsMap[button][self.app.theme === 'md' ? 1 : 0];
          return ("<button type=\"button\" class=\"text-editor-button\" data-button=\"" + button + "\">" + (iconContent.indexOf('<') >= 0 ? iconContent : "<i class=\"" + iconClass + "\">" + iconContent + "</i>") + "</button>").trim();
        }

        self.params.buttons.forEach(function (button, buttonIndex) {
          if (Array.isArray(button)) {
            button.forEach(function (b) {
              html += renderButton(b);
            });

            if (buttonIndex < self.params.buttons.length - 1 && self.params.dividers) {
              html += '<div class="text-editor-button-divider"></div>';
            }
          } else {
            html += renderButton(button);
          }
        });
        return html;
      };

      _proto.createToolbar = function createToolbar() {
        var self = this;
        self.$el.prepend("<div class=\"text-editor-toolbar\">" + self.renderButtons() + "</div>");
      };

      _proto.createKeyboardToolbar = function createKeyboardToolbar() {
        var self = this;
        self.$keyboardToolbarEl = $("<div class=\"toolbar toolbar-bottom text-editor-keyboard-toolbar\"><div class=\"toolbar-inner\">" + self.renderButtons() + "</div></div>");
      };

      _proto.createPopover = function createPopover() {
        var self = this;
        self.popover = self.app.popover.create({
          content: "\n        <div class=\"popover theme-dark text-editor-popover\">\n          <div class=\"popover-inner\">" + self.renderButtons() + "</div>\n        </div>\n      ",
          closeByOutsideClick: false,
          backdrop: false
        });
      };

      _proto.openKeyboardToolbar = function openKeyboardToolbar() {
        var self = this;
        if (self.$keyboardToolbarEl.parent(self.app.$el).length) return;
        self.$el.trigger('texteditor:keyboardopen');
        self.emit('local::keyboardOpen textEditorKeyboardOpen', self);
        self.app.$el.append(self.$keyboardToolbarEl);
      };

      _proto.closeKeyboardToolbar = function closeKeyboardToolbar() {
        var self = this;
        self.$keyboardToolbarEl.remove();
        self.$el.trigger('texteditor:keyboardclose');
        self.emit('local::keyboardClose textEditorKeyboardClose', self);
      };

      _proto.openPopover = function openPopover(targetX, targetY, targetWidth, targetHeight) {
        var self = this;
        if (!self.popover) return;
        Object.assign(self.popover.params, {
          targetX: targetX,
          targetY: targetY,
          targetWidth: targetWidth,
          targetHeight: targetHeight
        });
        clearTimeout(self.popoverTimeout);
        self.popoverTimeout = setTimeout(function () {
          if (!self.popover) return;

          if (self.popover.opened) {
            self.popover.resize();
          } else {
            self.$el.trigger('texteditor:popoveropen');
            self.emit('local::popoverOpen textEditorPopoverOpen', self);
            self.popover.open();
          }
        }, 400);
      };

      _proto.closePopover = function closePopover() {
        var self = this;
        clearTimeout(self.popoverTimeout);
        if (!self.popover || !self.popover.opened) return;
        self.popoverTimeout = setTimeout(function () {
          if (!self.popover) return;
          self.$el.trigger('texteditor:popoverclose');
          self.emit('local::popoverClose textEditorPopoverClose', self);
          self.popover.close();
        }, 400);
      };

      _proto.init = function init() {
        var self = this;

        if (self.value) {
          self.$contentEl.html(self.value);
        } else {
          self.value = self.$contentEl.html();
        }

        if (self.params.placeholder && self.value === '') {
          self.insertPlaceholder();
        }

        if (self.params.mode === 'toolbar') {
          self.createToolbar();
        } else if (self.params.mode === 'popover') {
          self.createPopover();
        } else if (self.params.mode === 'keyboard-toolbar') {
          self.createKeyboardToolbar();
        }

        self.attachEvents();
        self.$el.trigger('texteditor:init');
        self.emit('local::init textEditorInit', self);
        return self;
      };

      _proto.destroy = function destroy() {
        var self = this;
        self.$el.trigger('texteditor:beforedestroy');
        self.emit('local::beforeDestroy textEditorBeforeDestroy', self);
        self.detachEvents();

        if (self.params.mode === 'keyboard-toolbar' && self.$keyboardToolbarEl) {
          self.$keyboardToolbarEl.remove();
        }

        if (self.popover) {
          self.popover.close(false);
          self.popover.destroy();
        }

        delete self.$el[0].f7TextEditor;
        deleteProps$1(self);
        self = null;
      };

      return TextEditor;
    }(Framework7Class$1);

    var TextEditor$2 = TextEditor$1;

    var TextEditor = {
      name: 'textEditor',
      params: {
        textEditor: {
          el: null,
          mode: 'toolbar',
          // or 'popover'
          value: undefined,
          // will use html content
          customButtons: null,
          buttons: [['bold', 'italic', 'underline', 'strikeThrough'], ['orderedList', 'unorderedList'], ['link', 'image'], ['paragraph', 'h1', 'h2', 'h3'], ['alignLeft', 'alignCenter', 'alignRight', 'alignJustify'], ['subscript', 'superscript'], ['indent', 'outdent']],
          dividers: true,
          imageUrlText: 'Insert image URL',
          linkUrlText: 'Insert link URL',
          placeholder: null,
          clearFormattingOnPaste: true
        }
      },
      create: function create() {
        var app = this;
        app.textEditor = extend$2(ConstructorMethods({
          defaultSelector: '.text-editor',
          constructor: TextEditor$2,
          app: app,
          domProp: 'f7TextEditor'
        }));
      },
      static: {
        TextEditor: TextEditor$2
      },
      on: {
        tabMounted: function tabMounted(tabEl) {
          var app = this;
          $(tabEl).find('.text-editor-init').each(function (editorEl) {
            var dataset = $(editorEl).dataset();
            app.textEditor.create(extend$2({
              el: editorEl
            }, dataset || {}));
          });
        },
        tabBeforeRemove: function tabBeforeRemove(tabEl) {
          $(tabEl).find('.text-editor-init').each(function (editorEl) {
            if (editorEl.f7TextEditor) editorEl.f7TextEditor.destroy();
          });
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.text-editor-init').each(function (editorEl) {
            var dataset = $(editorEl).dataset();
            app.textEditor.create(extend$2({
              el: editorEl
            }, dataset || {}));
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          page.$el.find('.text-editor-init').each(function (editorEl) {
            if (editorEl.f7TextEditor) editorEl.f7TextEditor.destroy();
          });
        }
      },
      vnode: {
        'text-editor-init': {
          insert: function insert(vnode) {
            var app = this;
            var editorEl = vnode.elm;
            var dataset = $(editorEl).dataset();
            app.textEditor.create(extend$2({
              el: editorEl
            }, dataset || {}));
          },
          destroy: function destroy(vnode) {
            var editorEl = vnode.elm;
            if (editorEl.f7TextEditor) editorEl.f7TextEditor.destroy();
          }
        }
      }
    };

    var Elevation = {
      name: 'elevation'
    };

    var Typography = {
      name: 'typography'
    };

    /**
     * Framework7 6.3.5
     * Full featured mobile HTML framework for building iOS & Android apps
     * https://framework7.io/
     *
     * Copyright 2014-2021 Vladimir Kharlampidi
     *
     * Released under the MIT License
     *
     * Released on: September 30, 2021
     */
    Framework7$1.use([DeviceModule, SupportModule, UtilsModule, ResizeModule, RequestModule, TouchModule, ClicksModule, RouterModule, HistoryModule, ServiceWorkerModule, StoreModule, Statusbar$1, View$1, Navbar$2, Toolbar$2, Subnavbar, TouchRipple, Modal, Appbar, Dialog, Popup$1, LoginScreen, Popover, Actions, Sheet, Toast, Preloader$2, Progressbar$1, Sortable$1, Swipeout$1, Accordion$1, ContactsList, VirtualList, ListIndex, Timeline, Tabs, Panel, Card, Chip, Form, Input$1, Checkbox, Radio, Toggle, Range$1, Stepper, SmartSelect, Grid$1, Calendar, Picker, InfiniteScroll$1, PullToRefresh, Lazy$1, DataTable, Fab$2, Searchbar, Messages, Messagebar, Swiper, PhotoBrowser, Notification, Autocomplete, Tooltip, Skeleton, Menu$1, ColorPicker, Treeview$1, TextEditor, Elevation, Typography]);

    /**
     * Framework7 6.3.5
     * Full featured mobile HTML framework for building iOS & Android apps
     * https://framework7.io/
     *
     * Copyright 2014-2021 Vladimir Kharlampidi
     *
     * Released under the MIT License
     *
     * Released on: September 30, 2021
     */
    Framework7$1.use([DeviceModule, SupportModule, UtilsModule, ResizeModule, RequestModule, TouchModule, ClicksModule, RouterModule, HistoryModule, ServiceWorkerModule, StoreModule, Statusbar$1, View$1, Navbar$2, Toolbar$2, Subnavbar, TouchRipple, Modal]);

    function noUndefinedProps(obj) {
      var o = {};
      Object.keys(obj).forEach(function (key) {
        if (typeof obj[key] !== 'undefined') o[key] = obj[key];
      });
      return o;
    }
    function isStringProp(val) {
      return typeof val === 'string' && val !== '';
    }
    function isObject(o) {
      return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
    }
    function now() {
      return Date.now();
    }
    function extend() {
      var deep = true;
      var to;
      var from;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (typeof args[0] === 'boolean') {
        deep = args[0];
        to = args[1];
        args.splice(0, 2);
        from = args;
      } else {
        to = args[0];
        args.splice(0, 1);
        from = args;
      }

      for (var i = 0; i < from.length; i += 1) {
        var nextSource = args[i];

        if (nextSource !== undefined && nextSource !== null) {
          var keysArray = Object.keys(Object(nextSource));

          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              if (!deep) {
                to[nextKey] = nextSource[nextKey];
              } else if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                extend(to[nextKey], nextSource[nextKey]);
              } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                to[nextKey] = {};
                extend(to[nextKey], nextSource[nextKey]);
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }

      return to;
    }
    function classNames() {
      var classes = [];

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      args.forEach(function (arg) {
        if (typeof arg === 'object' && arg.constructor === Object) {
          Object.keys(arg).forEach(function (key) {
            if (arg[key]) classes.push(key);
          });
        } else if (arg) classes.push(arg);
      });
      var uniqueClasses = [];
      classes.forEach(function (c) {
        if (uniqueClasses.indexOf(c) < 0) uniqueClasses.push(c);
      });
      return uniqueClasses.join(' ');
    }
    function createEmitter(createEventDispatcher, props) {
      var dispatch = createEventDispatcher();

      var emit = function emit(events, argsArray) {
        if (!events || !events.trim().length || typeof events !== 'string') return;
        events.trim().split(' ').forEach(function (event) {
          var eventName = (event || '').trim();
          if (!eventName) return;
          var propName = "on" + (eventName.charAt(0).toUpperCase() + eventName.slice(1));
          dispatch(eventName, argsArray);
          if (typeof props[propName] === 'function') props[propName].apply(props, argsArray);
        });
      };

      return emit;
    }
    var routerIdCounter = 0;
    var routerComponentIdCounter = 0;
    function unsetRouterIds() {
      routerIdCounter = 0;
      routerComponentIdCounter = 0;
    }
    function getRouterId() {
      routerIdCounter += 1;
      return now() + "_" + routerIdCounter;
    }
    function getComponentId() {
      routerComponentIdCounter += 1;
      return now() + "_" + routerComponentIdCounter;
    }
    function plainText(text) {
      if (typeof text === 'undefined' || text === null) return '';
      return text;
    }

    /* eslint-disable import/no-mutable-exports */
    var f7;

    if (!Framework7$1.__app__) {
      // eslint-disable-next-line
      Framework7$1.__app__ = {
        f7: undefined,
        f7events: undefined,
        theme: {},
        f7routers: {
          views: [],
          tabs: [],
          modals: null
        }
      };
    }

    var app$1 = Framework7$1.__app__;

    app$1.setInstance = function (instance) {
      f7 = instance;
    };

    var setTheme = function setTheme() {
      if (!app$1.f7) return;
      app$1.theme.ios = app$1.f7.theme === 'ios';
      app$1.f7.theme === 'ios';
      app$1.theme.md = app$1.f7.theme === 'md';
      app$1.f7.theme === 'md';
      app$1.theme.aurora = app$1.f7.theme === 'aurora';
      app$1.f7.theme === 'aurora';
    };

    var cleanup = function cleanup() {
      unsetRouterIds();
      delete app$1.theme.ios;
      delete app$1.theme.md;
      delete app$1.theme.aurora;
      app$1.f7routers.views = [];
      app$1.f7routers.tabs = [];
      app$1.f7routers.modals = null;
    };

    var f7initEvents = function f7initEvents() {
      app$1.f7events = new Framework7$1.Events();
    };

    var f7init = function f7init(rootEl, params, init) {
      if (params === void 0) {
        params = {};
      }

      if (init === void 0) {
        init = true;
      }

      var f7Params = extend({}, params, {
        el: rootEl,
        init: init
      });
      if (typeof params.store !== 'undefined') f7Params.store = params.store;
      if (!f7Params.routes) f7Params.routes = [];

      if (f7Params.userAgent && (f7Params.theme === 'auto' || !f7Params.theme)) {
        var device = Framework7$1.getDevice({
          userAgent: f7Params.userAgent
        }, true);
        app$1.theme.ios = !!device.ios;
        app$1.theme.aurora = device.desktop && device.electron;
        app$1.theme.md = !app$1.theme.ios && !app$1.theme.aurora;
      } // eslint-disable-next-line


      if (app$1.f7 && typeof window !== 'undefined') return; // eslint-disable-next-line

      if (typeof window === 'undefined') cleanup();
      var instance = new Framework7$1(f7Params);
      app$1.f7 = instance;
      f7 = instance;
      app$1.setInstance(instance);
      setTheme();

      if (instance.initialized) {
        app$1.f7 = instance;
        f7 = instance;
        app$1.setInstance(instance);
        app$1.f7events.emit('ready', app$1.f7);
      } else {
        instance.on('init', function () {
          app$1.f7 = instance;
          f7 = instance;
          app$1.setInstance(instance);
          app$1.f7events.emit('ready', app$1.f7);
        });
      }
    };

    var f7ready = function f7ready(callback) {
      if (!callback) return;
      if (app$1.f7 && app$1.f7.initialized) callback(app$1.f7);else {
        app$1.f7events.once('ready', callback);
      }
    };

    /* eslint no-underscore-dangle: "off" */

    var getChildrenArray = function getChildrenArray(el) {
      var arr = [];

      for (var i = 0; i < el.children.length; i += 1) {
        arr.push(el.children[i]);
      }

      return arr;
    };

    var hasSameChildren = function hasSameChildren(childrenBefore, childrenAfter) {
      if (childrenBefore.length !== childrenAfter.length) return false;
      var set = new Set([].concat(childrenBefore, childrenAfter));
      if (set.size === childrenBefore.length) return true;
      return false;
    };

    var componentsRouter = {
      proto: {
        pageComponentLoader: function pageComponentLoader(_ref) {
          var routerEl = _ref.routerEl,
              component = _ref.component,
              options = _ref.options,
              resolve = _ref.resolve,
              reject = _ref.reject;
          var router = this;
          var routerId = router.id;
          var el = routerEl;
          var viewRouter;
          app$1.f7routers.views.forEach(function (data) {
            if (data.el && data.el === routerEl || data.routerId && data.routerId === routerId) {
              viewRouter = data;
            }
          });

          if (!viewRouter) {
            reject();
            return;
          }

          var pageData = {
            component: component,
            id: getComponentId(),
            props: extend({
              f7route: options.route,
              f7router: router
            }, options.route.params, options.props || {})
          };
          var resolved;
          var childrenBefore = getChildrenArray(el);

          function onDidUpdate(componentRouterData) {
            if (componentRouterData !== viewRouter || resolved) return;
            var childrenAfter = getChildrenArray(el);
            if (hasSameChildren(childrenBefore, childrenAfter)) return;
            app$1.f7events.off('viewRouterDidUpdate', onDidUpdate);
            var pageEl = el.children[el.children.length - 1];
            pageData.el = pageEl;
            resolve(pageEl);
            resolved = true;
          }

          app$1.f7events.on('viewRouterDidUpdate', onDidUpdate);
          viewRouter.pages.push(pageData);
          viewRouter.setPages(viewRouter.pages);
        },
        removePage: function removePage($pageEl) {
          if (!$pageEl) return;
          var router = this;
          var f7Page;
          if ('length' in $pageEl && $pageEl[0]) f7Page = $pageEl[0].f7Page;else f7Page = $pageEl.f7Page;

          if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
            router.app.$($pageEl).remove();
            return;
          }

          var viewRouter;
          app$1.f7routers.views.forEach(function (data) {
            if (data.el && data.el === router.el) {
              viewRouter = data;
            }
          });
          var pageEl;

          if ('length' in $pageEl) {
            // Dom7
            if ($pageEl.length === 0) return;
            pageEl = $pageEl[0];
          } else {
            pageEl = $pageEl;
          }

          if (!pageEl) return;
          var pageComponentFound;
          viewRouter.pages.forEach(function (page, index) {
            if (page.el === pageEl) {
              pageComponentFound = true;
              viewRouter.pages.splice(index, 1);
              viewRouter.setPages(viewRouter.pages);
            }
          });

          if (!pageComponentFound) {
            pageEl.parentNode.removeChild(pageEl);
          }
        },
        tabComponentLoader: function tabComponentLoader(_temp) {
          var _ref2 = _temp === void 0 ? {} : _temp,
              tabEl = _ref2.tabEl,
              component = _ref2.component,
              options = _ref2.options,
              resolve = _ref2.resolve,
              reject = _ref2.reject;

          var router = this;
          if (!tabEl) reject();
          var tabRouter;
          app$1.f7routers.tabs.forEach(function (tabData) {
            if (tabData.el && tabData.el === tabEl) {
              tabRouter = tabData;
            }
          });

          if (!tabRouter) {
            reject();
            return;
          }

          var id = getComponentId();
          var tabContent = {
            id: id,
            component: component,
            props: extend({
              f7route: options.route,
              f7router: router
            }, options.route.route && options.route.route.tab && options.route.route.tab.options && options.route.route.tab.options.props || {}, options.route.params, options.props || {})
          };
          var resolved;

          function onDidUpdate(componentRouterData) {
            if (componentRouterData !== tabRouter || resolved) return;
            app$1.f7events.off('tabRouterDidUpdate', onDidUpdate);
            var tabContentEl = tabEl.children[0];
            resolve(tabContentEl);
            resolved = true;
          }

          app$1.f7events.on('tabRouterDidUpdate', onDidUpdate);
          tabRouter.setTabContent(tabContent);
        },
        removeTabContent: function removeTabContent(tabEl) {
          if (!tabEl) return;
          var tabRouter;
          app$1.f7routers.tabs.forEach(function (tabData) {
            if (tabData.el && tabData.el === tabEl) {
              tabRouter = tabData;
            }
          });

          if (!tabRouter) {
            tabEl.innerHTML = ''; // eslint-disable-line

            return;
          }

          tabRouter.setTabContent(null);
        },
        modalComponentLoader: function modalComponentLoader(_temp2) {
          var _ref3 = _temp2 === void 0 ? {} : _temp2,
              component = _ref3.component,
              options = _ref3.options,
              resolve = _ref3.resolve,
              reject = _ref3.reject;

          var router = this;
          var modalsRouter = app$1.f7routers.modals;

          if (!modalsRouter) {
            reject();
            return;
          }

          var modalData = {
            component: component,
            id: getComponentId(),
            props: extend({
              f7route: options.route,
              f7router: router
            }, options.route.params, options.props || {})
          };
          var resolved;

          function onDidUpdate() {
            if (resolved) return;
            app$1.f7events.off('modalsRouterDidUpdate', onDidUpdate);
            var modalEl = modalsRouter.el.children[modalsRouter.el.children.length - 1];
            modalData.el = modalEl;
            resolve(modalEl);
            resolved = true;
          }

          app$1.f7events.on('modalsRouterDidUpdate', onDidUpdate);
          modalsRouter.modals.push(modalData);
          modalsRouter.setModals(modalsRouter.modals);
        },
        removeModal: function removeModal(modalEl) {
          var modalsRouter = app$1.f7routers.modals;
          if (!modalsRouter) return;
          var modalDataToRemove;
          modalsRouter.modals.forEach(function (modalData) {
            if (modalData.el === modalEl) modalDataToRemove = modalData;
          });
          modalsRouter.modals.splice(modalsRouter.modals.indexOf(modalDataToRemove), 1);
          modalsRouter.setModals(modalsRouter.modals);
        }
      }
    };

    // eslint-disable-next-line
    var Framework7Svelte = {
      name: 'sveltePlugin',
      installed: false,
      install: function install(params) {
        if (params === void 0) {
          params = {};
        }

        if (Framework7Svelte.installed) return;
        Framework7Svelte.installed = true;
        f7initEvents();
        var _params = params,
            paramsTheme = _params.theme,
            userAgent = _params.userAgent;

        if (paramsTheme === 'md') {
          app$1.theme.md = true;
        }

        if (paramsTheme === 'ios') {
          app$1.theme.md = true;
        }

        if (paramsTheme === 'aurora') {
          app$1.theme.md = true;
        } // eslint-disable-next-line


        var needThemeCalc = typeof window === 'undefined' ? !!userAgent : true;

        if (needThemeCalc && (!paramsTheme || paramsTheme === 'auto')) {
          var device = Framework7$1.getDevice({
            userAgent: userAgent
          }, true);
          app$1.theme.ios = !!device.ios;
          app$1.theme.ios;
          app$1.theme.aurora = device.desktop && device.electron;
          app$1.theme.aurora;
          app$1.theme.md = !app$1.theme.ios && !app$1.theme.aurora;
          app$1.theme.md;
        }

        f7ready(function () {
          setTheme();
        });
        Framework7$1.Router.use(componentsRouter);
      }
    };

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function compute_slots(slots) {
        const result = {};
        for (const key in slots) {
            result[key] = true;
        }
        return result;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text$1(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text$1(' ');
    }
    function empty() {
        return text$1('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
        select.selectedIndex = -1; // no option should be selected
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.0' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    function colorClasses(props) {
      var _ref;

      var color = props.color,
          colorTheme = props.colorTheme,
          textColor = props.textColor,
          bgColor = props.bgColor,
          borderColor = props.borderColor,
          rippleColor = props.rippleColor,
          themeDark = props.themeDark;
      return _ref = {
        'theme-dark': themeDark
      }, _ref["color-" + color] = color, _ref["color-theme-" + colorTheme] = colorTheme, _ref["text-color-" + textColor] = textColor, _ref["bg-color-" + bgColor] = bgColor, _ref["border-color-" + borderColor] = borderColor, _ref["ripple-color-" + rippleColor] = rippleColor, _ref;
    }
    function routerAttrs(props) {
      var force = props.force,
          reloadCurrent = props.reloadCurrent,
          reloadPrevious = props.reloadPrevious,
          reloadAll = props.reloadAll,
          reloadDetail = props.reloadDetail,
          animate = props.animate,
          ignoreCache = props.ignoreCache,
          routeTabId = props.routeTabId,
          view = props.view,
          transition = props.transition,
          openIn = props.openIn;
      var dataAnimate;

      if ('animate' in props && typeof animate !== 'undefined') {
        dataAnimate = animate.toString();
      }

      var dataReloadDetail;

      if ('reloadDetail' in props && typeof reloadDetail !== 'undefined') {
        dataReloadDetail = reloadDetail.toString();
      }

      return {
        'data-force': force || undefined,
        'data-reload-current': reloadCurrent || undefined,
        'data-reload-all': reloadAll || undefined,
        'data-reload-previous': reloadPrevious || undefined,
        'data-reload-detail': dataReloadDetail,
        'data-animate': dataAnimate,
        'data-ignore-cache': ignoreCache || undefined,
        'data-route-tab-id': routeTabId || undefined,
        'data-view': isStringProp(view) ? view : undefined,
        'data-transition': isStringProp(transition) ? transition : undefined,
        'data-open-in': isStringProp(openIn) ? openIn : undefined
      };
    }
    function routerClasses(props) {
      var back = props.back,
          linkBack = props.linkBack,
          external = props.external,
          preventRouter = props.preventRouter;
      return {
        back: back || linkBack,
        external: external,
        'prevent-router': preventRouter
      };
    }
    function actionsAttrs(props) {
      var searchbarEnable = props.searchbarEnable,
          searchbarDisable = props.searchbarDisable,
          searchbarClear = props.searchbarClear,
          searchbarToggle = props.searchbarToggle,
          panelOpen = props.panelOpen,
          panelClose = props.panelClose,
          panelToggle = props.panelToggle,
          popupOpen = props.popupOpen,
          popupClose = props.popupClose,
          actionsOpen = props.actionsOpen,
          actionsClose = props.actionsClose,
          popoverOpen = props.popoverOpen,
          popoverClose = props.popoverClose,
          loginScreenOpen = props.loginScreenOpen,
          loginScreenClose = props.loginScreenClose,
          sheetOpen = props.sheetOpen,
          sheetClose = props.sheetClose,
          sortableEnable = props.sortableEnable,
          sortableDisable = props.sortableDisable,
          sortableToggle = props.sortableToggle,
          cardOpen = props.cardOpen,
          cardClose = props.cardClose;
      return {
        'data-searchbar': isStringProp(searchbarEnable) && searchbarEnable || isStringProp(searchbarDisable) && searchbarDisable || isStringProp(searchbarClear) && searchbarClear || isStringProp(searchbarToggle) && searchbarToggle || undefined,
        'data-panel': isStringProp(panelOpen) && panelOpen || isStringProp(panelClose) && panelClose || isStringProp(panelToggle) && panelToggle || undefined,
        'data-popup': isStringProp(popupOpen) && popupOpen || isStringProp(popupClose) && popupClose || undefined,
        'data-actions': isStringProp(actionsOpen) && actionsOpen || isStringProp(actionsClose) && actionsClose || undefined,
        'data-popover': isStringProp(popoverOpen) && popoverOpen || isStringProp(popoverClose) && popoverClose || undefined,
        'data-sheet': isStringProp(sheetOpen) && sheetOpen || isStringProp(sheetClose) && sheetClose || undefined,
        'data-login-screen': isStringProp(loginScreenOpen) && loginScreenOpen || isStringProp(loginScreenClose) && loginScreenClose || undefined,
        'data-sortable': isStringProp(sortableEnable) && sortableEnable || isStringProp(sortableDisable) && sortableDisable || isStringProp(sortableToggle) && sortableToggle || undefined,
        'data-card': isStringProp(cardOpen) && cardOpen || isStringProp(cardClose) && cardClose || undefined
      };
    }
    function actionsClasses(props) {
      var searchbarEnable = props.searchbarEnable,
          searchbarDisable = props.searchbarDisable,
          searchbarClear = props.searchbarClear,
          searchbarToggle = props.searchbarToggle,
          panelOpen = props.panelOpen,
          panelClose = props.panelClose,
          panelToggle = props.panelToggle,
          popupOpen = props.popupOpen,
          popupClose = props.popupClose,
          actionsClose = props.actionsClose,
          actionsOpen = props.actionsOpen,
          popoverOpen = props.popoverOpen,
          popoverClose = props.popoverClose,
          loginScreenOpen = props.loginScreenOpen,
          loginScreenClose = props.loginScreenClose,
          sheetOpen = props.sheetOpen,
          sheetClose = props.sheetClose,
          sortableEnable = props.sortableEnable,
          sortableDisable = props.sortableDisable,
          sortableToggle = props.sortableToggle,
          cardOpen = props.cardOpen,
          cardPreventOpen = props.cardPreventOpen,
          cardClose = props.cardClose,
          menuClose = props.menuClose;
      return {
        'searchbar-enable': searchbarEnable || searchbarEnable === '',
        'searchbar-disable': searchbarDisable || searchbarDisable === '',
        'searchbar-clear': searchbarClear || searchbarClear === '',
        'searchbar-toggle': searchbarToggle || searchbarToggle === '',
        'panel-close': panelClose || panelClose === '',
        'panel-open': panelOpen || panelOpen === '',
        'panel-toggle': panelToggle || panelToggle === '',
        'popup-close': popupClose || popupClose === '',
        'popup-open': popupOpen || popupOpen === '',
        'actions-close': actionsClose || actionsClose === '',
        'actions-open': actionsOpen || actionsOpen === '',
        'popover-close': popoverClose || popoverClose === '',
        'popover-open': popoverOpen || popoverOpen === '',
        'sheet-close': sheetClose || sheetClose === '',
        'sheet-open': sheetOpen || sheetOpen === '',
        'login-screen-close': loginScreenClose || loginScreenClose === '',
        'login-screen-open': loginScreenOpen || loginScreenOpen === '',
        'sortable-enable': sortableEnable || sortableEnable === '',
        'sortable-disable': sortableDisable || sortableDisable === '',
        'sortable-toggle': sortableToggle || sortableToggle === '',
        'card-close': cardClose || cardClose === '',
        'card-open': cardOpen || cardOpen === '',
        'card-prevent-open': cardPreventOpen || cardPreventOpen === '',
        'menu-close': menuClose || menuClose === ''
      };
    }

    var ignoreProps = ['color', 'colorTheme', 'textColor', 'bgColor', 'borderColor', 'rippleColor', 'themeDark', 'force', 'reloadCurrent', 'reloadPrevious', 'reloadAll', 'reloadDetail', 'animate', 'ignoreCache', 'routeTabId', 'view', 'transition', 'openIn', 'back', 'linkBack', 'external', 'preventRouter', 'searchbarEnable', 'searchbarDisable', 'searchbarClear', 'searchbarToggle', 'panelOpen', 'panelClose', 'panelToggle', 'popupOpen', 'popupClose', 'actionsOpen', 'actionsClose', 'popoverOpen', 'popoverClose', 'loginScreenOpen', 'loginScreenClose', 'sheetOpen', 'sheetClose', 'sortableEnable', 'sortableDisable', 'sortableToggle', 'cardOpen', 'cardClose'];
    function restProps(rest) {
      if (rest === void 0) {
        rest = {};
      }

      var props = {};
      Object.keys(rest).filter(function (prop) {
        return !ignoreProps.includes(prop);
      }).forEach(function (key) {
        if (key.indexOf('on') !== 0) {
          props[key] = rest[key];
        }
      });
      return props;
    }

    var modalStateClasses = function modalStateClasses(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          isOpened = _ref.isOpened,
          isClosing = _ref.isClosing;

      return {
        'modal-in': isOpened && !isClosing,
        'modal-out': isClosing
      };
    };

    /* node_modules/framework7-svelte/esm/svelte/routable-modals.svelte generated by Svelte v3.44.0 */
    const file$t = "node_modules/framework7-svelte/esm/svelte/routable-modals.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (33:2) {#each modals as modal (modal.id)}
    function create_each_block$2(key_1, ctx) {
    	let first;
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*modal*/ ctx[5].props];
    	var switch_value = /*modal*/ ctx[5].component;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			const switch_instance_changes = (dirty & /*modals*/ 1)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*modal*/ ctx[5].props)])
    			: {};

    			if (switch_value !== (switch_value = /*modal*/ ctx[5].component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(33:2) {#each modals as modal (modal.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value = /*modals*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*modal*/ ctx[5].id;
    	validate_each_keys(ctx, each_value, get_each_context$2, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$2(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "framework7-modals");
    			add_location(div, file$t, 31, 0, 629);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			/*div_binding*/ ctx[2](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*modals*/ 1) {
    				each_value = /*modals*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$2, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*div_binding*/ ctx[2](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Routable_modals', slots, []);
    	let modals = [];
    	let el;
    	let routerData;

    	onMount(() => {
    		routerData = {
    			el,
    			modals,
    			setModals(m) {
    				tick().then(() => {
    					$$invalidate(0, modals = m);
    				});
    			}
    		};

    		app$1.f7routers.modals = routerData;
    	});

    	afterUpdate(() => {
    		if (!routerData) return;
    		app$1.f7events.emit('modalsRouterDidUpdate', routerData);
    	});

    	onDestroy(() => {
    		if (!routerData) return;
    		app$1.f7routers.modals = null;
    		routerData = null;
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Routable_modals> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(1, el);
    		});
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		afterUpdate,
    		tick,
    		app: app$1,
    		modals,
    		el,
    		routerData
    	});

    	$$self.$inject_state = $$props => {
    		if ('modals' in $$props) $$invalidate(0, modals = $$props.modals);
    		if ('el' in $$props) $$invalidate(1, el = $$props.el);
    		if ('routerData' in $$props) routerData = $$props.routerData;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [modals, el, div_binding];
    }

    class Routable_modals extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Routable_modals",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/app.svelte generated by Svelte v3.44.0 */
    const file$s = "node_modules/framework7-svelte/esm/svelte/app.svelte";

    function create_fragment$u(ctx) {
    	let div;
    	let t;
    	let routablemodals;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	routablemodals = new Routable_modals({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			t = space();
    			create_component(routablemodals.$$.fragment);
    			attr_dev(div, "class", /*classes*/ ctx[1]);
    			add_location(div, file$s, 32, 0, 843);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t);
    			mount_component(routablemodals, div, null);
    			/*div_binding*/ ctx[5](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*classes*/ 2) {
    				attr_dev(div, "class", /*classes*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(routablemodals.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(routablemodals.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			destroy_component(routablemodals);
    			/*div_binding*/ ctx[5](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let classes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let el;

    	if (!app$1.f7 || typeof window === 'undefined') {
    		f7init(el, noUndefinedProps($$props), false);
    	}

    	onMount(() => {
    		const parentEl = el.parentNode;

    		if (parentEl && parentEl !== document.body && parentEl.parentNode === document.body) {
    			parentEl.style.height = '100%';
    		}

    		if (app$1.f7) {
    			app$1.f7.init(el);
    			return;
    		}

    		f7init(el, noUndefinedProps($$props), true);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(0, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		app: app$1,
    		f7init,
    		colorClasses,
    		classNames,
    		noUndefinedProps,
    		RoutableModals: Routable_modals,
    		className,
    		el,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(1, classes = classNames(className, 'framework7-root', colorClasses($$props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [el, classes, className, $$scope, slots, div_binding];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$u, safe_not_equal, { class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get class() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var useTooltip = function useTooltip(el, props) {
      var f7Tooltip = null;
      var tooltip = props.tooltip,
          tooltipTrigger = props.tooltipTrigger;

      if (el && tooltip) {
        f7ready(function () {
          f7Tooltip = app$1.f7.tooltip.create({
            targetEl: el,
            text: tooltip,
            trigger: tooltipTrigger
          });
        });
      }

      return {
        update: function update(_temp) {
          var _ref = _temp === void 0 ? {} : _temp,
              value = _ref.tooltip;

          if (!value && f7Tooltip) {
            f7Tooltip.destroy();
            f7Tooltip = null;
            return;
          }

          if (value && !f7Tooltip && app$1.f7) {
            f7Tooltip = app$1.f7.tooltip.create({
              targetEl: el,
              text: value,
              trigger: tooltipTrigger
            });
            return;
          }

          if (!value || !f7Tooltip) return;
          f7Tooltip.setText(value);
        },
        destroy: function destroy() {
          if (f7Tooltip && f7Tooltip.destroy) {
            f7Tooltip.destroy();
            f7Tooltip = null;
          }
        }
      };
    };

    /* node_modules/framework7-svelte/esm/svelte/badge.svelte generated by Svelte v3.44.0 */
    const file$r = "node_modules/framework7-svelte/esm/svelte/badge.svelte";

    function create_fragment$t(ctx) {
    	let span;
    	let useTooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	let span_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			set_attributes(span, span_data);
    			add_location(span, file$r, 15, 0, 435);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(useTooltip_action = useTooltip.call(null, span, {
    					tooltip: /*tooltip*/ ctx[0],
    					tooltipTrigger: /*tooltipTrigger*/ ctx[1]
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
    				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
    			]));

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 3) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[0],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[1]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","tooltip","tooltipTrigger"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Badge', slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { tooltipTrigger = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ('tooltip' in $$new_props) $$invalidate(0, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$new_props) $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		colorClasses,
    		classNames,
    		restProps,
    		useTooltip,
    		className,
    		tooltip,
    		tooltipTrigger,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(4, className = $$new_props.className);
    		if ('tooltip' in $$props) $$invalidate(0, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$props) $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('classes' in $$props) $$invalidate(2, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(2, classes = classNames(className, 'badge', colorClasses($$props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [tooltip, tooltipTrigger, classes, $$restProps, className, $$scope, slots];
    }

    class Badge extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$t, safe_not_equal, { class: 4, tooltip: 0, tooltipTrigger: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Badge",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get class() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipTrigger() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipTrigger(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/block-title.svelte generated by Svelte v3.44.0 */
    const file$q = "node_modules/framework7-svelte/esm/svelte/block-title.svelte";

    function create_fragment$s(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$q, 22, 0, 469);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
    				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["large","medium","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Block_title', slots, ['default']);
    	let { large = false } = $$props;
    	let { medium = false } = $$props;
    	let { class: className = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('large' in $$new_props) $$invalidate(2, large = $$new_props.large);
    		if ('medium' in $$new_props) $$invalidate(3, medium = $$new_props.medium);
    		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		colorClasses,
    		classNames,
    		restProps,
    		large,
    		medium,
    		className,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    		if ('large' in $$props) $$invalidate(2, large = $$new_props.large);
    		if ('medium' in $$props) $$invalidate(3, medium = $$new_props.medium);
    		if ('className' in $$props) $$invalidate(4, className = $$new_props.className);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(0, classes = classNames(
    			className,
    			'block-title',
    			{
    				'block-title-large': large,
    				'block-title-medium': medium
    			},
    			colorClasses($$props)
    		));
    	};

    	$$props = exclude_internal_props($$props);
    	return [classes, $$restProps, large, medium, className, $$scope, slots];
    }

    class Block_title extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$s, safe_not_equal, { large: 2, medium: 3, class: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Block_title",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get large() {
    		throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set large(value) {
    		throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get medium() {
    		throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set medium(value) {
    		throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // eslint-disable-next-line
    var useTab = function useTab(getEl, emit) {
      var onTabShow = function onTabShow(el) {
        if (getEl() !== el) return;
        emit('tabShow', [el]);
      };

      var onTabHide = function onTabHide(el) {
        if (getEl() !== el) return;
        emit('tabHide', [el]);
      };

      var attachEvents = function attachEvents() {
        if (!getEl()) return;
        f7ready(function () {
          f7.on('tabShow', onTabShow);
          f7.on('tabHide', onTabHide);
        });
      };

      var detachEvents = function detachEvents() {
        if (!f7) return;
        f7.off('tabShow', onTabShow);
        f7.off('tabHide', onTabHide);
      };

      onMount(function () {
        attachEvents();
      });
      onDestroy(function () {
        detachEvents();
      });
    };

    /* node_modules/framework7-svelte/esm/svelte/block.svelte generated by Svelte v3.44.0 */
    const file$p = "node_modules/framework7-svelte/esm/svelte/block.svelte";

    function create_fragment$r(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[21].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
    	let div_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$p, 58, 0, 1600);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[22](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[20],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
    				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[22](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"inset","xsmallInset","smallInset","mediumInset","largeInset","xlargeInset","strong","tabs","tab","tabActive","accordionList","accordionOpposite","noHairlines","noHairlinesMd","noHairlinesIos","noHairlinesAurora","class"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Block', slots, ['default']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { inset = false } = $$props;
    	let { xsmallInset = false } = $$props;
    	let { smallInset = false } = $$props;
    	let { mediumInset = false } = $$props;
    	let { largeInset = false } = $$props;
    	let { xlargeInset = false } = $$props;
    	let { strong = false } = $$props;
    	let { tabs = false } = $$props;
    	let { tab = false } = $$props;
    	let { tabActive = false } = $$props;
    	let { accordionList = false } = $$props;
    	let { accordionOpposite = false } = $$props;
    	let { noHairlines = false } = $$props;
    	let { noHairlinesMd = false } = $$props;
    	let { noHairlinesIos = false } = $$props;
    	let { noHairlinesAurora = false } = $$props;
    	let { class: className = undefined } = $$props;
    	let el;
    	useTab(() => el, emit);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(0, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('inset' in $$new_props) $$invalidate(3, inset = $$new_props.inset);
    		if ('xsmallInset' in $$new_props) $$invalidate(4, xsmallInset = $$new_props.xsmallInset);
    		if ('smallInset' in $$new_props) $$invalidate(5, smallInset = $$new_props.smallInset);
    		if ('mediumInset' in $$new_props) $$invalidate(6, mediumInset = $$new_props.mediumInset);
    		if ('largeInset' in $$new_props) $$invalidate(7, largeInset = $$new_props.largeInset);
    		if ('xlargeInset' in $$new_props) $$invalidate(8, xlargeInset = $$new_props.xlargeInset);
    		if ('strong' in $$new_props) $$invalidate(9, strong = $$new_props.strong);
    		if ('tabs' in $$new_props) $$invalidate(10, tabs = $$new_props.tabs);
    		if ('tab' in $$new_props) $$invalidate(11, tab = $$new_props.tab);
    		if ('tabActive' in $$new_props) $$invalidate(12, tabActive = $$new_props.tabActive);
    		if ('accordionList' in $$new_props) $$invalidate(13, accordionList = $$new_props.accordionList);
    		if ('accordionOpposite' in $$new_props) $$invalidate(14, accordionOpposite = $$new_props.accordionOpposite);
    		if ('noHairlines' in $$new_props) $$invalidate(15, noHairlines = $$new_props.noHairlines);
    		if ('noHairlinesMd' in $$new_props) $$invalidate(16, noHairlinesMd = $$new_props.noHairlinesMd);
    		if ('noHairlinesIos' in $$new_props) $$invalidate(17, noHairlinesIos = $$new_props.noHairlinesIos);
    		if ('noHairlinesAurora' in $$new_props) $$invalidate(18, noHairlinesAurora = $$new_props.noHairlinesAurora);
    		if ('class' in $$new_props) $$invalidate(19, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		colorClasses,
    		classNames,
    		createEmitter,
    		restProps,
    		useTab,
    		emit,
    		inset,
    		xsmallInset,
    		smallInset,
    		mediumInset,
    		largeInset,
    		xlargeInset,
    		strong,
    		tabs,
    		tab,
    		tabActive,
    		accordionList,
    		accordionOpposite,
    		noHairlines,
    		noHairlinesMd,
    		noHairlinesIos,
    		noHairlinesAurora,
    		className,
    		el,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    		if ('inset' in $$props) $$invalidate(3, inset = $$new_props.inset);
    		if ('xsmallInset' in $$props) $$invalidate(4, xsmallInset = $$new_props.xsmallInset);
    		if ('smallInset' in $$props) $$invalidate(5, smallInset = $$new_props.smallInset);
    		if ('mediumInset' in $$props) $$invalidate(6, mediumInset = $$new_props.mediumInset);
    		if ('largeInset' in $$props) $$invalidate(7, largeInset = $$new_props.largeInset);
    		if ('xlargeInset' in $$props) $$invalidate(8, xlargeInset = $$new_props.xlargeInset);
    		if ('strong' in $$props) $$invalidate(9, strong = $$new_props.strong);
    		if ('tabs' in $$props) $$invalidate(10, tabs = $$new_props.tabs);
    		if ('tab' in $$props) $$invalidate(11, tab = $$new_props.tab);
    		if ('tabActive' in $$props) $$invalidate(12, tabActive = $$new_props.tabActive);
    		if ('accordionList' in $$props) $$invalidate(13, accordionList = $$new_props.accordionList);
    		if ('accordionOpposite' in $$props) $$invalidate(14, accordionOpposite = $$new_props.accordionOpposite);
    		if ('noHairlines' in $$props) $$invalidate(15, noHairlines = $$new_props.noHairlines);
    		if ('noHairlinesMd' in $$props) $$invalidate(16, noHairlinesMd = $$new_props.noHairlinesMd);
    		if ('noHairlinesIos' in $$props) $$invalidate(17, noHairlinesIos = $$new_props.noHairlinesIos);
    		if ('noHairlinesAurora' in $$props) $$invalidate(18, noHairlinesAurora = $$new_props.noHairlinesAurora);
    		if ('className' in $$props) $$invalidate(19, className = $$new_props.className);
    		if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(1, classes = classNames(
    			className,
    			'block',
    			{
    				inset,
    				'xsmall-inset': xsmallInset,
    				'small-inset': smallInset,
    				'medium-inset': mediumInset,
    				'large-inset': largeInset,
    				'xlarge-inset': xlargeInset,
    				'block-strong': strong,
    				'accordion-list': accordionList,
    				'accordion-opposite': accordionOpposite,
    				tabs,
    				tab,
    				'tab-active': tabActive,
    				'no-hairlines': noHairlines,
    				'no-hairlines-md': noHairlinesMd,
    				'no-hairlines-ios': noHairlinesIos,
    				'no-hairlines-aurora': noHairlinesAurora
    			},
    			colorClasses($$props)
    		));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		el,
    		classes,
    		$$restProps,
    		inset,
    		xsmallInset,
    		smallInset,
    		mediumInset,
    		largeInset,
    		xlargeInset,
    		strong,
    		tabs,
    		tab,
    		tabActive,
    		accordionList,
    		accordionOpposite,
    		noHairlines,
    		noHairlinesMd,
    		noHairlinesIos,
    		noHairlinesAurora,
    		className,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class Block extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$n, create_fragment$r, safe_not_equal, {
    			inset: 3,
    			xsmallInset: 4,
    			smallInset: 5,
    			mediumInset: 6,
    			largeInset: 7,
    			xlargeInset: 8,
    			strong: 9,
    			tabs: 10,
    			tab: 11,
    			tabActive: 12,
    			accordionList: 13,
    			accordionOpposite: 14,
    			noHairlines: 15,
    			noHairlinesMd: 16,
    			noHairlinesIos: 17,
    			noHairlinesAurora: 18,
    			class: 19
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Block",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get inset() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inset(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xsmallInset() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xsmallInset(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smallInset() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smallInset(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mediumInset() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mediumInset(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get largeInset() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set largeInset(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xlargeInset() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xlargeInset(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strong() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strong(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabs() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabs(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tab() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tab(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabActive() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabActive(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accordionList() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accordionList(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accordionOpposite() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accordionOpposite(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlines() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlines(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesMd() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesMd(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesIos() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesIos(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesAurora() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesAurora(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var useRouteProps = function useRouteProps(el, routeProps) {
      if (el && routeProps) {
        el.f7RouteProps = routeProps;
      }

      return {
        update: function update(newValue) {
          if (el && el.f7RouteProps && !newValue) delete el.f7RouteProps;else if (el && newValue) el.f7RouteProps = newValue;
        },
        destroy: function destroy() {
          if (el && routeProps) {
            delete el.f7RouteProps;
          }
        }
      };
    };

    var useIcon = function useIcon(props) {
      if (props === void 0) {
        props = {};
      }

      var _props = props,
          icon = _props.icon,
          iconMaterial = _props.iconMaterial,
          iconF7 = _props.iconF7,
          iconMd = _props.iconMd,
          iconIos = _props.iconIos,
          iconAurora = _props.iconAurora,
          iconColor = _props.iconColor,
          iconSize = _props.iconSize,
          iconBadge = _props.iconBadge,
          badgeColor = _props.badgeColor,
          iconBadgeColor = _props.iconBadgeColor;

      if (icon || iconMaterial || iconF7 || iconMd || iconIos || iconAurora) {
        return {
          props: {
            material: iconMaterial,
            f7: iconF7,
            icon: icon,
            md: iconMd,
            ios: iconIos,
            aurora: iconAurora,
            color: iconColor,
            size: iconSize
          },
          badge: iconBadge || iconBadge === 0 ? {
            props: {
              color: badgeColor || iconBadgeColor
            },
            content: iconBadge
          } : null
        };
      }

      return null;
    };

    var useTheme = function useTheme(set) {
      var t = app$1.f7 ? app$1.theme : null;

      if (!app$1.f7) {
        f7ready(function () {
          set(app$1.theme);
        });
      }

      return t;
    };

    /* node_modules/framework7-svelte/esm/svelte/icon.svelte generated by Svelte v3.44.0 */
    const file$o = "node_modules/framework7-svelte/esm/svelte/icon.svelte";

    function create_fragment$q(ctx) {
    	let i;
    	let t0_value = (/*iconText*/ ctx[4] || '') + "";
    	let t0;
    	let t1;
    	let useTooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[21].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

    	let i_levels = [
    		{ style: /*iconStyle*/ ctx[3] },
    		{ class: /*iconClasses*/ ctx[5] },
    		restProps(/*$$restProps*/ ctx[6])
    	];

    	let i_data = {};

    	for (let i = 0; i < i_levels.length; i += 1) {
    		i_data = assign(i_data, i_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			i = element("i");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (default_slot) default_slot.c();
    			set_attributes(i, i_data);
    			add_location(i, file$o, 89, 0, 2329);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    			append_dev(i, t0);
    			append_dev(i, t1);

    			if (default_slot) {
    				default_slot.m(i, null);
    			}

    			/*i_binding*/ ctx[22](i);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(useTooltip_action = useTooltip.call(null, i, {
    					tooltip: /*tooltip*/ ctx[0],
    					tooltipTrigger: /*tooltipTrigger*/ ctx[1]
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*iconText*/ 16) && t0_value !== (t0_value = (/*iconText*/ ctx[4] || '') + "")) set_data_dev(t0, t0_value);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[20],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(i, i_data = get_spread_update(i_levels, [
    				(!current || dirty & /*iconStyle*/ 8) && { style: /*iconStyle*/ ctx[3] },
    				(!current || dirty & /*iconClasses*/ 32) && { class: /*iconClasses*/ ctx[5] },
    				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
    			]));

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 3) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[0],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[1]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			if (default_slot) default_slot.d(detaching);
    			/*i_binding*/ ctx[22](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let iconClasses;
    	let iconText;
    	let iconSize;
    	let iconStyle;

    	const omit_props_names = [
    		"style","class","material","f7","icon","ios","aurora","md","tooltip","tooltipTrigger","size"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Icon', slots, ['default']);
    	let { style = undefined } = $$props;
    	let { class: className = undefined } = $$props;
    	let { material = undefined } = $$props;
    	let { f7 = undefined } = $$props;
    	let { icon = undefined } = $$props;
    	let { ios = undefined } = $$props;
    	let { aurora = undefined } = $$props;
    	let { md = undefined } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { tooltipTrigger = undefined } = $$props;
    	let { size = undefined } = $$props;
    	let el;

    	let theme = useTheme(t => {
    		$$invalidate(16, theme = t);
    	});

    	let classes = { icon: true };
    	let themeIcon;

    	function iconTextComputed(t) {
    		let textComputed = material || f7;

    		if (md && t && t.md && (md.indexOf('material:') >= 0 || md.indexOf('f7:') >= 0)) {
    			textComputed = md.split(':')[1];
    		} else if (ios && t && t.ios && (ios.indexOf('material:') >= 0 || ios.indexOf('f7:') >= 0)) {
    			textComputed = ios.split(':')[1];
    		} else if (aurora && t && t.aurora && (aurora.indexOf('material:') >= 0 || aurora.indexOf('f7:') >= 0)) {
    			textComputed = aurora.split(':')[1];
    		}

    		return textComputed;
    	}

    	function i_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(2, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('style' in $$new_props) $$invalidate(7, style = $$new_props.style);
    		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
    		if ('material' in $$new_props) $$invalidate(9, material = $$new_props.material);
    		if ('f7' in $$new_props) $$invalidate(10, f7 = $$new_props.f7);
    		if ('icon' in $$new_props) $$invalidate(11, icon = $$new_props.icon);
    		if ('ios' in $$new_props) $$invalidate(12, ios = $$new_props.ios);
    		if ('aurora' in $$new_props) $$invalidate(13, aurora = $$new_props.aurora);
    		if ('md' in $$new_props) $$invalidate(14, md = $$new_props.md);
    		if ('tooltip' in $$new_props) $$invalidate(0, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$new_props) $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('size' in $$new_props) $$invalidate(15, size = $$new_props.size);
    		if ('$$scope' in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		colorClasses,
    		classNames,
    		restProps,
    		useTooltip,
    		useTheme,
    		style,
    		className,
    		material,
    		f7,
    		icon,
    		ios,
    		aurora,
    		md,
    		tooltip,
    		tooltipTrigger,
    		size,
    		el,
    		theme,
    		classes,
    		themeIcon,
    		iconTextComputed,
    		iconSize,
    		iconStyle,
    		iconText,
    		iconClasses
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    		if ('style' in $$props) $$invalidate(7, style = $$new_props.style);
    		if ('className' in $$props) $$invalidate(8, className = $$new_props.className);
    		if ('material' in $$props) $$invalidate(9, material = $$new_props.material);
    		if ('f7' in $$props) $$invalidate(10, f7 = $$new_props.f7);
    		if ('icon' in $$props) $$invalidate(11, icon = $$new_props.icon);
    		if ('ios' in $$props) $$invalidate(12, ios = $$new_props.ios);
    		if ('aurora' in $$props) $$invalidate(13, aurora = $$new_props.aurora);
    		if ('md' in $$props) $$invalidate(14, md = $$new_props.md);
    		if ('tooltip' in $$props) $$invalidate(0, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$props) $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('size' in $$props) $$invalidate(15, size = $$new_props.size);
    		if ('el' in $$props) $$invalidate(2, el = $$new_props.el);
    		if ('theme' in $$props) $$invalidate(16, theme = $$new_props.theme);
    		if ('classes' in $$props) $$invalidate(17, classes = $$new_props.classes);
    		if ('themeIcon' in $$props) $$invalidate(18, themeIcon = $$new_props.themeIcon);
    		if ('iconSize' in $$props) $$invalidate(19, iconSize = $$new_props.iconSize);
    		if ('iconStyle' in $$props) $$invalidate(3, iconStyle = $$new_props.iconStyle);
    		if ('iconText' in $$props) $$invalidate(4, iconText = $$new_props.iconText);
    		if ('iconClasses' in $$props) $$invalidate(5, iconClasses = $$new_props.iconClasses);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*theme, ios, md, aurora*/ 94208) {
    			if (theme) {
    				if (theme.ios) $$invalidate(18, themeIcon = ios);
    				if (theme.md) $$invalidate(18, themeIcon = md);
    				if (theme.aurora) $$invalidate(18, themeIcon = aurora);
    			}
    		}

    		if ($$self.$$.dirty & /*themeIcon, material, f7, icon*/ 265728) {
    			if (themeIcon) {
    				const parts = themeIcon.split(':');
    				const prop = parts[0];
    				const value = parts[1];

    				if (prop === 'material' || prop === 'f7') {
    					$$invalidate(17, classes['material-icons'] = prop === 'material', classes);
    					$$invalidate(17, classes['f7-icons'] = prop === 'f7', classes);
    				}

    				if (prop === 'icon') {
    					$$invalidate(17, classes[value] = true, classes);
    				}
    			} else {
    				$$invalidate(17, classes = {
    					icon: true,
    					'material-icons': material,
    					'f7-icons': f7
    				});

    				if (icon) $$invalidate(17, classes[icon] = true, classes);
    			}
    		}

    		$$invalidate(5, iconClasses = classNames(className, classes, colorClasses($$props)));

    		if ($$self.$$.dirty & /*theme*/ 65536) {
    			$$invalidate(4, iconText = iconTextComputed(theme));
    		}

    		if ($$self.$$.dirty & /*size*/ 32768) {
    			$$invalidate(19, iconSize = typeof size === 'number' || parseFloat(size) === size * 1
    			? `${size}px`
    			: size);
    		}

    		if ($$self.$$.dirty & /*style, iconSize*/ 524416) {
    			$$invalidate(3, iconStyle = (style || '') + (iconSize
    			? `;font-size: ${iconSize}; width: ${iconSize}; height: ${iconSize}`.replace(';;', '')
    			: ''));
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		tooltip,
    		tooltipTrigger,
    		el,
    		iconStyle,
    		iconText,
    		iconClasses,
    		$$restProps,
    		style,
    		className,
    		material,
    		f7,
    		icon,
    		ios,
    		aurora,
    		md,
    		size,
    		theme,
    		classes,
    		themeIcon,
    		iconSize,
    		$$scope,
    		slots,
    		i_binding
    	];
    }

    class Icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$m, create_fragment$q, safe_not_equal, {
    			style: 7,
    			class: 8,
    			material: 9,
    			f7: 10,
    			icon: 11,
    			ios: 12,
    			aurora: 13,
    			md: 14,
    			tooltip: 0,
    			tooltipTrigger: 1,
    			size: 15
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get style() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get material() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set material(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get f7() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set f7(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ios() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ios(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get aurora() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set aurora(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get md() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set md(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipTrigger() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipTrigger(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/use-icon.svelte generated by Svelte v3.44.0 */

    // (9:2) {#if icon.badge}
    function create_if_block$h(ctx) {
    	let badge;
    	let current;
    	const badge_spread_levels = [/*icon*/ ctx[0].badge.props];

    	let badge_props = {
    		$$slots: { default: [create_default_slot_1$5] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < badge_spread_levels.length; i += 1) {
    		badge_props = assign(badge_props, badge_spread_levels[i]);
    	}

    	badge = new Badge({ props: badge_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(badge.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_changes = (dirty & /*icon*/ 1)
    			? get_spread_update(badge_spread_levels, [get_spread_object(/*icon*/ ctx[0].badge.props)])
    			: {};

    			if (dirty & /*$$scope, icon*/ 3) {
    				badge_changes.$$scope = { dirty, ctx };
    			}

    			badge.$set(badge_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(9:2) {#if icon.badge}",
    		ctx
    	});

    	return block;
    }

    // (10:4) <Badge {...icon.badge.props}>
    function create_default_slot_1$5(ctx) {
    	let t_value = /*icon*/ ctx[0].badge.content + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*icon*/ 1 && t_value !== (t_value = /*icon*/ ctx[0].badge.content + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(10:4) <Badge {...icon.badge.props}>",
    		ctx
    	});

    	return block;
    }

    // (8:0) <Icon {...icon.props}>
    function create_default_slot$b(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*icon*/ ctx[0].badge && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[0].badge) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*icon*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(8:0) <Icon {...icon.props}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let icon_1;
    	let current;
    	const icon_1_spread_levels = [/*icon*/ ctx[0].props];

    	let icon_1_props = {
    		$$slots: { default: [create_default_slot$b] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < icon_1_spread_levels.length; i += 1) {
    		icon_1_props = assign(icon_1_props, icon_1_spread_levels[i]);
    	}

    	icon_1 = new Icon({ props: icon_1_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(icon_1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const icon_1_changes = (dirty & /*icon*/ 1)
    			? get_spread_update(icon_1_spread_levels, [get_spread_object(/*icon*/ ctx[0].props)])
    			: {};

    			if (dirty & /*$$scope, icon*/ 3) {
    				icon_1_changes.$$scope = { dirty, ctx };
    			}

    			icon_1.$set(icon_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use_icon', slots, []);
    	let { icon = undefined } = $$props;
    	const writable_props = ['icon'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use_icon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('icon' in $$props) $$invalidate(0, icon = $$props.icon);
    	};

    	$$self.$capture_state = () => ({ Icon, Badge, icon });

    	$$self.$inject_state = $$props => {
    		if ('icon' in $$props) $$invalidate(0, icon = $$props.icon);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [icon];
    }

    class Use_icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$p, safe_not_equal, { icon: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use_icon",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get icon() {
    		throw new Error("<Use_icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Use_icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/preloader.svelte generated by Svelte v3.44.0 */
    const file$n = "node_modules/framework7-svelte/esm/svelte/preloader.svelte";

    // (50:2) {:else}
    function create_else_block$8(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "preloader-inner");
    			add_location(span, file$n, 49, 9, 1589);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(50:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (48:34) 
    function create_if_block_2$8(ctx) {
    	let span1;
    	let span0;

    	const block = {
    		c: function create() {
    			span1 = element("span");
    			span0 = element("span");
    			attr_dev(span0, "class", "preloader-inner-circle");
    			add_location(span0, file$n, 48, 35, 1532);
    			attr_dev(span1, "class", "preloader-inner");
    			add_location(span1, file$n, 48, 4, 1501);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span1, anchor);
    			append_dev(span1, span0);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(48:34) ",
    		ctx
    	});

    	return block;
    }

    // (37:31) 
    function create_if_block_1$a(ctx) {
    	let span8;
    	let span0;
    	let t0;
    	let span1;
    	let t1;
    	let span2;
    	let t2;
    	let span3;
    	let t3;
    	let span4;
    	let t4;
    	let span5;
    	let t5;
    	let span6;
    	let t6;
    	let span7;

    	const block = {
    		c: function create() {
    			span8 = element("span");
    			span0 = element("span");
    			t0 = space();
    			span1 = element("span");
    			t1 = space();
    			span2 = element("span");
    			t2 = space();
    			span3 = element("span");
    			t3 = space();
    			span4 = element("span");
    			t4 = space();
    			span5 = element("span");
    			t5 = space();
    			span6 = element("span");
    			t6 = space();
    			span7 = element("span");
    			attr_dev(span0, "class", "preloader-inner-line");
    			add_location(span0, file$n, 38, 6, 1104);
    			attr_dev(span1, "class", "preloader-inner-line");
    			add_location(span1, file$n, 39, 6, 1148);
    			attr_dev(span2, "class", "preloader-inner-line");
    			add_location(span2, file$n, 40, 6, 1192);
    			attr_dev(span3, "class", "preloader-inner-line");
    			add_location(span3, file$n, 41, 6, 1236);
    			attr_dev(span4, "class", "preloader-inner-line");
    			add_location(span4, file$n, 42, 6, 1280);
    			attr_dev(span5, "class", "preloader-inner-line");
    			add_location(span5, file$n, 43, 6, 1324);
    			attr_dev(span6, "class", "preloader-inner-line");
    			add_location(span6, file$n, 44, 6, 1368);
    			attr_dev(span7, "class", "preloader-inner-line");
    			add_location(span7, file$n, 45, 6, 1412);
    			attr_dev(span8, "class", "preloader-inner");
    			add_location(span8, file$n, 37, 4, 1067);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span8, anchor);
    			append_dev(span8, span0);
    			append_dev(span8, t0);
    			append_dev(span8, span1);
    			append_dev(span8, t1);
    			append_dev(span8, span2);
    			append_dev(span8, t2);
    			append_dev(span8, span3);
    			append_dev(span8, t3);
    			append_dev(span8, span4);
    			append_dev(span8, t4);
    			append_dev(span8, span5);
    			append_dev(span8, t5);
    			append_dev(span8, span6);
    			append_dev(span8, t6);
    			append_dev(span8, span7);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span8);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(37:31) ",
    		ctx
    	});

    	return block;
    }

    // (31:2) {#if theme && theme.md}
    function create_if_block$g(ctx) {
    	let span;
    	let svg;
    	let circle;

    	const block = {
    		c: function create() {
    			span = element("span");
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			attr_dev(circle, "cx", "18");
    			attr_dev(circle, "cy", "18");
    			attr_dev(circle, "r", "16");
    			add_location(circle, file$n, 33, 8, 972);
    			attr_dev(svg, "viewBox", "0 0 36 36");
    			add_location(svg, file$n, 32, 6, 938);
    			attr_dev(span, "class", "preloader-inner");
    			add_location(span, file$n, 31, 4, 901);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, svg);
    			append_dev(svg, circle);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(31:2) {#if theme && theme.md}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let span;

    	function select_block_type(ctx, dirty) {
    		if (/*theme*/ ctx[0] && /*theme*/ ctx[0].md) return create_if_block$g;
    		if (/*theme*/ ctx[0] && /*theme*/ ctx[0].ios) return create_if_block_1$a;
    		if (/*theme*/ ctx[0] && /*theme*/ ctx[0].aurora) return create_if_block_2$8;
    		return create_else_block$8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	let span_levels = [
    		{ style: /*preloaderStyle*/ ctx[2] },
    		{ class: /*classes*/ ctx[1] },
    		restProps(/*$$restProps*/ ctx[3])
    	];

    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block.c();
    			set_attributes(span, span_data);
    			add_location(span, file$n, 29, 0, 797);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if_block.m(span, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span, null);
    				}
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				dirty & /*preloaderStyle*/ 4 && { style: /*preloaderStyle*/ ctx[2] },
    				dirty & /*classes*/ 2 && { class: /*classes*/ ctx[1] },
    				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let sizeComputed;
    	let preloaderStyle;
    	let classes;
    	const omit_props_names = ["style","class","size"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Preloader', slots, []);
    	let { style = undefined } = $$props;
    	let { class: className = undefined } = $$props;
    	let { size = undefined } = $$props;

    	let theme = useTheme(t => {
    		$$invalidate(0, theme = t);
    	});

    	$$self.$$set = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('style' in $$new_props) $$invalidate(4, style = $$new_props.style);
    		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
    		if ('size' in $$new_props) $$invalidate(6, size = $$new_props.size);
    	};

    	$$self.$capture_state = () => ({
    		restProps,
    		colorClasses,
    		classNames,
    		useTheme,
    		style,
    		className,
    		size,
    		theme,
    		classes,
    		sizeComputed,
    		preloaderStyle
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    		if ('style' in $$props) $$invalidate(4, style = $$new_props.style);
    		if ('className' in $$props) $$invalidate(5, className = $$new_props.className);
    		if ('size' in $$props) $$invalidate(6, size = $$new_props.size);
    		if ('theme' in $$props) $$invalidate(0, theme = $$new_props.theme);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    		if ('sizeComputed' in $$props) $$invalidate(7, sizeComputed = $$new_props.sizeComputed);
    		if ('preloaderStyle' in $$props) $$invalidate(2, preloaderStyle = $$new_props.preloaderStyle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*size*/ 64) {
    			$$invalidate(7, sizeComputed = size && typeof size === 'string' && size.indexOf('px') >= 0
    			? size.replace('px', '')
    			: size);
    		}

    		if ($$self.$$.dirty & /*style, sizeComputed*/ 144) {
    			$$invalidate(2, preloaderStyle = ((style || '') + (sizeComputed
    			? `;width: ${sizeComputed}px; height: ${sizeComputed}px; --f7-preloader-size: ${sizeComputed}px`
    			: '')).replace(';;', ';'));
    		}

    		$$invalidate(1, classes = classNames(className, 'preloader', colorClasses($$props)));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		theme,
    		classes,
    		preloaderStyle,
    		$$restProps,
    		style,
    		className,
    		size,
    		sizeComputed
    	];
    }

    class Preloader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$o, safe_not_equal, { style: 4, class: 5, size: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Preloader",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get style() {
    		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/button.svelte generated by Svelte v3.44.0 */
    const file$m = "node_modules/framework7-svelte/esm/svelte/button.svelte";

    // (163:0) {:else}
    function create_else_block_1$3(ctx) {
    	let a;
    	let current_block_type_index;
    	let if_block;
    	let useRouteProps_action;
    	let useTooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_6$2, create_else_block_2$3];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*preloader*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let a_levels = [{ class: /*classes*/ ctx[10] }, /*attrs*/ ctx[11]];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if_block.c();
    			set_attributes(a, a_data);
    			add_location(a, file$m, 163, 2, 4437);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if_blocks[current_block_type_index].m(a, null);
    			/*a_binding*/ ctx[50](a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[3])),
    					listen_dev(a, "click", /*onClick*/ ctx[12], false, false, false),
    					action_destroyer(useTooltip_action = useTooltip.call(null, a, {
    						tooltip: /*tooltip*/ ctx[1],
    						tooltipTrigger: /*tooltipTrigger*/ ctx[2]
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(a, null);
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty[0] & /*classes*/ 1024) && { class: /*classes*/ ctx[10] },
    				dirty[0] & /*attrs*/ 2048 && /*attrs*/ ctx[11]
    			]));

    			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 8) useRouteProps_action.update.call(null, /*routeProps*/ ctx[3]);

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 6) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[1],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[2]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if_blocks[current_block_type_index].d();
    			/*a_binding*/ ctx[50](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(163:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (132:0) {#if tagName === 'button'}
    function create_if_block$f(ctx) {
    	let button;
    	let current_block_type_index;
    	let if_block;
    	let useRouteProps_action;
    	let useTooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$9, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*preloader*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let button_levels = [{ class: /*classes*/ ctx[10] }, /*attrs*/ ctx[11]];
    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			if_block.c();
    			set_attributes(button, button_data);
    			add_location(button, file$m, 132, 2, 3770);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			if_blocks[current_block_type_index].m(button, null);
    			if (button.autofocus) button.focus();
    			/*button_binding*/ ctx[49](button);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useRouteProps_action = useRouteProps.call(null, button, /*routeProps*/ ctx[3])),
    					listen_dev(button, "click", /*onClick*/ ctx[12], false, false, false),
    					action_destroyer(useTooltip_action = useTooltip.call(null, button, {
    						tooltip: /*tooltip*/ ctx[1],
    						tooltipTrigger: /*tooltipTrigger*/ ctx[2]
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(button, null);
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				(!current || dirty[0] & /*classes*/ 1024) && { class: /*classes*/ ctx[10] },
    				dirty[0] & /*attrs*/ 2048 && /*attrs*/ ctx[11]
    			]));

    			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 8) useRouteProps_action.update.call(null, /*routeProps*/ ctx[3]);

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 6) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[1],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[2]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if_blocks[current_block_type_index].d();
    			/*button_binding*/ ctx[49](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(132:0) {#if tagName === 'button'}",
    		ctx
    	});

    	return block;
    }

    // (183:4) {:else}
    function create_else_block_2$3(ctx) {
    	let t0;
    	let t1;
    	let current;
    	let if_block0 = /*icon*/ ctx[8] && create_if_block_10$2(ctx);
    	let if_block1 = typeof /*text*/ ctx[0] !== 'undefined' && create_if_block_9$2(ctx);
    	const default_slot_template = /*#slots*/ ctx[48].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[47], null);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[8]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 256) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_10$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (typeof /*text*/ ctx[0] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_9$2(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[47],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[47])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[47], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$3.name,
    		type: "else",
    		source: "(183:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (172:4) {#if preloader}
    function create_if_block_6$2(ctx) {
    	let preloader_1;
    	let t0;
    	let span;
    	let t1;
    	let t2;
    	let current;

    	preloader_1 = new Preloader({
    			props: {
    				size: /*preloaderSize*/ ctx[5],
    				color: /*preloaderColor*/ ctx[6]
    			},
    			$$inline: true
    		});

    	let if_block0 = /*icon*/ ctx[8] && create_if_block_8$2(ctx);
    	let if_block1 = typeof /*text*/ ctx[0] !== 'undefined' && create_if_block_7$2(ctx);
    	const default_slot_template = /*#slots*/ ctx[48].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[47], null);

    	const block = {
    		c: function create() {
    			create_component(preloader_1.$$.fragment);
    			t0 = space();
    			span = element("span");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (default_slot) default_slot.c();
    			add_location(span, file$m, 173, 6, 4695);
    		},
    		m: function mount(target, anchor) {
    			mount_component(preloader_1, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			if (if_block0) if_block0.m(span, null);
    			append_dev(span, t1);
    			if (if_block1) if_block1.m(span, null);
    			append_dev(span, t2);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const preloader_1_changes = {};
    			if (dirty[0] & /*preloaderSize*/ 32) preloader_1_changes.size = /*preloaderSize*/ ctx[5];
    			if (dirty[0] & /*preloaderColor*/ 64) preloader_1_changes.color = /*preloaderColor*/ ctx[6];
    			preloader_1.$set(preloader_1_changes);

    			if (/*icon*/ ctx[8]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 256) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_8$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(span, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (typeof /*text*/ ctx[0] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_7$2(ctx);
    					if_block1.c();
    					if_block1.m(span, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[47],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[47])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[47], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(preloader_1.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(preloader_1.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(preloader_1, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(172:4) {#if preloader}",
    		ctx
    	});

    	return block;
    }

    // (184:6) {#if icon}
    function create_if_block_10$2(ctx) {
    	let useicon;
    	let current;

    	useicon = new Use_icon({
    			props: { icon: /*icon*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(useicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(useicon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const useicon_changes = {};
    			if (dirty[0] & /*icon*/ 256) useicon_changes.icon = /*icon*/ ctx[8];
    			useicon.$set(useicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(useicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(useicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(useicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$2.name,
    		type: "if",
    		source: "(184:6) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (187:6) {#if typeof text !== 'undefined'}
    function create_if_block_9$2(ctx) {
    	let span;
    	let t_value = plainText(/*text*/ ctx[0]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$m, 187, 8, 5008);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*text*/ 1 && t_value !== (t_value = plainText(/*text*/ ctx[0]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$2.name,
    		type: "if",
    		source: "(187:6) {#if typeof text !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (175:8) {#if icon}
    function create_if_block_8$2(ctx) {
    	let useicon;
    	let current;

    	useicon = new Use_icon({
    			props: { icon: /*icon*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(useicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(useicon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const useicon_changes = {};
    			if (dirty[0] & /*icon*/ 256) useicon_changes.icon = /*icon*/ ctx[8];
    			useicon.$set(useicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(useicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(useicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(useicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$2.name,
    		type: "if",
    		source: "(175:8) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (178:8) {#if typeof text !== 'undefined'}
    function create_if_block_7$2(ctx) {
    	let span;
    	let t_value = plainText(/*text*/ ctx[0]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$m, 178, 10, 4816);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*text*/ 1 && t_value !== (t_value = plainText(/*text*/ ctx[0]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$2.name,
    		type: "if",
    		source: "(178:8) {#if typeof text !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (152:4) {:else}
    function create_else_block$7(ctx) {
    	let t0;
    	let t1;
    	let current;
    	let if_block0 = /*icon*/ ctx[8] && create_if_block_5$2(ctx);
    	let if_block1 = typeof /*text*/ ctx[0] !== 'undefined' && create_if_block_4$2(ctx);
    	const default_slot_template = /*#slots*/ ctx[48].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[47], null);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[8]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 256) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (typeof /*text*/ ctx[0] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4$2(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[47],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[47])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[47], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(152:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (141:4) {#if preloader}
    function create_if_block_1$9(ctx) {
    	let preloader_1;
    	let t0;
    	let span;
    	let t1;
    	let t2;
    	let current;

    	preloader_1 = new Preloader({
    			props: {
    				size: /*preloaderSize*/ ctx[5],
    				color: /*preloaderColor*/ ctx[6]
    			},
    			$$inline: true
    		});

    	let if_block0 = /*icon*/ ctx[8] && create_if_block_3$4(ctx);
    	let if_block1 = typeof /*text*/ ctx[0] !== 'undefined' && create_if_block_2$7(ctx);
    	const default_slot_template = /*#slots*/ ctx[48].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[47], null);

    	const block = {
    		c: function create() {
    			create_component(preloader_1.$$.fragment);
    			t0 = space();
    			span = element("span");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (default_slot) default_slot.c();
    			add_location(span, file$m, 142, 6, 4033);
    		},
    		m: function mount(target, anchor) {
    			mount_component(preloader_1, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			if (if_block0) if_block0.m(span, null);
    			append_dev(span, t1);
    			if (if_block1) if_block1.m(span, null);
    			append_dev(span, t2);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const preloader_1_changes = {};
    			if (dirty[0] & /*preloaderSize*/ 32) preloader_1_changes.size = /*preloaderSize*/ ctx[5];
    			if (dirty[0] & /*preloaderColor*/ 64) preloader_1_changes.color = /*preloaderColor*/ ctx[6];
    			preloader_1.$set(preloader_1_changes);

    			if (/*icon*/ ctx[8]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 256) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(span, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (typeof /*text*/ ctx[0] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$7(ctx);
    					if_block1.c();
    					if_block1.m(span, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[47],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[47])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[47], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(preloader_1.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(preloader_1.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(preloader_1, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(141:4) {#if preloader}",
    		ctx
    	});

    	return block;
    }

    // (153:6) {#if icon}
    function create_if_block_5$2(ctx) {
    	let useicon;
    	let current;

    	useicon = new Use_icon({
    			props: { icon: /*icon*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(useicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(useicon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const useicon_changes = {};
    			if (dirty[0] & /*icon*/ 256) useicon_changes.icon = /*icon*/ ctx[8];
    			useicon.$set(useicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(useicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(useicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(useicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(153:6) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (156:6) {#if typeof text !== 'undefined'}
    function create_if_block_4$2(ctx) {
    	let span;
    	let t_value = plainText(/*text*/ ctx[0]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$m, 156, 8, 4346);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*text*/ 1 && t_value !== (t_value = plainText(/*text*/ ctx[0]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(156:6) {#if typeof text !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (144:8) {#if icon}
    function create_if_block_3$4(ctx) {
    	let useicon;
    	let current;

    	useicon = new Use_icon({
    			props: { icon: /*icon*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(useicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(useicon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const useicon_changes = {};
    			if (dirty[0] & /*icon*/ 256) useicon_changes.icon = /*icon*/ ctx[8];
    			useicon.$set(useicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(useicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(useicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(useicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(144:8) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (147:8) {#if typeof text !== 'undefined'}
    function create_if_block_2$7(ctx) {
    	let span;
    	let t_value = plainText(/*text*/ ctx[0]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$m, 147, 10, 4154);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*text*/ 1 && t_value !== (t_value = plainText(/*text*/ ctx[0]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(147:8) {#if typeof text !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$f, create_else_block_1$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*tagName*/ ctx[9] === 'button') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let hrefComputed;
    	let attrs;
    	let classes;
    	let tagName;
    	let icon;

    	const omit_props_names = [
    		"class","text","tabLink","tabLinkActive","type","href","target","round","roundMd","roundIos","roundAurora","fill","fillMd","fillIos","fillAurora","large","largeMd","largeIos","largeAurora","small","smallMd","smallIos","smallAurora","raised","raisedMd","raisedIos","raisedAurora","outline","outlineMd","outlineIos","outlineAurora","active","disabled","tooltip","tooltipTrigger","routeProps","preloader","preloaderSize","preloaderColor","loading"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { text = undefined } = $$props;
    	let { tabLink = undefined } = $$props;
    	let { tabLinkActive = false } = $$props;
    	let { type = undefined } = $$props;
    	let { href = '#' } = $$props;
    	let { target = undefined } = $$props;
    	let { round = false } = $$props;
    	let { roundMd = false } = $$props;
    	let { roundIos = false } = $$props;
    	let { roundAurora = false } = $$props;
    	let { fill = false } = $$props;
    	let { fillMd = false } = $$props;
    	let { fillIos = false } = $$props;
    	let { fillAurora = false } = $$props;
    	let { large = false } = $$props;
    	let { largeMd = false } = $$props;
    	let { largeIos = false } = $$props;
    	let { largeAurora = false } = $$props;
    	let { small = false } = $$props;
    	let { smallMd = false } = $$props;
    	let { smallIos = false } = $$props;
    	let { smallAurora = false } = $$props;
    	let { raised = false } = $$props;
    	let { raisedMd = false } = $$props;
    	let { raisedIos = false } = $$props;
    	let { raisedAurora = false } = $$props;
    	let { outline = false } = $$props;
    	let { outlineMd = false } = $$props;
    	let { outlineIos = false } = $$props;
    	let { outlineAurora = false } = $$props;
    	let { active = false } = $$props;
    	let { disabled = false } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { tooltipTrigger = undefined } = $$props;
    	let { routeProps = undefined } = $$props;
    	let { preloader = false } = $$props;
    	let { preloaderSize = undefined } = $$props;
    	let { preloaderColor = undefined } = $$props;
    	let { loading = false } = $$props;
    	let el;

    	function onClick() {
    		emit('click');
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(7, el);
    		});
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(7, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(52, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(53, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(13, className = $$new_props.class);
    		if ('text' in $$new_props) $$invalidate(0, text = $$new_props.text);
    		if ('tabLink' in $$new_props) $$invalidate(14, tabLink = $$new_props.tabLink);
    		if ('tabLinkActive' in $$new_props) $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
    		if ('type' in $$new_props) $$invalidate(16, type = $$new_props.type);
    		if ('href' in $$new_props) $$invalidate(17, href = $$new_props.href);
    		if ('target' in $$new_props) $$invalidate(18, target = $$new_props.target);
    		if ('round' in $$new_props) $$invalidate(19, round = $$new_props.round);
    		if ('roundMd' in $$new_props) $$invalidate(20, roundMd = $$new_props.roundMd);
    		if ('roundIos' in $$new_props) $$invalidate(21, roundIos = $$new_props.roundIos);
    		if ('roundAurora' in $$new_props) $$invalidate(22, roundAurora = $$new_props.roundAurora);
    		if ('fill' in $$new_props) $$invalidate(23, fill = $$new_props.fill);
    		if ('fillMd' in $$new_props) $$invalidate(24, fillMd = $$new_props.fillMd);
    		if ('fillIos' in $$new_props) $$invalidate(25, fillIos = $$new_props.fillIos);
    		if ('fillAurora' in $$new_props) $$invalidate(26, fillAurora = $$new_props.fillAurora);
    		if ('large' in $$new_props) $$invalidate(27, large = $$new_props.large);
    		if ('largeMd' in $$new_props) $$invalidate(28, largeMd = $$new_props.largeMd);
    		if ('largeIos' in $$new_props) $$invalidate(29, largeIos = $$new_props.largeIos);
    		if ('largeAurora' in $$new_props) $$invalidate(30, largeAurora = $$new_props.largeAurora);
    		if ('small' in $$new_props) $$invalidate(31, small = $$new_props.small);
    		if ('smallMd' in $$new_props) $$invalidate(32, smallMd = $$new_props.smallMd);
    		if ('smallIos' in $$new_props) $$invalidate(33, smallIos = $$new_props.smallIos);
    		if ('smallAurora' in $$new_props) $$invalidate(34, smallAurora = $$new_props.smallAurora);
    		if ('raised' in $$new_props) $$invalidate(35, raised = $$new_props.raised);
    		if ('raisedMd' in $$new_props) $$invalidate(36, raisedMd = $$new_props.raisedMd);
    		if ('raisedIos' in $$new_props) $$invalidate(37, raisedIos = $$new_props.raisedIos);
    		if ('raisedAurora' in $$new_props) $$invalidate(38, raisedAurora = $$new_props.raisedAurora);
    		if ('outline' in $$new_props) $$invalidate(39, outline = $$new_props.outline);
    		if ('outlineMd' in $$new_props) $$invalidate(40, outlineMd = $$new_props.outlineMd);
    		if ('outlineIos' in $$new_props) $$invalidate(41, outlineIos = $$new_props.outlineIos);
    		if ('outlineAurora' in $$new_props) $$invalidate(42, outlineAurora = $$new_props.outlineAurora);
    		if ('active' in $$new_props) $$invalidate(43, active = $$new_props.active);
    		if ('disabled' in $$new_props) $$invalidate(44, disabled = $$new_props.disabled);
    		if ('tooltip' in $$new_props) $$invalidate(1, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$new_props) $$invalidate(2, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('routeProps' in $$new_props) $$invalidate(3, routeProps = $$new_props.routeProps);
    		if ('preloader' in $$new_props) $$invalidate(4, preloader = $$new_props.preloader);
    		if ('preloaderSize' in $$new_props) $$invalidate(5, preloaderSize = $$new_props.preloaderSize);
    		if ('preloaderColor' in $$new_props) $$invalidate(6, preloaderColor = $$new_props.preloaderColor);
    		if ('loading' in $$new_props) $$invalidate(45, loading = $$new_props.loading);
    		if ('$$scope' in $$new_props) $$invalidate(47, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		colorClasses,
    		routerAttrs,
    		routerClasses,
    		actionsAttrs,
    		actionsClasses,
    		classNames,
    		extend,
    		isStringProp,
    		plainText,
    		createEmitter,
    		restProps,
    		useTooltip,
    		useRouteProps,
    		useIcon,
    		UseIcon: Use_icon,
    		Preloader,
    		emit,
    		className,
    		text,
    		tabLink,
    		tabLinkActive,
    		type,
    		href,
    		target,
    		round,
    		roundMd,
    		roundIos,
    		roundAurora,
    		fill,
    		fillMd,
    		fillIos,
    		fillAurora,
    		large,
    		largeMd,
    		largeIos,
    		largeAurora,
    		small,
    		smallMd,
    		smallIos,
    		smallAurora,
    		raised,
    		raisedMd,
    		raisedIos,
    		raisedAurora,
    		outline,
    		outlineMd,
    		outlineIos,
    		outlineAurora,
    		active,
    		disabled,
    		tooltip,
    		tooltipTrigger,
    		routeProps,
    		preloader,
    		preloaderSize,
    		preloaderColor,
    		loading,
    		el,
    		onClick,
    		icon,
    		tagName,
    		classes,
    		hrefComputed,
    		attrs
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(52, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(13, className = $$new_props.className);
    		if ('text' in $$props) $$invalidate(0, text = $$new_props.text);
    		if ('tabLink' in $$props) $$invalidate(14, tabLink = $$new_props.tabLink);
    		if ('tabLinkActive' in $$props) $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
    		if ('type' in $$props) $$invalidate(16, type = $$new_props.type);
    		if ('href' in $$props) $$invalidate(17, href = $$new_props.href);
    		if ('target' in $$props) $$invalidate(18, target = $$new_props.target);
    		if ('round' in $$props) $$invalidate(19, round = $$new_props.round);
    		if ('roundMd' in $$props) $$invalidate(20, roundMd = $$new_props.roundMd);
    		if ('roundIos' in $$props) $$invalidate(21, roundIos = $$new_props.roundIos);
    		if ('roundAurora' in $$props) $$invalidate(22, roundAurora = $$new_props.roundAurora);
    		if ('fill' in $$props) $$invalidate(23, fill = $$new_props.fill);
    		if ('fillMd' in $$props) $$invalidate(24, fillMd = $$new_props.fillMd);
    		if ('fillIos' in $$props) $$invalidate(25, fillIos = $$new_props.fillIos);
    		if ('fillAurora' in $$props) $$invalidate(26, fillAurora = $$new_props.fillAurora);
    		if ('large' in $$props) $$invalidate(27, large = $$new_props.large);
    		if ('largeMd' in $$props) $$invalidate(28, largeMd = $$new_props.largeMd);
    		if ('largeIos' in $$props) $$invalidate(29, largeIos = $$new_props.largeIos);
    		if ('largeAurora' in $$props) $$invalidate(30, largeAurora = $$new_props.largeAurora);
    		if ('small' in $$props) $$invalidate(31, small = $$new_props.small);
    		if ('smallMd' in $$props) $$invalidate(32, smallMd = $$new_props.smallMd);
    		if ('smallIos' in $$props) $$invalidate(33, smallIos = $$new_props.smallIos);
    		if ('smallAurora' in $$props) $$invalidate(34, smallAurora = $$new_props.smallAurora);
    		if ('raised' in $$props) $$invalidate(35, raised = $$new_props.raised);
    		if ('raisedMd' in $$props) $$invalidate(36, raisedMd = $$new_props.raisedMd);
    		if ('raisedIos' in $$props) $$invalidate(37, raisedIos = $$new_props.raisedIos);
    		if ('raisedAurora' in $$props) $$invalidate(38, raisedAurora = $$new_props.raisedAurora);
    		if ('outline' in $$props) $$invalidate(39, outline = $$new_props.outline);
    		if ('outlineMd' in $$props) $$invalidate(40, outlineMd = $$new_props.outlineMd);
    		if ('outlineIos' in $$props) $$invalidate(41, outlineIos = $$new_props.outlineIos);
    		if ('outlineAurora' in $$props) $$invalidate(42, outlineAurora = $$new_props.outlineAurora);
    		if ('active' in $$props) $$invalidate(43, active = $$new_props.active);
    		if ('disabled' in $$props) $$invalidate(44, disabled = $$new_props.disabled);
    		if ('tooltip' in $$props) $$invalidate(1, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$props) $$invalidate(2, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('routeProps' in $$props) $$invalidate(3, routeProps = $$new_props.routeProps);
    		if ('preloader' in $$props) $$invalidate(4, preloader = $$new_props.preloader);
    		if ('preloaderSize' in $$props) $$invalidate(5, preloaderSize = $$new_props.preloaderSize);
    		if ('preloaderColor' in $$props) $$invalidate(6, preloaderColor = $$new_props.preloaderColor);
    		if ('loading' in $$props) $$invalidate(45, loading = $$new_props.loading);
    		if ('el' in $$props) $$invalidate(7, el = $$new_props.el);
    		if ('icon' in $$props) $$invalidate(8, icon = $$new_props.icon);
    		if ('tagName' in $$props) $$invalidate(9, tagName = $$new_props.tagName);
    		if ('classes' in $$props) $$invalidate(10, classes = $$new_props.classes);
    		if ('hrefComputed' in $$props) $$invalidate(46, hrefComputed = $$new_props.hrefComputed);
    		if ('attrs' in $$props) $$invalidate(11, attrs = $$new_props.attrs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*href*/ 131072) {
    			$$invalidate(46, hrefComputed = href === true ? '#' : href || undefined);
    		}

    		$$invalidate(11, attrs = extend(
    			{
    				href: hrefComputed,
    				target,
    				type,
    				'data-tab': isStringProp(tabLink) && tabLink || undefined,
    				...restProps($$restProps)
    			},
    			routerAttrs($$props),
    			actionsAttrs($$props)
    		));

    		$$invalidate(10, classes = classNames(
    			className,
    			'button',
    			{
    				'tab-link': tabLink || tabLink === '',
    				'tab-link-active': tabLinkActive,
    				'button-round': round,
    				'button-round-ios': roundIos,
    				'button-round-aurora': roundAurora,
    				'button-round-md': roundMd,
    				'button-fill': fill,
    				'button-fill-ios': fillIos,
    				'button-fill-aurora': fillAurora,
    				'button-fill-md': fillMd,
    				'button-large': large,
    				'button-large-ios': largeIos,
    				'button-large-aurora': largeAurora,
    				'button-large-md': largeMd,
    				'button-small': small,
    				'button-small-ios': smallIos,
    				'button-small-aurora': smallAurora,
    				'button-small-md': smallMd,
    				'button-raised': raised,
    				'button-raised-ios': raisedIos,
    				'button-raised-aurora': raisedAurora,
    				'button-raised-md': raisedMd,
    				'button-active': active,
    				'button-outline': outline,
    				'button-outline-ios': outlineIos,
    				'button-outline-aurora': outlineAurora,
    				'button-outline-md': outlineMd,
    				'button-preloader': preloader,
    				'button-loading': loading,
    				disabled
    			},
    			colorClasses($$props),
    			routerClasses($$props),
    			actionsClasses($$props)
    		));

    		if ($$self.$$.dirty[0] & /*type*/ 65536) {
    			$$invalidate(9, tagName = type === 'submit' || type === 'reset' || type === 'button'
    			? 'button'
    			: 'a');
    		}

    		$$invalidate(8, icon = useIcon($$props));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		text,
    		tooltip,
    		tooltipTrigger,
    		routeProps,
    		preloader,
    		preloaderSize,
    		preloaderColor,
    		el,
    		icon,
    		tagName,
    		classes,
    		attrs,
    		onClick,
    		className,
    		tabLink,
    		tabLinkActive,
    		type,
    		href,
    		target,
    		round,
    		roundMd,
    		roundIos,
    		roundAurora,
    		fill,
    		fillMd,
    		fillIos,
    		fillAurora,
    		large,
    		largeMd,
    		largeIos,
    		largeAurora,
    		small,
    		smallMd,
    		smallIos,
    		smallAurora,
    		raised,
    		raisedMd,
    		raisedIos,
    		raisedAurora,
    		outline,
    		outlineMd,
    		outlineIos,
    		outlineAurora,
    		active,
    		disabled,
    		loading,
    		hrefComputed,
    		$$scope,
    		slots,
    		button_binding,
    		a_binding
    	];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$j,
    			create_fragment$n,
    			safe_not_equal,
    			{
    				class: 13,
    				text: 0,
    				tabLink: 14,
    				tabLinkActive: 15,
    				type: 16,
    				href: 17,
    				target: 18,
    				round: 19,
    				roundMd: 20,
    				roundIos: 21,
    				roundAurora: 22,
    				fill: 23,
    				fillMd: 24,
    				fillIos: 25,
    				fillAurora: 26,
    				large: 27,
    				largeMd: 28,
    				largeIos: 29,
    				largeAurora: 30,
    				small: 31,
    				smallMd: 32,
    				smallIos: 33,
    				smallAurora: 34,
    				raised: 35,
    				raisedMd: 36,
    				raisedIos: 37,
    				raisedAurora: 38,
    				outline: 39,
    				outlineMd: 40,
    				outlineIos: 41,
    				outlineAurora: 42,
    				active: 43,
    				disabled: 44,
    				tooltip: 1,
    				tooltipTrigger: 2,
    				routeProps: 3,
    				preloader: 4,
    				preloaderSize: 5,
    				preloaderColor: 6,
    				loading: 45
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get class() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabLink() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabLink(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabLinkActive() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabLinkActive(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get target() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set target(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get round() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set round(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get roundMd() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set roundMd(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get roundIos() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set roundIos(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get roundAurora() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set roundAurora(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillMd() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillMd(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillIos() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillIos(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillAurora() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillAurora(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get large() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set large(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get largeMd() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set largeMd(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get largeIos() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set largeIos(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get largeAurora() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set largeAurora(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get small() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set small(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smallMd() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smallMd(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smallIos() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smallIos(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smallAurora() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smallAurora(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get raised() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set raised(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get raisedMd() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set raisedMd(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get raisedIos() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set raisedIos(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get raisedAurora() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set raisedAurora(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outline() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outline(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outlineMd() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outlineMd(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outlineIos() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outlineIos(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outlineAurora() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outlineAurora(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipTrigger() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipTrigger(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get routeProps() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routeProps(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get preloader() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set preloader(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get preloaderSize() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set preloaderSize(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get preloaderColor() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set preloaderColor(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/fab.svelte generated by Svelte v3.44.0 */
    const file$l = "node_modules/framework7-svelte/esm/svelte/fab.svelte";
    const get_root_slot_changes$3 = dirty => ({});
    const get_root_slot_context$3 = ctx => ({});
    const get_link_slot_changes = dirty => ({});
    const get_link_slot_context = ctx => ({});
    const get_text_slot_changes$1 = dirty => ({});
    const get_text_slot_context$1 = ctx => ({});

    // (81:4) {#if typeof text !== 'undefined' || hasTextSlots}
    function create_if_block$e(ctx) {
    	let div;
    	let t0_value = plainText(/*text*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const text_slot_template = /*#slots*/ ctx[18].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[17], get_text_slot_context$1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (text_slot) text_slot.c();
    			attr_dev(div, "class", "fab-text");
    			add_location(div, file$l, 81, 6, 1964);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[19](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[17], dirty, get_text_slot_changes$1),
    						get_text_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (text_slot) text_slot.d(detaching);
    			/*div_binding*/ ctx[19](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(81:4) {#if typeof text !== 'undefined' || hasTextSlots}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div;
    	let a;
    	let t0;
    	let t1;
    	let useTooltip_action;
    	let t2;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[18].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
    	let if_block = (typeof /*text*/ ctx[2] !== 'undefined' || /*hasTextSlots*/ ctx[7]) && create_if_block$e(ctx);
    	const link_slot_template = /*#slots*/ ctx[18].link;
    	const link_slot = create_slot(link_slot_template, ctx, /*$$scope*/ ctx[17], get_link_slot_context);
    	const root_slot_template = /*#slots*/ ctx[18].root;
    	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[17], get_root_slot_context$3);

    	let div_levels = [
    		{ class: /*classes*/ ctx[10] },
    		{ "data-morph-to": /*morphTo*/ ctx[0] },
    		{ "data-f7-slot": /*f7Slot*/ ctx[5] },
    		restProps(/*$$restProps*/ ctx[13])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			a = element("a");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			if (link_slot) link_slot.c();
    			t2 = space();
    			if (root_slot) root_slot.c();
    			attr_dev(a, "target", /*target*/ ctx[1]);
    			attr_dev(a, "href", /*hrefComputed*/ ctx[11]);
    			add_location(a, file$l, 72, 2, 1752);
    			set_attributes(div, div_data);
    			add_location(div, file$l, 65, 0, 1628);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, a);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			append_dev(a, t0);
    			if (if_block) if_block.m(a, null);
    			append_dev(a, t1);

    			if (link_slot) {
    				link_slot.m(a, null);
    			}

    			/*a_binding*/ ctx[20](a);
    			append_dev(div, t2);

    			if (root_slot) {
    				root_slot.m(div, null);
    			}

    			/*div_binding_1*/ ctx[21](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*onClick*/ ctx[12], false, false, false),
    					action_destroyer(useTooltip_action = useTooltip.call(null, a, {
    						tooltip: /*tooltip*/ ctx[3],
    						tooltipTrigger: /*tooltipTrigger*/ ctx[4]
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
    						null
    					);
    				}
    			}

    			if (typeof /*text*/ ctx[2] !== 'undefined' || /*hasTextSlots*/ ctx[7]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*text, hasTextSlots*/ 132) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(a, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (link_slot) {
    				if (link_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						link_slot,
    						link_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(link_slot_template, /*$$scope*/ ctx[17], dirty, get_link_slot_changes),
    						get_link_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*target*/ 2) {
    				attr_dev(a, "target", /*target*/ ctx[1]);
    			}

    			if (!current || dirty & /*hrefComputed*/ 2048) {
    				attr_dev(a, "href", /*hrefComputed*/ ctx[11]);
    			}

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 24) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[3],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[4]
    			});

    			if (root_slot) {
    				if (root_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						root_slot,
    						root_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(root_slot_template, /*$$scope*/ ctx[17], dirty, get_root_slot_changes$3),
    						get_root_slot_context$3
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 1024) && { class: /*classes*/ ctx[10] },
    				(!current || dirty & /*morphTo*/ 1) && { "data-morph-to": /*morphTo*/ ctx[0] },
    				(!current || dirty & /*f7Slot*/ 32) && { "data-f7-slot": /*f7Slot*/ ctx[5] },
    				dirty & /*$$restProps*/ 8192 && restProps(/*$$restProps*/ ctx[13])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(if_block);
    			transition_in(link_slot, local);
    			transition_in(root_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(if_block);
    			transition_out(link_slot, local);
    			transition_out(root_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			if (if_block) if_block.d();
    			if (link_slot) link_slot.d(detaching);
    			/*a_binding*/ ctx[20](null);
    			if (root_slot) root_slot.d(detaching);
    			/*div_binding_1*/ ctx[21](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let hrefComputed;
    	let hasTextSlots;
    	let classes;

    	const omit_props_names = [
    		"class","morphTo","href","target","text","position","tooltip","tooltipTrigger","f7Slot"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Fab', slots, ['default','text','link','root']);
    	const $$slots = compute_slots(slots);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { morphTo = undefined } = $$props;
    	let { href = undefined } = $$props;
    	let { target = undefined } = $$props;
    	let { text = undefined } = $$props;
    	let { position = 'right-bottom' } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { tooltipTrigger = undefined } = $$props;
    	let { f7Slot = 'fixed' } = $$props;
    	let el;
    	let linkEl;
    	let textEl;

    	function onClick() {
    		emit('click');
    	}

    	onMount(() => {
    		f7ready(() => {
    			const dom7 = app$1.f7.$;
    			const rootEls = dom7(linkEl).children('.fab-buttons');

    			if (rootEls.length) {
    				dom7(el).append(rootEls);
    			}
    		});
    	});

    	afterUpdate(() => {
    		if (!app$1.f7) return;
    		const dom7 = app$1.f7.$;
    		const rootEls = dom7(linkEl).children('.fab-buttons');

    		if (rootEls.length) {
    			dom7(el).append(rootEls);
    		}
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			textEl = $$value;
    			$$invalidate(6, textEl);
    		});
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			linkEl = $$value;
    			$$invalidate(9, linkEl);
    		});
    	}

    	function div_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(8, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(14, className = $$new_props.class);
    		if ('morphTo' in $$new_props) $$invalidate(0, morphTo = $$new_props.morphTo);
    		if ('href' in $$new_props) $$invalidate(15, href = $$new_props.href);
    		if ('target' in $$new_props) $$invalidate(1, target = $$new_props.target);
    		if ('text' in $$new_props) $$invalidate(2, text = $$new_props.text);
    		if ('position' in $$new_props) $$invalidate(16, position = $$new_props.position);
    		if ('tooltip' in $$new_props) $$invalidate(3, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$new_props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('f7Slot' in $$new_props) $$invalidate(5, f7Slot = $$new_props.f7Slot);
    		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		afterUpdate,
    		colorClasses,
    		classNames,
    		plainText,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		useTooltip,
    		emit,
    		className,
    		morphTo,
    		href,
    		target,
    		text,
    		position,
    		tooltip,
    		tooltipTrigger,
    		f7Slot,
    		el,
    		linkEl,
    		textEl,
    		onClick,
    		hasTextSlots,
    		classes,
    		hrefComputed
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(14, className = $$new_props.className);
    		if ('morphTo' in $$props) $$invalidate(0, morphTo = $$new_props.morphTo);
    		if ('href' in $$props) $$invalidate(15, href = $$new_props.href);
    		if ('target' in $$props) $$invalidate(1, target = $$new_props.target);
    		if ('text' in $$props) $$invalidate(2, text = $$new_props.text);
    		if ('position' in $$props) $$invalidate(16, position = $$new_props.position);
    		if ('tooltip' in $$props) $$invalidate(3, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('f7Slot' in $$props) $$invalidate(5, f7Slot = $$new_props.f7Slot);
    		if ('el' in $$props) $$invalidate(8, el = $$new_props.el);
    		if ('linkEl' in $$props) $$invalidate(9, linkEl = $$new_props.linkEl);
    		if ('textEl' in $$props) $$invalidate(6, textEl = $$new_props.textEl);
    		if ('hasTextSlots' in $$props) $$invalidate(7, hasTextSlots = $$new_props.hasTextSlots);
    		if ('classes' in $$props) $$invalidate(10, classes = $$new_props.classes);
    		if ('hrefComputed' in $$props) $$invalidate(11, hrefComputed = $$new_props.hrefComputed);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*href*/ 32768) {
    			$$invalidate(11, hrefComputed = href === true ? '#' : href || undefined);
    		}

    		$$invalidate(10, classes = classNames(
    			className,
    			'fab',
    			`fab-${position}`,
    			{
    				'fab-morph': morphTo,
    				'fab-extended': text || hasTextSlots || typeof textEl !== 'undefined'
    			},
    			colorClasses($$props)
    		));
    	};

    	$$invalidate(7, hasTextSlots = $$slots.text);
    	$$props = exclude_internal_props($$props);

    	return [
    		morphTo,
    		target,
    		text,
    		tooltip,
    		tooltipTrigger,
    		f7Slot,
    		textEl,
    		hasTextSlots,
    		el,
    		linkEl,
    		classes,
    		hrefComputed,
    		onClick,
    		$$restProps,
    		className,
    		href,
    		position,
    		$$scope,
    		slots,
    		div_binding,
    		a_binding,
    		div_binding_1
    	];
    }

    class Fab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$i, create_fragment$m, safe_not_equal, {
    			class: 14,
    			morphTo: 0,
    			href: 15,
    			target: 1,
    			text: 2,
    			position: 16,
    			tooltip: 3,
    			tooltipTrigger: 4,
    			f7Slot: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Fab",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get class() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get morphTo() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set morphTo(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get target() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set target(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get position() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipTrigger() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipTrigger(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get f7Slot() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set f7Slot(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/range.svelte generated by Svelte v3.44.0 */
    const file$k = "node_modules/framework7-svelte/esm/svelte/range.svelte";
    const get_default_slot_changes$3 = dirty => ({ range: dirty[0] & /*f7Range*/ 16 });
    const get_default_slot_context$3 = ctx => ({ range: /*f7Range*/ ctx[4] });

    // (104:2) {#if input}
    function create_if_block$d(ctx) {
    	let input_1;

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			attr_dev(input_1, "type", "range");
    			attr_dev(input_1, "name", /*name*/ ctx[0]);
    			attr_dev(input_1, "id", /*inputId*/ ctx[2]);
    			add_location(input_1, file$k, 103, 13, 2468);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*name*/ 1) {
    				attr_dev(input_1, "name", /*name*/ ctx[0]);
    			}

    			if (dirty[0] & /*inputId*/ 4) {
    				attr_dev(input_1, "id", /*inputId*/ ctx[2]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(104:2) {#if input}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = /*input*/ ctx[1] && create_if_block$d(ctx);
    	const default_slot_template = /*#slots*/ ctx[27].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[26], get_default_slot_context$3);
    	let div_levels = [{ class: /*classes*/ ctx[5] }, restProps(/*$$restProps*/ ctx[6])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$k, 102, 0, 2390);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[28](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*input*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope, f7Range*/ 67108880)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[26],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[26])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[26], dirty, get_default_slot_changes$3),
    						get_default_slot_context$3
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty[0] & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
    				dirty[0] & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[28](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance_1$3($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","init","value","min","max","step","label","dual","vertical","verticalReversed","draggableBar","formatLabel","scale","scaleSteps","scaleSubSteps","formatScaleLabel","limitKnobPosition","name","input","inputId","disabled","instance"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Range', slots, ['default']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { init = true } = $$props;
    	let { value = 0 } = $$props;
    	let { min = 0 } = $$props;
    	let { max = 100 } = $$props;
    	let { step = 1 } = $$props;
    	let { label = false } = $$props;
    	let { dual = false } = $$props;
    	let { vertical = false } = $$props;
    	let { verticalReversed = false } = $$props;
    	let { draggableBar = true } = $$props;
    	let { formatLabel = undefined } = $$props;
    	let { scale = false } = $$props;
    	let { scaleSteps = 5 } = $$props;
    	let { scaleSubSteps = 0 } = $$props;
    	let { formatScaleLabel = undefined } = $$props;
    	let { limitKnobPosition = undefined } = $$props;
    	let { name = undefined } = $$props;
    	let { input = false } = $$props;
    	let { inputId = undefined } = $$props;
    	let { disabled = false } = $$props;
    	let el;
    	let f7Range;

    	function instance() {
    		return f7Range;
    	}

    	function watchValue(newValue) {
    		if (!f7Range) return;
    		f7Range.setValue(newValue);
    	}

    	onMount(() => {
    		if (!init) return;

    		f7ready(() => {
    			$$invalidate(4, f7Range = app$1.f7.range.create(noUndefinedProps({
    				el,
    				value,
    				min,
    				max,
    				step,
    				label,
    				dual,
    				draggableBar,
    				vertical,
    				verticalReversed,
    				formatLabel,
    				scale,
    				scaleSteps,
    				scaleSubSteps,
    				formatScaleLabel,
    				limitKnobPosition,
    				on: {
    					change(range, val) {
    						emit('rangeChange', [val]);
    					},
    					changed(range, val) {
    						emit('rangeChanged', [val]);
    						$$invalidate(7, value = val);
    					}
    				}
    			})));
    		});
    	});

    	onDestroy(() => {
    		if (f7Range && f7Range.destroy) {
    			f7Range.destroy();
    			$$invalidate(4, f7Range = null);
    		}
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(3, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(31, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
    		if ('init' in $$new_props) $$invalidate(9, init = $$new_props.init);
    		if ('value' in $$new_props) $$invalidate(7, value = $$new_props.value);
    		if ('min' in $$new_props) $$invalidate(10, min = $$new_props.min);
    		if ('max' in $$new_props) $$invalidate(11, max = $$new_props.max);
    		if ('step' in $$new_props) $$invalidate(12, step = $$new_props.step);
    		if ('label' in $$new_props) $$invalidate(13, label = $$new_props.label);
    		if ('dual' in $$new_props) $$invalidate(14, dual = $$new_props.dual);
    		if ('vertical' in $$new_props) $$invalidate(15, vertical = $$new_props.vertical);
    		if ('verticalReversed' in $$new_props) $$invalidate(16, verticalReversed = $$new_props.verticalReversed);
    		if ('draggableBar' in $$new_props) $$invalidate(17, draggableBar = $$new_props.draggableBar);
    		if ('formatLabel' in $$new_props) $$invalidate(18, formatLabel = $$new_props.formatLabel);
    		if ('scale' in $$new_props) $$invalidate(19, scale = $$new_props.scale);
    		if ('scaleSteps' in $$new_props) $$invalidate(20, scaleSteps = $$new_props.scaleSteps);
    		if ('scaleSubSteps' in $$new_props) $$invalidate(21, scaleSubSteps = $$new_props.scaleSubSteps);
    		if ('formatScaleLabel' in $$new_props) $$invalidate(22, formatScaleLabel = $$new_props.formatScaleLabel);
    		if ('limitKnobPosition' in $$new_props) $$invalidate(23, limitKnobPosition = $$new_props.limitKnobPosition);
    		if ('name' in $$new_props) $$invalidate(0, name = $$new_props.name);
    		if ('input' in $$new_props) $$invalidate(1, input = $$new_props.input);
    		if ('inputId' in $$new_props) $$invalidate(2, inputId = $$new_props.inputId);
    		if ('disabled' in $$new_props) $$invalidate(24, disabled = $$new_props.disabled);
    		if ('$$scope' in $$new_props) $$invalidate(26, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		colorClasses,
    		classNames,
    		noUndefinedProps,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		emit,
    		className,
    		init,
    		value,
    		min,
    		max,
    		step,
    		label,
    		dual,
    		vertical,
    		verticalReversed,
    		draggableBar,
    		formatLabel,
    		scale,
    		scaleSteps,
    		scaleSubSteps,
    		formatScaleLabel,
    		limitKnobPosition,
    		name,
    		input,
    		inputId,
    		disabled,
    		el,
    		f7Range,
    		instance,
    		watchValue,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(31, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(8, className = $$new_props.className);
    		if ('init' in $$props) $$invalidate(9, init = $$new_props.init);
    		if ('value' in $$props) $$invalidate(7, value = $$new_props.value);
    		if ('min' in $$props) $$invalidate(10, min = $$new_props.min);
    		if ('max' in $$props) $$invalidate(11, max = $$new_props.max);
    		if ('step' in $$props) $$invalidate(12, step = $$new_props.step);
    		if ('label' in $$props) $$invalidate(13, label = $$new_props.label);
    		if ('dual' in $$props) $$invalidate(14, dual = $$new_props.dual);
    		if ('vertical' in $$props) $$invalidate(15, vertical = $$new_props.vertical);
    		if ('verticalReversed' in $$props) $$invalidate(16, verticalReversed = $$new_props.verticalReversed);
    		if ('draggableBar' in $$props) $$invalidate(17, draggableBar = $$new_props.draggableBar);
    		if ('formatLabel' in $$props) $$invalidate(18, formatLabel = $$new_props.formatLabel);
    		if ('scale' in $$props) $$invalidate(19, scale = $$new_props.scale);
    		if ('scaleSteps' in $$props) $$invalidate(20, scaleSteps = $$new_props.scaleSteps);
    		if ('scaleSubSteps' in $$props) $$invalidate(21, scaleSubSteps = $$new_props.scaleSubSteps);
    		if ('formatScaleLabel' in $$props) $$invalidate(22, formatScaleLabel = $$new_props.formatScaleLabel);
    		if ('limitKnobPosition' in $$props) $$invalidate(23, limitKnobPosition = $$new_props.limitKnobPosition);
    		if ('name' in $$props) $$invalidate(0, name = $$new_props.name);
    		if ('input' in $$props) $$invalidate(1, input = $$new_props.input);
    		if ('inputId' in $$props) $$invalidate(2, inputId = $$new_props.inputId);
    		if ('disabled' in $$props) $$invalidate(24, disabled = $$new_props.disabled);
    		if ('el' in $$props) $$invalidate(3, el = $$new_props.el);
    		if ('f7Range' in $$props) $$invalidate(4, f7Range = $$new_props.f7Range);
    		if ('classes' in $$props) $$invalidate(5, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(5, classes = classNames(
    			className,
    			'range-slider',
    			{
    				'range-slider-horizontal': !vertical,
    				'range-slider-vertical': vertical,
    				'range-slider-vertical-reversed': vertical && verticalReversed,
    				disabled
    			},
    			colorClasses($$props)
    		));

    		if ($$self.$$.dirty[0] & /*value*/ 128) {
    			watchValue(value);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		name,
    		input,
    		inputId,
    		el,
    		f7Range,
    		classes,
    		$$restProps,
    		value,
    		className,
    		init,
    		min,
    		max,
    		step,
    		label,
    		dual,
    		vertical,
    		verticalReversed,
    		draggableBar,
    		formatLabel,
    		scale,
    		scaleSteps,
    		scaleSubSteps,
    		formatScaleLabel,
    		limitKnobPosition,
    		disabled,
    		instance,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class Range extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance_1$3,
    			create_fragment$l,
    			safe_not_equal,
    			{
    				class: 8,
    				init: 9,
    				value: 7,
    				min: 10,
    				max: 11,
    				step: 12,
    				label: 13,
    				dual: 14,
    				vertical: 15,
    				verticalReversed: 16,
    				draggableBar: 17,
    				formatLabel: 18,
    				scale: 19,
    				scaleSteps: 20,
    				scaleSubSteps: 21,
    				formatScaleLabel: 22,
    				limitKnobPosition: 23,
    				name: 0,
    				input: 1,
    				inputId: 2,
    				disabled: 24,
    				instance: 25
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Range",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get class() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get init() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set init(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get step() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set step(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dual() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dual(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vertical() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vertical(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get verticalReversed() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set verticalReversed(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get draggableBar() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set draggableBar(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get formatLabel() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set formatLabel(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scale() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scale(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scaleSteps() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scaleSteps(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scaleSubSteps() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scaleSubSteps(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get formatScaleLabel() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set formatScaleLabel(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get limitKnobPosition() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set limitKnobPosition(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputId() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputId(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get instance() {
    		return this.$$.ctx[25];
    	}

    	set instance(value) {
    		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/text-editor.svelte generated by Svelte v3.44.0 */
    const file$j = "node_modules/framework7-svelte/esm/svelte/text-editor.svelte";

    const get_root_slot_changes$2 = dirty => ({
    	textEditor: dirty[0] & /*f7TextEditor*/ 2
    });

    const get_root_slot_context$2 = ctx => ({ textEditor: /*f7TextEditor*/ ctx[1] });

    const get_root_end_slot_changes$2 = dirty => ({
    	textEditor: dirty[0] & /*f7TextEditor*/ 2
    });

    const get_root_end_slot_context$2 = ctx => ({ textEditor: /*f7TextEditor*/ ctx[1] });

    const get_default_slot_changes$2 = dirty => ({
    	textEditor: dirty[0] & /*f7TextEditor*/ 2
    });

    const get_default_slot_context$2 = ctx => ({ textEditor: /*f7TextEditor*/ ctx[1] });

    const get_root_start_slot_changes$2 = dirty => ({
    	textEditor: dirty[0] & /*f7TextEditor*/ 2
    });

    const get_root_start_slot_context$2 = ctx => ({ textEditor: /*f7TextEditor*/ ctx[1] });

    function create_fragment$k(ctx) {
    	let div1;
    	let t0;
    	let div0;
    	let t1;
    	let t2;
    	let current;
    	const root_start_slot_template = /*#slots*/ ctx[17]["root-start"];
    	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[16], get_root_start_slot_context$2);
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], get_default_slot_context$2);
    	const root_end_slot_template = /*#slots*/ ctx[17]["root-end"];
    	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[16], get_root_end_slot_context$2);
    	const root_slot_template = /*#slots*/ ctx[17].root;
    	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[16], get_root_slot_context$2);
    	let div1_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
    	let div1_data = {};

    	for (let i = 0; i < div1_levels.length; i += 1) {
    		div1_data = assign(div1_data, div1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (root_start_slot) root_start_slot.c();
    			t0 = space();
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			t1 = space();
    			if (root_end_slot) root_end_slot.c();
    			t2 = space();
    			if (root_slot) root_slot.c();
    			attr_dev(div0, "class", "text-editor-content");
    			attr_dev(div0, "contenteditable", "");
    			add_location(div0, file$j, 120, 2, 2984);
    			set_attributes(div1, div1_data);
    			add_location(div1, file$j, 118, 0, 2862);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);

    			if (root_start_slot) {
    				root_start_slot.m(div1, null);
    			}

    			append_dev(div1, t0);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			append_dev(div1, t1);

    			if (root_end_slot) {
    				root_end_slot.m(div1, null);
    			}

    			append_dev(div1, t2);

    			if (root_slot) {
    				root_slot.m(div1, null);
    			}

    			/*div1_binding*/ ctx[18](div1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (root_start_slot) {
    				if (root_start_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/ 65538)) {
    					update_slot_base(
    						root_start_slot,
    						root_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(root_start_slot_template, /*$$scope*/ ctx[16], dirty, get_root_start_slot_changes$2),
    						get_root_start_slot_context$2
    					);
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/ 65538)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, get_default_slot_changes$2),
    						get_default_slot_context$2
    					);
    				}
    			}

    			if (root_end_slot) {
    				if (root_end_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/ 65538)) {
    					update_slot_base(
    						root_end_slot,
    						root_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(root_end_slot_template, /*$$scope*/ ctx[16], dirty, get_root_end_slot_changes$2),
    						get_root_end_slot_context$2
    					);
    				}
    			}

    			if (root_slot) {
    				if (root_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/ 65538)) {
    					update_slot_base(
    						root_slot,
    						root_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(root_slot_template, /*$$scope*/ ctx[16], dirty, get_root_slot_changes$2),
    						get_root_slot_context$2
    					);
    				}
    			}

    			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
    				(!current || dirty[0] & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
    				dirty[0] & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(root_start_slot, local);
    			transition_in(default_slot, local);
    			transition_in(root_end_slot, local);
    			transition_in(root_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(root_start_slot, local);
    			transition_out(default_slot, local);
    			transition_out(root_end_slot, local);
    			transition_out(root_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (root_start_slot) root_start_slot.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    			if (root_end_slot) root_end_slot.d(detaching);
    			if (root_slot) root_slot.d(detaching);
    			/*div1_binding*/ ctx[18](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance_1$2($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","mode","value","buttons","customButtons","dividers","imageUrlText","linkUrlText","placeholder","clearFormattingOnPaste","resizable","instance"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text_editor', slots, ['root-start','default','root-end','root']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { mode = undefined } = $$props;
    	let { value = undefined } = $$props;
    	let { buttons = undefined } = $$props;
    	let { customButtons = undefined } = $$props;
    	let { dividers = undefined } = $$props;
    	let { imageUrlText = undefined } = $$props;
    	let { linkUrlText = undefined } = $$props;
    	let { placeholder = undefined } = $$props;
    	let { clearFormattingOnPaste = undefined } = $$props;
    	let { resizable = false } = $$props;
    	let el;
    	let f7TextEditor;

    	function instance() {
    		return f7TextEditor;
    	}

    	function watchValue(newValue) {
    		if (f7TextEditor) {
    			f7TextEditor.setValue(newValue);
    		}
    	}

    	function onChange(editor, editorValue) {
    		emit('textEditorChange', [editorValue]);
    	}

    	function onInput(editor, editorValue) {
    		emit('textEditorInput', [editorValue]);
    	}

    	function onFocus() {
    		emit('textEditorFocus');
    	}

    	function onBlur() {
    		emit('textEditorBlur');
    	}

    	function onButtonClick(editor, button) {
    		emit('textEditorButtonClick', [button]);
    	}

    	function onKeyboardOpen() {
    		emit('textEditorKeyboardOpen');
    	}

    	function onKeyboardClose() {
    		emit('textEditorKeyboardClose');
    	}

    	function onPopoverOpen() {
    		emit('textEditorPopoverOpen');
    	}

    	function onPopoverClose() {
    		emit('textEditorPopoverClose');
    	}

    	const onInsertLink = (editor, url) => {
    		emit('textEditorInsertLink', [url]);
    	};

    	const onInsertImage = (editor, url) => {
    		emit('textEditorInsertImage', [url]);
    	};

    	onMount(() => {
    		const params = noUndefinedProps({
    			el,
    			mode,
    			value,
    			buttons,
    			customButtons,
    			dividers,
    			imageUrlText,
    			linkUrlText,
    			placeholder,
    			clearFormattingOnPaste,
    			on: {
    				change: onChange,
    				input: onInput,
    				focus: onFocus,
    				blur: onBlur,
    				buttonClick: onButtonClick,
    				keyboardOpen: onKeyboardOpen,
    				keyboardClose: onKeyboardClose,
    				popoverOpen: onPopoverOpen,
    				popoverClose: onPopoverClose,
    				insertLink: onInsertLink,
    				insertImage: onInsertImage
    			}
    		});

    		f7ready(() => {
    			$$invalidate(1, f7TextEditor = app$1.f7.textEditor.create(params));
    		});
    	});

    	onDestroy(() => {
    		if (f7TextEditor && f7TextEditor.destroy) {
    			f7TextEditor.destroy();
    			$$invalidate(1, f7TextEditor = null);
    		}
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(0, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ('mode' in $$new_props) $$invalidate(5, mode = $$new_props.mode);
    		if ('value' in $$new_props) $$invalidate(6, value = $$new_props.value);
    		if ('buttons' in $$new_props) $$invalidate(7, buttons = $$new_props.buttons);
    		if ('customButtons' in $$new_props) $$invalidate(8, customButtons = $$new_props.customButtons);
    		if ('dividers' in $$new_props) $$invalidate(9, dividers = $$new_props.dividers);
    		if ('imageUrlText' in $$new_props) $$invalidate(10, imageUrlText = $$new_props.imageUrlText);
    		if ('linkUrlText' in $$new_props) $$invalidate(11, linkUrlText = $$new_props.linkUrlText);
    		if ('placeholder' in $$new_props) $$invalidate(12, placeholder = $$new_props.placeholder);
    		if ('clearFormattingOnPaste' in $$new_props) $$invalidate(13, clearFormattingOnPaste = $$new_props.clearFormattingOnPaste);
    		if ('resizable' in $$new_props) $$invalidate(14, resizable = $$new_props.resizable);
    		if ('$$scope' in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		colorClasses,
    		classNames,
    		noUndefinedProps,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		emit,
    		className,
    		mode,
    		value,
    		buttons,
    		customButtons,
    		dividers,
    		imageUrlText,
    		linkUrlText,
    		placeholder,
    		clearFormattingOnPaste,
    		resizable,
    		el,
    		f7TextEditor,
    		instance,
    		watchValue,
    		onChange,
    		onInput,
    		onFocus,
    		onBlur,
    		onButtonClick,
    		onKeyboardOpen,
    		onKeyboardClose,
    		onPopoverOpen,
    		onPopoverClose,
    		onInsertLink,
    		onInsertImage,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(4, className = $$new_props.className);
    		if ('mode' in $$props) $$invalidate(5, mode = $$new_props.mode);
    		if ('value' in $$props) $$invalidate(6, value = $$new_props.value);
    		if ('buttons' in $$props) $$invalidate(7, buttons = $$new_props.buttons);
    		if ('customButtons' in $$props) $$invalidate(8, customButtons = $$new_props.customButtons);
    		if ('dividers' in $$props) $$invalidate(9, dividers = $$new_props.dividers);
    		if ('imageUrlText' in $$props) $$invalidate(10, imageUrlText = $$new_props.imageUrlText);
    		if ('linkUrlText' in $$props) $$invalidate(11, linkUrlText = $$new_props.linkUrlText);
    		if ('placeholder' in $$props) $$invalidate(12, placeholder = $$new_props.placeholder);
    		if ('clearFormattingOnPaste' in $$props) $$invalidate(13, clearFormattingOnPaste = $$new_props.clearFormattingOnPaste);
    		if ('resizable' in $$props) $$invalidate(14, resizable = $$new_props.resizable);
    		if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
    		if ('f7TextEditor' in $$props) $$invalidate(1, f7TextEditor = $$new_props.f7TextEditor);
    		if ('classes' in $$props) $$invalidate(2, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(2, classes = classNames(className, 'text-editor', resizable && 'text-editor-resizable', colorClasses($$props)));

    		if ($$self.$$.dirty[0] & /*value*/ 64) {
    			watchValue(value);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		el,
    		f7TextEditor,
    		classes,
    		$$restProps,
    		className,
    		mode,
    		value,
    		buttons,
    		customButtons,
    		dividers,
    		imageUrlText,
    		linkUrlText,
    		placeholder,
    		clearFormattingOnPaste,
    		resizable,
    		instance,
    		$$scope,
    		slots,
    		div1_binding
    	];
    }

    class Text_editor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance_1$2,
    			create_fragment$k,
    			safe_not_equal,
    			{
    				class: 4,
    				mode: 5,
    				value: 6,
    				buttons: 7,
    				customButtons: 8,
    				dividers: 9,
    				imageUrlText: 10,
    				linkUrlText: 11,
    				placeholder: 12,
    				clearFormattingOnPaste: 13,
    				resizable: 14,
    				instance: 15
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text_editor",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get class() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mode() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mode(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get buttons() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set buttons(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get customButtons() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set customButtons(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dividers() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dividers(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get imageUrlText() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageUrlText(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get linkUrlText() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set linkUrlText(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get clearFormattingOnPaste() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set clearFormattingOnPaste(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resizable() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resizable(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get instance() {
    		return this.$$.ctx[15];
    	}

    	set instance(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // eslint-disable-next-line
    var useSmartSelect = function useSmartSelect(props, setInstance, getEl) {
      var f7SmartSelect;
      onMount(function () {
        f7ready(function () {
          if (props.smartSelect) {
            var ssParams = extend({
              el: getEl()
            }, props.smartSelectParams || {});
            f7SmartSelect = app$1.f7.smartSelect.create(ssParams);
            setInstance(f7SmartSelect);
          }
        });
      });
      onDestroy(function () {
        if (f7SmartSelect && f7SmartSelect.destroy) {
          f7SmartSelect.destroy();
        }

        f7SmartSelect = null;
        setInstance(f7SmartSelect);
      });
    };

    // eslint-disable-next-line
    var getReactiveContext = function getReactiveContext(name, setValue) {
      var ctx = getContext(name);
      if (!ctx) return undefined;
      var value = ctx.value,
          subscribe = ctx.subscribe,
          unsubscribe = ctx.unsubscribe;
      subscribe(setValue);
      onDestroy(function () {
        unsubscribe(setValue);
      });
      return value;
    };

    /* node_modules/framework7-svelte/esm/svelte/link.svelte generated by Svelte v3.44.0 */
    const file$i = "node_modules/framework7-svelte/esm/svelte/link.svelte";

    // (110:2) {#if icon}
    function create_if_block_2$6(ctx) {
    	let useicon;
    	let current;

    	useicon = new Use_icon({
    			props: { icon: /*icon*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(useicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(useicon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const useicon_changes = {};
    			if (dirty[0] & /*icon*/ 256) useicon_changes.icon = /*icon*/ ctx[8];
    			useicon.$set(useicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(useicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(useicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(useicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(110:2) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (114:2) {#if typeof text !== 'undefined' || typeof badge !== 'undefined'}
    function create_if_block$c(ctx) {
    	let span;
    	let t0_value = plainText(/*text*/ ctx[0]) + "";
    	let t0;
    	let t1;
    	let current;
    	let if_block = typeof /*badge*/ ctx[1] !== 'undefined' && create_if_block_1$8(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			toggle_class(span, "tabbar-label", /*isTabbarLabel*/ ctx[6]);
    			add_location(span, file$i, 114, 4, 2938);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			if (if_block) if_block.m(span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*text*/ 1) && t0_value !== (t0_value = plainText(/*text*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

    			if (typeof /*badge*/ ctx[1] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(span, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*isTabbarLabel*/ 64) {
    				toggle_class(span, "tabbar-label", /*isTabbarLabel*/ ctx[6]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(114:2) {#if typeof text !== 'undefined' || typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (117:6) {#if typeof badge !== 'undefined'}
    function create_if_block_1$8(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[2],
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 4) badge_1_changes.color = /*badgeColor*/ ctx[2];

    			if (dirty[0] & /*$$scope, badge*/ 268435458) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(117:6) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (117:40) <Badge color={badgeColor}>
    function create_default_slot$a(ctx) {
    	let t_value = plainText(/*badge*/ ctx[1]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 2 && t_value !== (t_value = plainText(/*badge*/ ctx[1]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(117:40) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let a;
    	let t0;
    	let t1;
    	let useTooltip_action;
    	let useRouteProps_action;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*icon*/ ctx[8] && create_if_block_2$6(ctx);
    	const default_slot_template = /*#slots*/ ctx[26].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);
    	let if_block1 = (typeof /*text*/ ctx[0] !== 'undefined' || typeof /*badge*/ ctx[1] !== 'undefined') && create_if_block$c(ctx);
    	let a_levels = [{ class: /*classes*/ ctx[9] }, /*attrs*/ ctx[10]];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (default_slot) default_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			set_attributes(a, a_data);
    			add_location(a, file$i, 101, 0, 2657);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if (if_block0) if_block0.m(a, null);
    			append_dev(a, t0);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			append_dev(a, t1);
    			if (if_block1) if_block1.m(a, null);
    			/*a_binding*/ ctx[27](a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*onClick*/ ctx[11], false, false, false),
    					action_destroyer(useTooltip_action = useTooltip.call(null, a, {
    						tooltip: /*tooltip*/ ctx[3],
    						tooltipTrigger: /*tooltipTrigger*/ ctx[4]
    					})),
    					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[5]))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[8]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 256) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(a, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[28],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[28])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[28], dirty, null),
    						null
    					);
    				}
    			}

    			if (typeof /*text*/ ctx[0] !== 'undefined' || typeof /*badge*/ ctx[1] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*text, badge*/ 3) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$c(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(a, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty[0] & /*classes*/ 512) && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*attrs*/ 1024 && /*attrs*/ ctx[10]
    			]));

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 24) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[3],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[4]
    			});

    			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 32) useRouteProps_action.update.call(null, /*routeProps*/ ctx[5]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block0) if_block0.d();
    			if (default_slot) default_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			/*a_binding*/ ctx[27](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let isTabbarLabel;
    	let hrefComputed;
    	let attrs;
    	let hasDefaultSlots;
    	let iconOnlyComputed;
    	let classes;
    	let icon;

    	const omit_props_names = [
    		"class","noLinkClass","text","tabLink","tabLinkActive","tabbarLabel","iconOnly","badge","badgeColor","href","target","tooltip","tooltipTrigger","routeProps","smartSelect","smartSelectParams"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Link', slots, ['default']);
    	const $$slots = compute_slots(slots);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { noLinkClass = false } = $$props;
    	let { text = undefined } = $$props;
    	let { tabLink = undefined } = $$props;
    	let { tabLinkActive = false } = $$props;
    	let { tabbarLabel = false } = $$props;
    	let { iconOnly = false } = $$props;
    	let { badge = undefined } = $$props;
    	let { badgeColor = undefined } = $$props;
    	let { href = '#' } = $$props;
    	let { target = undefined } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { tooltipTrigger = undefined } = $$props;
    	let { routeProps = undefined } = $$props;
    	let { smartSelect = false } = $$props;
    	let { smartSelectParams = undefined } = $$props;
    	let el;
    	let f7SmartSelect;

    	let TabbarContext = getReactiveContext('TabbarContext', newValue => {
    		$$invalidate(22, TabbarContext = newValue);
    	}) || {};

    	function onClick() {
    		emit('click');
    	}

    	useSmartSelect(
    		{ smartSelect, smartSelectParams },
    		instance => {
    			f7SmartSelect = instance;
    		},
    		() => el
    	);

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(7, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(31, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(33, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(12, className = $$new_props.class);
    		if ('noLinkClass' in $$new_props) $$invalidate(13, noLinkClass = $$new_props.noLinkClass);
    		if ('text' in $$new_props) $$invalidate(0, text = $$new_props.text);
    		if ('tabLink' in $$new_props) $$invalidate(14, tabLink = $$new_props.tabLink);
    		if ('tabLinkActive' in $$new_props) $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
    		if ('tabbarLabel' in $$new_props) $$invalidate(16, tabbarLabel = $$new_props.tabbarLabel);
    		if ('iconOnly' in $$new_props) $$invalidate(17, iconOnly = $$new_props.iconOnly);
    		if ('badge' in $$new_props) $$invalidate(1, badge = $$new_props.badge);
    		if ('badgeColor' in $$new_props) $$invalidate(2, badgeColor = $$new_props.badgeColor);
    		if ('href' in $$new_props) $$invalidate(18, href = $$new_props.href);
    		if ('target' in $$new_props) $$invalidate(19, target = $$new_props.target);
    		if ('tooltip' in $$new_props) $$invalidate(3, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$new_props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('routeProps' in $$new_props) $$invalidate(5, routeProps = $$new_props.routeProps);
    		if ('smartSelect' in $$new_props) $$invalidate(20, smartSelect = $$new_props.smartSelect);
    		if ('smartSelectParams' in $$new_props) $$invalidate(21, smartSelectParams = $$new_props.smartSelectParams);
    		if ('$$scope' in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		colorClasses,
    		routerAttrs,
    		routerClasses,
    		actionsAttrs,
    		actionsClasses,
    		classNames,
    		extend,
    		isStringProp,
    		plainText,
    		createEmitter,
    		restProps,
    		useTooltip,
    		useSmartSelect,
    		useRouteProps,
    		useIcon,
    		getReactiveContext,
    		UseIcon: Use_icon,
    		Badge,
    		emit,
    		className,
    		noLinkClass,
    		text,
    		tabLink,
    		tabLinkActive,
    		tabbarLabel,
    		iconOnly,
    		badge,
    		badgeColor,
    		href,
    		target,
    		tooltip,
    		tooltipTrigger,
    		routeProps,
    		smartSelect,
    		smartSelectParams,
    		el,
    		f7SmartSelect,
    		TabbarContext,
    		onClick,
    		icon,
    		iconOnlyComputed,
    		isTabbarLabel,
    		classes,
    		hasDefaultSlots,
    		hrefComputed,
    		attrs
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(31, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(12, className = $$new_props.className);
    		if ('noLinkClass' in $$props) $$invalidate(13, noLinkClass = $$new_props.noLinkClass);
    		if ('text' in $$props) $$invalidate(0, text = $$new_props.text);
    		if ('tabLink' in $$props) $$invalidate(14, tabLink = $$new_props.tabLink);
    		if ('tabLinkActive' in $$props) $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
    		if ('tabbarLabel' in $$props) $$invalidate(16, tabbarLabel = $$new_props.tabbarLabel);
    		if ('iconOnly' in $$props) $$invalidate(17, iconOnly = $$new_props.iconOnly);
    		if ('badge' in $$props) $$invalidate(1, badge = $$new_props.badge);
    		if ('badgeColor' in $$props) $$invalidate(2, badgeColor = $$new_props.badgeColor);
    		if ('href' in $$props) $$invalidate(18, href = $$new_props.href);
    		if ('target' in $$props) $$invalidate(19, target = $$new_props.target);
    		if ('tooltip' in $$props) $$invalidate(3, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('routeProps' in $$props) $$invalidate(5, routeProps = $$new_props.routeProps);
    		if ('smartSelect' in $$props) $$invalidate(20, smartSelect = $$new_props.smartSelect);
    		if ('smartSelectParams' in $$props) $$invalidate(21, smartSelectParams = $$new_props.smartSelectParams);
    		if ('el' in $$props) $$invalidate(7, el = $$new_props.el);
    		if ('f7SmartSelect' in $$props) f7SmartSelect = $$new_props.f7SmartSelect;
    		if ('TabbarContext' in $$props) $$invalidate(22, TabbarContext = $$new_props.TabbarContext);
    		if ('icon' in $$props) $$invalidate(8, icon = $$new_props.icon);
    		if ('iconOnlyComputed' in $$props) $$invalidate(23, iconOnlyComputed = $$new_props.iconOnlyComputed);
    		if ('isTabbarLabel' in $$props) $$invalidate(6, isTabbarLabel = $$new_props.isTabbarLabel);
    		if ('classes' in $$props) $$invalidate(9, classes = $$new_props.classes);
    		if ('hasDefaultSlots' in $$props) $$invalidate(24, hasDefaultSlots = $$new_props.hasDefaultSlots);
    		if ('hrefComputed' in $$props) $$invalidate(25, hrefComputed = $$new_props.hrefComputed);
    		if ('attrs' in $$props) $$invalidate(10, attrs = $$new_props.attrs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*tabbarLabel, TabbarContext*/ 4259840) {
    			$$invalidate(6, isTabbarLabel = tabbarLabel || TabbarContext.tabbarHasLabels);
    		}

    		if ($$self.$$.dirty[0] & /*href*/ 262144) {
    			$$invalidate(25, hrefComputed = href === true ? '#' : href || undefined);
    		}

    		$$invalidate(10, attrs = extend(
    			{
    				href: hrefComputed,
    				target,
    				'data-tab': isStringProp(tabLink) && tabLink || undefined,
    				...restProps($$restProps)
    			},
    			routerAttrs($$props),
    			actionsAttrs($$props)
    		));

    		if ($$self.$$.dirty[0] & /*iconOnly, text, hasDefaultSlots*/ 16908289) {
    			$$invalidate(23, iconOnlyComputed = iconOnly || !text && !hasDefaultSlots);
    		}

    		$$invalidate(9, classes = classNames(
    			className,
    			{
    				link: !(noLinkClass || isTabbarLabel),
    				'icon-only': iconOnlyComputed,
    				'tab-link': tabLink || tabLink === '',
    				'tab-link-active': tabLinkActive,
    				'smart-select': smartSelect
    			},
    			colorClasses($$props),
    			routerClasses($$props),
    			actionsClasses($$props)
    		));

    		$$invalidate(8, icon = useIcon($$props));
    	};

    	$$invalidate(24, hasDefaultSlots = $$slots.default);
    	$$props = exclude_internal_props($$props);

    	return [
    		text,
    		badge,
    		badgeColor,
    		tooltip,
    		tooltipTrigger,
    		routeProps,
    		isTabbarLabel,
    		el,
    		icon,
    		classes,
    		attrs,
    		onClick,
    		className,
    		noLinkClass,
    		tabLink,
    		tabLinkActive,
    		tabbarLabel,
    		iconOnly,
    		href,
    		target,
    		smartSelect,
    		smartSelectParams,
    		TabbarContext,
    		iconOnlyComputed,
    		hasDefaultSlots,
    		hrefComputed,
    		slots,
    		a_binding,
    		$$scope
    	];
    }

    class Link extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$h,
    			create_fragment$j,
    			safe_not_equal,
    			{
    				class: 12,
    				noLinkClass: 13,
    				text: 0,
    				tabLink: 14,
    				tabLinkActive: 15,
    				tabbarLabel: 16,
    				iconOnly: 17,
    				badge: 1,
    				badgeColor: 2,
    				href: 18,
    				target: 19,
    				tooltip: 3,
    				tooltipTrigger: 4,
    				routeProps: 5,
    				smartSelect: 20,
    				smartSelectParams: 21
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Link",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get class() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noLinkClass() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noLinkClass(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabLink() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabLink(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabLinkActive() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabLinkActive(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabbarLabel() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabbarLabel(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconOnly() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconOnly(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get badge() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set badge(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get badgeColor() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set badgeColor(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get target() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set target(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipTrigger() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipTrigger(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get routeProps() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routeProps(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smartSelect() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smartSelect(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smartSelectParams() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smartSelectParams(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // eslint-disable-next-line
    var setReactiveContext = function setReactiveContext(name, getValue) {
      var contextCallbacks = [];

      var contextSubscribe = function contextSubscribe(callback) {
        contextCallbacks.push(callback);
      };

      var contextUnsubscribe = function contextUnsubscribe(callback) {
        if (contextCallbacks.indexOf(callback) >= 0) {
          contextCallbacks.splice(contextCallbacks.indexOf, callback);
        }
      };

      var contextRunCallbacks = function contextRunCallbacks() {
        contextCallbacks.forEach(function (callback) {
          callback(getValue());
        });
      };

      setContext(name, {
        value: getValue(),
        subscribe: contextSubscribe,
        unsubscribe: contextUnsubscribe
      });
      beforeUpdate(function () {
        contextRunCallbacks();
      });
    };

    /* node_modules/framework7-svelte/esm/svelte/list-input.svelte generated by Svelte v3.44.0 */
    const file$h = "node_modules/framework7-svelte/esm/svelte/list-input.svelte";
    const get_content_end_slot_changes_1$1 = dirty => ({});
    const get_content_end_slot_context_1$1 = ctx => ({});
    const get_content_slot_changes_1$1 = dirty => ({});
    const get_content_slot_context_1$1 = ctx => ({});
    const get_inner_end_slot_changes_1$1 = dirty => ({});
    const get_inner_end_slot_context_1$1 = ctx => ({});
    const get_inner_slot_changes_1$1 = dirty => ({});
    const get_inner_slot_context_1$1 = ctx => ({});
    const get_info_slot_changes_1 = dirty => ({});
    const get_info_slot_context_1 = ctx => ({});
    const get_error_message_slot_changes_1 = dirty => ({});
    const get_error_message_slot_context_1 = ctx => ({});
    const get_input_slot_changes_1 = dirty => ({});
    const get_input_slot_context_1 = ctx => ({});
    const get_label_slot_changes_1 = dirty => ({});
    const get_label_slot_context_1 = ctx => ({});
    const get_inner_start_slot_changes_1$1 = dirty => ({});
    const get_inner_start_slot_context_1$1 = ctx => ({});
    const get_media_slot_changes_1$1 = dirty => ({});
    const get_media_slot_context_1$1 = ctx => ({});
    const get_content_start_slot_changes_1$1 = dirty => ({});
    const get_content_start_slot_context_1$1 = ctx => ({});
    const get_root_end_slot_changes$1 = dirty => ({});
    const get_root_end_slot_context$1 = ctx => ({});
    const get_root_slot_changes$1 = dirty => ({});
    const get_root_slot_context$1 = ctx => ({});
    const get_content_end_slot_changes$1 = dirty => ({});
    const get_content_end_slot_context$1 = ctx => ({});
    const get_content_slot_changes$1 = dirty => ({});
    const get_content_slot_context$1 = ctx => ({});
    const get_inner_end_slot_changes$1 = dirty => ({});
    const get_inner_end_slot_context$1 = ctx => ({});
    const get_inner_slot_changes$1 = dirty => ({});
    const get_inner_slot_context$1 = ctx => ({});
    const get_info_slot_changes = dirty => ({});
    const get_info_slot_context = ctx => ({});
    const get_error_message_slot_changes = dirty => ({});
    const get_error_message_slot_context = ctx => ({});
    const get_input_slot_changes = dirty => ({});
    const get_input_slot_context = ctx => ({});
    const get_label_slot_changes = dirty => ({});
    const get_label_slot_context = ctx => ({});
    const get_inner_start_slot_changes$1 = dirty => ({});
    const get_inner_start_slot_context$1 = ctx => ({});
    const get_media_slot_changes$1 = dirty => ({});
    const get_media_slot_context$1 = ctx => ({});
    const get_content_start_slot_changes$1 = dirty => ({});
    const get_content_start_slot_context$1 = ctx => ({});
    const get_root_start_slot_changes$1 = dirty => ({});
    const get_root_start_slot_context$1 = ctx => ({});

    // (577:0) {:else}
    function create_else_block_1$2(ctx) {
    	let div2;
    	let t0;
    	let t1;
    	let t2;
    	let div1;
    	let t3;
    	let t4;
    	let div0;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let t10;
    	let t11;
    	let t12;
    	let current;
    	const content_start_slot_template = /*#slots*/ ctx[77]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[76], get_content_start_slot_context_1$1);
    	let if_block0 = /*isSortable*/ ctx[51] && /*isSortableOpposite*/ ctx[50] && create_if_block_23$1(ctx);
    	let if_block1 = (/*media*/ ctx[1] || /*hasMediaSlots*/ ctx[48]) && create_if_block_21$1(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[77]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[76], get_inner_start_slot_context_1$1);
    	let if_block2 = (typeof /*label*/ ctx[36] !== 'undefined' || /*hasLabelSlots*/ ctx[47]) && create_if_block_20$1(ctx);
    	let if_block3 = /*input*/ ctx[3] && create_if_block_16$1(ctx);
    	const input_slot_template = /*#slots*/ ctx[77].input;
    	const input_slot = create_slot(input_slot_template, ctx, /*$$scope*/ ctx[76], get_input_slot_context_1);
    	let if_block4 = /*hasErrorMessage*/ ctx[38] && /*errorMessageForce*/ ctx[34] && create_if_block_15$1(ctx);
    	let if_block5 = /*clearButton*/ ctx[32] && create_if_block_14$1(ctx);
    	let if_block6 = (typeof /*info*/ ctx[35] !== 'undefined' || /*hasInfoSlots*/ ctx[39]) && create_if_block_13$1(ctx);
    	const inner_slot_template = /*#slots*/ ctx[77].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[76], get_inner_slot_context_1$1);
    	const inner_end_slot_template = /*#slots*/ ctx[77]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[76], get_inner_end_slot_context_1$1);
    	const content_slot_template = /*#slots*/ ctx[77].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[76], get_content_slot_context_1$1);
    	const content_end_slot_template = /*#slots*/ ctx[77]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[76], get_content_end_slot_context_1$1);
    	let div2_levels = [{ class: /*itemContentClasses*/ ctx[45] }, restProps(/*$$restProps*/ ctx[56])];
    	let div2_data = {};

    	for (let i = 0; i < div2_levels.length; i += 1) {
    		div2_data = assign(div2_data, div2_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			if (content_start_slot) content_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div1 = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			div0 = element("div");
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (input_slot) input_slot.c();
    			t6 = space();
    			if (if_block4) if_block4.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			t9 = space();
    			if (inner_slot) inner_slot.c();
    			t10 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t11 = space();
    			if (content_slot) content_slot.c();
    			t12 = space();
    			if (content_end_slot) content_end_slot.c();
    			attr_dev(div0, "class", /*inputWrapClasses*/ ctx[43]);
    			add_location(div0, file$h, 597, 6, 17800);
    			attr_dev(div1, "class", "item-inner");
    			add_location(div1, file$h, 589, 4, 17554);
    			set_attributes(div2, div2_data);
    			add_location(div2, file$h, 577, 2, 17178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);

    			if (content_start_slot) {
    				content_start_slot.m(div2, null);
    			}

    			append_dev(div2, t0);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t1);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);

    			if (inner_start_slot) {
    				inner_start_slot.m(div1, null);
    			}

    			append_dev(div1, t3);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div1, t4);
    			append_dev(div1, div0);
    			if (if_block3) if_block3.m(div0, null);
    			append_dev(div0, t5);

    			if (input_slot) {
    				input_slot.m(div0, null);
    			}

    			append_dev(div0, t6);
    			if (if_block4) if_block4.m(div0, null);
    			append_dev(div0, t7);
    			if (if_block5) if_block5.m(div0, null);
    			append_dev(div0, t8);
    			if (if_block6) if_block6.m(div0, null);
    			append_dev(div1, t9);

    			if (inner_slot) {
    				inner_slot.m(div1, null);
    			}

    			append_dev(div1, t10);

    			if (inner_end_slot) {
    				inner_end_slot.m(div1, null);
    			}

    			append_dev(div2, t11);

    			if (content_slot) {
    				content_slot.m(div2, null);
    			}

    			append_dev(div2, t12);

    			if (content_end_slot) {
    				content_end_slot.m(div2, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[76], dirty, get_content_start_slot_changes_1$1),
    						get_content_start_slot_context_1$1
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[51] && /*isSortableOpposite*/ ctx[50]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_23$1(ctx);
    					if_block0.c();
    					if_block0.m(div2, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*media*/ ctx[1] || /*hasMediaSlots*/ ctx[48]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*media*/ 2 | dirty[1] & /*hasMediaSlots*/ 131072) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_21$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div2, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[76], dirty, get_inner_start_slot_changes_1$1),
    						get_inner_start_slot_context_1$1
    					);
    				}
    			}

    			if (typeof /*label*/ ctx[36] !== 'undefined' || /*hasLabelSlots*/ ctx[47]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*label, hasLabelSlots*/ 65568) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_20$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div1, t4);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*input*/ ctx[3]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*input*/ 8) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_16$1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div0, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (input_slot) {
    				if (input_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						input_slot,
    						input_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(input_slot_template, /*$$scope*/ ctx[76], dirty, get_input_slot_changes_1),
    						get_input_slot_context_1
    					);
    				}
    			}

    			if (/*hasErrorMessage*/ ctx[38] && /*errorMessageForce*/ ctx[34]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasErrorMessage, errorMessageForce*/ 136) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_15$1(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div0, t7);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*clearButton*/ ctx[32]) {
    				if (if_block5) ; else {
    					if_block5 = create_if_block_14$1(ctx);
    					if_block5.c();
    					if_block5.m(div0, t8);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (typeof /*info*/ ctx[35] !== 'undefined' || /*hasInfoSlots*/ ctx[39]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*info, hasInfoSlots*/ 272) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_13$1(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(div0, null);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[1] & /*inputWrapClasses*/ 4096) {
    				attr_dev(div0, "class", /*inputWrapClasses*/ ctx[43]);
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[76], dirty, get_inner_slot_changes_1$1),
    						get_inner_slot_context_1$1
    					);
    				}
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[76], dirty, get_inner_end_slot_changes_1$1),
    						get_inner_end_slot_context_1$1
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[76], dirty, get_content_slot_changes_1$1),
    						get_content_slot_context_1$1
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[76], dirty, get_content_end_slot_changes_1$1),
    						get_content_end_slot_context_1$1
    					);
    				}
    			}

    			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
    				(!current || dirty[1] & /*itemContentClasses*/ 16384) && { class: /*itemContentClasses*/ ctx[45] },
    				dirty[1] & /*$$restProps*/ 33554432 && restProps(/*$$restProps*/ ctx[56])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(input_slot, local);
    			transition_in(if_block4);
    			transition_in(if_block6);
    			transition_in(inner_slot, local);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(input_slot, local);
    			transition_out(if_block4);
    			transition_out(if_block6);
    			transition_out(inner_slot, local);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (input_slot) input_slot.d(detaching);
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (inner_slot) inner_slot.d(detaching);
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(577:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (373:0) {#if wrap}
    function create_if_block$b(ctx) {
    	let li;
    	let t0;
    	let div2;
    	let t1;
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let t5;
    	let div0;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let t10;
    	let t11;
    	let t12;
    	let t13;
    	let t14;
    	let t15;
    	let t16;
    	let current;
    	const root_start_slot_template = /*#slots*/ ctx[77]["root-start"];
    	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[76], get_root_start_slot_context$1);
    	const content_start_slot_template = /*#slots*/ ctx[77]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[76], get_content_start_slot_context$1);
    	let if_block0 = /*isSortable*/ ctx[51] && /*isSortableOpposite*/ ctx[50] && create_if_block_12$1(ctx);
    	let if_block1 = (/*media*/ ctx[1] || /*hasMediaSlots*/ ctx[48]) && create_if_block_10$1(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[77]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[76], get_inner_start_slot_context$1);
    	let if_block2 = (typeof /*label*/ ctx[36] !== 'undefined' || /*hasLabelSlots*/ ctx[47]) && create_if_block_9$1(ctx);
    	let if_block3 = /*input*/ ctx[3] && create_if_block_5$1(ctx);
    	const input_slot_template = /*#slots*/ ctx[77].input;
    	const input_slot = create_slot(input_slot_template, ctx, /*$$scope*/ ctx[76], get_input_slot_context);
    	let if_block4 = /*hasErrorMessage*/ ctx[38] && /*errorMessageForce*/ ctx[34] && create_if_block_4$1(ctx);
    	let if_block5 = /*clearButton*/ ctx[32] && create_if_block_3$3(ctx);
    	let if_block6 = (typeof /*info*/ ctx[35] !== 'undefined' || /*hasInfoSlots*/ ctx[39]) && create_if_block_2$5(ctx);
    	const inner_slot_template = /*#slots*/ ctx[77].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[76], get_inner_slot_context$1);
    	const inner_end_slot_template = /*#slots*/ ctx[77]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[76], get_inner_end_slot_context$1);
    	const content_slot_template = /*#slots*/ ctx[77].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[76], get_content_slot_context$1);
    	const content_end_slot_template = /*#slots*/ ctx[77]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[76], get_content_end_slot_context$1);
    	let if_block7 = /*isSortable*/ ctx[51] && !/*isSortableOpposite*/ ctx[50] && create_if_block_1$7(ctx);
    	const root_slot_template = /*#slots*/ ctx[77].root;
    	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[76], get_root_slot_context$1);
    	const root_end_slot_template = /*#slots*/ ctx[77]["root-end"];
    	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[76], get_root_end_slot_context$1);
    	let li_levels = [{ class: /*classes*/ ctx[42] }, restProps(/*$$restProps*/ ctx[56])];
    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (root_start_slot) root_start_slot.c();
    			t0 = space();
    			div2 = element("div");
    			if (content_start_slot) content_start_slot.c();
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			div1 = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			t5 = space();
    			div0 = element("div");
    			if (if_block3) if_block3.c();
    			t6 = space();
    			if (input_slot) input_slot.c();
    			t7 = space();
    			if (if_block4) if_block4.c();
    			t8 = space();
    			if (if_block5) if_block5.c();
    			t9 = space();
    			if (if_block6) if_block6.c();
    			t10 = space();
    			if (inner_slot) inner_slot.c();
    			t11 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t12 = space();
    			if (content_slot) content_slot.c();
    			t13 = space();
    			if (content_end_slot) content_end_slot.c();
    			t14 = space();
    			if (if_block7) if_block7.c();
    			t15 = space();
    			if (root_slot) root_slot.c();
    			t16 = space();
    			if (root_end_slot) root_end_slot.c();
    			attr_dev(div0, "class", /*inputWrapClasses*/ ctx[43]);
    			add_location(div0, file$h, 395, 8, 11064);
    			attr_dev(div1, "class", "item-inner");
    			add_location(div1, file$h, 387, 6, 10802);
    			attr_dev(div2, "class", /*itemContentClasses*/ ctx[45]);
    			add_location(div2, file$h, 375, 4, 10432);
    			set_attributes(li, li_data);
    			add_location(li, file$h, 373, 2, 10348);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (root_start_slot) {
    				root_start_slot.m(li, null);
    			}

    			append_dev(li, t0);
    			append_dev(li, div2);

    			if (content_start_slot) {
    				content_start_slot.m(div2, null);
    			}

    			append_dev(div2, t1);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t2);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			if (inner_start_slot) {
    				inner_start_slot.m(div1, null);
    			}

    			append_dev(div1, t4);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div1, t5);
    			append_dev(div1, div0);
    			if (if_block3) if_block3.m(div0, null);
    			append_dev(div0, t6);

    			if (input_slot) {
    				input_slot.m(div0, null);
    			}

    			append_dev(div0, t7);
    			if (if_block4) if_block4.m(div0, null);
    			append_dev(div0, t8);
    			if (if_block5) if_block5.m(div0, null);
    			append_dev(div0, t9);
    			if (if_block6) if_block6.m(div0, null);
    			append_dev(div1, t10);

    			if (inner_slot) {
    				inner_slot.m(div1, null);
    			}

    			append_dev(div1, t11);

    			if (inner_end_slot) {
    				inner_end_slot.m(div1, null);
    			}

    			append_dev(div2, t12);

    			if (content_slot) {
    				content_slot.m(div2, null);
    			}

    			append_dev(div2, t13);

    			if (content_end_slot) {
    				content_end_slot.m(div2, null);
    			}

    			append_dev(li, t14);
    			if (if_block7) if_block7.m(li, null);
    			append_dev(li, t15);

    			if (root_slot) {
    				root_slot.m(li, null);
    			}

    			append_dev(li, t16);

    			if (root_end_slot) {
    				root_end_slot.m(li, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (root_start_slot) {
    				if (root_start_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						root_start_slot,
    						root_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(root_start_slot_template, /*$$scope*/ ctx[76], dirty, get_root_start_slot_changes$1),
    						get_root_start_slot_context$1
    					);
    				}
    			}

    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[76], dirty, get_content_start_slot_changes$1),
    						get_content_start_slot_context$1
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[51] && /*isSortableOpposite*/ ctx[50]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_12$1(ctx);
    					if_block0.c();
    					if_block0.m(div2, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*media*/ ctx[1] || /*hasMediaSlots*/ ctx[48]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*media*/ 2 | dirty[1] & /*hasMediaSlots*/ 131072) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_10$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div2, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[76], dirty, get_inner_start_slot_changes$1),
    						get_inner_start_slot_context$1
    					);
    				}
    			}

    			if (typeof /*label*/ ctx[36] !== 'undefined' || /*hasLabelSlots*/ ctx[47]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*label, hasLabelSlots*/ 65568) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_9$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div1, t5);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*input*/ ctx[3]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*input*/ 8) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_5$1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div0, t6);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (input_slot) {
    				if (input_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						input_slot,
    						input_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(input_slot_template, /*$$scope*/ ctx[76], dirty, get_input_slot_changes),
    						get_input_slot_context
    					);
    				}
    			}

    			if (/*hasErrorMessage*/ ctx[38] && /*errorMessageForce*/ ctx[34]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasErrorMessage, errorMessageForce*/ 136) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_4$1(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div0, t8);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*clearButton*/ ctx[32]) {
    				if (if_block5) ; else {
    					if_block5 = create_if_block_3$3(ctx);
    					if_block5.c();
    					if_block5.m(div0, t9);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (typeof /*info*/ ctx[35] !== 'undefined' || /*hasInfoSlots*/ ctx[39]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*info, hasInfoSlots*/ 272) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_2$5(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(div0, null);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[1] & /*inputWrapClasses*/ 4096) {
    				attr_dev(div0, "class", /*inputWrapClasses*/ ctx[43]);
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[76], dirty, get_inner_slot_changes$1),
    						get_inner_slot_context$1
    					);
    				}
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[76], dirty, get_inner_end_slot_changes$1),
    						get_inner_end_slot_context$1
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[76], dirty, get_content_slot_changes$1),
    						get_content_slot_context$1
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[76], dirty, get_content_end_slot_changes$1),
    						get_content_end_slot_context$1
    					);
    				}
    			}

    			if (!current || dirty[1] & /*itemContentClasses*/ 16384) {
    				attr_dev(div2, "class", /*itemContentClasses*/ ctx[45]);
    			}

    			if (/*isSortable*/ ctx[51] && !/*isSortableOpposite*/ ctx[50]) {
    				if (if_block7) ; else {
    					if_block7 = create_if_block_1$7(ctx);
    					if_block7.c();
    					if_block7.m(li, t15);
    				}
    			} else if (if_block7) {
    				if_block7.d(1);
    				if_block7 = null;
    			}

    			if (root_slot) {
    				if (root_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						root_slot,
    						root_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(root_slot_template, /*$$scope*/ ctx[76], dirty, get_root_slot_changes$1),
    						get_root_slot_context$1
    					);
    				}
    			}

    			if (root_end_slot) {
    				if (root_end_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						root_end_slot,
    						root_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(root_end_slot_template, /*$$scope*/ ctx[76], dirty, get_root_end_slot_changes$1),
    						get_root_end_slot_context$1
    					);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				(!current || dirty[1] & /*classes*/ 2048) && { class: /*classes*/ ctx[42] },
    				dirty[1] & /*$$restProps*/ 33554432 && restProps(/*$$restProps*/ ctx[56])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(root_start_slot, local);
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(input_slot, local);
    			transition_in(if_block4);
    			transition_in(if_block6);
    			transition_in(inner_slot, local);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			transition_in(root_slot, local);
    			transition_in(root_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(root_start_slot, local);
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(input_slot, local);
    			transition_out(if_block4);
    			transition_out(if_block6);
    			transition_out(inner_slot, local);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			transition_out(root_slot, local);
    			transition_out(root_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (root_start_slot) root_start_slot.d(detaching);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (input_slot) input_slot.d(detaching);
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (inner_slot) inner_slot.d(detaching);
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    			if (if_block7) if_block7.d();
    			if (root_slot) root_slot.d(detaching);
    			if (root_end_slot) root_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(373:0) {#if wrap}",
    		ctx
    	});

    	return block;
    }

    // (580:4) {#if isSortable && isSortableOpposite}
    function create_if_block_23$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$h, 580, 6, 17322);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_23$1.name,
    		type: "if",
    		source: "(580:4) {#if isSortable && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (584:4) {#if media || hasMediaSlots}
    function create_if_block_21$1(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[1] !== 'undefined' && create_if_block_22$1(ctx);
    	const media_slot_template = /*#slots*/ ctx[77].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[76], get_media_slot_context_1$1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$h, 584, 6, 17405);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[1] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_22$1(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[76], dirty, get_media_slot_changes_1$1),
    						get_media_slot_context_1$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_21$1.name,
    		type: "if",
    		source: "(584:4) {#if media || hasMediaSlots}",
    		ctx
    	});

    	return block;
    }

    // (586:8) {#if typeof media !== 'undefined'}
    function create_if_block_22$1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[1])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$h, 585, 42, 17472);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 2 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[1])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_22$1.name,
    		type: "if",
    		source: "(586:8) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (592:6) {#if typeof label !== 'undefined' || hasLabelSlots}
    function create_if_block_20$1(ctx) {
    	let div;
    	let t0_value = plainText(/*label*/ ctx[36]) + "";
    	let t0;
    	let t1;
    	let current;
    	const label_slot_template = /*#slots*/ ctx[77].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[76], get_label_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (label_slot) label_slot.c();
    			attr_dev(div, "class", /*labelClasses*/ ctx[44]);
    			add_location(div, file$h, 592, 8, 17679);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (label_slot) {
    				label_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[1] & /*label*/ 32) && t0_value !== (t0_value = plainText(/*label*/ ctx[36]) + "")) set_data_dev(t0, t0_value);

    			if (label_slot) {
    				if (label_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[76], dirty, get_label_slot_changes_1),
    						get_label_slot_context_1
    					);
    				}
    			}

    			if (!current || dirty[1] & /*labelClasses*/ 8192) {
    				attr_dev(div, "class", /*labelClasses*/ ctx[44]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (label_slot) label_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_20$1.name,
    		type: "if",
    		source: "(592:6) {#if typeof label !== 'undefined' || hasLabelSlots}",
    		ctx
    	});

    	return block;
    }

    // (599:8) {#if input}
    function create_if_block_16$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	const if_block_creators = [
    		create_if_block_17$1,
    		create_if_block_18$1,
    		create_if_block_19$1,
    		create_else_block_2$2
    	];

    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*type*/ ctx[4] === 'select') return 0;
    		if (/*type*/ ctx[4] === 'textarea') return 1;
    		if (/*type*/ ctx[4] === 'texteditor') return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16$1.name,
    		type: "if",
    		source: "(599:8) {#if input}",
    		ctx
    	});

    	return block;
    }

    // (702:10) {:else}
    function create_else_block_2$2(ctx) {
    	let input_1;
    	let input_1_validate_value;
    	let input_1_data_validate_value;
    	let input_1_data_validate_on_blur_value;
    	let input_1_data_error_message_value;
    	let input_1_value_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
    			attr_dev(input_1, "name", /*name*/ ctx[5]);
    			attr_dev(input_1, "type", /*inputType*/ ctx[40]);
    			attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
    			attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
    			attr_dev(input_1, "id", /*inputId*/ ctx[11]);
    			attr_dev(input_1, "size", /*size*/ ctx[12]);
    			attr_dev(input_1, "accept", /*accept*/ ctx[13]);
    			attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
    			attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
    			attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
    			input_1.autofocus = /*autofocus*/ ctx[18];
    			attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
    			input_1.disabled = /*disabled*/ ctx[9];
    			attr_dev(input_1, "max", /*max*/ ctx[20]);
    			attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
    			attr_dev(input_1, "min", /*min*/ ctx[21]);
    			attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
    			attr_dev(input_1, "step", /*step*/ ctx[22]);
    			input_1.multiple = /*multiple*/ ctx[25];
    			input_1.readOnly = /*readonly*/ ctx[7];
    			input_1.required = /*required*/ ctx[8];
    			attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);

    			attr_dev(input_1, "validate", input_1_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined);

    			attr_dev(input_1, "data-validate", input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);

    			attr_dev(input_1, "data-error-message", input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33]);

    			attr_dev(input_1, "class", /*inputClasses*/ ctx[46]);

    			input_1.value = input_1_value_value = /*type*/ ctx[4] === 'datepicker' || /*type*/ ctx[4] === 'colorpicker' || /*type*/ ctx[4] === 'file'
    			? ''
    			: /*inputValue*/ ctx[49];

    			add_location(input_1, file$h, 702, 12, 21184);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    			/*input_1_binding_1*/ ctx[83](input_1);
    			if (/*autofocus*/ ctx[18]) input_1.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(input_1, "focus", /*onFocus*/ ctx[53], false, false, false),
    					listen_dev(input_1, "blur", /*onBlur*/ ctx[54], false, false, false),
    					listen_dev(input_1, "input", /*onInput*/ ctx[52], false, false, false),
    					listen_dev(input_1, "change", /*onChange*/ ctx[55], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*inputStyle*/ 67108864) {
    				attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
    			}

    			if (dirty[0] & /*name*/ 32) {
    				attr_dev(input_1, "name", /*name*/ ctx[5]);
    			}

    			if (dirty[1] & /*inputType*/ 512) {
    				attr_dev(input_1, "type", /*inputType*/ ctx[40]);
    			}

    			if (dirty[0] & /*inputmode*/ 64) {
    				attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
    			}

    			if (dirty[0] & /*placeholder*/ 1024) {
    				attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
    			}

    			if (dirty[0] & /*inputId*/ 2048) {
    				attr_dev(input_1, "id", /*inputId*/ ctx[11]);
    			}

    			if (dirty[0] & /*size*/ 4096) {
    				attr_dev(input_1, "size", /*size*/ ctx[12]);
    			}

    			if (dirty[0] & /*accept*/ 8192) {
    				attr_dev(input_1, "accept", /*accept*/ ctx[13]);
    			}

    			if (dirty[0] & /*autocomplete*/ 16384) {
    				attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
    			}

    			if (dirty[0] & /*autocorrect*/ 32768) {
    				attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
    			}

    			if (dirty[0] & /*autocapitalize*/ 65536) {
    				attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			}

    			if (dirty[0] & /*spellcheck*/ 131072) {
    				attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
    			}

    			if (dirty[0] & /*autofocus*/ 262144) {
    				prop_dev(input_1, "autofocus", /*autofocus*/ ctx[18]);
    			}

    			if (dirty[0] & /*autosave*/ 524288) {
    				attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
    			}

    			if (dirty[0] & /*disabled*/ 512) {
    				prop_dev(input_1, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*max*/ 1048576) {
    				attr_dev(input_1, "max", /*max*/ ctx[20]);
    			}

    			if (dirty[0] & /*maxlength*/ 8388608) {
    				attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
    			}

    			if (dirty[0] & /*min*/ 2097152) {
    				attr_dev(input_1, "min", /*min*/ ctx[21]);
    			}

    			if (dirty[0] & /*minlength*/ 16777216) {
    				attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
    			}

    			if (dirty[0] & /*step*/ 4194304) {
    				attr_dev(input_1, "step", /*step*/ ctx[22]);
    			}

    			if (dirty[0] & /*multiple*/ 33554432) {
    				prop_dev(input_1, "multiple", /*multiple*/ ctx[25]);
    			}

    			if (dirty[0] & /*readonly*/ 128) {
    				prop_dev(input_1, "readOnly", /*readonly*/ ctx[7]);
    			}

    			if (dirty[0] & /*required*/ 256) {
    				prop_dev(input_1, "required", /*required*/ ctx[8]);
    			}

    			if (dirty[0] & /*pattern*/ 134217728) {
    				attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);
    			}

    			if (dirty[0] & /*validate*/ 268435456 && input_1_validate_value !== (input_1_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined)) {
    				attr_dev(input_1, "validate", input_1_validate_value);
    			}

    			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && input_1_data_validate_value !== (input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(input_1, "data-validate", input_1_data_validate_value);
    			}

    			if (dirty[0] & /*validateOnBlur*/ 536870912 && input_1_data_validate_on_blur_value !== (input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value);
    			}

    			if (dirty[0] & /*tabindex*/ 1073741824) {
    				attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);
    			}

    			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && input_1_data_error_message_value !== (input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33])) {
    				attr_dev(input_1, "data-error-message", input_1_data_error_message_value);
    			}

    			if (dirty[1] & /*inputClasses*/ 32768) {
    				attr_dev(input_1, "class", /*inputClasses*/ ctx[46]);
    			}

    			if (dirty[0] & /*type*/ 16 | dirty[1] & /*inputValue*/ 262144 && input_1_value_value !== (input_1_value_value = /*type*/ ctx[4] === 'datepicker' || /*type*/ ctx[4] === 'colorpicker' || /*type*/ ctx[4] === 'file'
    			? ''
    			: /*inputValue*/ ctx[49]) && input_1.value !== input_1_value_value) {
    				prop_dev(input_1, "value", input_1_value_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    			/*input_1_binding_1*/ ctx[83](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$2.name,
    		type: "else",
    		source: "(702:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (691:42) 
    function create_if_block_19$1(ctx) {
    	let texteditor;
    	let current;

    	const texteditor_spread_levels = [
    		{
    			value: typeof /*value*/ ctx[0] === 'undefined'
    			? ''
    			: /*value*/ ctx[0]
    		},
    		{ resizable: /*resizable*/ ctx[31] },
    		{ placeholder: /*placeholder*/ ctx[10] },
    		{ onTextEditorFocus: /*onFocus*/ ctx[53] },
    		{ onTextEditorBlur: /*onBlur*/ ctx[54] },
    		{ onTextEditorInput: /*onInput*/ ctx[52] },
    		{ onTextEditorChange: /*onChange*/ ctx[55] },
    		/*textEditorParams*/ ctx[37]
    	];

    	let texteditor_props = {};

    	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
    		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
    	}

    	texteditor = new Text_editor({ props: texteditor_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(texteditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(texteditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const texteditor_changes = (dirty[0] & /*value, placeholder*/ 1025 | dirty[1] & /*resizable, onFocus, onBlur, onInput, onChange, textEditorParams*/ 31457345)
    			? get_spread_update(texteditor_spread_levels, [
    					dirty[0] & /*value*/ 1 && {
    						value: typeof /*value*/ ctx[0] === 'undefined'
    						? ''
    						: /*value*/ ctx[0]
    					},
    					dirty[1] & /*resizable*/ 1 && { resizable: /*resizable*/ ctx[31] },
    					dirty[0] & /*placeholder*/ 1024 && { placeholder: /*placeholder*/ ctx[10] },
    					dirty[1] & /*onFocus*/ 4194304 && { onTextEditorFocus: /*onFocus*/ ctx[53] },
    					dirty[1] & /*onBlur*/ 8388608 && { onTextEditorBlur: /*onBlur*/ ctx[54] },
    					dirty[1] & /*onInput*/ 2097152 && { onTextEditorInput: /*onInput*/ ctx[52] },
    					dirty[1] & /*onChange*/ 16777216 && { onTextEditorChange: /*onChange*/ ctx[55] },
    					dirty[1] & /*textEditorParams*/ 64 && get_spread_object(/*textEditorParams*/ ctx[37])
    				])
    			: {};

    			texteditor.$set(texteditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(texteditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(texteditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(texteditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19$1.name,
    		type: "if",
    		source: "(691:42) ",
    		ctx
    	});

    	return block;
    }

    // (646:40) 
    function create_if_block_18$1(ctx) {
    	let textarea;
    	let textarea_validate_value;
    	let textarea_data_validate_value;
    	let textarea_data_validate_on_blur_value;
    	let textarea_data_error_message_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			textarea = element("textarea");
    			attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
    			attr_dev(textarea, "name", /*name*/ ctx[5]);
    			attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
    			attr_dev(textarea, "id", /*inputId*/ ctx[11]);
    			attr_dev(textarea, "size", /*size*/ ctx[12]);
    			attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
    			attr_dev(textarea, "accept", /*accept*/ ctx[13]);
    			attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
    			attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
    			attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
    			textarea.autofocus = /*autofocus*/ ctx[18];
    			attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
    			textarea.disabled = /*disabled*/ ctx[9];
    			attr_dev(textarea, "max", /*max*/ ctx[20]);
    			attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
    			attr_dev(textarea, "min", /*min*/ ctx[21]);
    			attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
    			attr_dev(textarea, "step", /*step*/ ctx[22]);
    			attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
    			textarea.readOnly = /*readonly*/ ctx[7];
    			textarea.required = /*required*/ ctx[8];
    			attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);

    			attr_dev(textarea, "validate", textarea_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined);

    			attr_dev(textarea, "data-validate", textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);

    			attr_dev(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33]);

    			attr_dev(textarea, "class", /*inputClasses*/ ctx[46]);
    			textarea.value = /*inputValue*/ ctx[49];
    			add_location(textarea, file$h, 646, 12, 19358);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, textarea, anchor);
    			/*textarea_binding_1*/ ctx[82](textarea);
    			if (/*autofocus*/ ctx[18]) textarea.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "focus", /*onFocus*/ ctx[53], false, false, false),
    					listen_dev(textarea, "blur", /*onBlur*/ ctx[54], false, false, false),
    					listen_dev(textarea, "input", /*onInput*/ ctx[52], false, false, false),
    					listen_dev(textarea, "change", /*onChange*/ ctx[55], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*inputStyle*/ 67108864) {
    				attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
    			}

    			if (dirty[0] & /*name*/ 32) {
    				attr_dev(textarea, "name", /*name*/ ctx[5]);
    			}

    			if (dirty[0] & /*placeholder*/ 1024) {
    				attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
    			}

    			if (dirty[0] & /*inputId*/ 2048) {
    				attr_dev(textarea, "id", /*inputId*/ ctx[11]);
    			}

    			if (dirty[0] & /*size*/ 4096) {
    				attr_dev(textarea, "size", /*size*/ ctx[12]);
    			}

    			if (dirty[0] & /*inputmode*/ 64) {
    				attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
    			}

    			if (dirty[0] & /*accept*/ 8192) {
    				attr_dev(textarea, "accept", /*accept*/ ctx[13]);
    			}

    			if (dirty[0] & /*autocomplete*/ 16384) {
    				attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
    			}

    			if (dirty[0] & /*autocorrect*/ 32768) {
    				attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
    			}

    			if (dirty[0] & /*autocapitalize*/ 65536) {
    				attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			}

    			if (dirty[0] & /*spellcheck*/ 131072) {
    				attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
    			}

    			if (dirty[0] & /*autofocus*/ 262144) {
    				prop_dev(textarea, "autofocus", /*autofocus*/ ctx[18]);
    			}

    			if (dirty[0] & /*autosave*/ 524288) {
    				attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
    			}

    			if (dirty[0] & /*disabled*/ 512) {
    				prop_dev(textarea, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*max*/ 1048576) {
    				attr_dev(textarea, "max", /*max*/ ctx[20]);
    			}

    			if (dirty[0] & /*maxlength*/ 8388608) {
    				attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
    			}

    			if (dirty[0] & /*min*/ 2097152) {
    				attr_dev(textarea, "min", /*min*/ ctx[21]);
    			}

    			if (dirty[0] & /*minlength*/ 16777216) {
    				attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
    			}

    			if (dirty[0] & /*step*/ 4194304) {
    				attr_dev(textarea, "step", /*step*/ ctx[22]);
    			}

    			if (dirty[0] & /*multiple*/ 33554432) {
    				attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
    			}

    			if (dirty[0] & /*readonly*/ 128) {
    				prop_dev(textarea, "readOnly", /*readonly*/ ctx[7]);
    			}

    			if (dirty[0] & /*required*/ 256) {
    				prop_dev(textarea, "required", /*required*/ ctx[8]);
    			}

    			if (dirty[0] & /*pattern*/ 134217728) {
    				attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);
    			}

    			if (dirty[0] & /*validate*/ 268435456 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined)) {
    				attr_dev(textarea, "validate", textarea_validate_value);
    			}

    			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(textarea, "data-validate", textarea_data_validate_value);
    			}

    			if (dirty[0] & /*validateOnBlur*/ 536870912 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
    			}

    			if (dirty[0] & /*tabindex*/ 1073741824) {
    				attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);
    			}

    			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33])) {
    				attr_dev(textarea, "data-error-message", textarea_data_error_message_value);
    			}

    			if (dirty[1] & /*inputClasses*/ 32768) {
    				attr_dev(textarea, "class", /*inputClasses*/ ctx[46]);
    			}

    			if (dirty[1] & /*inputValue*/ 262144) {
    				prop_dev(textarea, "value", /*inputValue*/ ctx[49]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea);
    			/*textarea_binding_1*/ ctx[82](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18$1.name,
    		type: "if",
    		source: "(646:40) ",
    		ctx
    	});

    	return block;
    }

    // (600:10) {#if type === 'select'}
    function create_if_block_17$1(ctx) {
    	let select;
    	let select_validate_value;
    	let select_data_validate_value;
    	let select_data_validate_on_blur_value;
    	let select_data_error_message_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[77].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[76], null);

    	const block = {
    		c: function create() {
    			select = element("select");
    			if (default_slot) default_slot.c();
    			attr_dev(select, "style", /*inputStyle*/ ctx[26]);
    			attr_dev(select, "name", /*name*/ ctx[5]);
    			attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
    			attr_dev(select, "id", /*inputId*/ ctx[11]);
    			attr_dev(select, "size", /*size*/ ctx[12]);
    			attr_dev(select, "accept", /*accept*/ ctx[13]);
    			attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
    			attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
    			attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
    			select.autofocus = /*autofocus*/ ctx[18];
    			attr_dev(select, "autosave", /*autosave*/ ctx[19]);
    			select.disabled = /*disabled*/ ctx[9];
    			attr_dev(select, "max", /*max*/ ctx[20]);
    			attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
    			attr_dev(select, "min", /*min*/ ctx[21]);
    			attr_dev(select, "minlength", /*minlength*/ ctx[24]);
    			attr_dev(select, "step", /*step*/ ctx[22]);
    			select.multiple = /*multiple*/ ctx[25];
    			attr_dev(select, "readonly", /*readonly*/ ctx[7]);
    			select.required = /*required*/ ctx[8];
    			attr_dev(select, "pattern", /*pattern*/ ctx[27]);

    			attr_dev(select, "validate", select_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined);

    			attr_dev(select, "data-validate", select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);

    			attr_dev(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33]);

    			attr_dev(select, "class", /*inputClasses*/ ctx[46]);
    			add_location(select, file$h, 600, 12, 17897);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);

    			if (default_slot) {
    				default_slot.m(select, null);
    			}

    			select_option(select, /*inputValue*/ ctx[49]);
    			/*select_binding_1*/ ctx[81](select);
    			current = true;
    			if (/*autofocus*/ ctx[18]) select.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "focus", /*onFocus*/ ctx[53], false, false, false),
    					listen_dev(select, "blur", /*onBlur*/ ctx[54], false, false, false),
    					listen_dev(select, "input", /*onInput*/ ctx[52], false, false, false),
    					listen_dev(select, "change", /*onChange*/ ctx[55], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[76], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty[0] & /*inputStyle*/ 67108864) {
    				attr_dev(select, "style", /*inputStyle*/ ctx[26]);
    			}

    			if (!current || dirty[0] & /*name*/ 32) {
    				attr_dev(select, "name", /*name*/ ctx[5]);
    			}

    			if (!current || dirty[0] & /*placeholder*/ 1024) {
    				attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
    			}

    			if (!current || dirty[0] & /*inputId*/ 2048) {
    				attr_dev(select, "id", /*inputId*/ ctx[11]);
    			}

    			if (!current || dirty[0] & /*size*/ 4096) {
    				attr_dev(select, "size", /*size*/ ctx[12]);
    			}

    			if (!current || dirty[0] & /*accept*/ 8192) {
    				attr_dev(select, "accept", /*accept*/ ctx[13]);
    			}

    			if (!current || dirty[0] & /*autocomplete*/ 16384) {
    				attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
    			}

    			if (!current || dirty[0] & /*autocorrect*/ 32768) {
    				attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
    			}

    			if (!current || dirty[0] & /*autocapitalize*/ 65536) {
    				attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			}

    			if (!current || dirty[0] & /*spellcheck*/ 131072) {
    				attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
    			}

    			if (!current || dirty[0] & /*autofocus*/ 262144) {
    				prop_dev(select, "autofocus", /*autofocus*/ ctx[18]);
    			}

    			if (!current || dirty[0] & /*autosave*/ 524288) {
    				attr_dev(select, "autosave", /*autosave*/ ctx[19]);
    			}

    			if (!current || dirty[0] & /*disabled*/ 512) {
    				prop_dev(select, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (!current || dirty[0] & /*max*/ 1048576) {
    				attr_dev(select, "max", /*max*/ ctx[20]);
    			}

    			if (!current || dirty[0] & /*maxlength*/ 8388608) {
    				attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
    			}

    			if (!current || dirty[0] & /*min*/ 2097152) {
    				attr_dev(select, "min", /*min*/ ctx[21]);
    			}

    			if (!current || dirty[0] & /*minlength*/ 16777216) {
    				attr_dev(select, "minlength", /*minlength*/ ctx[24]);
    			}

    			if (!current || dirty[0] & /*step*/ 4194304) {
    				attr_dev(select, "step", /*step*/ ctx[22]);
    			}

    			if (!current || dirty[0] & /*multiple*/ 33554432) {
    				prop_dev(select, "multiple", /*multiple*/ ctx[25]);
    			}

    			if (!current || dirty[0] & /*readonly*/ 128) {
    				attr_dev(select, "readonly", /*readonly*/ ctx[7]);
    			}

    			if (!current || dirty[0] & /*required*/ 256) {
    				prop_dev(select, "required", /*required*/ ctx[8]);
    			}

    			if (!current || dirty[0] & /*pattern*/ 134217728) {
    				attr_dev(select, "pattern", /*pattern*/ ctx[27]);
    			}

    			if (!current || dirty[0] & /*validate*/ 268435456 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined)) {
    				attr_dev(select, "validate", select_validate_value);
    			}

    			if (!current || dirty[0] & /*validate, validateOnBlur*/ 805306368 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(select, "data-validate", select_data_validate_value);
    			}

    			if (!current || dirty[0] & /*validateOnBlur*/ 536870912 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value);
    			}

    			if (!current || dirty[0] & /*tabindex*/ 1073741824) {
    				attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);
    			}

    			if (!current || dirty[1] & /*errorMessageForce, errorMessage*/ 12 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33])) {
    				attr_dev(select, "data-error-message", select_data_error_message_value);
    			}

    			if (!current || dirty[1] & /*inputClasses*/ 32768) {
    				attr_dev(select, "class", /*inputClasses*/ ctx[46]);
    			}

    			if (!current || dirty[1] & /*inputValue*/ 262144) {
    				select_option(select, /*inputValue*/ ctx[49]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			if (default_slot) default_slot.d(detaching);
    			/*select_binding_1*/ ctx[81](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17$1.name,
    		type: "if",
    		source: "(600:10) {#if type === 'select'}",
    		ctx
    	});

    	return block;
    }

    // (753:8) {#if hasErrorMessage && errorMessageForce}
    function create_if_block_15$1(ctx) {
    	let div;
    	let t0_value = plainText(/*errorMessage*/ ctx[33]) + "";
    	let t0;
    	let t1;
    	let current;
    	const error_message_slot_template = /*#slots*/ ctx[77]["error-message"];
    	const error_message_slot = create_slot(error_message_slot_template, ctx, /*$$scope*/ ctx[76], get_error_message_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (error_message_slot) error_message_slot.c();
    			attr_dev(div, "class", "item-input-error-message");
    			add_location(div, file$h, 753, 10, 22840);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (error_message_slot) {
    				error_message_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[1] & /*errorMessage*/ 4) && t0_value !== (t0_value = plainText(/*errorMessage*/ ctx[33]) + "")) set_data_dev(t0, t0_value);

    			if (error_message_slot) {
    				if (error_message_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						error_message_slot,
    						error_message_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(error_message_slot_template, /*$$scope*/ ctx[76], dirty, get_error_message_slot_changes_1),
    						get_error_message_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(error_message_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(error_message_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (error_message_slot) error_message_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15$1.name,
    		type: "if",
    		source: "(753:8) {#if hasErrorMessage && errorMessageForce}",
    		ctx
    	});

    	return block;
    }

    // (759:8) {#if clearButton}
    function create_if_block_14$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "input-clear-button");
    			add_location(span, file$h, 758, 25, 23015);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14$1.name,
    		type: "if",
    		source: "(759:8) {#if clearButton}",
    		ctx
    	});

    	return block;
    }

    // (760:8) {#if typeof info !== 'undefined' || hasInfoSlots}
    function create_if_block_13$1(ctx) {
    	let div;
    	let t0_value = plainText(/*info*/ ctx[35]) + "";
    	let t0;
    	let t1;
    	let current;
    	const info_slot_template = /*#slots*/ ctx[77].info;
    	const info_slot = create_slot(info_slot_template, ctx, /*$$scope*/ ctx[76], get_info_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (info_slot) info_slot.c();
    			attr_dev(div, "class", "item-input-info");
    			add_location(div, file$h, 760, 10, 23124);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (info_slot) {
    				info_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[1] & /*info*/ 16) && t0_value !== (t0_value = plainText(/*info*/ ctx[35]) + "")) set_data_dev(t0, t0_value);

    			if (info_slot) {
    				if (info_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						info_slot,
    						info_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(info_slot_template, /*$$scope*/ ctx[76], dirty, get_info_slot_changes_1),
    						get_info_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(info_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (info_slot) info_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13$1.name,
    		type: "if",
    		source: "(760:8) {#if typeof info !== 'undefined' || hasInfoSlots}",
    		ctx
    	});

    	return block;
    }

    // (378:6) {#if isSortable && isSortableOpposite}
    function create_if_block_12$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$h, 378, 8, 10554);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12$1.name,
    		type: "if",
    		source: "(378:6) {#if isSortable && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (382:6) {#if media || hasMediaSlots}
    function create_if_block_10$1(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[1] !== 'undefined' && create_if_block_11$1(ctx);
    	const media_slot_template = /*#slots*/ ctx[77].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[76], get_media_slot_context$1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$h, 382, 8, 10643);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[1] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_11$1(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[76], dirty, get_media_slot_changes$1),
    						get_media_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$1.name,
    		type: "if",
    		source: "(382:6) {#if media || hasMediaSlots}",
    		ctx
    	});

    	return block;
    }

    // (384:10) {#if typeof media !== 'undefined'}
    function create_if_block_11$1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[1])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$h, 383, 44, 10712);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 2 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[1])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11$1.name,
    		type: "if",
    		source: "(384:10) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (390:8) {#if typeof label !== 'undefined' || hasLabelSlots}
    function create_if_block_9$1(ctx) {
    	let div;
    	let t0_value = plainText(/*label*/ ctx[36]) + "";
    	let t0;
    	let t1;
    	let current;
    	const label_slot_template = /*#slots*/ ctx[77].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[76], get_label_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (label_slot) label_slot.c();
    			attr_dev(div, "class", /*labelClasses*/ ctx[44]);
    			add_location(div, file$h, 390, 10, 10933);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (label_slot) {
    				label_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[1] & /*label*/ 32) && t0_value !== (t0_value = plainText(/*label*/ ctx[36]) + "")) set_data_dev(t0, t0_value);

    			if (label_slot) {
    				if (label_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[76], dirty, get_label_slot_changes),
    						get_label_slot_context
    					);
    				}
    			}

    			if (!current || dirty[1] & /*labelClasses*/ 8192) {
    				attr_dev(div, "class", /*labelClasses*/ ctx[44]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (label_slot) label_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$1.name,
    		type: "if",
    		source: "(390:8) {#if typeof label !== 'undefined' || hasLabelSlots}",
    		ctx
    	});

    	return block;
    }

    // (397:10) {#if input}
    function create_if_block_5$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_6$1, create_if_block_7$1, create_if_block_8$1, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*type*/ ctx[4] === 'select') return 0;
    		if (/*type*/ ctx[4] === 'textarea') return 1;
    		if (/*type*/ ctx[4] === 'texteditor') return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(397:10) {#if input}",
    		ctx
    	});

    	return block;
    }

    // (500:12) {:else}
    function create_else_block$6(ctx) {
    	let input_1;
    	let input_1_validate_value;
    	let input_1_data_validate_value;
    	let input_1_data_validate_on_blur_value;
    	let input_1_data_error_message_value;
    	let input_1_value_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
    			attr_dev(input_1, "name", /*name*/ ctx[5]);
    			attr_dev(input_1, "type", /*inputType*/ ctx[40]);
    			attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
    			attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
    			attr_dev(input_1, "id", /*inputId*/ ctx[11]);
    			attr_dev(input_1, "size", /*size*/ ctx[12]);
    			attr_dev(input_1, "accept", /*accept*/ ctx[13]);
    			attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
    			attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
    			attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
    			input_1.autofocus = /*autofocus*/ ctx[18];
    			attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
    			input_1.disabled = /*disabled*/ ctx[9];
    			attr_dev(input_1, "max", /*max*/ ctx[20]);
    			attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
    			attr_dev(input_1, "min", /*min*/ ctx[21]);
    			attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
    			attr_dev(input_1, "step", /*step*/ ctx[22]);
    			input_1.multiple = /*multiple*/ ctx[25];
    			input_1.readOnly = /*readonly*/ ctx[7];
    			input_1.required = /*required*/ ctx[8];
    			attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);

    			attr_dev(input_1, "validate", input_1_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined);

    			attr_dev(input_1, "data-validate", input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);

    			attr_dev(input_1, "data-error-message", input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33]);

    			attr_dev(input_1, "class", /*inputClasses*/ ctx[46]);

    			input_1.value = input_1_value_value = /*type*/ ctx[4] === 'datepicker' || /*type*/ ctx[4] === 'colorpicker' || /*type*/ ctx[4] === 'file'
    			? ''
    			: /*inputValue*/ ctx[49];

    			add_location(input_1, file$h, 500, 14, 14658);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    			/*input_1_binding*/ ctx[80](input_1);
    			if (/*autofocus*/ ctx[18]) input_1.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(input_1, "focus", /*onFocus*/ ctx[53], false, false, false),
    					listen_dev(input_1, "blur", /*onBlur*/ ctx[54], false, false, false),
    					listen_dev(input_1, "input", /*onInput*/ ctx[52], false, false, false),
    					listen_dev(input_1, "change", /*onChange*/ ctx[55], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*inputStyle*/ 67108864) {
    				attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
    			}

    			if (dirty[0] & /*name*/ 32) {
    				attr_dev(input_1, "name", /*name*/ ctx[5]);
    			}

    			if (dirty[1] & /*inputType*/ 512) {
    				attr_dev(input_1, "type", /*inputType*/ ctx[40]);
    			}

    			if (dirty[0] & /*inputmode*/ 64) {
    				attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
    			}

    			if (dirty[0] & /*placeholder*/ 1024) {
    				attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
    			}

    			if (dirty[0] & /*inputId*/ 2048) {
    				attr_dev(input_1, "id", /*inputId*/ ctx[11]);
    			}

    			if (dirty[0] & /*size*/ 4096) {
    				attr_dev(input_1, "size", /*size*/ ctx[12]);
    			}

    			if (dirty[0] & /*accept*/ 8192) {
    				attr_dev(input_1, "accept", /*accept*/ ctx[13]);
    			}

    			if (dirty[0] & /*autocomplete*/ 16384) {
    				attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
    			}

    			if (dirty[0] & /*autocorrect*/ 32768) {
    				attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
    			}

    			if (dirty[0] & /*autocapitalize*/ 65536) {
    				attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			}

    			if (dirty[0] & /*spellcheck*/ 131072) {
    				attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
    			}

    			if (dirty[0] & /*autofocus*/ 262144) {
    				prop_dev(input_1, "autofocus", /*autofocus*/ ctx[18]);
    			}

    			if (dirty[0] & /*autosave*/ 524288) {
    				attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
    			}

    			if (dirty[0] & /*disabled*/ 512) {
    				prop_dev(input_1, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*max*/ 1048576) {
    				attr_dev(input_1, "max", /*max*/ ctx[20]);
    			}

    			if (dirty[0] & /*maxlength*/ 8388608) {
    				attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
    			}

    			if (dirty[0] & /*min*/ 2097152) {
    				attr_dev(input_1, "min", /*min*/ ctx[21]);
    			}

    			if (dirty[0] & /*minlength*/ 16777216) {
    				attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
    			}

    			if (dirty[0] & /*step*/ 4194304) {
    				attr_dev(input_1, "step", /*step*/ ctx[22]);
    			}

    			if (dirty[0] & /*multiple*/ 33554432) {
    				prop_dev(input_1, "multiple", /*multiple*/ ctx[25]);
    			}

    			if (dirty[0] & /*readonly*/ 128) {
    				prop_dev(input_1, "readOnly", /*readonly*/ ctx[7]);
    			}

    			if (dirty[0] & /*required*/ 256) {
    				prop_dev(input_1, "required", /*required*/ ctx[8]);
    			}

    			if (dirty[0] & /*pattern*/ 134217728) {
    				attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);
    			}

    			if (dirty[0] & /*validate*/ 268435456 && input_1_validate_value !== (input_1_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined)) {
    				attr_dev(input_1, "validate", input_1_validate_value);
    			}

    			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && input_1_data_validate_value !== (input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(input_1, "data-validate", input_1_data_validate_value);
    			}

    			if (dirty[0] & /*validateOnBlur*/ 536870912 && input_1_data_validate_on_blur_value !== (input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value);
    			}

    			if (dirty[0] & /*tabindex*/ 1073741824) {
    				attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);
    			}

    			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && input_1_data_error_message_value !== (input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33])) {
    				attr_dev(input_1, "data-error-message", input_1_data_error_message_value);
    			}

    			if (dirty[1] & /*inputClasses*/ 32768) {
    				attr_dev(input_1, "class", /*inputClasses*/ ctx[46]);
    			}

    			if (dirty[0] & /*type*/ 16 | dirty[1] & /*inputValue*/ 262144 && input_1_value_value !== (input_1_value_value = /*type*/ ctx[4] === 'datepicker' || /*type*/ ctx[4] === 'colorpicker' || /*type*/ ctx[4] === 'file'
    			? ''
    			: /*inputValue*/ ctx[49]) && input_1.value !== input_1_value_value) {
    				prop_dev(input_1, "value", input_1_value_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    			/*input_1_binding*/ ctx[80](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(500:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (489:44) 
    function create_if_block_8$1(ctx) {
    	let texteditor;
    	let current;

    	const texteditor_spread_levels = [
    		{
    			value: typeof /*value*/ ctx[0] === 'undefined'
    			? ''
    			: /*value*/ ctx[0]
    		},
    		{ resizable: /*resizable*/ ctx[31] },
    		{ placeholder: /*placeholder*/ ctx[10] },
    		{ onTextEditorFocus: /*onFocus*/ ctx[53] },
    		{ onTextEditorBlur: /*onBlur*/ ctx[54] },
    		{ onTextEditorInput: /*onInput*/ ctx[52] },
    		{ onTextEditorChange: /*onChange*/ ctx[55] },
    		/*textEditorParams*/ ctx[37]
    	];

    	let texteditor_props = {};

    	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
    		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
    	}

    	texteditor = new Text_editor({ props: texteditor_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(texteditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(texteditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const texteditor_changes = (dirty[0] & /*value, placeholder*/ 1025 | dirty[1] & /*resizable, onFocus, onBlur, onInput, onChange, textEditorParams*/ 31457345)
    			? get_spread_update(texteditor_spread_levels, [
    					dirty[0] & /*value*/ 1 && {
    						value: typeof /*value*/ ctx[0] === 'undefined'
    						? ''
    						: /*value*/ ctx[0]
    					},
    					dirty[1] & /*resizable*/ 1 && { resizable: /*resizable*/ ctx[31] },
    					dirty[0] & /*placeholder*/ 1024 && { placeholder: /*placeholder*/ ctx[10] },
    					dirty[1] & /*onFocus*/ 4194304 && { onTextEditorFocus: /*onFocus*/ ctx[53] },
    					dirty[1] & /*onBlur*/ 8388608 && { onTextEditorBlur: /*onBlur*/ ctx[54] },
    					dirty[1] & /*onInput*/ 2097152 && { onTextEditorInput: /*onInput*/ ctx[52] },
    					dirty[1] & /*onChange*/ 16777216 && { onTextEditorChange: /*onChange*/ ctx[55] },
    					dirty[1] & /*textEditorParams*/ 64 && get_spread_object(/*textEditorParams*/ ctx[37])
    				])
    			: {};

    			texteditor.$set(texteditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(texteditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(texteditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(texteditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(489:44) ",
    		ctx
    	});

    	return block;
    }

    // (444:42) 
    function create_if_block_7$1(ctx) {
    	let textarea;
    	let textarea_validate_value;
    	let textarea_data_validate_value;
    	let textarea_data_validate_on_blur_value;
    	let textarea_data_error_message_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			textarea = element("textarea");
    			attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
    			attr_dev(textarea, "name", /*name*/ ctx[5]);
    			attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
    			attr_dev(textarea, "id", /*inputId*/ ctx[11]);
    			attr_dev(textarea, "size", /*size*/ ctx[12]);
    			attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
    			attr_dev(textarea, "accept", /*accept*/ ctx[13]);
    			attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
    			attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
    			attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
    			textarea.autofocus = /*autofocus*/ ctx[18];
    			attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
    			textarea.disabled = /*disabled*/ ctx[9];
    			attr_dev(textarea, "max", /*max*/ ctx[20]);
    			attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
    			attr_dev(textarea, "min", /*min*/ ctx[21]);
    			attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
    			attr_dev(textarea, "step", /*step*/ ctx[22]);
    			attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
    			textarea.readOnly = /*readonly*/ ctx[7];
    			textarea.required = /*required*/ ctx[8];
    			attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);

    			attr_dev(textarea, "validate", textarea_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined);

    			attr_dev(textarea, "data-validate", textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);

    			attr_dev(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33]);

    			attr_dev(textarea, "class", /*inputClasses*/ ctx[46]);
    			textarea.value = /*inputValue*/ ctx[49];
    			add_location(textarea, file$h, 444, 14, 12720);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, textarea, anchor);
    			/*textarea_binding*/ ctx[79](textarea);
    			if (/*autofocus*/ ctx[18]) textarea.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "focus", /*onFocus*/ ctx[53], false, false, false),
    					listen_dev(textarea, "blur", /*onBlur*/ ctx[54], false, false, false),
    					listen_dev(textarea, "input", /*onInput*/ ctx[52], false, false, false),
    					listen_dev(textarea, "change", /*onChange*/ ctx[55], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*inputStyle*/ 67108864) {
    				attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
    			}

    			if (dirty[0] & /*name*/ 32) {
    				attr_dev(textarea, "name", /*name*/ ctx[5]);
    			}

    			if (dirty[0] & /*placeholder*/ 1024) {
    				attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
    			}

    			if (dirty[0] & /*inputId*/ 2048) {
    				attr_dev(textarea, "id", /*inputId*/ ctx[11]);
    			}

    			if (dirty[0] & /*size*/ 4096) {
    				attr_dev(textarea, "size", /*size*/ ctx[12]);
    			}

    			if (dirty[0] & /*inputmode*/ 64) {
    				attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
    			}

    			if (dirty[0] & /*accept*/ 8192) {
    				attr_dev(textarea, "accept", /*accept*/ ctx[13]);
    			}

    			if (dirty[0] & /*autocomplete*/ 16384) {
    				attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
    			}

    			if (dirty[0] & /*autocorrect*/ 32768) {
    				attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
    			}

    			if (dirty[0] & /*autocapitalize*/ 65536) {
    				attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			}

    			if (dirty[0] & /*spellcheck*/ 131072) {
    				attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
    			}

    			if (dirty[0] & /*autofocus*/ 262144) {
    				prop_dev(textarea, "autofocus", /*autofocus*/ ctx[18]);
    			}

    			if (dirty[0] & /*autosave*/ 524288) {
    				attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
    			}

    			if (dirty[0] & /*disabled*/ 512) {
    				prop_dev(textarea, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*max*/ 1048576) {
    				attr_dev(textarea, "max", /*max*/ ctx[20]);
    			}

    			if (dirty[0] & /*maxlength*/ 8388608) {
    				attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
    			}

    			if (dirty[0] & /*min*/ 2097152) {
    				attr_dev(textarea, "min", /*min*/ ctx[21]);
    			}

    			if (dirty[0] & /*minlength*/ 16777216) {
    				attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
    			}

    			if (dirty[0] & /*step*/ 4194304) {
    				attr_dev(textarea, "step", /*step*/ ctx[22]);
    			}

    			if (dirty[0] & /*multiple*/ 33554432) {
    				attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
    			}

    			if (dirty[0] & /*readonly*/ 128) {
    				prop_dev(textarea, "readOnly", /*readonly*/ ctx[7]);
    			}

    			if (dirty[0] & /*required*/ 256) {
    				prop_dev(textarea, "required", /*required*/ ctx[8]);
    			}

    			if (dirty[0] & /*pattern*/ 134217728) {
    				attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);
    			}

    			if (dirty[0] & /*validate*/ 268435456 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined)) {
    				attr_dev(textarea, "validate", textarea_validate_value);
    			}

    			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(textarea, "data-validate", textarea_data_validate_value);
    			}

    			if (dirty[0] & /*validateOnBlur*/ 536870912 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
    			}

    			if (dirty[0] & /*tabindex*/ 1073741824) {
    				attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);
    			}

    			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33])) {
    				attr_dev(textarea, "data-error-message", textarea_data_error_message_value);
    			}

    			if (dirty[1] & /*inputClasses*/ 32768) {
    				attr_dev(textarea, "class", /*inputClasses*/ ctx[46]);
    			}

    			if (dirty[1] & /*inputValue*/ 262144) {
    				prop_dev(textarea, "value", /*inputValue*/ ctx[49]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea);
    			/*textarea_binding*/ ctx[79](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(444:42) ",
    		ctx
    	});

    	return block;
    }

    // (398:12) {#if type === 'select'}
    function create_if_block_6$1(ctx) {
    	let select;
    	let select_validate_value;
    	let select_data_validate_value;
    	let select_data_validate_on_blur_value;
    	let select_data_error_message_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[77].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[76], null);

    	const block = {
    		c: function create() {
    			select = element("select");
    			if (default_slot) default_slot.c();
    			attr_dev(select, "style", /*inputStyle*/ ctx[26]);
    			attr_dev(select, "name", /*name*/ ctx[5]);
    			attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
    			attr_dev(select, "id", /*inputId*/ ctx[11]);
    			attr_dev(select, "size", /*size*/ ctx[12]);
    			attr_dev(select, "accept", /*accept*/ ctx[13]);
    			attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
    			attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
    			attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
    			select.autofocus = /*autofocus*/ ctx[18];
    			attr_dev(select, "autosave", /*autosave*/ ctx[19]);
    			select.disabled = /*disabled*/ ctx[9];
    			attr_dev(select, "max", /*max*/ ctx[20]);
    			attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
    			attr_dev(select, "min", /*min*/ ctx[21]);
    			attr_dev(select, "minlength", /*minlength*/ ctx[24]);
    			attr_dev(select, "step", /*step*/ ctx[22]);
    			select.multiple = /*multiple*/ ctx[25];
    			attr_dev(select, "readonly", /*readonly*/ ctx[7]);
    			select.required = /*required*/ ctx[8];
    			attr_dev(select, "pattern", /*pattern*/ ctx[27]);

    			attr_dev(select, "validate", select_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined);

    			attr_dev(select, "data-validate", select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);

    			attr_dev(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33]);

    			attr_dev(select, "class", /*inputClasses*/ ctx[46]);
    			add_location(select, file$h, 398, 14, 11167);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);

    			if (default_slot) {
    				default_slot.m(select, null);
    			}

    			select_option(select, /*inputValue*/ ctx[49]);
    			/*select_binding*/ ctx[78](select);
    			current = true;
    			if (/*autofocus*/ ctx[18]) select.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "focus", /*onFocus*/ ctx[53], false, false, false),
    					listen_dev(select, "blur", /*onBlur*/ ctx[54], false, false, false),
    					listen_dev(select, "input", /*onInput*/ ctx[52], false, false, false),
    					listen_dev(select, "change", /*onChange*/ ctx[55], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[76], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty[0] & /*inputStyle*/ 67108864) {
    				attr_dev(select, "style", /*inputStyle*/ ctx[26]);
    			}

    			if (!current || dirty[0] & /*name*/ 32) {
    				attr_dev(select, "name", /*name*/ ctx[5]);
    			}

    			if (!current || dirty[0] & /*placeholder*/ 1024) {
    				attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
    			}

    			if (!current || dirty[0] & /*inputId*/ 2048) {
    				attr_dev(select, "id", /*inputId*/ ctx[11]);
    			}

    			if (!current || dirty[0] & /*size*/ 4096) {
    				attr_dev(select, "size", /*size*/ ctx[12]);
    			}

    			if (!current || dirty[0] & /*accept*/ 8192) {
    				attr_dev(select, "accept", /*accept*/ ctx[13]);
    			}

    			if (!current || dirty[0] & /*autocomplete*/ 16384) {
    				attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
    			}

    			if (!current || dirty[0] & /*autocorrect*/ 32768) {
    				attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
    			}

    			if (!current || dirty[0] & /*autocapitalize*/ 65536) {
    				attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			}

    			if (!current || dirty[0] & /*spellcheck*/ 131072) {
    				attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
    			}

    			if (!current || dirty[0] & /*autofocus*/ 262144) {
    				prop_dev(select, "autofocus", /*autofocus*/ ctx[18]);
    			}

    			if (!current || dirty[0] & /*autosave*/ 524288) {
    				attr_dev(select, "autosave", /*autosave*/ ctx[19]);
    			}

    			if (!current || dirty[0] & /*disabled*/ 512) {
    				prop_dev(select, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (!current || dirty[0] & /*max*/ 1048576) {
    				attr_dev(select, "max", /*max*/ ctx[20]);
    			}

    			if (!current || dirty[0] & /*maxlength*/ 8388608) {
    				attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
    			}

    			if (!current || dirty[0] & /*min*/ 2097152) {
    				attr_dev(select, "min", /*min*/ ctx[21]);
    			}

    			if (!current || dirty[0] & /*minlength*/ 16777216) {
    				attr_dev(select, "minlength", /*minlength*/ ctx[24]);
    			}

    			if (!current || dirty[0] & /*step*/ 4194304) {
    				attr_dev(select, "step", /*step*/ ctx[22]);
    			}

    			if (!current || dirty[0] & /*multiple*/ 33554432) {
    				prop_dev(select, "multiple", /*multiple*/ ctx[25]);
    			}

    			if (!current || dirty[0] & /*readonly*/ 128) {
    				attr_dev(select, "readonly", /*readonly*/ ctx[7]);
    			}

    			if (!current || dirty[0] & /*required*/ 256) {
    				prop_dev(select, "required", /*required*/ ctx[8]);
    			}

    			if (!current || dirty[0] & /*pattern*/ 134217728) {
    				attr_dev(select, "pattern", /*pattern*/ ctx[27]);
    			}

    			if (!current || dirty[0] & /*validate*/ 268435456 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined)) {
    				attr_dev(select, "validate", select_validate_value);
    			}

    			if (!current || dirty[0] & /*validate, validateOnBlur*/ 805306368 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(select, "data-validate", select_data_validate_value);
    			}

    			if (!current || dirty[0] & /*validateOnBlur*/ 536870912 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value);
    			}

    			if (!current || dirty[0] & /*tabindex*/ 1073741824) {
    				attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);
    			}

    			if (!current || dirty[1] & /*errorMessageForce, errorMessage*/ 12 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33])) {
    				attr_dev(select, "data-error-message", select_data_error_message_value);
    			}

    			if (!current || dirty[1] & /*inputClasses*/ 32768) {
    				attr_dev(select, "class", /*inputClasses*/ ctx[46]);
    			}

    			if (!current || dirty[1] & /*inputValue*/ 262144) {
    				select_option(select, /*inputValue*/ ctx[49]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			if (default_slot) default_slot.d(detaching);
    			/*select_binding*/ ctx[78](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(398:12) {#if type === 'select'}",
    		ctx
    	});

    	return block;
    }

    // (551:10) {#if hasErrorMessage && errorMessageForce}
    function create_if_block_4$1(ctx) {
    	let div;
    	let t0_value = plainText(/*errorMessage*/ ctx[33]) + "";
    	let t0;
    	let t1;
    	let current;
    	const error_message_slot_template = /*#slots*/ ctx[77]["error-message"];
    	const error_message_slot = create_slot(error_message_slot_template, ctx, /*$$scope*/ ctx[76], get_error_message_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (error_message_slot) error_message_slot.c();
    			attr_dev(div, "class", "item-input-error-message");
    			add_location(div, file$h, 551, 12, 16416);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (error_message_slot) {
    				error_message_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[1] & /*errorMessage*/ 4) && t0_value !== (t0_value = plainText(/*errorMessage*/ ctx[33]) + "")) set_data_dev(t0, t0_value);

    			if (error_message_slot) {
    				if (error_message_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						error_message_slot,
    						error_message_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(error_message_slot_template, /*$$scope*/ ctx[76], dirty, get_error_message_slot_changes),
    						get_error_message_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(error_message_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(error_message_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (error_message_slot) error_message_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(551:10) {#if hasErrorMessage && errorMessageForce}",
    		ctx
    	});

    	return block;
    }

    // (557:10) {#if clearButton}
    function create_if_block_3$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "input-clear-button");
    			add_location(span, file$h, 556, 27, 16601);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(557:10) {#if clearButton}",
    		ctx
    	});

    	return block;
    }

    // (558:10) {#if typeof info !== 'undefined' || hasInfoSlots}
    function create_if_block_2$5(ctx) {
    	let div;
    	let t0_value = plainText(/*info*/ ctx[35]) + "";
    	let t0;
    	let t1;
    	let current;
    	const info_slot_template = /*#slots*/ ctx[77].info;
    	const info_slot = create_slot(info_slot_template, ctx, /*$$scope*/ ctx[76], get_info_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (info_slot) info_slot.c();
    			attr_dev(div, "class", "item-input-info");
    			add_location(div, file$h, 558, 12, 16714);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (info_slot) {
    				info_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[1] & /*info*/ 16) && t0_value !== (t0_value = plainText(/*info*/ ctx[35]) + "")) set_data_dev(t0, t0_value);

    			if (info_slot) {
    				if (info_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						info_slot,
    						info_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(info_slot_template, /*$$scope*/ ctx[76], dirty, get_info_slot_changes),
    						get_info_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(info_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (info_slot) info_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(558:10) {#if typeof info !== 'undefined' || hasInfoSlots}",
    		ctx
    	});

    	return block;
    }

    // (571:4) {#if isSortable && !isSortableOpposite}
    function create_if_block_1$7(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$h, 571, 6, 17063);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(571:4) {#if isSortable && !isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$b, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*wrap*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let isSortable;
    	let isSortableOpposite;
    	let inputType;
    	let needsValue;
    	let inputValue;
    	let hasInfoSlots;
    	let hasErrorSlots;
    	let hasMediaSlots;
    	let hasLabelSlots;
    	let hasErrorMessage;
    	let inputClasses;
    	let itemContentClasses;
    	let labelClasses;
    	let inputWrapClasses;
    	let classes;

    	const omit_props_names = [
    		"class","sortable","sortableOpposite","media","dropdown","wrap","input","type","name","value","inputmode","readonly","required","disabled","placeholder","inputId","size","accept","autocomplete","autocorrect","autocapitalize","spellcheck","autofocus","autosave","max","min","step","maxlength","minlength","multiple","inputStyle","pattern","validate","validateOnBlur","onValidate","tabindex","resizable","clearButton","noFormStoreData","noStoreData","ignoreStoreData","errorMessage","errorMessageForce","info","outline","label","inlineLabel","floatingLabel","calendarParams","colorPickerParams","textEditorParams","calendarInstance","colorPickerInstance"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;

    	validate_slots('List_input', slots, [
    		'root-start','content-start','media','inner-start','label','default','input','error-message','info','inner','inner-end','content','content-end','root','root-end'
    	]);

    	const $$slots = compute_slots(slots);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { sortable = undefined } = $$props;
    	let { sortableOpposite = undefined } = $$props;
    	let { media = undefined } = $$props;
    	let { dropdown = 'auto' } = $$props;
    	let { wrap = true } = $$props;
    	let { input = true } = $$props;
    	let { type = 'text' } = $$props;
    	let { name = undefined } = $$props;
    	let { value = undefined } = $$props;
    	let { inputmode = undefined } = $$props;
    	let { readonly = undefined } = $$props;
    	let { required = undefined } = $$props;
    	let { disabled = undefined } = $$props;
    	let { placeholder = undefined } = $$props;
    	let { inputId = undefined } = $$props;
    	let { size = undefined } = $$props;
    	let { accept = undefined } = $$props;
    	let { autocomplete = undefined } = $$props;
    	let { autocorrect = undefined } = $$props;
    	let { autocapitalize = undefined } = $$props;
    	let { spellcheck = undefined } = $$props;
    	let { autofocus = undefined } = $$props;
    	let { autosave = undefined } = $$props;
    	let { max = undefined } = $$props;
    	let { min = undefined } = $$props;
    	let { step = undefined } = $$props;
    	let { maxlength = undefined } = $$props;
    	let { minlength = undefined } = $$props;
    	let { multiple = undefined } = $$props;
    	let { inputStyle = undefined } = $$props;
    	let { pattern = undefined } = $$props;
    	let { validate = undefined } = $$props;
    	let { validateOnBlur = undefined } = $$props;
    	let { onValidate = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { resizable = undefined } = $$props;
    	let { clearButton = undefined } = $$props;
    	let { noFormStoreData = undefined } = $$props;
    	let { noStoreData = undefined } = $$props;
    	let { ignoreStoreData = undefined } = $$props;
    	let { errorMessage = undefined } = $$props;
    	let { errorMessageForce = undefined } = $$props;
    	let { info = undefined } = $$props;
    	let { outline = undefined } = $$props;
    	let { label = undefined } = $$props;
    	let { inlineLabel = undefined } = $$props;
    	let { floatingLabel = undefined } = $$props;
    	let { calendarParams = undefined } = $$props;
    	let { colorPickerParams = undefined } = $$props;
    	let { textEditorParams = undefined } = $$props;

    	// State
    	let inputEl;

    	let inputFocused = false;
    	let inputInvalid = false;
    	let updateInputOnDidUpdate = false;
    	let f7Calendar;
    	let f7ColorPicker;

    	function calendarInstance() {
    		return f7Calendar;
    	}

    	function colorPickerInstance() {
    		return f7ColorPicker;
    	}

    	let ListContext = getReactiveContext('ListContext', newValue => {
    		$$invalidate(74, ListContext = newValue || {});
    	}) || {};

    	function domValue() {
    		if (!inputEl) return undefined;
    		return inputEl.value;
    	}

    	function inputHasValue() {
    		if (type === 'datepicker' && Array.isArray(value) && value.length === 0) {
    			return false;
    		}

    		const domV = domValue();

    		return typeof value === 'undefined'
    		? domV || domV === 0
    		: value || value === 0;
    	}

    	function validateInput() {
    		if (!app$1.f7 || !inputEl) return;
    		const validity = inputEl.validity;
    		if (!validity) return;

    		if (!validity.valid) {
    			if (onValidate) onValidate(false);

    			if (inputInvalid !== true) {
    				$$invalidate(73, inputInvalid = true);
    			}
    		} else {
    			if (onValidate) onValidate(true);

    			if (inputInvalid !== false) {
    				$$invalidate(73, inputInvalid = false);
    			}
    		}
    	}

    	let initialWatched = false;

    	function watchValue() {
    		if (!initialWatched) {
    			initialWatched = true;
    			return;
    		}

    		if (type === 'range' || type === 'toggle') return;
    		if (!app$1.f7) return;
    		updateInputOnDidUpdate = true;

    		if (f7Calendar) {
    			f7Calendar.setValue(value);
    		}

    		if (f7ColorPicker) {
    			f7ColorPicker.setValue(value);
    		}
    	}

    	function watchColorPickerParams() {
    		if (!app$1.f7 || !f7ColorPicker) return;
    		extend(f7ColorPicker.params, colorPickerParams || {});
    	}

    	function watchCalendarParams() {
    		if (!app$1.f7 || !f7Calendar) return;
    		extend(f7Calendar.params, calendarParams || {});
    	}

    	function onTextareaResize(event) {
    		emit('textareaResize', [event]);
    	}

    	function onInputNotEmpty(event) {
    		emit('inputNotEmpty', [event]);
    	}

    	function onInputEmpty(event) {
    		emit('inputEmpty', [event]);
    	}

    	function onInputClear(event) {
    		emit('inputClear', [event]);
    	}

    	function onInput(...args) {
    		emit('input', [...args]);

    		if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && inputEl) {
    			validateInput();
    		}

    		if (inputEl && type !== 'texteditor' && type !== 'colorpicker' && type !== 'datepicker') {
    			$$invalidate(0, value = inputEl.value);
    		}
    	}

    	function onFocus(...args) {
    		emit('focus', [...args]);
    		$$invalidate(72, inputFocused = true);
    	}

    	function onBlur(...args) {
    		emit('blur', [...args]);

    		if ((validate || validate === '' || validateOnBlur || validateOnBlur === '') && inputEl) {
    			validateInput();
    		}

    		$$invalidate(72, inputFocused = false);
    	}

    	function onChange(...args) {
    		emit('change', [...args]);

    		if (type === 'texteditor') {
    			emit('textEditorChange', [args[0]]);
    			$$invalidate(0, value = args[1]);
    		}
    	}

    	onMount(() => {
    		f7ready(() => {
    			if (type === 'range' || type === 'toggle') return;
    			if (!inputEl) return;
    			inputEl.addEventListener('input:notempty', onInputNotEmpty, false);

    			if (type === 'textarea' && resizable) {
    				inputEl.addEventListener('textarea:resize', onTextareaResize, false);
    			}

    			if (clearButton) {
    				inputEl.addEventListener('input:empty', onInputEmpty, false);
    				inputEl.addEventListener('input:clear', onInputClear, false);
    			}

    			if (type === 'datepicker') {
    				f7Calendar = app$1.f7.calendar.create({
    					inputEl,
    					value,
    					on: {
    						change(calendar, calendarValue) {
    							emit('calendarChange', [calendarValue]);
    							$$invalidate(0, value = calendarValue);
    						}
    					},
    					...calendarParams || {}
    				});
    			}

    			if (type === 'colorpicker') {
    				f7ColorPicker = app$1.f7.colorPicker.create({
    					inputEl,
    					value,
    					on: {
    						change(colorPicker, colorPickerValue) {
    							emit('colorPickerChange', [colorPickerValue]);
    							$$invalidate(0, value = colorPickerValue);
    						}
    					},
    					...colorPickerParams || {}
    				});
    			}

    			app$1.f7.input.checkEmptyState(inputEl);

    			if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && typeof value !== 'undefined' && value !== null && value !== '') {
    				setTimeout(
    					() => {
    						validateInput();
    					},
    					0
    				);
    			}

    			if (resizable) {
    				app$1.f7.input.resizeTextarea(inputEl);
    			}
    		});
    	});

    	afterUpdate(() => {
    		if (!app$1.f7) return;

    		if (updateInputOnDidUpdate) {
    			if (!inputEl) return;
    			updateInputOnDidUpdate = false;
    			app$1.f7.input.checkEmptyState(inputEl);

    			if (validate && !validateOnBlur) {
    				validateInput();
    			}

    			if (resizable) {
    				app$1.f7.input.resizeTextarea(inputEl);
    			}
    		}
    	});

    	onDestroy(() => {
    		if (type === 'range' || type === 'toggle') return;
    		if (!inputEl) return;
    		inputEl.removeEventListener('input:notempty', onInputNotEmpty, false);

    		if (type === 'textarea' && resizable) {
    			inputEl.removeEventListener('textarea:resize', onTextareaResize, false);
    		}

    		if (clearButton) {
    			inputEl.removeEventListener('input:empty', onInputEmpty, false);
    			inputEl.removeEventListener('input:clear', onInputClear, false);
    		}

    		if (f7Calendar && f7Calendar.destroy) {
    			f7Calendar.destroy();
    		}

    		if (f7ColorPicker && f7ColorPicker.destroy) {
    			f7ColorPicker.destroy();
    		}

    		f7Calendar = null;
    		f7ColorPicker = null;
    	});

    	function select_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(41, inputEl);
    		});
    	}

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(41, inputEl);
    		});
    	}

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(41, inputEl);
    		});
    	}

    	function select_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(41, inputEl);
    		});
    	}

    	function textarea_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(41, inputEl);
    		});
    	}

    	function input_1_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(41, inputEl);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(100, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(56, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(57, className = $$new_props.class);
    		if ('sortable' in $$new_props) $$invalidate(58, sortable = $$new_props.sortable);
    		if ('sortableOpposite' in $$new_props) $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
    		if ('media' in $$new_props) $$invalidate(1, media = $$new_props.media);
    		if ('dropdown' in $$new_props) $$invalidate(60, dropdown = $$new_props.dropdown);
    		if ('wrap' in $$new_props) $$invalidate(2, wrap = $$new_props.wrap);
    		if ('input' in $$new_props) $$invalidate(3, input = $$new_props.input);
    		if ('type' in $$new_props) $$invalidate(4, type = $$new_props.type);
    		if ('name' in $$new_props) $$invalidate(5, name = $$new_props.name);
    		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ('inputmode' in $$new_props) $$invalidate(6, inputmode = $$new_props.inputmode);
    		if ('readonly' in $$new_props) $$invalidate(7, readonly = $$new_props.readonly);
    		if ('required' in $$new_props) $$invalidate(8, required = $$new_props.required);
    		if ('disabled' in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
    		if ('placeholder' in $$new_props) $$invalidate(10, placeholder = $$new_props.placeholder);
    		if ('inputId' in $$new_props) $$invalidate(11, inputId = $$new_props.inputId);
    		if ('size' in $$new_props) $$invalidate(12, size = $$new_props.size);
    		if ('accept' in $$new_props) $$invalidate(13, accept = $$new_props.accept);
    		if ('autocomplete' in $$new_props) $$invalidate(14, autocomplete = $$new_props.autocomplete);
    		if ('autocorrect' in $$new_props) $$invalidate(15, autocorrect = $$new_props.autocorrect);
    		if ('autocapitalize' in $$new_props) $$invalidate(16, autocapitalize = $$new_props.autocapitalize);
    		if ('spellcheck' in $$new_props) $$invalidate(17, spellcheck = $$new_props.spellcheck);
    		if ('autofocus' in $$new_props) $$invalidate(18, autofocus = $$new_props.autofocus);
    		if ('autosave' in $$new_props) $$invalidate(19, autosave = $$new_props.autosave);
    		if ('max' in $$new_props) $$invalidate(20, max = $$new_props.max);
    		if ('min' in $$new_props) $$invalidate(21, min = $$new_props.min);
    		if ('step' in $$new_props) $$invalidate(22, step = $$new_props.step);
    		if ('maxlength' in $$new_props) $$invalidate(23, maxlength = $$new_props.maxlength);
    		if ('minlength' in $$new_props) $$invalidate(24, minlength = $$new_props.minlength);
    		if ('multiple' in $$new_props) $$invalidate(25, multiple = $$new_props.multiple);
    		if ('inputStyle' in $$new_props) $$invalidate(26, inputStyle = $$new_props.inputStyle);
    		if ('pattern' in $$new_props) $$invalidate(27, pattern = $$new_props.pattern);
    		if ('validate' in $$new_props) $$invalidate(28, validate = $$new_props.validate);
    		if ('validateOnBlur' in $$new_props) $$invalidate(29, validateOnBlur = $$new_props.validateOnBlur);
    		if ('onValidate' in $$new_props) $$invalidate(61, onValidate = $$new_props.onValidate);
    		if ('tabindex' in $$new_props) $$invalidate(30, tabindex = $$new_props.tabindex);
    		if ('resizable' in $$new_props) $$invalidate(31, resizable = $$new_props.resizable);
    		if ('clearButton' in $$new_props) $$invalidate(32, clearButton = $$new_props.clearButton);
    		if ('noFormStoreData' in $$new_props) $$invalidate(62, noFormStoreData = $$new_props.noFormStoreData);
    		if ('noStoreData' in $$new_props) $$invalidate(63, noStoreData = $$new_props.noStoreData);
    		if ('ignoreStoreData' in $$new_props) $$invalidate(64, ignoreStoreData = $$new_props.ignoreStoreData);
    		if ('errorMessage' in $$new_props) $$invalidate(33, errorMessage = $$new_props.errorMessage);
    		if ('errorMessageForce' in $$new_props) $$invalidate(34, errorMessageForce = $$new_props.errorMessageForce);
    		if ('info' in $$new_props) $$invalidate(35, info = $$new_props.info);
    		if ('outline' in $$new_props) $$invalidate(65, outline = $$new_props.outline);
    		if ('label' in $$new_props) $$invalidate(36, label = $$new_props.label);
    		if ('inlineLabel' in $$new_props) $$invalidate(66, inlineLabel = $$new_props.inlineLabel);
    		if ('floatingLabel' in $$new_props) $$invalidate(67, floatingLabel = $$new_props.floatingLabel);
    		if ('calendarParams' in $$new_props) $$invalidate(68, calendarParams = $$new_props.calendarParams);
    		if ('colorPickerParams' in $$new_props) $$invalidate(69, colorPickerParams = $$new_props.colorPickerParams);
    		if ('textEditorParams' in $$new_props) $$invalidate(37, textEditorParams = $$new_props.textEditorParams);
    		if ('$$scope' in $$new_props) $$invalidate(76, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		afterUpdate,
    		onDestroy,
    		colorClasses,
    		classNames,
    		extend,
    		plainText,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		getReactiveContext,
    		TextEditor: Text_editor,
    		emit,
    		className,
    		sortable,
    		sortableOpposite,
    		media,
    		dropdown,
    		wrap,
    		input,
    		type,
    		name,
    		value,
    		inputmode,
    		readonly,
    		required,
    		disabled,
    		placeholder,
    		inputId,
    		size,
    		accept,
    		autocomplete,
    		autocorrect,
    		autocapitalize,
    		spellcheck,
    		autofocus,
    		autosave,
    		max,
    		min,
    		step,
    		maxlength,
    		minlength,
    		multiple,
    		inputStyle,
    		pattern,
    		validate,
    		validateOnBlur,
    		onValidate,
    		tabindex,
    		resizable,
    		clearButton,
    		noFormStoreData,
    		noStoreData,
    		ignoreStoreData,
    		errorMessage,
    		errorMessageForce,
    		info,
    		outline,
    		label,
    		inlineLabel,
    		floatingLabel,
    		calendarParams,
    		colorPickerParams,
    		textEditorParams,
    		inputEl,
    		inputFocused,
    		inputInvalid,
    		updateInputOnDidUpdate,
    		f7Calendar,
    		f7ColorPicker,
    		calendarInstance,
    		colorPickerInstance,
    		ListContext,
    		domValue,
    		inputHasValue,
    		validateInput,
    		initialWatched,
    		watchValue,
    		watchColorPickerParams,
    		watchCalendarParams,
    		onTextareaResize,
    		onInputNotEmpty,
    		onInputEmpty,
    		onInputClear,
    		onInput,
    		onFocus,
    		onBlur,
    		onChange,
    		classes,
    		inputWrapClasses,
    		labelClasses,
    		hasErrorMessage,
    		hasInfoSlots,
    		itemContentClasses,
    		inputType,
    		inputClasses,
    		hasErrorSlots,
    		hasLabelSlots,
    		hasMediaSlots,
    		inputValue,
    		needsValue,
    		isSortableOpposite,
    		isSortable
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(100, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(57, className = $$new_props.className);
    		if ('sortable' in $$props) $$invalidate(58, sortable = $$new_props.sortable);
    		if ('sortableOpposite' in $$props) $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
    		if ('media' in $$props) $$invalidate(1, media = $$new_props.media);
    		if ('dropdown' in $$props) $$invalidate(60, dropdown = $$new_props.dropdown);
    		if ('wrap' in $$props) $$invalidate(2, wrap = $$new_props.wrap);
    		if ('input' in $$props) $$invalidate(3, input = $$new_props.input);
    		if ('type' in $$props) $$invalidate(4, type = $$new_props.type);
    		if ('name' in $$props) $$invalidate(5, name = $$new_props.name);
    		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
    		if ('inputmode' in $$props) $$invalidate(6, inputmode = $$new_props.inputmode);
    		if ('readonly' in $$props) $$invalidate(7, readonly = $$new_props.readonly);
    		if ('required' in $$props) $$invalidate(8, required = $$new_props.required);
    		if ('disabled' in $$props) $$invalidate(9, disabled = $$new_props.disabled);
    		if ('placeholder' in $$props) $$invalidate(10, placeholder = $$new_props.placeholder);
    		if ('inputId' in $$props) $$invalidate(11, inputId = $$new_props.inputId);
    		if ('size' in $$props) $$invalidate(12, size = $$new_props.size);
    		if ('accept' in $$props) $$invalidate(13, accept = $$new_props.accept);
    		if ('autocomplete' in $$props) $$invalidate(14, autocomplete = $$new_props.autocomplete);
    		if ('autocorrect' in $$props) $$invalidate(15, autocorrect = $$new_props.autocorrect);
    		if ('autocapitalize' in $$props) $$invalidate(16, autocapitalize = $$new_props.autocapitalize);
    		if ('spellcheck' in $$props) $$invalidate(17, spellcheck = $$new_props.spellcheck);
    		if ('autofocus' in $$props) $$invalidate(18, autofocus = $$new_props.autofocus);
    		if ('autosave' in $$props) $$invalidate(19, autosave = $$new_props.autosave);
    		if ('max' in $$props) $$invalidate(20, max = $$new_props.max);
    		if ('min' in $$props) $$invalidate(21, min = $$new_props.min);
    		if ('step' in $$props) $$invalidate(22, step = $$new_props.step);
    		if ('maxlength' in $$props) $$invalidate(23, maxlength = $$new_props.maxlength);
    		if ('minlength' in $$props) $$invalidate(24, minlength = $$new_props.minlength);
    		if ('multiple' in $$props) $$invalidate(25, multiple = $$new_props.multiple);
    		if ('inputStyle' in $$props) $$invalidate(26, inputStyle = $$new_props.inputStyle);
    		if ('pattern' in $$props) $$invalidate(27, pattern = $$new_props.pattern);
    		if ('validate' in $$props) $$invalidate(28, validate = $$new_props.validate);
    		if ('validateOnBlur' in $$props) $$invalidate(29, validateOnBlur = $$new_props.validateOnBlur);
    		if ('onValidate' in $$props) $$invalidate(61, onValidate = $$new_props.onValidate);
    		if ('tabindex' in $$props) $$invalidate(30, tabindex = $$new_props.tabindex);
    		if ('resizable' in $$props) $$invalidate(31, resizable = $$new_props.resizable);
    		if ('clearButton' in $$props) $$invalidate(32, clearButton = $$new_props.clearButton);
    		if ('noFormStoreData' in $$props) $$invalidate(62, noFormStoreData = $$new_props.noFormStoreData);
    		if ('noStoreData' in $$props) $$invalidate(63, noStoreData = $$new_props.noStoreData);
    		if ('ignoreStoreData' in $$props) $$invalidate(64, ignoreStoreData = $$new_props.ignoreStoreData);
    		if ('errorMessage' in $$props) $$invalidate(33, errorMessage = $$new_props.errorMessage);
    		if ('errorMessageForce' in $$props) $$invalidate(34, errorMessageForce = $$new_props.errorMessageForce);
    		if ('info' in $$props) $$invalidate(35, info = $$new_props.info);
    		if ('outline' in $$props) $$invalidate(65, outline = $$new_props.outline);
    		if ('label' in $$props) $$invalidate(36, label = $$new_props.label);
    		if ('inlineLabel' in $$props) $$invalidate(66, inlineLabel = $$new_props.inlineLabel);
    		if ('floatingLabel' in $$props) $$invalidate(67, floatingLabel = $$new_props.floatingLabel);
    		if ('calendarParams' in $$props) $$invalidate(68, calendarParams = $$new_props.calendarParams);
    		if ('colorPickerParams' in $$props) $$invalidate(69, colorPickerParams = $$new_props.colorPickerParams);
    		if ('textEditorParams' in $$props) $$invalidate(37, textEditorParams = $$new_props.textEditorParams);
    		if ('inputEl' in $$props) $$invalidate(41, inputEl = $$new_props.inputEl);
    		if ('inputFocused' in $$props) $$invalidate(72, inputFocused = $$new_props.inputFocused);
    		if ('inputInvalid' in $$props) $$invalidate(73, inputInvalid = $$new_props.inputInvalid);
    		if ('updateInputOnDidUpdate' in $$props) updateInputOnDidUpdate = $$new_props.updateInputOnDidUpdate;
    		if ('f7Calendar' in $$props) f7Calendar = $$new_props.f7Calendar;
    		if ('f7ColorPicker' in $$props) f7ColorPicker = $$new_props.f7ColorPicker;
    		if ('ListContext' in $$props) $$invalidate(74, ListContext = $$new_props.ListContext);
    		if ('initialWatched' in $$props) initialWatched = $$new_props.initialWatched;
    		if ('classes' in $$props) $$invalidate(42, classes = $$new_props.classes);
    		if ('inputWrapClasses' in $$props) $$invalidate(43, inputWrapClasses = $$new_props.inputWrapClasses);
    		if ('labelClasses' in $$props) $$invalidate(44, labelClasses = $$new_props.labelClasses);
    		if ('hasErrorMessage' in $$props) $$invalidate(38, hasErrorMessage = $$new_props.hasErrorMessage);
    		if ('hasInfoSlots' in $$props) $$invalidate(39, hasInfoSlots = $$new_props.hasInfoSlots);
    		if ('itemContentClasses' in $$props) $$invalidate(45, itemContentClasses = $$new_props.itemContentClasses);
    		if ('inputType' in $$props) $$invalidate(40, inputType = $$new_props.inputType);
    		if ('inputClasses' in $$props) $$invalidate(46, inputClasses = $$new_props.inputClasses);
    		if ('hasErrorSlots' in $$props) $$invalidate(75, hasErrorSlots = $$new_props.hasErrorSlots);
    		if ('hasLabelSlots' in $$props) $$invalidate(47, hasLabelSlots = $$new_props.hasLabelSlots);
    		if ('hasMediaSlots' in $$props) $$invalidate(48, hasMediaSlots = $$new_props.hasMediaSlots);
    		if ('inputValue' in $$props) $$invalidate(49, inputValue = $$new_props.inputValue);
    		if ('needsValue' in $$props) needsValue = $$new_props.needsValue;
    		if ('isSortableOpposite' in $$props) $$invalidate(50, isSortableOpposite = $$new_props.isSortableOpposite);
    		if ('isSortable' in $$props) $$invalidate(51, isSortable = $$new_props.isSortable);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[1] & /*sortable*/ 134217728 | $$self.$$.dirty[2] & /*ListContext*/ 4096) {
    			$$invalidate(51, isSortable = sortable === true || sortable === false
    			? sortable
    			: ListContext.listIsSortable);
    		}

    		if ($$self.$$.dirty[1] & /*sortableOpposite*/ 268435456 | $$self.$$.dirty[2] & /*ListContext*/ 4096) {
    			$$invalidate(50, isSortableOpposite = sortableOpposite || ListContext.listIsSortableOpposite);
    		}

    		if ($$self.$$.dirty[0] & /*value*/ 1) {
    			watchValue();
    		}

    		if ($$self.$$.dirty[2] & /*colorPickerParams*/ 128) {
    			watchColorPickerParams();
    		}

    		if ($$self.$$.dirty[2] & /*calendarParams*/ 64) {
    			watchCalendarParams();
    		}

    		if ($$self.$$.dirty[0] & /*type*/ 16) {
    			$$invalidate(40, inputType = type === 'datepicker' || type === 'colorpicker'
    			? 'text'
    			: type);
    		}

    		if ($$self.$$.dirty[0] & /*type*/ 16) {
    			needsValue = type !== 'file' && type !== 'datepicker' && type !== 'colorpicker';
    		}

    		if ($$self.$$.dirty[0] & /*value*/ 1) {
    			$$invalidate(49, inputValue = (() => {
    				let v;

    				if (typeof value !== 'undefined') {
    					v = value;
    				} else {
    					v = domValue();
    				}

    				if (typeof v === 'undefined' || v === null) return '';
    				return v;
    			})());
    		}

    		if ($$self.$$.dirty[1] & /*errorMessage*/ 4 | $$self.$$.dirty[2] & /*hasErrorSlots*/ 8192) {
    			$$invalidate(38, hasErrorMessage = !!errorMessage || hasErrorSlots);
    		}

    		if ($$self.$$.dirty[1] & /*inputType, resizable, errorMessage, errorMessageForce*/ 525 | $$self.$$.dirty[2] & /*noFormStoreData, noStoreData, ignoreStoreData, inputInvalid, inputFocused*/ 3079) {
    			$$invalidate(46, inputClasses = classNames({
    				resizable: inputType === 'textarea' && resizable,
    				'no-store-data': noFormStoreData || noStoreData || ignoreStoreData,
    				'input-invalid': errorMessage && errorMessageForce || inputInvalid,
    				'input-with-value': inputHasValue(),
    				'input-focused': inputFocused
    			}));
    		}

    		$$invalidate(45, itemContentClasses = classNames('item-content item-input', !wrap && className, !wrap && { disabled }, !wrap && colorClasses($$props), {
    			'inline-label': inlineLabel,
    			'item-input-outline': outline,
    			'item-input-focused': inputFocused,
    			'item-input-with-info': !!info || hasInfoSlots,
    			'item-input-with-value': inputHasValue(),
    			'item-input-with-error-message': hasErrorMessage && errorMessageForce || inputInvalid,
    			'item-input-invalid': hasErrorMessage && errorMessageForce || inputInvalid
    		}));

    		if ($$self.$$.dirty[2] & /*floatingLabel*/ 32) {
    			$$invalidate(44, labelClasses = classNames('item-title item-label', { 'item-floating-label': floatingLabel }));
    		}

    		if ($$self.$$.dirty[0] & /*type*/ 16 | $$self.$$.dirty[1] & /*dropdown*/ 536870912) {
    			$$invalidate(43, inputWrapClasses = classNames('item-input-wrap', {
    				'input-dropdown': dropdown === 'auto' ? type === 'select' : dropdown
    			}));
    		}

    		$$invalidate(42, classes = classNames(className, { disabled }, colorClasses($$props)));
    	};

    	$$invalidate(39, hasInfoSlots = $$slots.info);
    	$$invalidate(75, hasErrorSlots = $$slots['error-message']);
    	$$invalidate(48, hasMediaSlots = $$slots.media);
    	$$invalidate(47, hasLabelSlots = $$slots.label);
    	$$props = exclude_internal_props($$props);

    	return [
    		value,
    		media,
    		wrap,
    		input,
    		type,
    		name,
    		inputmode,
    		readonly,
    		required,
    		disabled,
    		placeholder,
    		inputId,
    		size,
    		accept,
    		autocomplete,
    		autocorrect,
    		autocapitalize,
    		spellcheck,
    		autofocus,
    		autosave,
    		max,
    		min,
    		step,
    		maxlength,
    		minlength,
    		multiple,
    		inputStyle,
    		pattern,
    		validate,
    		validateOnBlur,
    		tabindex,
    		resizable,
    		clearButton,
    		errorMessage,
    		errorMessageForce,
    		info,
    		label,
    		textEditorParams,
    		hasErrorMessage,
    		hasInfoSlots,
    		inputType,
    		inputEl,
    		classes,
    		inputWrapClasses,
    		labelClasses,
    		itemContentClasses,
    		inputClasses,
    		hasLabelSlots,
    		hasMediaSlots,
    		inputValue,
    		isSortableOpposite,
    		isSortable,
    		onInput,
    		onFocus,
    		onBlur,
    		onChange,
    		$$restProps,
    		className,
    		sortable,
    		sortableOpposite,
    		dropdown,
    		onValidate,
    		noFormStoreData,
    		noStoreData,
    		ignoreStoreData,
    		outline,
    		inlineLabel,
    		floatingLabel,
    		calendarParams,
    		colorPickerParams,
    		calendarInstance,
    		colorPickerInstance,
    		inputFocused,
    		inputInvalid,
    		ListContext,
    		hasErrorSlots,
    		$$scope,
    		slots,
    		select_binding,
    		textarea_binding,
    		input_1_binding,
    		select_binding_1,
    		textarea_binding_1,
    		input_1_binding_1
    	];
    }

    class List_input extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$g,
    			create_fragment$i,
    			safe_not_equal,
    			{
    				class: 57,
    				sortable: 58,
    				sortableOpposite: 59,
    				media: 1,
    				dropdown: 60,
    				wrap: 2,
    				input: 3,
    				type: 4,
    				name: 5,
    				value: 0,
    				inputmode: 6,
    				readonly: 7,
    				required: 8,
    				disabled: 9,
    				placeholder: 10,
    				inputId: 11,
    				size: 12,
    				accept: 13,
    				autocomplete: 14,
    				autocorrect: 15,
    				autocapitalize: 16,
    				spellcheck: 17,
    				autofocus: 18,
    				autosave: 19,
    				max: 20,
    				min: 21,
    				step: 22,
    				maxlength: 23,
    				minlength: 24,
    				multiple: 25,
    				inputStyle: 26,
    				pattern: 27,
    				validate: 28,
    				validateOnBlur: 29,
    				onValidate: 61,
    				tabindex: 30,
    				resizable: 31,
    				clearButton: 32,
    				noFormStoreData: 62,
    				noStoreData: 63,
    				ignoreStoreData: 64,
    				errorMessage: 33,
    				errorMessageForce: 34,
    				info: 35,
    				outline: 65,
    				label: 36,
    				inlineLabel: 66,
    				floatingLabel: 67,
    				calendarParams: 68,
    				colorPickerParams: 69,
    				textEditorParams: 37,
    				calendarInstance: 70,
    				colorPickerInstance: 71
    			},
    			null,
    			[-1, -1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List_input",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get class() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortable() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortable(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortableOpposite() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortableOpposite(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get media() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set media(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dropdown() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dropdown(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrap() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrap(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputmode() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputmode(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readonly() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readonly(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputId() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputId(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accept() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accept(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autocomplete() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autocomplete(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autocorrect() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autocorrect(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autocapitalize() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autocapitalize(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get spellcheck() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set spellcheck(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autofocus() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autofocus(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autosave() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autosave(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get step() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set step(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxlength() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxlength(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minlength() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minlength(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiple() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiple(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputStyle() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputStyle(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pattern() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pattern(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get validate() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set validate(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get validateOnBlur() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set validateOnBlur(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onValidate() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onValidate(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resizable() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resizable(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get clearButton() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set clearButton(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noFormStoreData() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noFormStoreData(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noStoreData() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noStoreData(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ignoreStoreData() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ignoreStoreData(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get errorMessage() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errorMessage(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get errorMessageForce() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errorMessageForce(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get info() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set info(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outline() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outline(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inlineLabel() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inlineLabel(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get floatingLabel() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set floatingLabel(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get calendarParams() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set calendarParams(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get colorPickerParams() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colorPickerParams(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get textEditorParams() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set textEditorParams(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get calendarInstance() {
    		return this.$$.ctx[70];
    	}

    	set calendarInstance(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get colorPickerInstance() {
    		return this.$$.ctx[71];
    	}

    	set colorPickerInstance(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/list-item.svelte generated by Svelte v3.44.0 */
    const file$g = "node_modules/framework7-svelte/esm/svelte/list-item.svelte";
    const get_root_end_slot_changes = dirty => ({});
    const get_root_end_slot_context = ctx => ({});
    const get_root_slot_changes = dirty => ({});
    const get_root_slot_context = ctx => ({});
    const get_content_end_slot_changes_5 = dirty => ({});
    const get_content_end_slot_context_5 = ctx => ({});
    const get_content_slot_changes_5 = dirty => ({});
    const get_content_slot_context_5 = ctx => ({});
    const get_inner_end_slot_changes_5 = dirty => ({});
    const get_inner_end_slot_context_5 = ctx => ({});
    const get_inner_slot_changes_11 = dirty => ({});
    const get_inner_slot_context_11 = ctx => ({});
    const get_after_end_slot_changes_11 = dirty => ({});
    const get_after_end_slot_context_11 = ctx => ({});
    const get_after_slot_changes_11 = dirty => ({});
    const get_after_slot_context_11 = ctx => ({});
    const get_after_start_slot_changes_11 = dirty => ({});
    const get_after_start_slot_context_11 = ctx => ({});
    const get_after_title_slot_changes_11 = dirty => ({});
    const get_after_title_slot_context_11 = ctx => ({});
    const get_footer_slot_changes_11 = dirty => ({});
    const get_footer_slot_context_11 = ctx => ({});
    const get_title_slot_changes_11 = dirty => ({});
    const get_title_slot_context_11 = ctx => ({});
    const get_header_slot_changes_11 = dirty => ({});
    const get_header_slot_context_11 = ctx => ({});
    const get_before_title_slot_changes_11 = dirty => ({});
    const get_before_title_slot_context_11 = ctx => ({});
    const get_footer_slot_changes_10 = dirty => ({});
    const get_footer_slot_context_10 = ctx => ({});
    const get_inner_slot_changes_10 = dirty => ({});
    const get_inner_slot_context_10 = ctx => ({});
    const get_text_slot_changes_5 = dirty => ({});
    const get_text_slot_context_5 = ctx => ({});
    const get_subtitle_slot_changes_5 = dirty => ({});
    const get_subtitle_slot_context_5 = ctx => ({});
    const get_after_end_slot_changes_10 = dirty => ({});
    const get_after_end_slot_context_10 = ctx => ({});
    const get_after_slot_changes_10 = dirty => ({});
    const get_after_slot_context_10 = ctx => ({});
    const get_after_start_slot_changes_10 = dirty => ({});
    const get_after_start_slot_context_10 = ctx => ({});
    const get_after_title_slot_changes_10 = dirty => ({});
    const get_after_title_slot_context_10 = ctx => ({});
    const get_title_slot_changes_10 = dirty => ({});
    const get_title_slot_context_10 = ctx => ({});
    const get_before_title_slot_changes_10 = dirty => ({});
    const get_before_title_slot_context_10 = ctx => ({});
    const get_header_slot_changes_10 = dirty => ({});
    const get_header_slot_context_10 = ctx => ({});
    const get_inner_start_slot_changes_5 = dirty => ({});
    const get_inner_start_slot_context_5 = ctx => ({});
    const get_media_slot_changes_5 = dirty => ({});
    const get_media_slot_context_5 = ctx => ({});
    const get_content_start_slot_changes_5 = dirty => ({});
    const get_content_start_slot_context_5 = ctx => ({});
    const get_content_end_slot_changes_4 = dirty => ({});
    const get_content_end_slot_context_4 = ctx => ({});
    const get_content_slot_changes_4 = dirty => ({});
    const get_content_slot_context_4 = ctx => ({});
    const get_inner_end_slot_changes_4 = dirty => ({});
    const get_inner_end_slot_context_4 = ctx => ({});
    const get_inner_slot_changes_9 = dirty => ({});
    const get_inner_slot_context_9 = ctx => ({});
    const get_after_end_slot_changes_9 = dirty => ({});
    const get_after_end_slot_context_9 = ctx => ({});
    const get_after_slot_changes_9 = dirty => ({});
    const get_after_slot_context_9 = ctx => ({});
    const get_after_start_slot_changes_9 = dirty => ({});
    const get_after_start_slot_context_9 = ctx => ({});
    const get_after_title_slot_changes_9 = dirty => ({});
    const get_after_title_slot_context_9 = ctx => ({});
    const get_footer_slot_changes_9 = dirty => ({});
    const get_footer_slot_context_9 = ctx => ({});
    const get_title_slot_changes_9 = dirty => ({});
    const get_title_slot_context_9 = ctx => ({});
    const get_header_slot_changes_9 = dirty => ({});
    const get_header_slot_context_9 = ctx => ({});
    const get_before_title_slot_changes_9 = dirty => ({});
    const get_before_title_slot_context_9 = ctx => ({});
    const get_footer_slot_changes_8 = dirty => ({});
    const get_footer_slot_context_8 = ctx => ({});
    const get_inner_slot_changes_8 = dirty => ({});
    const get_inner_slot_context_8 = ctx => ({});
    const get_text_slot_changes_4 = dirty => ({});
    const get_text_slot_context_4 = ctx => ({});
    const get_subtitle_slot_changes_4 = dirty => ({});
    const get_subtitle_slot_context_4 = ctx => ({});
    const get_after_end_slot_changes_8 = dirty => ({});
    const get_after_end_slot_context_8 = ctx => ({});
    const get_after_slot_changes_8 = dirty => ({});
    const get_after_slot_context_8 = ctx => ({});
    const get_after_start_slot_changes_8 = dirty => ({});
    const get_after_start_slot_context_8 = ctx => ({});
    const get_after_title_slot_changes_8 = dirty => ({});
    const get_after_title_slot_context_8 = ctx => ({});
    const get_title_slot_changes_8 = dirty => ({});
    const get_title_slot_context_8 = ctx => ({});
    const get_before_title_slot_changes_8 = dirty => ({});
    const get_before_title_slot_context_8 = ctx => ({});
    const get_header_slot_changes_8 = dirty => ({});
    const get_header_slot_context_8 = ctx => ({});
    const get_inner_start_slot_changes_4 = dirty => ({});
    const get_inner_start_slot_context_4 = ctx => ({});
    const get_media_slot_changes_4 = dirty => ({});
    const get_media_slot_context_4 = ctx => ({});
    const get_content_start_slot_changes_4 = dirty => ({});
    const get_content_start_slot_context_4 = ctx => ({});
    const get_content_end_slot_changes_3 = dirty => ({});
    const get_content_end_slot_context_3 = ctx => ({});
    const get_content_slot_changes_3 = dirty => ({});
    const get_content_slot_context_3 = ctx => ({});
    const get_inner_end_slot_changes_3 = dirty => ({});
    const get_inner_end_slot_context_3 = ctx => ({});
    const get_inner_slot_changes_7 = dirty => ({});
    const get_inner_slot_context_7 = ctx => ({});
    const get_after_end_slot_changes_7 = dirty => ({});
    const get_after_end_slot_context_7 = ctx => ({});
    const get_after_slot_changes_7 = dirty => ({});
    const get_after_slot_context_7 = ctx => ({});
    const get_after_start_slot_changes_7 = dirty => ({});
    const get_after_start_slot_context_7 = ctx => ({});
    const get_after_title_slot_changes_7 = dirty => ({});
    const get_after_title_slot_context_7 = ctx => ({});
    const get_footer_slot_changes_7 = dirty => ({});
    const get_footer_slot_context_7 = ctx => ({});
    const get_title_slot_changes_7 = dirty => ({});
    const get_title_slot_context_7 = ctx => ({});
    const get_header_slot_changes_7 = dirty => ({});
    const get_header_slot_context_7 = ctx => ({});
    const get_before_title_slot_changes_7 = dirty => ({});
    const get_before_title_slot_context_7 = ctx => ({});
    const get_footer_slot_changes_6 = dirty => ({});
    const get_footer_slot_context_6 = ctx => ({});
    const get_inner_slot_changes_6 = dirty => ({});
    const get_inner_slot_context_6 = ctx => ({});
    const get_text_slot_changes_3 = dirty => ({});
    const get_text_slot_context_3 = ctx => ({});
    const get_subtitle_slot_changes_3 = dirty => ({});
    const get_subtitle_slot_context_3 = ctx => ({});
    const get_after_end_slot_changes_6 = dirty => ({});
    const get_after_end_slot_context_6 = ctx => ({});
    const get_after_slot_changes_6 = dirty => ({});
    const get_after_slot_context_6 = ctx => ({});
    const get_after_start_slot_changes_6 = dirty => ({});
    const get_after_start_slot_context_6 = ctx => ({});
    const get_after_title_slot_changes_6 = dirty => ({});
    const get_after_title_slot_context_6 = ctx => ({});
    const get_title_slot_changes_6 = dirty => ({});
    const get_title_slot_context_6 = ctx => ({});
    const get_before_title_slot_changes_6 = dirty => ({});
    const get_before_title_slot_context_6 = ctx => ({});
    const get_header_slot_changes_6 = dirty => ({});
    const get_header_slot_context_6 = ctx => ({});
    const get_inner_start_slot_changes_3 = dirty => ({});
    const get_inner_start_slot_context_3 = ctx => ({});
    const get_media_slot_changes_3 = dirty => ({});
    const get_media_slot_context_3 = ctx => ({});
    const get_content_start_slot_changes_3 = dirty => ({});
    const get_content_start_slot_context_3 = ctx => ({});
    const get_content_end_slot_changes_2 = dirty => ({});
    const get_content_end_slot_context_2 = ctx => ({});
    const get_content_slot_changes_2 = dirty => ({});
    const get_content_slot_context_2 = ctx => ({});
    const get_inner_end_slot_changes_2 = dirty => ({});
    const get_inner_end_slot_context_2 = ctx => ({});
    const get_inner_slot_changes_5 = dirty => ({});
    const get_inner_slot_context_5 = ctx => ({});
    const get_after_end_slot_changes_5 = dirty => ({});
    const get_after_end_slot_context_5 = ctx => ({});
    const get_after_slot_changes_5 = dirty => ({});
    const get_after_slot_context_5 = ctx => ({});
    const get_after_start_slot_changes_5 = dirty => ({});
    const get_after_start_slot_context_5 = ctx => ({});
    const get_after_title_slot_changes_5 = dirty => ({});
    const get_after_title_slot_context_5 = ctx => ({});
    const get_footer_slot_changes_5 = dirty => ({});
    const get_footer_slot_context_5 = ctx => ({});
    const get_title_slot_changes_5 = dirty => ({});
    const get_title_slot_context_5 = ctx => ({});
    const get_header_slot_changes_5 = dirty => ({});
    const get_header_slot_context_5 = ctx => ({});
    const get_before_title_slot_changes_5 = dirty => ({});
    const get_before_title_slot_context_5 = ctx => ({});
    const get_footer_slot_changes_4 = dirty => ({});
    const get_footer_slot_context_4 = ctx => ({});
    const get_inner_slot_changes_4 = dirty => ({});
    const get_inner_slot_context_4 = ctx => ({});
    const get_text_slot_changes_2 = dirty => ({});
    const get_text_slot_context_2 = ctx => ({});
    const get_subtitle_slot_changes_2 = dirty => ({});
    const get_subtitle_slot_context_2 = ctx => ({});
    const get_after_end_slot_changes_4 = dirty => ({});
    const get_after_end_slot_context_4 = ctx => ({});
    const get_after_slot_changes_4 = dirty => ({});
    const get_after_slot_context_4 = ctx => ({});
    const get_after_start_slot_changes_4 = dirty => ({});
    const get_after_start_slot_context_4 = ctx => ({});
    const get_after_title_slot_changes_4 = dirty => ({});
    const get_after_title_slot_context_4 = ctx => ({});
    const get_title_slot_changes_4 = dirty => ({});
    const get_title_slot_context_4 = ctx => ({});
    const get_before_title_slot_changes_4 = dirty => ({});
    const get_before_title_slot_context_4 = ctx => ({});
    const get_header_slot_changes_4 = dirty => ({});
    const get_header_slot_context_4 = ctx => ({});
    const get_inner_start_slot_changes_2 = dirty => ({});
    const get_inner_start_slot_context_2 = ctx => ({});
    const get_media_slot_changes_2 = dirty => ({});
    const get_media_slot_context_2 = ctx => ({});
    const get_content_start_slot_changes_2 = dirty => ({});
    const get_content_start_slot_context_2 = ctx => ({});
    const get_content_end_slot_changes_1 = dirty => ({});
    const get_content_end_slot_context_1 = ctx => ({});
    const get_content_slot_changes_1 = dirty => ({});
    const get_content_slot_context_1 = ctx => ({});
    const get_inner_end_slot_changes_1 = dirty => ({});
    const get_inner_end_slot_context_1 = ctx => ({});
    const get_inner_slot_changes_3 = dirty => ({});
    const get_inner_slot_context_3 = ctx => ({});
    const get_after_end_slot_changes_3 = dirty => ({});
    const get_after_end_slot_context_3 = ctx => ({});
    const get_after_slot_changes_3 = dirty => ({});
    const get_after_slot_context_3 = ctx => ({});
    const get_after_start_slot_changes_3 = dirty => ({});
    const get_after_start_slot_context_3 = ctx => ({});
    const get_after_title_slot_changes_3 = dirty => ({});
    const get_after_title_slot_context_3 = ctx => ({});
    const get_footer_slot_changes_3 = dirty => ({});
    const get_footer_slot_context_3 = ctx => ({});
    const get_title_slot_changes_3 = dirty => ({});
    const get_title_slot_context_3 = ctx => ({});
    const get_header_slot_changes_3 = dirty => ({});
    const get_header_slot_context_3 = ctx => ({});
    const get_before_title_slot_changes_3 = dirty => ({});
    const get_before_title_slot_context_3 = ctx => ({});
    const get_footer_slot_changes_2 = dirty => ({});
    const get_footer_slot_context_2 = ctx => ({});
    const get_inner_slot_changes_2 = dirty => ({});
    const get_inner_slot_context_2 = ctx => ({});
    const get_text_slot_changes_1 = dirty => ({});
    const get_text_slot_context_1 = ctx => ({});
    const get_subtitle_slot_changes_1 = dirty => ({});
    const get_subtitle_slot_context_1 = ctx => ({});
    const get_after_end_slot_changes_2 = dirty => ({});
    const get_after_end_slot_context_2 = ctx => ({});
    const get_after_slot_changes_2 = dirty => ({});
    const get_after_slot_context_2 = ctx => ({});
    const get_after_start_slot_changes_2 = dirty => ({});
    const get_after_start_slot_context_2 = ctx => ({});
    const get_after_title_slot_changes_2 = dirty => ({});
    const get_after_title_slot_context_2 = ctx => ({});
    const get_title_slot_changes_2 = dirty => ({});
    const get_title_slot_context_2 = ctx => ({});
    const get_before_title_slot_changes_2 = dirty => ({});
    const get_before_title_slot_context_2 = ctx => ({});
    const get_header_slot_changes_2 = dirty => ({});
    const get_header_slot_context_2 = ctx => ({});
    const get_inner_start_slot_changes_1 = dirty => ({});
    const get_inner_start_slot_context_1 = ctx => ({});
    const get_media_slot_changes_1 = dirty => ({});
    const get_media_slot_context_1 = ctx => ({});
    const get_content_start_slot_changes_1 = dirty => ({});
    const get_content_start_slot_context_1 = ctx => ({});
    const get_content_end_slot_changes = dirty => ({});
    const get_content_end_slot_context = ctx => ({});
    const get_content_slot_changes = dirty => ({});
    const get_content_slot_context = ctx => ({});
    const get_inner_end_slot_changes = dirty => ({});
    const get_inner_end_slot_context = ctx => ({});
    const get_inner_slot_changes_1 = dirty => ({});
    const get_inner_slot_context_1 = ctx => ({});
    const get_after_end_slot_changes_1 = dirty => ({});
    const get_after_end_slot_context_1 = ctx => ({});
    const get_after_slot_changes_1 = dirty => ({});
    const get_after_slot_context_1 = ctx => ({});
    const get_after_start_slot_changes_1 = dirty => ({});
    const get_after_start_slot_context_1 = ctx => ({});
    const get_after_title_slot_changes_1 = dirty => ({});
    const get_after_title_slot_context_1 = ctx => ({});
    const get_footer_slot_changes_1 = dirty => ({});
    const get_footer_slot_context_1 = ctx => ({});
    const get_title_slot_changes_1 = dirty => ({});
    const get_title_slot_context_1 = ctx => ({});
    const get_header_slot_changes_1 = dirty => ({});
    const get_header_slot_context_1 = ctx => ({});
    const get_before_title_slot_changes_1 = dirty => ({});
    const get_before_title_slot_context_1 = ctx => ({});
    const get_footer_slot_changes = dirty => ({});
    const get_footer_slot_context = ctx => ({});
    const get_inner_slot_changes = dirty => ({});
    const get_inner_slot_context = ctx => ({});
    const get_text_slot_changes = dirty => ({});
    const get_text_slot_context = ctx => ({});
    const get_subtitle_slot_changes = dirty => ({});
    const get_subtitle_slot_context = ctx => ({});
    const get_after_end_slot_changes = dirty => ({});
    const get_after_end_slot_context = ctx => ({});
    const get_after_slot_changes = dirty => ({});
    const get_after_slot_context = ctx => ({});
    const get_after_start_slot_changes = dirty => ({});
    const get_after_start_slot_context = ctx => ({});
    const get_after_title_slot_changes = dirty => ({});
    const get_after_title_slot_context = ctx => ({});
    const get_title_slot_changes$1 = dirty => ({});
    const get_title_slot_context$1 = ctx => ({});
    const get_before_title_slot_changes = dirty => ({});
    const get_before_title_slot_context = ctx => ({});
    const get_header_slot_changes = dirty => ({});
    const get_header_slot_context = ctx => ({});
    const get_inner_start_slot_changes = dirty => ({});
    const get_inner_start_slot_context = ctx => ({});
    const get_media_slot_changes = dirty => ({});
    const get_media_slot_context = ctx => ({});
    const get_content_start_slot_changes = dirty => ({});
    const get_content_start_slot_context = ctx => ({});
    const get_root_start_slot_changes = dirty => ({});
    const get_root_start_slot_context = ctx => ({});

    // (341:0) {:else}
    function create_else_block$5(ctx) {
    	let li;
    	let t0;
    	let current_block_type_index;
    	let if_block0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let useTooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	const root_start_slot_template = /*#slots*/ ctx[69]["root-start"];
    	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[83], get_root_start_slot_context);
    	const if_block_creators = [create_if_block_4, create_if_block_67, create_else_block_7];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*swipeout*/ ctx[14]) return 0;
    		if (/*isLink*/ ctx[38]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && !/*isSortableOpposite*/ ctx[44] && create_if_block_3$2(ctx);
    	let if_block2 = (/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_2$4(ctx);
    	const root_slot_template = /*#slots*/ ctx[69].root;
    	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[83], get_root_slot_context);
    	const root_end_slot_template = /*#slots*/ ctx[69]["root-end"];
    	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[83], get_root_end_slot_context);

    	let li_levels = [
    		{ class: /*liClasses*/ ctx[42] },
    		{
    			"data-virtual-list-index": /*virtualListIndex*/ ctx[24]
    		},
    		restProps(/*$$restProps*/ ctx[48])
    	];

    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (root_start_slot) root_start_slot.c();
    			t0 = space();
    			if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (root_slot) root_slot.c();
    			t4 = space();
    			if (root_end_slot) root_end_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$g, 341, 2, 9886);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (root_start_slot) {
    				root_start_slot.m(li, null);
    			}

    			append_dev(li, t0);
    			if_blocks[current_block_type_index].m(li, null);
    			append_dev(li, t1);
    			if (if_block1) if_block1.m(li, null);
    			append_dev(li, t2);
    			if (if_block2) if_block2.m(li, null);
    			append_dev(li, t3);

    			if (root_slot) {
    				root_slot.m(li, null);
    			}

    			append_dev(li, t4);

    			if (root_end_slot) {
    				root_end_slot.m(li, null);
    			}

    			/*li_binding_2*/ ctx[82](li);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(useTooltip_action = useTooltip.call(null, li, {
    					tooltip: /*tooltip*/ ctx[7],
    					tooltipTrigger: /*tooltipTrigger*/ ctx[8]
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (root_start_slot) {
    				if (root_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						root_start_slot,
    						root_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(root_start_slot_template, /*$$scope*/ ctx[83], dirty, get_root_start_slot_changes),
    						get_root_start_slot_context
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(li, t1);
    			}

    			if (/*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && !/*isSortableOpposite*/ ctx[44]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_3$2(ctx);
    					if_block1.c();
    					if_block1.m(li, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2$4(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(li, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (root_slot) {
    				if (root_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						root_slot,
    						root_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(root_slot_template, /*$$scope*/ ctx[83], dirty, get_root_slot_changes),
    						get_root_slot_context
    					);
    				}
    			}

    			if (root_end_slot) {
    				if (root_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						root_end_slot,
    						root_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(root_end_slot_template, /*$$scope*/ ctx[83], dirty, get_root_end_slot_changes),
    						get_root_end_slot_context
    					);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				(!current || dirty[1] & /*liClasses*/ 2048) && { class: /*liClasses*/ ctx[42] },
    				(!current || dirty[0] & /*virtualListIndex*/ 16777216) && {
    					"data-virtual-list-index": /*virtualListIndex*/ ctx[24]
    				},
    				dirty[1] & /*$$restProps*/ 131072 && restProps(/*$$restProps*/ ctx[48])
    			]));

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 384) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[7],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[8]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(root_start_slot, local);
    			transition_in(if_block0);
    			transition_in(if_block2);
    			transition_in(root_slot, local);
    			transition_in(root_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(root_start_slot, local);
    			transition_out(if_block0);
    			transition_out(if_block2);
    			transition_out(root_slot, local);
    			transition_out(root_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (root_start_slot) root_start_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (root_slot) root_slot.d(detaching);
    			if (root_end_slot) root_end_slot.d(detaching);
    			/*li_binding_2*/ ctx[82](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(341:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (329:19) 
    function create_if_block_1$6(ctx) {
    	let li;
    	let t0_value = plainText(/*title*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let useTooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	let li_levels = [
    		{ class: /*liClasses*/ ctx[42] },
    		{
    			"data-virtual-list-index": /*virtualListIndex*/ ctx[24]
    		},
    		restProps(/*$$restProps*/ ctx[48])
    	];

    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (default_slot) default_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$g, 329, 2, 9632);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t0);
    			append_dev(li, t1);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			/*li_binding_1*/ ctx[71](li);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li, "click", /*onClick*/ ctx[46], false, false, false),
    					action_destroyer(useTooltip_action = useTooltip.call(null, li, {
    						tooltip: /*tooltip*/ ctx[7],
    						tooltipTrigger: /*tooltipTrigger*/ ctx[8]
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				(!current || dirty[1] & /*liClasses*/ 2048) && { class: /*liClasses*/ ctx[42] },
    				(!current || dirty[0] & /*virtualListIndex*/ 16777216) && {
    					"data-virtual-list-index": /*virtualListIndex*/ ctx[24]
    				},
    				dirty[1] & /*$$restProps*/ 131072 && restProps(/*$$restProps*/ ctx[48])
    			]));

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 384) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[7],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[8]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    			/*li_binding_1*/ ctx[71](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(329:19) ",
    		ctx
    	});

    	return block;
    }

    // (318:0) {#if divider || groupTitle}
    function create_if_block$a(ctx) {
    	let li;
    	let span;
    	let useTooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	let li_levels = [
    		{ class: /*liClasses*/ ctx[42] },
    		{
    			"data-virtual-list-index": /*virtualListIndex*/ ctx[24]
    		},
    		restProps(/*$$restProps*/ ctx[48])
    	];

    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			span = element("span");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			add_location(span, file$g, 326, 4, 9557);
    			set_attributes(li, li_data);
    			add_location(li, file$g, 318, 2, 9353);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, span);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(span, null);
    			}

    			/*li_binding*/ ctx[70](li);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li, "click", /*onClick*/ ctx[46], false, false, false),
    					action_destroyer(useTooltip_action = useTooltip.call(null, li, {
    						tooltip: /*tooltip*/ ctx[7],
    						tooltipTrigger: /*tooltipTrigger*/ ctx[8]
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*title*/ 2)) {
    					default_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1] : dirty);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				(!current || dirty[1] & /*liClasses*/ 2048) && { class: /*liClasses*/ ctx[42] },
    				(!current || dirty[0] & /*virtualListIndex*/ 16777216) && {
    					"data-virtual-list-index": /*virtualListIndex*/ ctx[24]
    				},
    				dirty[1] & /*$$restProps*/ 131072 && restProps(/*$$restProps*/ ctx[48])
    			]));

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 384) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[7],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[8]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			/*li_binding*/ ctx[70](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(318:0) {#if divider || groupTitle}",
    		ctx
    	});

    	return block;
    }

    // (838:4) {:else}
    function create_else_block_7(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_88, create_else_block_9];
    	const if_blocks = [];

    	function select_block_type_8(ctx, dirty) {
    		if (/*checkbox*/ ctx[17] || /*radio*/ ctx[18]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_8(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_8(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_7.name,
    		type: "else",
    		source: "(838:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (716:21) 
    function create_if_block_67(ctx) {
    	let a;
    	let div1;
    	let t0;
    	let t1;
    	let t2;
    	let div0;
    	let t3;
    	let current_block_type_index;
    	let if_block2;
    	let t4;
    	let t5;
    	let t6;
    	let useRouteProps_action;
    	let current;
    	let mounted;
    	let dispose;
    	const content_start_slot_template = /*#slots*/ ctx[69]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[83], get_content_start_slot_context_3);
    	let if_block0 = /*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44] && create_if_block_87(ctx);
    	let if_block1 = /*hasMedia*/ ctx[37] && create_if_block_85(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[69]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_start_slot_context_3);
    	const if_block_creators = [create_if_block_68, create_else_block_6];
    	const if_blocks = [];

    	function select_block_type_7(ctx, dirty) {
    		if (/*isMedia*/ ctx[26]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_7(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const inner_end_slot_template = /*#slots*/ ctx[69]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_end_slot_context_3);
    	const content_slot_template = /*#slots*/ ctx[69].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[83], get_content_slot_context_3);
    	const content_end_slot_template = /*#slots*/ ctx[69]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[83], get_content_end_slot_context_3);
    	let a_levels = [{ class: /*linkClasses*/ ctx[40] }, /*linkAttrs*/ ctx[39]];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			div1 = element("div");
    			if (content_start_slot) content_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div0 = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t3 = space();
    			if_block2.c();
    			t4 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t5 = space();
    			if (content_slot) content_slot.c();
    			t6 = space();
    			if (content_end_slot) content_end_slot.c();
    			attr_dev(div0, "class", "item-inner");
    			add_location(div0, file$g, 737, 10, 24957);
    			attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			add_location(div1, file$g, 724, 8, 24508);
    			set_attributes(a, a_data);
    			add_location(a, file$g, 716, 6, 24309);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, div1);

    			if (content_start_slot) {
    				content_start_slot.m(div1, null);
    			}

    			append_dev(div1, t0);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, div0);

    			if (inner_start_slot) {
    				inner_start_slot.m(div0, null);
    			}

    			append_dev(div0, t3);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div0, t4);

    			if (inner_end_slot) {
    				inner_end_slot.m(div0, null);
    			}

    			/*div0_binding_2*/ ctx[77](div0);
    			append_dev(div1, t5);

    			if (content_slot) {
    				content_slot.m(div1, null);
    			}

    			append_dev(div1, t6);

    			if (content_end_slot) {
    				content_end_slot.m(div1, null);
    			}

    			/*a_binding_1*/ ctx[78](a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[25])),
    					listen_dev(a, "click", /*onClick*/ ctx[46], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[83], dirty, get_content_start_slot_changes_3),
    						get_content_start_slot_context_3
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_87(ctx);
    					if_block0.c();
    					if_block0.m(div1, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*hasMedia*/ ctx[37]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasMedia*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_85(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_start_slot_changes_3),
    						get_inner_start_slot_context_3
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_7(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div0, t4);
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_end_slot_changes_3),
    						get_inner_end_slot_context_3
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[83], dirty, get_content_slot_changes_3),
    						get_content_slot_context_3
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[83], dirty, get_content_end_slot_changes_3),
    						get_content_end_slot_context_3
    					);
    				}
    			}

    			if (!current || dirty[1] & /*contentClasses*/ 1024) {
    				attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty[1] & /*linkClasses*/ 512) && { class: /*linkClasses*/ ctx[40] },
    				dirty[1] & /*linkAttrs*/ 256 && /*linkAttrs*/ ctx[39]
    			]));

    			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 33554432) useRouteProps_action.update.call(null, /*routeProps*/ ctx[25]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			/*div0_binding_2*/ ctx[77](null);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    			/*a_binding_1*/ ctx[78](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_67.name,
    		type: "if",
    		source: "(716:21) ",
    		ctx
    	});

    	return block;
    }

    // (350:4) {#if swipeout}
    function create_if_block_4(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block_5, create_else_block_2$1];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*isLink*/ ctx[38]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "swipeout-content");
    			add_location(div, file$g, 350, 6, 10119);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(350:4) {#if swipeout}",
    		ctx
    	});

    	return block;
    }

    // (964:6) {:else}
    function create_else_block_9(ctx) {
    	let div1;
    	let t0;
    	let t1;
    	let t2;
    	let div0;
    	let t3;
    	let current_block_type_index;
    	let if_block2;
    	let t4;
    	let t5;
    	let t6;
    	let current;
    	let mounted;
    	let dispose;
    	const content_start_slot_template = /*#slots*/ ctx[69]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[83], get_content_start_slot_context_5);
    	let if_block0 = /*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44] && create_if_block_128(ctx);
    	let if_block1 = /*hasMedia*/ ctx[37] && create_if_block_126(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[69]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_start_slot_context_5);
    	const if_block_creators = [create_if_block_109, create_else_block_10];
    	const if_blocks = [];

    	function select_block_type_10(ctx, dirty) {
    		if (/*isMedia*/ ctx[26]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_10(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const inner_end_slot_template = /*#slots*/ ctx[69]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_end_slot_context_5);
    	const content_slot_template = /*#slots*/ ctx[69].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[83], get_content_slot_context_5);
    	const content_end_slot_template = /*#slots*/ ctx[69]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[83], get_content_end_slot_context_5);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (content_start_slot) content_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div0 = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t3 = space();
    			if_block2.c();
    			t4 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t5 = space();
    			if (content_slot) content_slot.c();
    			t6 = space();
    			if (content_end_slot) content_end_slot.c();
    			attr_dev(div0, "class", "item-inner");
    			add_location(div0, file$g, 977, 10, 33409);
    			attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			add_location(div1, file$g, 964, 8, 32941);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);

    			if (content_start_slot) {
    				content_start_slot.m(div1, null);
    			}

    			append_dev(div1, t0);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, div0);

    			if (inner_start_slot) {
    				inner_start_slot.m(div0, null);
    			}

    			append_dev(div0, t3);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div0, t4);

    			if (inner_end_slot) {
    				inner_end_slot.m(div0, null);
    			}

    			/*div0_binding_3*/ ctx[81](div0);
    			append_dev(div1, t5);

    			if (content_slot) {
    				content_slot.m(div1, null);
    			}

    			append_dev(div1, t6);

    			if (content_end_slot) {
    				content_end_slot.m(div1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", /*onClick*/ ctx[46], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[83], dirty, get_content_start_slot_changes_5),
    						get_content_start_slot_context_5
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_128(ctx);
    					if_block0.c();
    					if_block0.m(div1, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*hasMedia*/ ctx[37]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasMedia*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_126(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_start_slot_changes_5),
    						get_inner_start_slot_context_5
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_10(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div0, t4);
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_end_slot_changes_5),
    						get_inner_end_slot_context_5
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[83], dirty, get_content_slot_changes_5),
    						get_content_slot_context_5
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[83], dirty, get_content_end_slot_changes_5),
    						get_content_end_slot_context_5
    					);
    				}
    			}

    			if (!current || dirty[1] & /*contentClasses*/ 1024) {
    				attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			/*div0_binding_3*/ ctx[81](null);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_9.name,
    		type: "else",
    		source: "(964:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (840:6) {#if checkbox || radio}
    function create_if_block_88(ctx) {
    	let label;
    	let t0;
    	let t1;
    	let input;
    	let input_value_value;
    	let input_type_value;
    	let t2;
    	let i;
    	let i_class_value;
    	let t3;
    	let t4;
    	let div;
    	let t5;
    	let current_block_type_index;
    	let if_block2;
    	let t6;
    	let t7;
    	let t8;
    	let current;
    	let mounted;
    	let dispose;
    	const content_start_slot_template = /*#slots*/ ctx[69]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[83], get_content_start_slot_context_4);
    	let if_block0 = /*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44] && create_if_block_108(ctx);
    	let if_block1 = /*hasMedia*/ ctx[37] && create_if_block_106(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[69]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_start_slot_context_4);
    	const if_block_creators = [create_if_block_89, create_else_block_8];
    	const if_blocks = [];

    	function select_block_type_9(ctx, dirty) {
    		if (/*isMedia*/ ctx[26]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_9(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const inner_end_slot_template = /*#slots*/ ctx[69]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_end_slot_context_4);
    	const content_slot_template = /*#slots*/ ctx[69].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[83], get_content_slot_context_4);
    	const content_end_slot_template = /*#slots*/ ctx[69]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[83], get_content_end_slot_context_4);

    	const block = {
    		c: function create() {
    			label = element("label");
    			if (content_start_slot) content_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			i = element("i");
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			div = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t5 = space();
    			if_block2.c();
    			t6 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t7 = space();
    			if (content_slot) content_slot.c();
    			t8 = space();
    			if (content_end_slot) content_end_slot.c();

    			input.value = input_value_value = typeof /*value*/ ctx[20] === 'undefined'
    			? ''
    			: /*value*/ ctx[20];

    			attr_dev(input, "name", /*name*/ ctx[19]);
    			input.checked = /*checked*/ ctx[0];
    			input.readOnly = /*readonly*/ ctx[21];
    			input.disabled = /*disabled*/ ctx[23];
    			input.required = /*required*/ ctx[22];
    			attr_dev(input, "type", input_type_value = /*radio*/ ctx[18] ? 'radio' : 'checkbox');
    			add_location(input, file$g, 845, 10, 28807);
    			attr_dev(i, "class", i_class_value = `icon icon-${/*radio*/ ctx[18] ? 'radio' : 'checkbox'}`);
    			add_location(i, file$g, 856, 10, 29122);
    			attr_dev(div, "class", "item-inner");
    			add_location(div, file$g, 865, 10, 29428);
    			attr_dev(label, "class", /*contentClasses*/ ctx[41]);
    			add_location(label, file$g, 840, 8, 28575);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);

    			if (content_start_slot) {
    				content_start_slot.m(label, null);
    			}

    			append_dev(label, t0);
    			if (if_block0) if_block0.m(label, null);
    			append_dev(label, t1);
    			append_dev(label, input);
    			/*input_binding_1*/ ctx[79](input);
    			append_dev(label, t2);
    			append_dev(label, i);
    			append_dev(label, t3);
    			if (if_block1) if_block1.m(label, null);
    			append_dev(label, t4);
    			append_dev(label, div);

    			if (inner_start_slot) {
    				inner_start_slot.m(div, null);
    			}

    			append_dev(div, t5);
    			if_blocks[current_block_type_index].m(div, null);
    			append_dev(div, t6);

    			if (inner_end_slot) {
    				inner_end_slot.m(div, null);
    			}

    			/*div_binding_1*/ ctx[80](div);
    			append_dev(label, t7);

    			if (content_slot) {
    				content_slot.m(label, null);
    			}

    			append_dev(label, t8);

    			if (content_end_slot) {
    				content_end_slot.m(label, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*onChange*/ ctx[47], false, false, false),
    					listen_dev(label, "click", /*onClick*/ ctx[46], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[83], dirty, get_content_start_slot_changes_4),
    						get_content_start_slot_context_4
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_108(ctx);
    					if_block0.c();
    					if_block0.m(label, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty[0] & /*value*/ 1048576 && input_value_value !== (input_value_value = typeof /*value*/ ctx[20] === 'undefined'
    			? ''
    			: /*value*/ ctx[20]) && input.value !== input_value_value) {
    				prop_dev(input, "value", input_value_value);
    			}

    			if (!current || dirty[0] & /*name*/ 524288) {
    				attr_dev(input, "name", /*name*/ ctx[19]);
    			}

    			if (!current || dirty[0] & /*checked*/ 1) {
    				prop_dev(input, "checked", /*checked*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*readonly*/ 2097152) {
    				prop_dev(input, "readOnly", /*readonly*/ ctx[21]);
    			}

    			if (!current || dirty[0] & /*disabled*/ 8388608) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[23]);
    			}

    			if (!current || dirty[0] & /*required*/ 4194304) {
    				prop_dev(input, "required", /*required*/ ctx[22]);
    			}

    			if (!current || dirty[0] & /*radio*/ 262144 && input_type_value !== (input_type_value = /*radio*/ ctx[18] ? 'radio' : 'checkbox')) {
    				attr_dev(input, "type", input_type_value);
    			}

    			if (!current || dirty[0] & /*radio*/ 262144 && i_class_value !== (i_class_value = `icon icon-${/*radio*/ ctx[18] ? 'radio' : 'checkbox'}`)) {
    				attr_dev(i, "class", i_class_value);
    			}

    			if (/*hasMedia*/ ctx[37]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasMedia*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_106(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(label, t4);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_start_slot_changes_4),
    						get_inner_start_slot_context_4
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_9(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div, t6);
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_end_slot_changes_4),
    						get_inner_end_slot_context_4
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[83], dirty, get_content_slot_changes_4),
    						get_content_slot_context_4
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[83], dirty, get_content_end_slot_changes_4),
    						get_content_end_slot_context_4
    					);
    				}
    			}

    			if (!current || dirty[1] & /*contentClasses*/ 1024) {
    				attr_dev(label, "class", /*contentClasses*/ ctx[41]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			/*input_binding_1*/ ctx[79](null);
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			/*div_binding_1*/ ctx[80](null);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_88.name,
    		type: "if",
    		source: "(840:6) {#if checkbox || radio}",
    		ctx
    	});

    	return block;
    }

    // (967:10) {#if isSortable && sortable !== false && isSortableOpposite}
    function create_if_block_128(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$g, 967, 12, 33112);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_128.name,
    		type: "if",
    		source: "(967:10) {#if isSortable && sortable !== false && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (970:10) {#if hasMedia}
    function create_if_block_126(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[3] !== 'undefined' && create_if_block_127(ctx);
    	const media_slot_template = /*#slots*/ ctx[69].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[83], get_media_slot_context_5);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$g, 970, 12, 33198);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[3] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_127(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[83], dirty, get_media_slot_changes_5),
    						get_media_slot_context_5
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_126.name,
    		type: "if",
    		source: "(970:10) {#if hasMedia}",
    		ctx
    	});

    	return block;
    }

    // (972:14) {#if typeof media !== 'undefined'}
    function create_if_block_127(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$g, 972, 16, 33288);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 8 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_127.name,
    		type: "if",
    		source: "(972:14) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (1032:12) {:else}
    function create_else_block_10(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block2_anchor;
    	let current;
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_11);
    	let if_block0 = (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) && create_if_block_123(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_11);
    	let if_block1 = /*hasAfter*/ ctx[31] && create_if_block_120(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_11);
    	let if_block2 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_119(ctx);

    	const block = {
    		c: function create() {
    			if (before_title_slot) before_title_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (after_title_slot) after_title_slot.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (inner_slot) inner_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (before_title_slot) {
    				before_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (after_title_slot) {
    				after_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t4, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_11),
    						get_before_title_slot_context_11
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 56) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_123(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_11),
    						get_after_title_slot_context_11
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_120(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_11),
    						get_inner_slot_context_11
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_119(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_title_slot, local);
    			transition_in(if_block0);
    			transition_in(after_title_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_slot, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_title_slot, local);
    			transition_out(if_block0);
    			transition_out(after_title_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_slot, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_10.name,
    		type: "else",
    		source: "(1032:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (980:12) {#if isMedia}
    function create_if_block_109(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let if_block6_anchor;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_118(ctx);
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_10);
    	let if_block1 = /*hasTitle*/ ctx[36] && create_if_block_117(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_10);
    	let if_block2 = /*hasAfter*/ ctx[31] && create_if_block_114(ctx);
    	let if_block3 = /*hasSubtitle*/ ctx[33] && create_if_block_113(ctx);
    	let if_block4 = /*hasText*/ ctx[32] && create_if_block_112(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_10);
    	let if_block5 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_111(ctx);
    	let if_block6 = /*hasFooter*/ ctx[34] && create_if_block_110(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (before_title_slot) before_title_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_title_slot) after_title_slot.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (inner_slot) inner_slot.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    			attr_dev(div, "class", "item-title-row");
    			add_location(div, file$g, 986, 14, 33728);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			if (before_title_slot) {
    				before_title_slot.m(div, null);
    			}

    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_title_slot) {
    				after_title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block2) if_block2.m(div, null);
    			insert_dev(target, t4, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t6, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t7, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_118(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_10),
    						get_before_title_slot_context_10
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_117(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_10),
    						get_after_title_slot_context_10
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_114(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*hasSubtitle*/ ctx[33]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[1] & /*hasSubtitle*/ 4) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_113(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t5.parentNode, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*hasText*/ ctx[32]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasText*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_112(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t6.parentNode, t6);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_10),
    						get_inner_slot_context_10
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_111(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t8.parentNode, t8);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_110(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(before_title_slot, local);
    			transition_in(if_block1);
    			transition_in(after_title_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(inner_slot, local);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(before_title_slot, local);
    			transition_out(if_block1);
    			transition_out(after_title_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(inner_slot, local);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t4);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_109.name,
    		type: "if",
    		source: "(980:12) {#if isMedia}",
    		ctx
    	});

    	return block;
    }

    // (1034:14) {#if hasTitle || hasHeader || hasFooter}
    function create_if_block_123(ctx) {
    	let div;
    	let t0;
    	let t1_value = plainText(/*title*/ ctx[1]) + "";
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_125(ctx);
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_11);
    	let if_block1 = /*hasFooter*/ ctx[34] && create_if_block_124(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			t1 = text$1(t1_value);
    			t2 = space();
    			if (title_slot) title_slot.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$g, 1034, 16, 35463);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_125(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*title*/ 2) && t1_value !== (t1_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t1, t1_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_11),
    						get_title_slot_context_11
    					);
    				}
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_124(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(title_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(title_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (title_slot) title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_123.name,
    		type: "if",
    		source: "(1034:14) {#if hasTitle || hasHeader || hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (1036:18) {#if hasHeader}
    function create_if_block_125(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_11);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$g, 1036, 20, 35542);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_11),
    						get_header_slot_context_11
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_125.name,
    		type: "if",
    		source: "(1036:18) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (1044:18) {#if hasFooter}
    function create_if_block_124(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_11);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$g, 1044, 20, 35837);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_11),
    						get_footer_slot_context_11
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_124.name,
    		type: "if",
    		source: "(1044:18) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (1053:14) {#if hasAfter}
    function create_if_block_120(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_11);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_122(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_121(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_11);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_11);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$g, 1053, 16, 36131);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_11),
    						get_after_start_slot_context_11
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_122(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_121(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_11),
    						get_after_slot_context_11
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_11),
    						get_after_end_slot_context_11
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_120.name,
    		type: "if",
    		source: "(1053:14) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (1056:18) {#if typeof after !== 'undefined'}
    function create_if_block_122(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$g, 1056, 20, 36275);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_122.name,
    		type: "if",
    		source: "(1056:18) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (1059:18) {#if typeof badge !== 'undefined'}
    function create_if_block_121(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_121.name,
    		type: "if",
    		source: "(1059:18) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (1060:20) <Badge color={badgeColor}>
    function create_default_slot_11(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(1060:20) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (1067:14) {#if !(swipeout || accordionItem)}
    function create_if_block_119(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_119.name,
    		type: "if",
    		source: "(1067:14) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (981:14) {#if hasHeader}
    function create_if_block_118(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_10);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$g, 981, 16, 33566);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_10),
    						get_header_slot_context_10
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_118.name,
    		type: "if",
    		source: "(981:14) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (989:16) {#if hasTitle}
    function create_if_block_117(ctx) {
    	let div;
    	let t0_value = plainText(/*title*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_10);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (title_slot) title_slot.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$g, 989, 18, 33851);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_10),
    						get_title_slot_context_10
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_117.name,
    		type: "if",
    		source: "(989:16) {#if hasTitle}",
    		ctx
    	});

    	return block;
    }

    // (996:16) {#if hasAfter}
    function create_if_block_114(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_10);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_116(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_115(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_10);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_10);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$g, 996, 18, 34097);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_10),
    						get_after_start_slot_context_10
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_116(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_115(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_10),
    						get_after_slot_context_10
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_10),
    						get_after_end_slot_context_10
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_114.name,
    		type: "if",
    		source: "(996:16) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (999:20) {#if typeof after !== 'undefined'}
    function create_if_block_116(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$g, 999, 22, 34247);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_116.name,
    		type: "if",
    		source: "(999:20) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (1002:20) {#if typeof badge !== 'undefined'}
    function create_if_block_115(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_115.name,
    		type: "if",
    		source: "(1002:20) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (1003:22) <Badge color={badgeColor}>
    function create_default_slot_10(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(1003:22) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (1010:14) {#if hasSubtitle}
    function create_if_block_113(ctx) {
    	let div;
    	let t0_value = plainText(/*subtitle*/ ctx[4]) + "";
    	let t0;
    	let t1;
    	let current;
    	const subtitle_slot_template = /*#slots*/ ctx[69].subtitle;
    	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[83], get_subtitle_slot_context_5);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (subtitle_slot) subtitle_slot.c();
    			attr_dev(div, "class", "item-subtitle");
    			add_location(div, file$g, 1010, 16, 34665);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (subtitle_slot) {
    				subtitle_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*subtitle*/ 16) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

    			if (subtitle_slot) {
    				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						subtitle_slot,
    						subtitle_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[83], dirty, get_subtitle_slot_changes_5),
    						get_subtitle_slot_context_5
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(subtitle_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(subtitle_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (subtitle_slot) subtitle_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_113.name,
    		type: "if",
    		source: "(1010:14) {#if hasSubtitle}",
    		ctx
    	});

    	return block;
    }

    // (1016:14) {#if hasText}
    function create_if_block_112(ctx) {
    	let div;
    	let t0_value = plainText(/*text*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const text_slot_template = /*#slots*/ ctx[69].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[83], get_text_slot_context_5);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (text_slot) text_slot.c();
    			attr_dev(div, "class", "item-text");
    			add_location(div, file$g, 1016, 16, 34863);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[83], dirty, get_text_slot_changes_5),
    						get_text_slot_context_5
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (text_slot) text_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_112.name,
    		type: "if",
    		source: "(1016:14) {#if hasText}",
    		ctx
    	});

    	return block;
    }

    // (1023:14) {#if !(swipeout || accordionItem)}
    function create_if_block_111(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_111.name,
    		type: "if",
    		source: "(1023:14) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (1026:14) {#if hasFooter}
    function create_if_block_110(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_10);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$g, 1026, 16, 35181);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_10),
    						get_footer_slot_context_10
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_110.name,
    		type: "if",
    		source: "(1026:14) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (843:10) {#if isSortable && sortable !== false && isSortableOpposite}
    function create_if_block_108(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$g, 843, 12, 28748);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_108.name,
    		type: "if",
    		source: "(843:10) {#if isSortable && sortable !== false && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (858:10) {#if hasMedia}
    function create_if_block_106(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[3] !== 'undefined' && create_if_block_107(ctx);
    	const media_slot_template = /*#slots*/ ctx[69].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[83], get_media_slot_context_4);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$g, 858, 12, 29217);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[3] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_107(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[83], dirty, get_media_slot_changes_4),
    						get_media_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_106.name,
    		type: "if",
    		source: "(858:10) {#if hasMedia}",
    		ctx
    	});

    	return block;
    }

    // (860:14) {#if typeof media !== 'undefined'}
    function create_if_block_107(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$g, 860, 16, 29307);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 8 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_107.name,
    		type: "if",
    		source: "(860:14) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (920:12) {:else}
    function create_else_block_8(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block2_anchor;
    	let current;
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_9);
    	let if_block0 = (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) && create_if_block_103(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_9);
    	let if_block1 = /*hasAfter*/ ctx[31] && create_if_block_100(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_9);
    	let if_block2 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_99(ctx);

    	const block = {
    		c: function create() {
    			if (before_title_slot) before_title_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (after_title_slot) after_title_slot.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (inner_slot) inner_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (before_title_slot) {
    				before_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (after_title_slot) {
    				after_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t4, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_9),
    						get_before_title_slot_context_9
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 56) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_103(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_9),
    						get_after_title_slot_context_9
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_100(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_9),
    						get_inner_slot_context_9
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_99(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_title_slot, local);
    			transition_in(if_block0);
    			transition_in(after_title_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_slot, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_title_slot, local);
    			transition_out(if_block0);
    			transition_out(after_title_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_slot, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_8.name,
    		type: "else",
    		source: "(920:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (868:12) {#if isMedia}
    function create_if_block_89(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let if_block6_anchor;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_98(ctx);
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_8);
    	let if_block1 = /*hasTitle*/ ctx[36] && create_if_block_97(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_8);
    	let if_block2 = /*hasAfter*/ ctx[31] && create_if_block_94(ctx);
    	let if_block3 = /*hasSubtitle*/ ctx[33] && create_if_block_93(ctx);
    	let if_block4 = /*hasText*/ ctx[32] && create_if_block_92(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_8);
    	let if_block5 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_91(ctx);
    	let if_block6 = /*hasFooter*/ ctx[34] && create_if_block_90(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (before_title_slot) before_title_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_title_slot) after_title_slot.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (inner_slot) inner_slot.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    			attr_dev(div, "class", "item-title-row");
    			add_location(div, file$g, 874, 14, 29747);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			if (before_title_slot) {
    				before_title_slot.m(div, null);
    			}

    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_title_slot) {
    				after_title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block2) if_block2.m(div, null);
    			insert_dev(target, t4, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t6, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t7, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_98(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_8),
    						get_before_title_slot_context_8
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_97(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_8),
    						get_after_title_slot_context_8
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_94(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*hasSubtitle*/ ctx[33]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[1] & /*hasSubtitle*/ 4) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_93(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t5.parentNode, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*hasText*/ ctx[32]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasText*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_92(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t6.parentNode, t6);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_8),
    						get_inner_slot_context_8
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_91(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t8.parentNode, t8);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_90(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(before_title_slot, local);
    			transition_in(if_block1);
    			transition_in(after_title_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(inner_slot, local);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(before_title_slot, local);
    			transition_out(if_block1);
    			transition_out(after_title_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(inner_slot, local);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t4);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_89.name,
    		type: "if",
    		source: "(868:12) {#if isMedia}",
    		ctx
    	});

    	return block;
    }

    // (922:14) {#if hasTitle || hasHeader || hasFooter}
    function create_if_block_103(ctx) {
    	let div;
    	let t0;
    	let t1_value = plainText(/*title*/ ctx[1]) + "";
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_105(ctx);
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_9);
    	let if_block1 = /*hasFooter*/ ctx[34] && create_if_block_104(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			t1 = text$1(t1_value);
    			t2 = space();
    			if (title_slot) title_slot.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$g, 922, 16, 31482);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_105(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*title*/ 2) && t1_value !== (t1_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t1, t1_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_9),
    						get_title_slot_context_9
    					);
    				}
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_104(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(title_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(title_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (title_slot) title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_103.name,
    		type: "if",
    		source: "(922:14) {#if hasTitle || hasHeader || hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (924:18) {#if hasHeader}
    function create_if_block_105(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_9);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$g, 924, 20, 31561);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_9),
    						get_header_slot_context_9
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_105.name,
    		type: "if",
    		source: "(924:18) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (932:18) {#if hasFooter}
    function create_if_block_104(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_9);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$g, 932, 20, 31856);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_9),
    						get_footer_slot_context_9
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_104.name,
    		type: "if",
    		source: "(932:18) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (941:14) {#if hasAfter}
    function create_if_block_100(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_9);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_102(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_101(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_9);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_9);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$g, 941, 16, 32150);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_9),
    						get_after_start_slot_context_9
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_102(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_101(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_9),
    						get_after_slot_context_9
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_9),
    						get_after_end_slot_context_9
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_100.name,
    		type: "if",
    		source: "(941:14) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (944:18) {#if typeof after !== 'undefined'}
    function create_if_block_102(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$g, 944, 20, 32294);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_102.name,
    		type: "if",
    		source: "(944:18) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (947:18) {#if typeof badge !== 'undefined'}
    function create_if_block_101(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_101.name,
    		type: "if",
    		source: "(947:18) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (948:20) <Badge color={badgeColor}>
    function create_default_slot_9(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(948:20) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (955:14) {#if !(swipeout || accordionItem)}
    function create_if_block_99(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_99.name,
    		type: "if",
    		source: "(955:14) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (869:14) {#if hasHeader}
    function create_if_block_98(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_8);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$g, 869, 16, 29585);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_8),
    						get_header_slot_context_8
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_98.name,
    		type: "if",
    		source: "(869:14) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (877:16) {#if hasTitle}
    function create_if_block_97(ctx) {
    	let div;
    	let t0_value = plainText(/*title*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_8);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (title_slot) title_slot.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$g, 877, 18, 29870);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_8),
    						get_title_slot_context_8
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_97.name,
    		type: "if",
    		source: "(877:16) {#if hasTitle}",
    		ctx
    	});

    	return block;
    }

    // (884:16) {#if hasAfter}
    function create_if_block_94(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_8);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_96(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_95(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_8);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_8);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$g, 884, 18, 30116);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_8),
    						get_after_start_slot_context_8
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_96(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_95(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_8),
    						get_after_slot_context_8
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_8),
    						get_after_end_slot_context_8
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_94.name,
    		type: "if",
    		source: "(884:16) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (887:20) {#if typeof after !== 'undefined'}
    function create_if_block_96(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$g, 887, 22, 30266);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_96.name,
    		type: "if",
    		source: "(887:20) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (890:20) {#if typeof badge !== 'undefined'}
    function create_if_block_95(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_95.name,
    		type: "if",
    		source: "(890:20) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (891:22) <Badge color={badgeColor}>
    function create_default_slot_8(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(891:22) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (898:14) {#if hasSubtitle}
    function create_if_block_93(ctx) {
    	let div;
    	let t0_value = plainText(/*subtitle*/ ctx[4]) + "";
    	let t0;
    	let t1;
    	let current;
    	const subtitle_slot_template = /*#slots*/ ctx[69].subtitle;
    	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[83], get_subtitle_slot_context_4);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (subtitle_slot) subtitle_slot.c();
    			attr_dev(div, "class", "item-subtitle");
    			add_location(div, file$g, 898, 16, 30684);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (subtitle_slot) {
    				subtitle_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*subtitle*/ 16) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

    			if (subtitle_slot) {
    				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						subtitle_slot,
    						subtitle_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[83], dirty, get_subtitle_slot_changes_4),
    						get_subtitle_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(subtitle_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(subtitle_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (subtitle_slot) subtitle_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_93.name,
    		type: "if",
    		source: "(898:14) {#if hasSubtitle}",
    		ctx
    	});

    	return block;
    }

    // (904:14) {#if hasText}
    function create_if_block_92(ctx) {
    	let div;
    	let t0_value = plainText(/*text*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const text_slot_template = /*#slots*/ ctx[69].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[83], get_text_slot_context_4);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (text_slot) text_slot.c();
    			attr_dev(div, "class", "item-text");
    			add_location(div, file$g, 904, 16, 30882);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[83], dirty, get_text_slot_changes_4),
    						get_text_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (text_slot) text_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_92.name,
    		type: "if",
    		source: "(904:14) {#if hasText}",
    		ctx
    	});

    	return block;
    }

    // (911:14) {#if !(swipeout || accordionItem)}
    function create_if_block_91(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_91.name,
    		type: "if",
    		source: "(911:14) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (914:14) {#if hasFooter}
    function create_if_block_90(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_8);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$g, 914, 16, 31200);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_8),
    						get_footer_slot_context_8
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_90.name,
    		type: "if",
    		source: "(914:14) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (727:10) {#if isSortable && sortable !== false && isSortableOpposite}
    function create_if_block_87(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$g, 727, 12, 24660);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_87.name,
    		type: "if",
    		source: "(727:10) {#if isSortable && sortable !== false && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (730:10) {#if hasMedia}
    function create_if_block_85(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[3] !== 'undefined' && create_if_block_86(ctx);
    	const media_slot_template = /*#slots*/ ctx[69].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[83], get_media_slot_context_3);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$g, 730, 12, 24746);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[3] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_86(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[83], dirty, get_media_slot_changes_3),
    						get_media_slot_context_3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_85.name,
    		type: "if",
    		source: "(730:10) {#if hasMedia}",
    		ctx
    	});

    	return block;
    }

    // (732:14) {#if typeof media !== 'undefined'}
    function create_if_block_86(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$g, 732, 16, 24836);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 8 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_86.name,
    		type: "if",
    		source: "(732:14) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (792:12) {:else}
    function create_else_block_6(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block2_anchor;
    	let current;
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_7);
    	let if_block0 = (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) && create_if_block_82(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_7);
    	let if_block1 = /*hasAfter*/ ctx[31] && create_if_block_79(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_7);
    	let if_block2 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_78(ctx);

    	const block = {
    		c: function create() {
    			if (before_title_slot) before_title_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (after_title_slot) after_title_slot.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (inner_slot) inner_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (before_title_slot) {
    				before_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (after_title_slot) {
    				after_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t4, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_7),
    						get_before_title_slot_context_7
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 56) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_82(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_7),
    						get_after_title_slot_context_7
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_79(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_7),
    						get_inner_slot_context_7
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_78(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_title_slot, local);
    			transition_in(if_block0);
    			transition_in(after_title_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_slot, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_title_slot, local);
    			transition_out(if_block0);
    			transition_out(after_title_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_slot, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_6.name,
    		type: "else",
    		source: "(792:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (740:12) {#if isMedia}
    function create_if_block_68(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let if_block6_anchor;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_77(ctx);
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_6);
    	let if_block1 = /*hasTitle*/ ctx[36] && create_if_block_76(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_6);
    	let if_block2 = /*hasAfter*/ ctx[31] && create_if_block_73(ctx);
    	let if_block3 = /*hasSubtitle*/ ctx[33] && create_if_block_72(ctx);
    	let if_block4 = /*hasText*/ ctx[32] && create_if_block_71(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_6);
    	let if_block5 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_70(ctx);
    	let if_block6 = /*hasFooter*/ ctx[34] && create_if_block_69(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (before_title_slot) before_title_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_title_slot) after_title_slot.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (inner_slot) inner_slot.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    			attr_dev(div, "class", "item-title-row");
    			add_location(div, file$g, 746, 14, 25276);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			if (before_title_slot) {
    				before_title_slot.m(div, null);
    			}

    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_title_slot) {
    				after_title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block2) if_block2.m(div, null);
    			insert_dev(target, t4, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t6, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t7, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_77(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_6),
    						get_before_title_slot_context_6
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_76(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_6),
    						get_after_title_slot_context_6
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_73(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*hasSubtitle*/ ctx[33]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[1] & /*hasSubtitle*/ 4) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_72(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t5.parentNode, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*hasText*/ ctx[32]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasText*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_71(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t6.parentNode, t6);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_6),
    						get_inner_slot_context_6
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_70(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t8.parentNode, t8);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_69(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(before_title_slot, local);
    			transition_in(if_block1);
    			transition_in(after_title_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(inner_slot, local);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(before_title_slot, local);
    			transition_out(if_block1);
    			transition_out(after_title_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(inner_slot, local);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t4);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_68.name,
    		type: "if",
    		source: "(740:12) {#if isMedia}",
    		ctx
    	});

    	return block;
    }

    // (794:14) {#if hasTitle || hasHeader || hasFooter}
    function create_if_block_82(ctx) {
    	let div;
    	let t0;
    	let t1_value = plainText(/*title*/ ctx[1]) + "";
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_84(ctx);
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_7);
    	let if_block1 = /*hasFooter*/ ctx[34] && create_if_block_83(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			t1 = text$1(t1_value);
    			t2 = space();
    			if (title_slot) title_slot.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$g, 794, 16, 27011);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_84(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*title*/ 2) && t1_value !== (t1_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t1, t1_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_7),
    						get_title_slot_context_7
    					);
    				}
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_83(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(title_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(title_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (title_slot) title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_82.name,
    		type: "if",
    		source: "(794:14) {#if hasTitle || hasHeader || hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (796:18) {#if hasHeader}
    function create_if_block_84(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_7);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$g, 796, 20, 27090);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_7),
    						get_header_slot_context_7
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_84.name,
    		type: "if",
    		source: "(796:18) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (804:18) {#if hasFooter}
    function create_if_block_83(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_7);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$g, 804, 20, 27385);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_7),
    						get_footer_slot_context_7
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_83.name,
    		type: "if",
    		source: "(804:18) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (813:14) {#if hasAfter}
    function create_if_block_79(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_7);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_81(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_80(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_7);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_7);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$g, 813, 16, 27679);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_7),
    						get_after_start_slot_context_7
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_81(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_80(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_7),
    						get_after_slot_context_7
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_7),
    						get_after_end_slot_context_7
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_79.name,
    		type: "if",
    		source: "(813:14) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (816:18) {#if typeof after !== 'undefined'}
    function create_if_block_81(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$g, 816, 20, 27823);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_81.name,
    		type: "if",
    		source: "(816:18) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (819:18) {#if typeof badge !== 'undefined'}
    function create_if_block_80(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_80.name,
    		type: "if",
    		source: "(819:18) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (820:20) <Badge color={badgeColor}>
    function create_default_slot_7(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(820:20) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (827:14) {#if !(swipeout || accordionItem)}
    function create_if_block_78(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_78.name,
    		type: "if",
    		source: "(827:14) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (741:14) {#if hasHeader}
    function create_if_block_77(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_6);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$g, 741, 16, 25114);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_6),
    						get_header_slot_context_6
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_77.name,
    		type: "if",
    		source: "(741:14) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (749:16) {#if hasTitle}
    function create_if_block_76(ctx) {
    	let div;
    	let t0_value = plainText(/*title*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_6);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (title_slot) title_slot.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$g, 749, 18, 25399);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_6),
    						get_title_slot_context_6
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_76.name,
    		type: "if",
    		source: "(749:16) {#if hasTitle}",
    		ctx
    	});

    	return block;
    }

    // (756:16) {#if hasAfter}
    function create_if_block_73(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_6);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_75(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_74(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_6);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_6);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$g, 756, 18, 25645);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_6),
    						get_after_start_slot_context_6
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_75(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_74(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_6),
    						get_after_slot_context_6
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_6),
    						get_after_end_slot_context_6
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_73.name,
    		type: "if",
    		source: "(756:16) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (759:20) {#if typeof after !== 'undefined'}
    function create_if_block_75(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$g, 759, 22, 25795);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_75.name,
    		type: "if",
    		source: "(759:20) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (762:20) {#if typeof badge !== 'undefined'}
    function create_if_block_74(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_74.name,
    		type: "if",
    		source: "(762:20) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (763:22) <Badge color={badgeColor}>
    function create_default_slot_6$1(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(763:22) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (770:14) {#if hasSubtitle}
    function create_if_block_72(ctx) {
    	let div;
    	let t0_value = plainText(/*subtitle*/ ctx[4]) + "";
    	let t0;
    	let t1;
    	let current;
    	const subtitle_slot_template = /*#slots*/ ctx[69].subtitle;
    	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[83], get_subtitle_slot_context_3);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (subtitle_slot) subtitle_slot.c();
    			attr_dev(div, "class", "item-subtitle");
    			add_location(div, file$g, 770, 16, 26213);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (subtitle_slot) {
    				subtitle_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*subtitle*/ 16) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

    			if (subtitle_slot) {
    				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						subtitle_slot,
    						subtitle_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[83], dirty, get_subtitle_slot_changes_3),
    						get_subtitle_slot_context_3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(subtitle_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(subtitle_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (subtitle_slot) subtitle_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_72.name,
    		type: "if",
    		source: "(770:14) {#if hasSubtitle}",
    		ctx
    	});

    	return block;
    }

    // (776:14) {#if hasText}
    function create_if_block_71(ctx) {
    	let div;
    	let t0_value = plainText(/*text*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const text_slot_template = /*#slots*/ ctx[69].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[83], get_text_slot_context_3);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (text_slot) text_slot.c();
    			attr_dev(div, "class", "item-text");
    			add_location(div, file$g, 776, 16, 26411);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[83], dirty, get_text_slot_changes_3),
    						get_text_slot_context_3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (text_slot) text_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_71.name,
    		type: "if",
    		source: "(776:14) {#if hasText}",
    		ctx
    	});

    	return block;
    }

    // (783:14) {#if !(swipeout || accordionItem)}
    function create_if_block_70(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_70.name,
    		type: "if",
    		source: "(783:14) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (786:14) {#if hasFooter}
    function create_if_block_69(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_6);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$g, 786, 16, 26729);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_6),
    						get_footer_slot_context_6
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_69.name,
    		type: "if",
    		source: "(786:14) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (474:8) {:else}
    function create_else_block_2$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_26, create_else_block_4];
    	const if_blocks = [];

    	function select_block_type_4(ctx, dirty) {
    		if (/*checkbox*/ ctx[17] || /*radio*/ ctx[18]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_4(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_4(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(474:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (352:8) {#if isLink}
    function create_if_block_5(ctx) {
    	let a;
    	let div1;
    	let t0;
    	let t1;
    	let t2;
    	let div0;
    	let t3;
    	let current_block_type_index;
    	let if_block2;
    	let t4;
    	let t5;
    	let t6;
    	let useRouteProps_action;
    	let current;
    	let mounted;
    	let dispose;
    	const content_start_slot_template = /*#slots*/ ctx[69]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[83], get_content_start_slot_context);
    	let if_block0 = /*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44] && create_if_block_25(ctx);
    	let if_block1 = /*hasMedia*/ ctx[37] && create_if_block_23(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[69]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_start_slot_context);
    	const if_block_creators = [create_if_block_6, create_else_block_1$1];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*isMedia*/ ctx[26]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_3(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const inner_end_slot_template = /*#slots*/ ctx[69]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_end_slot_context);
    	const content_slot_template = /*#slots*/ ctx[69].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[83], get_content_slot_context);
    	const content_end_slot_template = /*#slots*/ ctx[69]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[83], get_content_end_slot_context);
    	let a_levels = [{ class: /*linkClasses*/ ctx[40] }, /*linkAttrs*/ ctx[39]];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			div1 = element("div");
    			if (content_start_slot) content_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div0 = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t3 = space();
    			if_block2.c();
    			t4 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t5 = space();
    			if (content_slot) content_slot.c();
    			t6 = space();
    			if (content_end_slot) content_end_slot.c();
    			attr_dev(div0, "class", "item-inner");
    			add_location(div0, file$g, 373, 14, 10913);
    			attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			add_location(div1, file$g, 360, 12, 10412);
    			set_attributes(a, a_data);
    			add_location(a, file$g, 352, 10, 10181);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, div1);

    			if (content_start_slot) {
    				content_start_slot.m(div1, null);
    			}

    			append_dev(div1, t0);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, div0);

    			if (inner_start_slot) {
    				inner_start_slot.m(div0, null);
    			}

    			append_dev(div0, t3);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div0, t4);

    			if (inner_end_slot) {
    				inner_end_slot.m(div0, null);
    			}

    			/*div0_binding*/ ctx[72](div0);
    			append_dev(div1, t5);

    			if (content_slot) {
    				content_slot.m(div1, null);
    			}

    			append_dev(div1, t6);

    			if (content_end_slot) {
    				content_end_slot.m(div1, null);
    			}

    			/*a_binding*/ ctx[73](a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[25])),
    					listen_dev(a, "click", /*onClick*/ ctx[46], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[83], dirty, get_content_start_slot_changes),
    						get_content_start_slot_context
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_25(ctx);
    					if_block0.c();
    					if_block0.m(div1, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*hasMedia*/ ctx[37]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasMedia*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_23(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_start_slot_changes),
    						get_inner_start_slot_context
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div0, t4);
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_end_slot_changes),
    						get_inner_end_slot_context
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[83], dirty, get_content_slot_changes),
    						get_content_slot_context
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[83], dirty, get_content_end_slot_changes),
    						get_content_end_slot_context
    					);
    				}
    			}

    			if (!current || dirty[1] & /*contentClasses*/ 1024) {
    				attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty[1] & /*linkClasses*/ 512) && { class: /*linkClasses*/ ctx[40] },
    				dirty[1] & /*linkAttrs*/ 256 && /*linkAttrs*/ ctx[39]
    			]));

    			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 33554432) useRouteProps_action.update.call(null, /*routeProps*/ ctx[25]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			/*div0_binding*/ ctx[72](null);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    			/*a_binding*/ ctx[73](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(352:8) {#if isLink}",
    		ctx
    	});

    	return block;
    }

    // (600:10) {:else}
    function create_else_block_4(ctx) {
    	let div1;
    	let t0;
    	let t1;
    	let t2;
    	let div0;
    	let t3;
    	let current_block_type_index;
    	let if_block2;
    	let t4;
    	let t5;
    	let t6;
    	let current;
    	let mounted;
    	let dispose;
    	const content_start_slot_template = /*#slots*/ ctx[69]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[83], get_content_start_slot_context_2);
    	let if_block0 = /*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44] && create_if_block_66(ctx);
    	let if_block1 = /*hasMedia*/ ctx[37] && create_if_block_64(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[69]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_start_slot_context_2);
    	const if_block_creators = [create_if_block_47, create_else_block_5];
    	const if_blocks = [];

    	function select_block_type_6(ctx, dirty) {
    		if (/*isMedia*/ ctx[26]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_6(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const inner_end_slot_template = /*#slots*/ ctx[69]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_end_slot_context_2);
    	const content_slot_template = /*#slots*/ ctx[69].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[83], get_content_slot_context_2);
    	const content_end_slot_template = /*#slots*/ ctx[69]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[83], get_content_end_slot_context_2);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (content_start_slot) content_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div0 = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t3 = space();
    			if_block2.c();
    			t4 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t5 = space();
    			if (content_slot) content_slot.c();
    			t6 = space();
    			if (content_end_slot) content_end_slot.c();
    			attr_dev(div0, "class", "item-inner");
    			add_location(div0, file$g, 613, 14, 20325);
    			attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			add_location(div1, file$g, 600, 12, 19805);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);

    			if (content_start_slot) {
    				content_start_slot.m(div1, null);
    			}

    			append_dev(div1, t0);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, div0);

    			if (inner_start_slot) {
    				inner_start_slot.m(div0, null);
    			}

    			append_dev(div0, t3);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div0, t4);

    			if (inner_end_slot) {
    				inner_end_slot.m(div0, null);
    			}

    			/*div0_binding_1*/ ctx[76](div0);
    			append_dev(div1, t5);

    			if (content_slot) {
    				content_slot.m(div1, null);
    			}

    			append_dev(div1, t6);

    			if (content_end_slot) {
    				content_end_slot.m(div1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", /*onClick*/ ctx[46], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[83], dirty, get_content_start_slot_changes_2),
    						get_content_start_slot_context_2
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_66(ctx);
    					if_block0.c();
    					if_block0.m(div1, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*hasMedia*/ ctx[37]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasMedia*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_64(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_start_slot_changes_2),
    						get_inner_start_slot_context_2
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_6(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div0, t4);
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_end_slot_changes_2),
    						get_inner_end_slot_context_2
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[83], dirty, get_content_slot_changes_2),
    						get_content_slot_context_2
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[83], dirty, get_content_end_slot_changes_2),
    						get_content_end_slot_context_2
    					);
    				}
    			}

    			if (!current || dirty[1] & /*contentClasses*/ 1024) {
    				attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			/*div0_binding_1*/ ctx[76](null);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4.name,
    		type: "else",
    		source: "(600:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (476:10) {#if checkbox || radio}
    function create_if_block_26(ctx) {
    	let label;
    	let t0;
    	let t1;
    	let input;
    	let input_value_value;
    	let input_type_value;
    	let t2;
    	let i;
    	let i_class_value;
    	let t3;
    	let t4;
    	let div;
    	let t5;
    	let current_block_type_index;
    	let if_block2;
    	let t6;
    	let t7;
    	let t8;
    	let current;
    	let mounted;
    	let dispose;
    	const content_start_slot_template = /*#slots*/ ctx[69]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[83], get_content_start_slot_context_1);
    	let if_block0 = /*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44] && create_if_block_46(ctx);
    	let if_block1 = /*hasMedia*/ ctx[37] && create_if_block_44(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[69]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_start_slot_context_1);
    	const if_block_creators = [create_if_block_27, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type_5(ctx, dirty) {
    		if (/*isMedia*/ ctx[26]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_5(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const inner_end_slot_template = /*#slots*/ ctx[69]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_end_slot_context_1);
    	const content_slot_template = /*#slots*/ ctx[69].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[83], get_content_slot_context_1);
    	const content_end_slot_template = /*#slots*/ ctx[69]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[83], get_content_end_slot_context_1);

    	const block = {
    		c: function create() {
    			label = element("label");
    			if (content_start_slot) content_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			i = element("i");
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			div = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t5 = space();
    			if_block2.c();
    			t6 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t7 = space();
    			if (content_slot) content_slot.c();
    			t8 = space();
    			if (content_end_slot) content_end_slot.c();

    			input.value = input_value_value = typeof /*value*/ ctx[20] === 'undefined'
    			? ''
    			: /*value*/ ctx[20];

    			attr_dev(input, "name", /*name*/ ctx[19]);
    			input.checked = /*checked*/ ctx[0];
    			input.readOnly = /*readonly*/ ctx[21];
    			input.disabled = /*disabled*/ ctx[23];
    			input.required = /*required*/ ctx[22];
    			attr_dev(input, "type", input_type_value = /*radio*/ ctx[18] ? 'radio' : 'checkbox');
    			add_location(input, file$g, 481, 14, 15195);
    			attr_dev(i, "class", i_class_value = `icon icon-${/*radio*/ ctx[18] ? 'radio' : 'checkbox'}`);
    			add_location(i, file$g, 492, 14, 15554);
    			attr_dev(div, "class", "item-inner");
    			add_location(div, file$g, 501, 14, 15896);
    			attr_dev(label, "class", /*contentClasses*/ ctx[41]);
    			add_location(label, file$g, 476, 12, 14943);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);

    			if (content_start_slot) {
    				content_start_slot.m(label, null);
    			}

    			append_dev(label, t0);
    			if (if_block0) if_block0.m(label, null);
    			append_dev(label, t1);
    			append_dev(label, input);
    			/*input_binding*/ ctx[74](input);
    			append_dev(label, t2);
    			append_dev(label, i);
    			append_dev(label, t3);
    			if (if_block1) if_block1.m(label, null);
    			append_dev(label, t4);
    			append_dev(label, div);

    			if (inner_start_slot) {
    				inner_start_slot.m(div, null);
    			}

    			append_dev(div, t5);
    			if_blocks[current_block_type_index].m(div, null);
    			append_dev(div, t6);

    			if (inner_end_slot) {
    				inner_end_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[75](div);
    			append_dev(label, t7);

    			if (content_slot) {
    				content_slot.m(label, null);
    			}

    			append_dev(label, t8);

    			if (content_end_slot) {
    				content_end_slot.m(label, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*onChange*/ ctx[47], false, false, false),
    					listen_dev(label, "click", /*onClick*/ ctx[46], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[83], dirty, get_content_start_slot_changes_1),
    						get_content_start_slot_context_1
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_46(ctx);
    					if_block0.c();
    					if_block0.m(label, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty[0] & /*value*/ 1048576 && input_value_value !== (input_value_value = typeof /*value*/ ctx[20] === 'undefined'
    			? ''
    			: /*value*/ ctx[20]) && input.value !== input_value_value) {
    				prop_dev(input, "value", input_value_value);
    			}

    			if (!current || dirty[0] & /*name*/ 524288) {
    				attr_dev(input, "name", /*name*/ ctx[19]);
    			}

    			if (!current || dirty[0] & /*checked*/ 1) {
    				prop_dev(input, "checked", /*checked*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*readonly*/ 2097152) {
    				prop_dev(input, "readOnly", /*readonly*/ ctx[21]);
    			}

    			if (!current || dirty[0] & /*disabled*/ 8388608) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[23]);
    			}

    			if (!current || dirty[0] & /*required*/ 4194304) {
    				prop_dev(input, "required", /*required*/ ctx[22]);
    			}

    			if (!current || dirty[0] & /*radio*/ 262144 && input_type_value !== (input_type_value = /*radio*/ ctx[18] ? 'radio' : 'checkbox')) {
    				attr_dev(input, "type", input_type_value);
    			}

    			if (!current || dirty[0] & /*radio*/ 262144 && i_class_value !== (i_class_value = `icon icon-${/*radio*/ ctx[18] ? 'radio' : 'checkbox'}`)) {
    				attr_dev(i, "class", i_class_value);
    			}

    			if (/*hasMedia*/ ctx[37]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasMedia*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_44(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(label, t4);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_start_slot_changes_1),
    						get_inner_start_slot_context_1
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_5(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div, t6);
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_end_slot_changes_1),
    						get_inner_end_slot_context_1
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[83], dirty, get_content_slot_changes_1),
    						get_content_slot_context_1
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[83], dirty, get_content_end_slot_changes_1),
    						get_content_end_slot_context_1
    					);
    				}
    			}

    			if (!current || dirty[1] & /*contentClasses*/ 1024) {
    				attr_dev(label, "class", /*contentClasses*/ ctx[41]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			/*input_binding*/ ctx[74](null);
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			/*div_binding*/ ctx[75](null);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_26.name,
    		type: "if",
    		source: "(476:10) {#if checkbox || radio}",
    		ctx
    	});

    	return block;
    }

    // (603:14) {#if isSortable && sortable !== false && isSortableOpposite}
    function create_if_block_66(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$g, 603, 16, 19988);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_66.name,
    		type: "if",
    		source: "(603:14) {#if isSortable && sortable !== false && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (606:14) {#if hasMedia}
    function create_if_block_64(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[3] !== 'undefined' && create_if_block_65(ctx);
    	const media_slot_template = /*#slots*/ ctx[69].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[83], get_media_slot_context_2);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$g, 606, 16, 20086);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[3] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_65(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[83], dirty, get_media_slot_changes_2),
    						get_media_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_64.name,
    		type: "if",
    		source: "(606:14) {#if hasMedia}",
    		ctx
    	});

    	return block;
    }

    // (608:18) {#if typeof media !== 'undefined'}
    function create_if_block_65(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$g, 608, 20, 20184);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 8 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_65.name,
    		type: "if",
    		source: "(608:18) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (668:16) {:else}
    function create_else_block_5(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block2_anchor;
    	let current;
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_5);
    	let if_block0 = (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) && create_if_block_61(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_5);
    	let if_block1 = /*hasAfter*/ ctx[31] && create_if_block_58(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_5);
    	let if_block2 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_57(ctx);

    	const block = {
    		c: function create() {
    			if (before_title_slot) before_title_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (after_title_slot) after_title_slot.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (inner_slot) inner_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (before_title_slot) {
    				before_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (after_title_slot) {
    				after_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t4, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_5),
    						get_before_title_slot_context_5
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 56) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_61(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_5),
    						get_after_title_slot_context_5
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_58(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_5),
    						get_inner_slot_context_5
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_57(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_title_slot, local);
    			transition_in(if_block0);
    			transition_in(after_title_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_slot, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_title_slot, local);
    			transition_out(if_block0);
    			transition_out(after_title_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_slot, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_5.name,
    		type: "else",
    		source: "(668:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (616:16) {#if isMedia}
    function create_if_block_47(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let if_block6_anchor;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_56(ctx);
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_4);
    	let if_block1 = /*hasTitle*/ ctx[36] && create_if_block_55(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_4);
    	let if_block2 = /*hasAfter*/ ctx[31] && create_if_block_52(ctx);
    	let if_block3 = /*hasSubtitle*/ ctx[33] && create_if_block_51(ctx);
    	let if_block4 = /*hasText*/ ctx[32] && create_if_block_50(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_4);
    	let if_block5 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_49(ctx);
    	let if_block6 = /*hasFooter*/ ctx[34] && create_if_block_48(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (before_title_slot) before_title_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_title_slot) after_title_slot.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (inner_slot) inner_slot.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    			attr_dev(div, "class", "item-title-row");
    			add_location(div, file$g, 622, 18, 20680);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			if (before_title_slot) {
    				before_title_slot.m(div, null);
    			}

    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_title_slot) {
    				after_title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block2) if_block2.m(div, null);
    			insert_dev(target, t4, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t6, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t7, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_56(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_4),
    						get_before_title_slot_context_4
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_55(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_4),
    						get_after_title_slot_context_4
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_52(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*hasSubtitle*/ ctx[33]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[1] & /*hasSubtitle*/ 4) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_51(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t5.parentNode, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*hasText*/ ctx[32]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasText*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_50(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t6.parentNode, t6);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_4),
    						get_inner_slot_context_4
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_49(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t8.parentNode, t8);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_48(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(before_title_slot, local);
    			transition_in(if_block1);
    			transition_in(after_title_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(inner_slot, local);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(before_title_slot, local);
    			transition_out(if_block1);
    			transition_out(after_title_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(inner_slot, local);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t4);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_47.name,
    		type: "if",
    		source: "(616:16) {#if isMedia}",
    		ctx
    	});

    	return block;
    }

    // (670:18) {#if hasTitle || hasHeader || hasFooter}
    function create_if_block_61(ctx) {
    	let div;
    	let t0;
    	let t1_value = plainText(/*title*/ ctx[1]) + "";
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_63(ctx);
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_5);
    	let if_block1 = /*hasFooter*/ ctx[34] && create_if_block_62(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			t1 = text$1(t1_value);
    			t2 = space();
    			if (title_slot) title_slot.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$g, 670, 20, 22607);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_63(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*title*/ 2) && t1_value !== (t1_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t1, t1_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_5),
    						get_title_slot_context_5
    					);
    				}
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_62(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(title_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(title_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (title_slot) title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_61.name,
    		type: "if",
    		source: "(670:18) {#if hasTitle || hasHeader || hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (672:22) {#if hasHeader}
    function create_if_block_63(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_5);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$g, 672, 24, 22694);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_5),
    						get_header_slot_context_5
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_63.name,
    		type: "if",
    		source: "(672:22) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (680:22) {#if hasFooter}
    function create_if_block_62(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_5);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$g, 680, 24, 23021);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_5),
    						get_footer_slot_context_5
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_62.name,
    		type: "if",
    		source: "(680:22) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (689:18) {#if hasAfter}
    function create_if_block_58(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_5);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_60(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_59(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_5);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_5);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$g, 689, 20, 23351);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_5),
    						get_after_start_slot_context_5
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_60(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_59(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_5),
    						get_after_slot_context_5
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_5),
    						get_after_end_slot_context_5
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_58.name,
    		type: "if",
    		source: "(689:18) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (692:22) {#if typeof after !== 'undefined'}
    function create_if_block_60(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$g, 692, 24, 23507);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_60.name,
    		type: "if",
    		source: "(692:22) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (695:22) {#if typeof badge !== 'undefined'}
    function create_if_block_59(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_59.name,
    		type: "if",
    		source: "(695:22) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (696:24) <Badge color={badgeColor}>
    function create_default_slot_5$2(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(696:24) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (703:18) {#if !(swipeout || accordionItem)}
    function create_if_block_57(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_57.name,
    		type: "if",
    		source: "(703:18) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (617:18) {#if hasHeader}
    function create_if_block_56(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_4);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$g, 617, 20, 20498);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_4),
    						get_header_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_56.name,
    		type: "if",
    		source: "(617:18) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (625:20) {#if hasTitle}
    function create_if_block_55(ctx) {
    	let div;
    	let t0_value = plainText(/*title*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_4);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (title_slot) title_slot.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$g, 625, 22, 20815);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_4),
    						get_title_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_55.name,
    		type: "if",
    		source: "(625:20) {#if hasTitle}",
    		ctx
    	});

    	return block;
    }

    // (632:20) {#if hasAfter}
    function create_if_block_52(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_4);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_54(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_53(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_4);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_4);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$g, 632, 22, 21089);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_4),
    						get_after_start_slot_context_4
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_54(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_53(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_4),
    						get_after_slot_context_4
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_4),
    						get_after_end_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_52.name,
    		type: "if",
    		source: "(632:20) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (635:24) {#if typeof after !== 'undefined'}
    function create_if_block_54(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$g, 635, 26, 21251);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_54.name,
    		type: "if",
    		source: "(635:24) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (638:24) {#if typeof badge !== 'undefined'}
    function create_if_block_53(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_53.name,
    		type: "if",
    		source: "(638:24) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (639:26) <Badge color={badgeColor}>
    function create_default_slot_4$2(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(639:26) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (646:18) {#if hasSubtitle}
    function create_if_block_51(ctx) {
    	let div;
    	let t0_value = plainText(/*subtitle*/ ctx[4]) + "";
    	let t0;
    	let t1;
    	let current;
    	const subtitle_slot_template = /*#slots*/ ctx[69].subtitle;
    	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[83], get_subtitle_slot_context_2);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (subtitle_slot) subtitle_slot.c();
    			attr_dev(div, "class", "item-subtitle");
    			add_location(div, file$g, 646, 20, 21713);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (subtitle_slot) {
    				subtitle_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*subtitle*/ 16) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

    			if (subtitle_slot) {
    				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						subtitle_slot,
    						subtitle_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[83], dirty, get_subtitle_slot_changes_2),
    						get_subtitle_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(subtitle_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(subtitle_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (subtitle_slot) subtitle_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_51.name,
    		type: "if",
    		source: "(646:18) {#if hasSubtitle}",
    		ctx
    	});

    	return block;
    }

    // (652:18) {#if hasText}
    function create_if_block_50(ctx) {
    	let div;
    	let t0_value = plainText(/*text*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const text_slot_template = /*#slots*/ ctx[69].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[83], get_text_slot_context_2);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (text_slot) text_slot.c();
    			attr_dev(div, "class", "item-text");
    			add_location(div, file$g, 652, 20, 21935);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[83], dirty, get_text_slot_changes_2),
    						get_text_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (text_slot) text_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_50.name,
    		type: "if",
    		source: "(652:18) {#if hasText}",
    		ctx
    	});

    	return block;
    }

    // (659:18) {#if !(swipeout || accordionItem)}
    function create_if_block_49(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_49.name,
    		type: "if",
    		source: "(659:18) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (662:18) {#if hasFooter}
    function create_if_block_48(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_4);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$g, 662, 20, 22293);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_4),
    						get_footer_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_48.name,
    		type: "if",
    		source: "(662:18) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (479:14) {#if isSortable && sortable !== false && isSortableOpposite}
    function create_if_block_46(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$g, 479, 16, 15128);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_46.name,
    		type: "if",
    		source: "(479:14) {#if isSortable && sortable !== false && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (494:14) {#if hasMedia}
    function create_if_block_44(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[3] !== 'undefined' && create_if_block_45(ctx);
    	const media_slot_template = /*#slots*/ ctx[69].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[83], get_media_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$g, 494, 16, 15657);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[3] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_45(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[83], dirty, get_media_slot_changes_1),
    						get_media_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_44.name,
    		type: "if",
    		source: "(494:14) {#if hasMedia}",
    		ctx
    	});

    	return block;
    }

    // (496:18) {#if typeof media !== 'undefined'}
    function create_if_block_45(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$g, 496, 20, 15755);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 8 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_45.name,
    		type: "if",
    		source: "(496:18) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (556:16) {:else}
    function create_else_block_3(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block2_anchor;
    	let current;
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_3);
    	let if_block0 = (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) && create_if_block_41(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_3);
    	let if_block1 = /*hasAfter*/ ctx[31] && create_if_block_38(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_3);
    	let if_block2 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_37(ctx);

    	const block = {
    		c: function create() {
    			if (before_title_slot) before_title_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (after_title_slot) after_title_slot.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (inner_slot) inner_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (before_title_slot) {
    				before_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (after_title_slot) {
    				after_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t4, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_3),
    						get_before_title_slot_context_3
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 56) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_41(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_3),
    						get_after_title_slot_context_3
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_38(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_3),
    						get_inner_slot_context_3
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_37(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_title_slot, local);
    			transition_in(if_block0);
    			transition_in(after_title_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_slot, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_title_slot, local);
    			transition_out(if_block0);
    			transition_out(after_title_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_slot, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(556:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (504:16) {#if isMedia}
    function create_if_block_27(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let if_block6_anchor;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_36(ctx);
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_2);
    	let if_block1 = /*hasTitle*/ ctx[36] && create_if_block_35(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_2);
    	let if_block2 = /*hasAfter*/ ctx[31] && create_if_block_32(ctx);
    	let if_block3 = /*hasSubtitle*/ ctx[33] && create_if_block_31(ctx);
    	let if_block4 = /*hasText*/ ctx[32] && create_if_block_30(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_2);
    	let if_block5 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_29(ctx);
    	let if_block6 = /*hasFooter*/ ctx[34] && create_if_block_28(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (before_title_slot) before_title_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_title_slot) after_title_slot.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (inner_slot) inner_slot.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    			attr_dev(div, "class", "item-title-row");
    			add_location(div, file$g, 510, 18, 16251);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			if (before_title_slot) {
    				before_title_slot.m(div, null);
    			}

    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_title_slot) {
    				after_title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block2) if_block2.m(div, null);
    			insert_dev(target, t4, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t6, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t7, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_36(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_2),
    						get_before_title_slot_context_2
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_35(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_2),
    						get_after_title_slot_context_2
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_32(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*hasSubtitle*/ ctx[33]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[1] & /*hasSubtitle*/ 4) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_31(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t5.parentNode, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*hasText*/ ctx[32]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasText*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_30(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t6.parentNode, t6);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_2),
    						get_inner_slot_context_2
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_29(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t8.parentNode, t8);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_28(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(before_title_slot, local);
    			transition_in(if_block1);
    			transition_in(after_title_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(inner_slot, local);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(before_title_slot, local);
    			transition_out(if_block1);
    			transition_out(after_title_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(inner_slot, local);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t4);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_27.name,
    		type: "if",
    		source: "(504:16) {#if isMedia}",
    		ctx
    	});

    	return block;
    }

    // (558:18) {#if hasTitle || hasHeader || hasFooter}
    function create_if_block_41(ctx) {
    	let div;
    	let t0;
    	let t1_value = plainText(/*title*/ ctx[1]) + "";
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_43(ctx);
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_3);
    	let if_block1 = /*hasFooter*/ ctx[34] && create_if_block_42(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			t1 = text$1(t1_value);
    			t2 = space();
    			if (title_slot) title_slot.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$g, 558, 20, 18178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_43(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*title*/ 2) && t1_value !== (t1_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t1, t1_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_3),
    						get_title_slot_context_3
    					);
    				}
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_42(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(title_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(title_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (title_slot) title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_41.name,
    		type: "if",
    		source: "(558:18) {#if hasTitle || hasHeader || hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (560:22) {#if hasHeader}
    function create_if_block_43(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_3);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$g, 560, 24, 18265);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_3),
    						get_header_slot_context_3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_43.name,
    		type: "if",
    		source: "(560:22) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (568:22) {#if hasFooter}
    function create_if_block_42(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_3);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$g, 568, 24, 18592);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_3),
    						get_footer_slot_context_3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_42.name,
    		type: "if",
    		source: "(568:22) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (577:18) {#if hasAfter}
    function create_if_block_38(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_3);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_40(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_39(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_3);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_3);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$g, 577, 20, 18922);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_3),
    						get_after_start_slot_context_3
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_40(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_39(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_3),
    						get_after_slot_context_3
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_3),
    						get_after_end_slot_context_3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_38.name,
    		type: "if",
    		source: "(577:18) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (580:22) {#if typeof after !== 'undefined'}
    function create_if_block_40(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$g, 580, 24, 19078);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_40.name,
    		type: "if",
    		source: "(580:22) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (583:22) {#if typeof badge !== 'undefined'}
    function create_if_block_39(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_39.name,
    		type: "if",
    		source: "(583:22) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (584:24) <Badge color={badgeColor}>
    function create_default_slot_3$2(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(584:24) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (591:18) {#if !(swipeout || accordionItem)}
    function create_if_block_37(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_37.name,
    		type: "if",
    		source: "(591:18) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (505:18) {#if hasHeader}
    function create_if_block_36(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_2);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$g, 505, 20, 16069);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_2),
    						get_header_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_36.name,
    		type: "if",
    		source: "(505:18) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (513:20) {#if hasTitle}
    function create_if_block_35(ctx) {
    	let div;
    	let t0_value = plainText(/*title*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_2);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (title_slot) title_slot.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$g, 513, 22, 16386);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_2),
    						get_title_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_35.name,
    		type: "if",
    		source: "(513:20) {#if hasTitle}",
    		ctx
    	});

    	return block;
    }

    // (520:20) {#if hasAfter}
    function create_if_block_32(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_2);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_34(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_33(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_2);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_2);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$g, 520, 22, 16660);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_2),
    						get_after_start_slot_context_2
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_34(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_33(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_2),
    						get_after_slot_context_2
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_2),
    						get_after_end_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_32.name,
    		type: "if",
    		source: "(520:20) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (523:24) {#if typeof after !== 'undefined'}
    function create_if_block_34(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$g, 523, 26, 16822);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_34.name,
    		type: "if",
    		source: "(523:24) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (526:24) {#if typeof badge !== 'undefined'}
    function create_if_block_33(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_33.name,
    		type: "if",
    		source: "(526:24) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (527:26) <Badge color={badgeColor}>
    function create_default_slot_2$4(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(527:26) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (534:18) {#if hasSubtitle}
    function create_if_block_31(ctx) {
    	let div;
    	let t0_value = plainText(/*subtitle*/ ctx[4]) + "";
    	let t0;
    	let t1;
    	let current;
    	const subtitle_slot_template = /*#slots*/ ctx[69].subtitle;
    	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[83], get_subtitle_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (subtitle_slot) subtitle_slot.c();
    			attr_dev(div, "class", "item-subtitle");
    			add_location(div, file$g, 534, 20, 17284);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (subtitle_slot) {
    				subtitle_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*subtitle*/ 16) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

    			if (subtitle_slot) {
    				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						subtitle_slot,
    						subtitle_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[83], dirty, get_subtitle_slot_changes_1),
    						get_subtitle_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(subtitle_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(subtitle_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (subtitle_slot) subtitle_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_31.name,
    		type: "if",
    		source: "(534:18) {#if hasSubtitle}",
    		ctx
    	});

    	return block;
    }

    // (540:18) {#if hasText}
    function create_if_block_30(ctx) {
    	let div;
    	let t0_value = plainText(/*text*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const text_slot_template = /*#slots*/ ctx[69].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[83], get_text_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (text_slot) text_slot.c();
    			attr_dev(div, "class", "item-text");
    			add_location(div, file$g, 540, 20, 17506);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[83], dirty, get_text_slot_changes_1),
    						get_text_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (text_slot) text_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_30.name,
    		type: "if",
    		source: "(540:18) {#if hasText}",
    		ctx
    	});

    	return block;
    }

    // (547:18) {#if !(swipeout || accordionItem)}
    function create_if_block_29(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_29.name,
    		type: "if",
    		source: "(547:18) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (550:18) {#if hasFooter}
    function create_if_block_28(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_2);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$g, 550, 20, 17864);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_2),
    						get_footer_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_28.name,
    		type: "if",
    		source: "(550:18) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (363:14) {#if isSortable && sortable !== false && isSortableOpposite}
    function create_if_block_25(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$g, 363, 16, 10576);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_25.name,
    		type: "if",
    		source: "(363:14) {#if isSortable && sortable !== false && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (366:14) {#if hasMedia}
    function create_if_block_23(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[3] !== 'undefined' && create_if_block_24(ctx);
    	const media_slot_template = /*#slots*/ ctx[69].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[83], get_media_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$g, 366, 16, 10674);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[3] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_24(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[83], dirty, get_media_slot_changes),
    						get_media_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_23.name,
    		type: "if",
    		source: "(366:14) {#if hasMedia}",
    		ctx
    	});

    	return block;
    }

    // (368:18) {#if typeof media !== 'undefined'}
    function create_if_block_24(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$g, 368, 20, 10772);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 8 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_24.name,
    		type: "if",
    		source: "(368:18) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (428:16) {:else}
    function create_else_block_1$1(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block2_anchor;
    	let current;
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_1);
    	let if_block0 = (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) && create_if_block_20(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_1);
    	let if_block1 = /*hasAfter*/ ctx[31] && create_if_block_17(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_1);
    	let if_block2 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_16(ctx);

    	const block = {
    		c: function create() {
    			if (before_title_slot) before_title_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (after_title_slot) after_title_slot.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (inner_slot) inner_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (before_title_slot) {
    				before_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (after_title_slot) {
    				after_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t4, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_1),
    						get_before_title_slot_context_1
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 56) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_20(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_1),
    						get_after_title_slot_context_1
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_17(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_1),
    						get_inner_slot_context_1
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_16(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_title_slot, local);
    			transition_in(if_block0);
    			transition_in(after_title_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_slot, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_title_slot, local);
    			transition_out(if_block0);
    			transition_out(after_title_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_slot, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(428:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (376:16) {#if isMedia}
    function create_if_block_6(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let if_block6_anchor;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_15(ctx);
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context);
    	let if_block1 = /*hasTitle*/ ctx[36] && create_if_block_14(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context);
    	let if_block2 = /*hasAfter*/ ctx[31] && create_if_block_11(ctx);
    	let if_block3 = /*hasSubtitle*/ ctx[33] && create_if_block_10(ctx);
    	let if_block4 = /*hasText*/ ctx[32] && create_if_block_9(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context);
    	let if_block5 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_8(ctx);
    	let if_block6 = /*hasFooter*/ ctx[34] && create_if_block_7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (before_title_slot) before_title_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_title_slot) after_title_slot.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (inner_slot) inner_slot.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    			attr_dev(div, "class", "item-title-row");
    			add_location(div, file$g, 382, 18, 11268);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			if (before_title_slot) {
    				before_title_slot.m(div, null);
    			}

    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_title_slot) {
    				after_title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block2) if_block2.m(div, null);
    			insert_dev(target, t4, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t6, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t7, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_15(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes),
    						get_before_title_slot_context
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_14(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes),
    						get_after_title_slot_context
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_11(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*hasSubtitle*/ ctx[33]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[1] & /*hasSubtitle*/ 4) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_10(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t5.parentNode, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*hasText*/ ctx[32]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasText*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_9(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t6.parentNode, t6);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes),
    						get_inner_slot_context
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_8(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t8.parentNode, t8);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_7(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(before_title_slot, local);
    			transition_in(if_block1);
    			transition_in(after_title_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(inner_slot, local);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(before_title_slot, local);
    			transition_out(if_block1);
    			transition_out(after_title_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(inner_slot, local);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t4);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(376:16) {#if isMedia}",
    		ctx
    	});

    	return block;
    }

    // (430:18) {#if hasTitle || hasHeader || hasFooter}
    function create_if_block_20(ctx) {
    	let div;
    	let t0;
    	let t1_value = plainText(/*title*/ ctx[1]) + "";
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_22(ctx);
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_1);
    	let if_block1 = /*hasFooter*/ ctx[34] && create_if_block_21(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			t1 = text$1(t1_value);
    			t2 = space();
    			if (title_slot) title_slot.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$g, 430, 20, 13195);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_22(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*title*/ 2) && t1_value !== (t1_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t1, t1_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_1),
    						get_title_slot_context_1
    					);
    				}
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_21(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(title_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(title_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (title_slot) title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_20.name,
    		type: "if",
    		source: "(430:18) {#if hasTitle || hasHeader || hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (432:22) {#if hasHeader}
    function create_if_block_22(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$g, 432, 24, 13282);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_1),
    						get_header_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_22.name,
    		type: "if",
    		source: "(432:22) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (440:22) {#if hasFooter}
    function create_if_block_21(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$g, 440, 24, 13609);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_1),
    						get_footer_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_21.name,
    		type: "if",
    		source: "(440:22) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (449:18) {#if hasAfter}
    function create_if_block_17(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_1);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_19(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_18(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_1);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$g, 449, 20, 13939);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_1),
    						get_after_start_slot_context_1
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_19(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_18(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_1),
    						get_after_slot_context_1
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_1),
    						get_after_end_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17.name,
    		type: "if",
    		source: "(449:18) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (452:22) {#if typeof after !== 'undefined'}
    function create_if_block_19(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$g, 452, 24, 14095);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19.name,
    		type: "if",
    		source: "(452:22) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (455:22) {#if typeof badge !== 'undefined'}
    function create_if_block_18(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18.name,
    		type: "if",
    		source: "(455:22) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (456:24) <Badge color={badgeColor}>
    function create_default_slot_1$4(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(456:24) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (463:18) {#if !(swipeout || accordionItem)}
    function create_if_block_16(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16.name,
    		type: "if",
    		source: "(463:18) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (377:18) {#if hasHeader}
    function create_if_block_15(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$g, 377, 20, 11086);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes),
    						get_header_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15.name,
    		type: "if",
    		source: "(377:18) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (385:20) {#if hasTitle}
    function create_if_block_14(ctx) {
    	let div;
    	let t0_value = plainText(/*title*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context$1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (title_slot) title_slot.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$g, 385, 22, 11403);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes$1),
    						get_title_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(385:20) {#if hasTitle}",
    		ctx
    	});

    	return block;
    }

    // (392:20) {#if hasAfter}
    function create_if_block_11(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_13(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_12(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$g, 392, 22, 11677);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes),
    						get_after_start_slot_context
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_13(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_12(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes),
    						get_after_slot_context
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes),
    						get_after_end_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(392:20) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (395:24) {#if typeof after !== 'undefined'}
    function create_if_block_13(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$g, 395, 26, 11839);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(395:24) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (398:24) {#if typeof badge !== 'undefined'}
    function create_if_block_12(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(398:24) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (399:26) <Badge color={badgeColor}>
    function create_default_slot$9(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(399:26) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (406:18) {#if hasSubtitle}
    function create_if_block_10(ctx) {
    	let div;
    	let t0_value = plainText(/*subtitle*/ ctx[4]) + "";
    	let t0;
    	let t1;
    	let current;
    	const subtitle_slot_template = /*#slots*/ ctx[69].subtitle;
    	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[83], get_subtitle_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (subtitle_slot) subtitle_slot.c();
    			attr_dev(div, "class", "item-subtitle");
    			add_location(div, file$g, 406, 20, 12301);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (subtitle_slot) {
    				subtitle_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*subtitle*/ 16) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

    			if (subtitle_slot) {
    				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						subtitle_slot,
    						subtitle_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[83], dirty, get_subtitle_slot_changes),
    						get_subtitle_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(subtitle_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(subtitle_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (subtitle_slot) subtitle_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(406:18) {#if hasSubtitle}",
    		ctx
    	});

    	return block;
    }

    // (412:18) {#if hasText}
    function create_if_block_9(ctx) {
    	let div;
    	let t0_value = plainText(/*text*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const text_slot_template = /*#slots*/ ctx[69].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[83], get_text_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (text_slot) text_slot.c();
    			attr_dev(div, "class", "item-text");
    			add_location(div, file$g, 412, 20, 12523);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[83], dirty, get_text_slot_changes),
    						get_text_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (text_slot) text_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(412:18) {#if hasText}",
    		ctx
    	});

    	return block;
    }

    // (419:18) {#if !(swipeout || accordionItem)}
    function create_if_block_8(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(419:18) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (422:18) {#if hasFooter}
    function create_if_block_7(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$g, 422, 20, 12881);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes),
    						get_footer_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(422:18) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (1079:4) {#if isSortable && sortable !== false && !isSortableOpposite}
    function create_if_block_3$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$g, 1079, 6, 37024);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(1079:4) {#if isSortable && sortable !== false && !isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (1082:4) {#if swipeout || accordionItem}
    function create_if_block_2$4(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(1082:4) {#if swipeout || accordionItem}",
    		ctx
    	});

    	return block;
    }

    // (327:16) {plainText(title)}
    function fallback_block(ctx) {
    	let t_value = plainText(/*title*/ ctx[1]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*title*/ 2 && t_value !== (t_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(327:16) {plainText(title)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$a, create_if_block_1$6, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*divider*/ ctx[12] || /*groupTitle*/ ctx[13]) return 0;
    		if (/*isSimple*/ ctx[43]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let isMedia;
    	let isSortable;
    	let isSortableOpposite;
    	let isSimple;
    	let liClasses;
    	let contentClasses;
    	let linkClasses;
    	let linkAttrs;
    	let isLink;
    	let hasMedia;
    	let hasTitle;
    	let hasHeader;
    	let hasFooter;
    	let hasSubtitle;
    	let hasText;
    	let hasAfter;

    	const omit_props_names = [
    		"class","title","text","media","subtitle","header","footer","tooltip","tooltipTrigger","link","tabLink","tabLinkActive","selected","href","target","after","badge","badgeColor","mediaItem","mediaList","divider","groupTitle","swipeout","swipeoutOpened","sortable","sortableOpposite","accordionItem","accordionItemOpened","smartSelect","smartSelectParams","noChevron","chevronCenter","checkbox","radio","radioIcon","checked","indeterminate","name","value","readonly","required","disabled","virtualListIndex","routeProps","smartSelectInstance"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;

    	validate_slots('List_item', slots, [
    		'default','root-start','content-start','media','inner-start','header','before-title','title','after-title','after-start','after','after-end','subtitle','text','inner','footer','inner-end','content','content-end','root','root-end'
    	]);

    	const $$slots = compute_slots(slots);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { title = undefined } = $$props;
    	let { text = undefined } = $$props;
    	let { media = undefined } = $$props;
    	let { subtitle = undefined } = $$props;
    	let { header = undefined } = $$props;
    	let { footer = undefined } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { tooltipTrigger = undefined } = $$props;
    	let { link = undefined } = $$props;
    	let { tabLink = undefined } = $$props;
    	let { tabLinkActive = false } = $$props;
    	let { selected = false } = $$props;
    	let { href = undefined } = $$props;
    	let { target = undefined } = $$props;
    	let { after = undefined } = $$props;
    	let { badge = undefined } = $$props;
    	let { badgeColor = undefined } = $$props;
    	let { mediaItem = false } = $$props;
    	let { mediaList = false } = $$props;
    	let { divider = false } = $$props;
    	let { groupTitle = false } = $$props;
    	let { swipeout = false } = $$props;
    	let { swipeoutOpened = false } = $$props;
    	let { sortable = undefined } = $$props;
    	let { sortableOpposite = undefined } = $$props;
    	let { accordionItem = false } = $$props;
    	let { accordionItemOpened = false } = $$props;
    	let { smartSelect = false } = $$props;
    	let { smartSelectParams = undefined } = $$props;
    	let { noChevron = undefined } = $$props;
    	let { chevronCenter = undefined } = $$props;
    	let { checkbox = undefined } = $$props;
    	let { radio = undefined } = $$props;
    	let { radioIcon = undefined } = $$props;
    	let { checked = undefined } = $$props;
    	let { indeterminate = undefined } = $$props;
    	let { name = undefined } = $$props;
    	let { value = undefined } = $$props;
    	let { readonly = undefined } = $$props;
    	let { required = undefined } = $$props;
    	let { disabled = undefined } = $$props;
    	let { virtualListIndex = undefined } = $$props;
    	let { routeProps = undefined } = $$props;
    	let el;
    	let linkEl;
    	let innerEl;
    	let inputEl;
    	let f7SmartSelect;

    	function smartSelectInstance() {
    		return f7SmartSelect;
    	}

    	let ListContext = getReactiveContext('ListContext', value => {
    		$$invalidate(68, ListContext = value || {});
    	}) || {};

    	/* eslint-enable no-undef */
    	let initialWatchedOpened = false;

    	function watchSwipeoutOpened(opened) {
    		if (!initialWatchedOpened) {
    			initialWatchedOpened = true;
    			return;
    		}

    		if (!swipeout) return;

    		if (opened) {
    			app$1.f7.swipeout.open(el);
    		} else {
    			app$1.f7.swipeout.close(el);
    		}
    	}

    	function onClick(event) {
    		if (event.target.tagName.toLowerCase() !== 'input') {
    			emit('click', event);
    		}
    	}

    	function onSwipeoutOverswipeEnter(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutOverswipeEnter');
    	}

    	function onSwipeoutOverswipeExit(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutOverswipeExit');
    	}

    	function onSwipeoutDeleted(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutDeleted');
    	}

    	function onSwipeoutDelete(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutDelete');
    	}

    	function onSwipeoutClose(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutClose');
    	}

    	function onSwipeoutClosed(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutClosed');
    	}

    	function onSwipeoutOpen(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutOpen');
    	}

    	function onSwipeoutOpened(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutOpened');
    	}

    	function onSwipeout(eventEl, progress) {
    		if (eventEl !== el) return;
    		emit('swipeout', progress);
    	}

    	function onAccBeforeClose(eventEl, prevent) {
    		if (eventEl !== el) return;
    		emit('accordionBeforeClose', [prevent]);
    	}

    	function onAccClose(eventEl) {
    		if (eventEl !== el) return;
    		emit('accordionClose');
    	}

    	function onAccClosed(eventEl) {
    		if (eventEl !== el) return;
    		emit('accordionClosed');
    	}

    	function onAccBeforeOpen(eventEl, prevent) {
    		if (eventEl !== el) return;
    		emit('accordionBeforeOpen', [prevent]);
    	}

    	function onAccOpen(eventEl) {
    		if (eventEl !== el) return;
    		emit('accordionOpen');
    	}

    	function onAccOpened(eventEl) {
    		if (eventEl !== el) return;
    		emit('accordionOpened');
    	}

    	function onChange(event) {
    		emit('change', [event]);
    		$$invalidate(0, checked = event.target.checked);
    	}

    	useSmartSelect(
    		{ smartSelect, smartSelectParams },
    		instance => {
    			f7SmartSelect = instance;
    		},
    		() => linkEl
    	);

    	onMount(() => {
    		if (indeterminate && inputEl) {
    			$$invalidate(30, inputEl.indeterminate = true, inputEl);
    		}

    		f7ready(() => {
    			if (swipeout) {
    				app$1.f7.on('swipeoutOpen', onSwipeoutOpen);
    				app$1.f7.on('swipeoutOpened', onSwipeoutOpened);
    				app$1.f7.on('swipeoutClose', onSwipeoutClose);
    				app$1.f7.on('swipeoutClosed', onSwipeoutClosed);
    				app$1.f7.on('swipeoutDelete', onSwipeoutDelete);
    				app$1.f7.on('swipeoutDeleted', onSwipeoutDeleted);
    				app$1.f7.on('swipeoutOverswipeEnter', onSwipeoutOverswipeEnter);
    				app$1.f7.on('swipeoutOverswipeExit', onSwipeoutOverswipeExit);
    				app$1.f7.on('swipeout', onSwipeout);
    			}

    			if (accordionItem) {
    				app$1.f7.on('accordionBeforeOpen', onAccBeforeOpen);
    				app$1.f7.on('accordionOpen', onAccOpen);
    				app$1.f7.on('accordionOpened', onAccOpened);
    				app$1.f7.on('accordionBeforeClose', onAccBeforeClose);
    				app$1.f7.on('accordionClose', onAccClose);
    				app$1.f7.on('accordionClosed', onAccClosed);
    			}

    			if (swipeoutOpened) {
    				app$1.f7.swipeout.open(el);
    			}
    		});
    	});

    	afterUpdate(() => {
    		if (inputEl) {
    			$$invalidate(30, inputEl.indeterminate = indeterminate, inputEl);
    		}
    	});

    	onDestroy(() => {
    		if (!app$1.f7) return;

    		if (swipeout) {
    			app$1.f7.off('swipeoutOpen', onSwipeoutOpen);
    			app$1.f7.off('swipeoutOpened', onSwipeoutOpened);
    			app$1.f7.off('swipeoutClose', onSwipeoutClose);
    			app$1.f7.off('swipeoutClosed', onSwipeoutClosed);
    			app$1.f7.off('swipeoutDelete', onSwipeoutDelete);
    			app$1.f7.off('swipeoutDeleted', onSwipeoutDeleted);
    			app$1.f7.off('swipeoutOverswipeEnter', onSwipeoutOverswipeEnter);
    			app$1.f7.off('swipeoutOverswipeExit', onSwipeoutOverswipeExit);
    			app$1.f7.off('swipeout', onSwipeout);
    		}

    		if (accordionItem) {
    			app$1.f7.off('accordionBeforeOpen', onAccBeforeOpen);
    			app$1.f7.off('accordionOpen', onAccOpen);
    			app$1.f7.off('accordionOpened', onAccOpened);
    			app$1.f7.off('accordionBeforeClose', onAccBeforeClose);
    			app$1.f7.off('accordionClose', onAccClose);
    			app$1.f7.off('accordionClosed', onAccClosed);
    		}
    	});

    	function li_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(27, el);
    		});
    	}

    	function li_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(27, el);
    		});
    	}

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			innerEl = $$value;
    			$$invalidate(29, innerEl);
    		});
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			linkEl = $$value;
    			$$invalidate(28, linkEl);
    		});
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(30, inputEl);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			innerEl = $$value;
    			$$invalidate(29, innerEl);
    		});
    	}

    	function div0_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			innerEl = $$value;
    			$$invalidate(29, innerEl);
    		});
    	}

    	function div0_binding_2($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			innerEl = $$value;
    			$$invalidate(29, innerEl);
    		});
    	}

    	function a_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			linkEl = $$value;
    			$$invalidate(28, linkEl);
    		});
    	}

    	function input_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(30, inputEl);
    		});
    	}

    	function div_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			innerEl = $$value;
    			$$invalidate(29, innerEl);
    		});
    	}

    	function div0_binding_3($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			innerEl = $$value;
    			$$invalidate(29, innerEl);
    		});
    	}

    	function li_binding_2($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(27, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(104, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(48, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(49, className = $$new_props.class);
    		if ('title' in $$new_props) $$invalidate(1, title = $$new_props.title);
    		if ('text' in $$new_props) $$invalidate(2, text = $$new_props.text);
    		if ('media' in $$new_props) $$invalidate(3, media = $$new_props.media);
    		if ('subtitle' in $$new_props) $$invalidate(4, subtitle = $$new_props.subtitle);
    		if ('header' in $$new_props) $$invalidate(5, header = $$new_props.header);
    		if ('footer' in $$new_props) $$invalidate(6, footer = $$new_props.footer);
    		if ('tooltip' in $$new_props) $$invalidate(7, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$new_props) $$invalidate(8, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('link' in $$new_props) $$invalidate(50, link = $$new_props.link);
    		if ('tabLink' in $$new_props) $$invalidate(51, tabLink = $$new_props.tabLink);
    		if ('tabLinkActive' in $$new_props) $$invalidate(52, tabLinkActive = $$new_props.tabLinkActive);
    		if ('selected' in $$new_props) $$invalidate(53, selected = $$new_props.selected);
    		if ('href' in $$new_props) $$invalidate(54, href = $$new_props.href);
    		if ('target' in $$new_props) $$invalidate(55, target = $$new_props.target);
    		if ('after' in $$new_props) $$invalidate(9, after = $$new_props.after);
    		if ('badge' in $$new_props) $$invalidate(10, badge = $$new_props.badge);
    		if ('badgeColor' in $$new_props) $$invalidate(11, badgeColor = $$new_props.badgeColor);
    		if ('mediaItem' in $$new_props) $$invalidate(56, mediaItem = $$new_props.mediaItem);
    		if ('mediaList' in $$new_props) $$invalidate(57, mediaList = $$new_props.mediaList);
    		if ('divider' in $$new_props) $$invalidate(12, divider = $$new_props.divider);
    		if ('groupTitle' in $$new_props) $$invalidate(13, groupTitle = $$new_props.groupTitle);
    		if ('swipeout' in $$new_props) $$invalidate(14, swipeout = $$new_props.swipeout);
    		if ('swipeoutOpened' in $$new_props) $$invalidate(58, swipeoutOpened = $$new_props.swipeoutOpened);
    		if ('sortable' in $$new_props) $$invalidate(15, sortable = $$new_props.sortable);
    		if ('sortableOpposite' in $$new_props) $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
    		if ('accordionItem' in $$new_props) $$invalidate(16, accordionItem = $$new_props.accordionItem);
    		if ('accordionItemOpened' in $$new_props) $$invalidate(60, accordionItemOpened = $$new_props.accordionItemOpened);
    		if ('smartSelect' in $$new_props) $$invalidate(61, smartSelect = $$new_props.smartSelect);
    		if ('smartSelectParams' in $$new_props) $$invalidate(62, smartSelectParams = $$new_props.smartSelectParams);
    		if ('noChevron' in $$new_props) $$invalidate(63, noChevron = $$new_props.noChevron);
    		if ('chevronCenter' in $$new_props) $$invalidate(64, chevronCenter = $$new_props.chevronCenter);
    		if ('checkbox' in $$new_props) $$invalidate(17, checkbox = $$new_props.checkbox);
    		if ('radio' in $$new_props) $$invalidate(18, radio = $$new_props.radio);
    		if ('radioIcon' in $$new_props) $$invalidate(65, radioIcon = $$new_props.radioIcon);
    		if ('checked' in $$new_props) $$invalidate(0, checked = $$new_props.checked);
    		if ('indeterminate' in $$new_props) $$invalidate(66, indeterminate = $$new_props.indeterminate);
    		if ('name' in $$new_props) $$invalidate(19, name = $$new_props.name);
    		if ('value' in $$new_props) $$invalidate(20, value = $$new_props.value);
    		if ('readonly' in $$new_props) $$invalidate(21, readonly = $$new_props.readonly);
    		if ('required' in $$new_props) $$invalidate(22, required = $$new_props.required);
    		if ('disabled' in $$new_props) $$invalidate(23, disabled = $$new_props.disabled);
    		if ('virtualListIndex' in $$new_props) $$invalidate(24, virtualListIndex = $$new_props.virtualListIndex);
    		if ('routeProps' in $$new_props) $$invalidate(25, routeProps = $$new_props.routeProps);
    		if ('$$scope' in $$new_props) $$invalidate(83, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		afterUpdate,
    		colorClasses,
    		routerClasses,
    		routerAttrs,
    		actionsClasses,
    		actionsAttrs,
    		classNames,
    		plainText,
    		isStringProp,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		useTooltip,
    		useSmartSelect,
    		useRouteProps,
    		getReactiveContext,
    		Badge,
    		emit,
    		className,
    		title,
    		text,
    		media,
    		subtitle,
    		header,
    		footer,
    		tooltip,
    		tooltipTrigger,
    		link,
    		tabLink,
    		tabLinkActive,
    		selected,
    		href,
    		target,
    		after,
    		badge,
    		badgeColor,
    		mediaItem,
    		mediaList,
    		divider,
    		groupTitle,
    		swipeout,
    		swipeoutOpened,
    		sortable,
    		sortableOpposite,
    		accordionItem,
    		accordionItemOpened,
    		smartSelect,
    		smartSelectParams,
    		noChevron,
    		chevronCenter,
    		checkbox,
    		radio,
    		radioIcon,
    		checked,
    		indeterminate,
    		name,
    		value,
    		readonly,
    		required,
    		disabled,
    		virtualListIndex,
    		routeProps,
    		el,
    		linkEl,
    		innerEl,
    		inputEl,
    		f7SmartSelect,
    		smartSelectInstance,
    		ListContext,
    		initialWatchedOpened,
    		watchSwipeoutOpened,
    		onClick,
    		onSwipeoutOverswipeEnter,
    		onSwipeoutOverswipeExit,
    		onSwipeoutDeleted,
    		onSwipeoutDelete,
    		onSwipeoutClose,
    		onSwipeoutClosed,
    		onSwipeoutOpen,
    		onSwipeoutOpened,
    		onSwipeout,
    		onAccBeforeClose,
    		onAccClose,
    		onAccClosed,
    		onAccBeforeOpen,
    		onAccOpen,
    		onAccOpened,
    		onChange,
    		hasAfter,
    		hasText,
    		hasSubtitle,
    		hasFooter,
    		hasHeader,
    		hasTitle,
    		hasMedia,
    		isLink,
    		linkAttrs,
    		linkClasses,
    		contentClasses,
    		isMedia,
    		liClasses,
    		isSimple,
    		isSortableOpposite,
    		isSortable
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(104, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(49, className = $$new_props.className);
    		if ('title' in $$props) $$invalidate(1, title = $$new_props.title);
    		if ('text' in $$props) $$invalidate(2, text = $$new_props.text);
    		if ('media' in $$props) $$invalidate(3, media = $$new_props.media);
    		if ('subtitle' in $$props) $$invalidate(4, subtitle = $$new_props.subtitle);
    		if ('header' in $$props) $$invalidate(5, header = $$new_props.header);
    		if ('footer' in $$props) $$invalidate(6, footer = $$new_props.footer);
    		if ('tooltip' in $$props) $$invalidate(7, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$props) $$invalidate(8, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('link' in $$props) $$invalidate(50, link = $$new_props.link);
    		if ('tabLink' in $$props) $$invalidate(51, tabLink = $$new_props.tabLink);
    		if ('tabLinkActive' in $$props) $$invalidate(52, tabLinkActive = $$new_props.tabLinkActive);
    		if ('selected' in $$props) $$invalidate(53, selected = $$new_props.selected);
    		if ('href' in $$props) $$invalidate(54, href = $$new_props.href);
    		if ('target' in $$props) $$invalidate(55, target = $$new_props.target);
    		if ('after' in $$props) $$invalidate(9, after = $$new_props.after);
    		if ('badge' in $$props) $$invalidate(10, badge = $$new_props.badge);
    		if ('badgeColor' in $$props) $$invalidate(11, badgeColor = $$new_props.badgeColor);
    		if ('mediaItem' in $$props) $$invalidate(56, mediaItem = $$new_props.mediaItem);
    		if ('mediaList' in $$props) $$invalidate(57, mediaList = $$new_props.mediaList);
    		if ('divider' in $$props) $$invalidate(12, divider = $$new_props.divider);
    		if ('groupTitle' in $$props) $$invalidate(13, groupTitle = $$new_props.groupTitle);
    		if ('swipeout' in $$props) $$invalidate(14, swipeout = $$new_props.swipeout);
    		if ('swipeoutOpened' in $$props) $$invalidate(58, swipeoutOpened = $$new_props.swipeoutOpened);
    		if ('sortable' in $$props) $$invalidate(15, sortable = $$new_props.sortable);
    		if ('sortableOpposite' in $$props) $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
    		if ('accordionItem' in $$props) $$invalidate(16, accordionItem = $$new_props.accordionItem);
    		if ('accordionItemOpened' in $$props) $$invalidate(60, accordionItemOpened = $$new_props.accordionItemOpened);
    		if ('smartSelect' in $$props) $$invalidate(61, smartSelect = $$new_props.smartSelect);
    		if ('smartSelectParams' in $$props) $$invalidate(62, smartSelectParams = $$new_props.smartSelectParams);
    		if ('noChevron' in $$props) $$invalidate(63, noChevron = $$new_props.noChevron);
    		if ('chevronCenter' in $$props) $$invalidate(64, chevronCenter = $$new_props.chevronCenter);
    		if ('checkbox' in $$props) $$invalidate(17, checkbox = $$new_props.checkbox);
    		if ('radio' in $$props) $$invalidate(18, radio = $$new_props.radio);
    		if ('radioIcon' in $$props) $$invalidate(65, radioIcon = $$new_props.radioIcon);
    		if ('checked' in $$props) $$invalidate(0, checked = $$new_props.checked);
    		if ('indeterminate' in $$props) $$invalidate(66, indeterminate = $$new_props.indeterminate);
    		if ('name' in $$props) $$invalidate(19, name = $$new_props.name);
    		if ('value' in $$props) $$invalidate(20, value = $$new_props.value);
    		if ('readonly' in $$props) $$invalidate(21, readonly = $$new_props.readonly);
    		if ('required' in $$props) $$invalidate(22, required = $$new_props.required);
    		if ('disabled' in $$props) $$invalidate(23, disabled = $$new_props.disabled);
    		if ('virtualListIndex' in $$props) $$invalidate(24, virtualListIndex = $$new_props.virtualListIndex);
    		if ('routeProps' in $$props) $$invalidate(25, routeProps = $$new_props.routeProps);
    		if ('el' in $$props) $$invalidate(27, el = $$new_props.el);
    		if ('linkEl' in $$props) $$invalidate(28, linkEl = $$new_props.linkEl);
    		if ('innerEl' in $$props) $$invalidate(29, innerEl = $$new_props.innerEl);
    		if ('inputEl' in $$props) $$invalidate(30, inputEl = $$new_props.inputEl);
    		if ('f7SmartSelect' in $$props) f7SmartSelect = $$new_props.f7SmartSelect;
    		if ('ListContext' in $$props) $$invalidate(68, ListContext = $$new_props.ListContext);
    		if ('initialWatchedOpened' in $$props) initialWatchedOpened = $$new_props.initialWatchedOpened;
    		if ('hasAfter' in $$props) $$invalidate(31, hasAfter = $$new_props.hasAfter);
    		if ('hasText' in $$props) $$invalidate(32, hasText = $$new_props.hasText);
    		if ('hasSubtitle' in $$props) $$invalidate(33, hasSubtitle = $$new_props.hasSubtitle);
    		if ('hasFooter' in $$props) $$invalidate(34, hasFooter = $$new_props.hasFooter);
    		if ('hasHeader' in $$props) $$invalidate(35, hasHeader = $$new_props.hasHeader);
    		if ('hasTitle' in $$props) $$invalidate(36, hasTitle = $$new_props.hasTitle);
    		if ('hasMedia' in $$props) $$invalidate(37, hasMedia = $$new_props.hasMedia);
    		if ('isLink' in $$props) $$invalidate(38, isLink = $$new_props.isLink);
    		if ('linkAttrs' in $$props) $$invalidate(39, linkAttrs = $$new_props.linkAttrs);
    		if ('linkClasses' in $$props) $$invalidate(40, linkClasses = $$new_props.linkClasses);
    		if ('contentClasses' in $$props) $$invalidate(41, contentClasses = $$new_props.contentClasses);
    		if ('isMedia' in $$props) $$invalidate(26, isMedia = $$new_props.isMedia);
    		if ('liClasses' in $$props) $$invalidate(42, liClasses = $$new_props.liClasses);
    		if ('isSimple' in $$props) $$invalidate(43, isSimple = $$new_props.isSimple);
    		if ('isSortableOpposite' in $$props) $$invalidate(44, isSortableOpposite = $$new_props.isSortableOpposite);
    		if ('isSortable' in $$props) $$invalidate(45, isSortable = $$new_props.isSortable);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[1] & /*mediaList, mediaItem*/ 100663296 | $$self.$$.dirty[2] & /*ListContext*/ 64) {
    			$$invalidate(26, isMedia = mediaList || mediaItem || ListContext.listIsMedia);
    		}

    		if ($$self.$$.dirty[0] & /*sortable*/ 32768 | $$self.$$.dirty[2] & /*ListContext*/ 64) {
    			$$invalidate(45, isSortable = sortable === true || sortable === false
    			? sortable
    			: ListContext.listIsSortable);
    		}

    		if ($$self.$$.dirty[1] & /*sortableOpposite*/ 268435456 | $$self.$$.dirty[2] & /*ListContext*/ 64) {
    			$$invalidate(44, isSortableOpposite = sortableOpposite || ListContext.listIsSortableOpposite);
    		}

    		if ($$self.$$.dirty[2] & /*ListContext*/ 64) {
    			$$invalidate(43, isSimple = ListContext.listIsSimple);
    		}

    		$$invalidate(42, liClasses = classNames(
    			className,
    			{
    				'item-divider': divider,
    				'list-group-title': groupTitle,
    				'media-item': isMedia,
    				swipeout,
    				'accordion-item': accordionItem,
    				'accordion-item-opened': accordionItemOpened,
    				disabled: disabled && !(radio || checkbox),
    				'no-chevron': noChevron,
    				'chevron-center': chevronCenter,
    				'disallow-sorting': sortable === false
    			},
    			colorClasses($$props)
    		));

    		$$invalidate(41, contentClasses = classNames(
    			className,
    			'item-content',
    			{
    				'item-checkbox': checkbox,
    				'item-radio': radio,
    				'item-radio-icon-start': radio && radioIcon === 'start',
    				'item-radio-icon-end': radio && radioIcon === 'end'
    			},
    			colorClasses($$props)
    		));

    		$$invalidate(40, linkClasses = classNames(
    			{
    				'item-link': true,
    				'smart-select': smartSelect,
    				'tab-link': tabLink || tabLink === '',
    				'tab-link-active': tabLinkActive,
    				'item-selected': selected
    			},
    			routerClasses($$props),
    			actionsClasses($$props)
    		));

    		$$invalidate(39, linkAttrs = {
    			href: link === true ? '' : link || href,
    			target,
    			'data-tab': isStringProp(tabLink) && tabLink || undefined,
    			...routerAttrs($$props),
    			...actionsAttrs($$props)
    		});

    		if ($$self.$$.dirty[0] & /*accordionItem*/ 65536 | $$self.$$.dirty[1] & /*link, href, smartSelect*/ 1082654720) {
    			$$invalidate(38, isLink = link || href || smartSelect || accordionItem);
    		}

    		if ($$self.$$.dirty[0] & /*media*/ 8) {
    			/* eslint-disable no-undef */
    			$$invalidate(37, hasMedia = typeof media !== 'undefined' || $$slots.media);
    		}

    		if ($$self.$$.dirty[0] & /*title*/ 2) {
    			$$invalidate(36, hasTitle = typeof title !== 'undefined' || $$slots.title);
    		}

    		if ($$self.$$.dirty[0] & /*header*/ 32) {
    			$$invalidate(35, hasHeader = typeof header !== 'undefined' || $$slots.header);
    		}

    		if ($$self.$$.dirty[0] & /*footer*/ 64) {
    			$$invalidate(34, hasFooter = typeof footer !== 'undefined' || $$slots.footer);
    		}

    		if ($$self.$$.dirty[0] & /*subtitle*/ 16) {
    			$$invalidate(33, hasSubtitle = typeof subtitle !== 'undefined' || $$slots.subtitle);
    		}

    		if ($$self.$$.dirty[0] & /*text*/ 4) {
    			$$invalidate(32, hasText = typeof text !== 'undefined' || $$slots.text);
    		}

    		if ($$self.$$.dirty[0] & /*after, badge*/ 1536) {
    			$$invalidate(31, hasAfter = typeof after !== 'undefined' || typeof badge !== 'undefined' || $$slots.after);
    		}

    		if ($$self.$$.dirty[1] & /*swipeoutOpened*/ 134217728) {
    			watchSwipeoutOpened(swipeoutOpened);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		checked,
    		title,
    		text,
    		media,
    		subtitle,
    		header,
    		footer,
    		tooltip,
    		tooltipTrigger,
    		after,
    		badge,
    		badgeColor,
    		divider,
    		groupTitle,
    		swipeout,
    		sortable,
    		accordionItem,
    		checkbox,
    		radio,
    		name,
    		value,
    		readonly,
    		required,
    		disabled,
    		virtualListIndex,
    		routeProps,
    		isMedia,
    		el,
    		linkEl,
    		innerEl,
    		inputEl,
    		hasAfter,
    		hasText,
    		hasSubtitle,
    		hasFooter,
    		hasHeader,
    		hasTitle,
    		hasMedia,
    		isLink,
    		linkAttrs,
    		linkClasses,
    		contentClasses,
    		liClasses,
    		isSimple,
    		isSortableOpposite,
    		isSortable,
    		onClick,
    		onChange,
    		$$restProps,
    		className,
    		link,
    		tabLink,
    		tabLinkActive,
    		selected,
    		href,
    		target,
    		mediaItem,
    		mediaList,
    		swipeoutOpened,
    		sortableOpposite,
    		accordionItemOpened,
    		smartSelect,
    		smartSelectParams,
    		noChevron,
    		chevronCenter,
    		radioIcon,
    		indeterminate,
    		smartSelectInstance,
    		ListContext,
    		slots,
    		li_binding,
    		li_binding_1,
    		div0_binding,
    		a_binding,
    		input_binding,
    		div_binding,
    		div0_binding_1,
    		div0_binding_2,
    		a_binding_1,
    		input_binding_1,
    		div_binding_1,
    		div0_binding_3,
    		li_binding_2,
    		$$scope
    	];
    }

    class List_item extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$f,
    			create_fragment$h,
    			safe_not_equal,
    			{
    				class: 49,
    				title: 1,
    				text: 2,
    				media: 3,
    				subtitle: 4,
    				header: 5,
    				footer: 6,
    				tooltip: 7,
    				tooltipTrigger: 8,
    				link: 50,
    				tabLink: 51,
    				tabLinkActive: 52,
    				selected: 53,
    				href: 54,
    				target: 55,
    				after: 9,
    				badge: 10,
    				badgeColor: 11,
    				mediaItem: 56,
    				mediaList: 57,
    				divider: 12,
    				groupTitle: 13,
    				swipeout: 14,
    				swipeoutOpened: 58,
    				sortable: 15,
    				sortableOpposite: 59,
    				accordionItem: 16,
    				accordionItemOpened: 60,
    				smartSelect: 61,
    				smartSelectParams: 62,
    				noChevron: 63,
    				chevronCenter: 64,
    				checkbox: 17,
    				radio: 18,
    				radioIcon: 65,
    				checked: 0,
    				indeterminate: 66,
    				name: 19,
    				value: 20,
    				readonly: 21,
    				required: 22,
    				disabled: 23,
    				virtualListIndex: 24,
    				routeProps: 25,
    				smartSelectInstance: 67
    			},
    			null,
    			[-1, -1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List_item",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get class() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get media() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set media(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitle() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitle(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get header() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set header(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get footer() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set footer(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipTrigger() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipTrigger(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get link() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set link(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabLink() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabLink(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabLinkActive() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabLinkActive(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get target() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set target(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get after() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set after(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get badge() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set badge(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get badgeColor() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set badgeColor(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mediaItem() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mediaItem(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mediaList() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mediaList(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get divider() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set divider(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupTitle() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupTitle(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get swipeout() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set swipeout(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get swipeoutOpened() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set swipeoutOpened(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortable() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortable(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortableOpposite() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortableOpposite(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accordionItem() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accordionItem(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accordionItemOpened() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accordionItemOpened(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smartSelect() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smartSelect(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smartSelectParams() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smartSelectParams(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noChevron() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noChevron(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get chevronCenter() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set chevronCenter(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checkbox() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checkbox(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radio() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radio(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radioIcon() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radioIcon(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checked() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checked(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indeterminate() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indeterminate(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readonly() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readonly(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get virtualListIndex() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set virtualListIndex(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get routeProps() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routeProps(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smartSelectInstance() {
    		return this.$$.ctx[67];
    	}

    	set smartSelectInstance(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/list.svelte generated by Svelte v3.44.0 */
    const file$f = "node_modules/framework7-svelte/esm/svelte/list.svelte";
    const get_after_list_slot_changes_1 = dirty => ({});
    const get_after_list_slot_context_1 = ctx => ({});
    const get_list_slot_changes_1 = dirty => ({});
    const get_list_slot_context_1 = ctx => ({});
    const get_before_list_slot_changes_1 = dirty => ({});
    const get_before_list_slot_context_1 = ctx => ({});
    const get_after_list_slot_changes = dirty => ({});
    const get_after_list_slot_context = ctx => ({});
    const get_list_slot_changes = dirty => ({});
    const get_list_slot_context = ctx => ({});
    const get_before_list_slot_changes = dirty => ({});
    const get_before_list_slot_context = ctx => ({});

    // (211:0) {:else}
    function create_else_block_1(ctx) {
    	let div;
    	let t0;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let div_data_sortable_move_elements_value;
    	let current;
    	const before_list_slot_template = /*#slots*/ ctx[44]["before-list"];
    	const before_list_slot = create_slot(before_list_slot_template, ctx, /*$$scope*/ ctx[43], get_before_list_slot_context_1);
    	const if_block_creators = [create_if_block_2$3, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*hasUlSlots*/ ctx[5] && /*ul*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const after_list_slot_template = /*#slots*/ ctx[44]["after-list"];
    	const after_list_slot = create_slot(after_list_slot_template, ctx, /*$$scope*/ ctx[43], get_after_list_slot_context_1);

    	let div_levels = [
    		{ class: /*classes*/ ctx[4] },
    		{
    			"data-sortable-move-elements": div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== 'undefined'
    			? /*sortableMoveElements*/ ctx[1].toString()
    			: undefined
    		},
    		restProps(/*$$restProps*/ ctx[7])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (before_list_slot) before_list_slot.c();
    			t0 = space();
    			if_block.c();
    			t1 = space();
    			if (after_list_slot) after_list_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$f, 211, 2, 6024);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (before_list_slot) {
    				before_list_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if_blocks[current_block_type_index].m(div, null);
    			append_dev(div, t1);

    			if (after_list_slot) {
    				after_list_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[46](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_list_slot) {
    				if (before_list_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						before_list_slot,
    						before_list_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(before_list_slot_template, /*$$scope*/ ctx[43], dirty, get_before_list_slot_changes_1),
    						get_before_list_slot_context_1
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, t1);
    			}

    			if (after_list_slot) {
    				if (after_list_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						after_list_slot,
    						after_list_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(after_list_slot_template, /*$$scope*/ ctx[43], dirty, get_after_list_slot_changes_1),
    						get_after_list_slot_context_1
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty[0] & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
    				(!current || dirty[0] & /*sortableMoveElements*/ 2 && div_data_sortable_move_elements_value !== (div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== 'undefined'
    				? /*sortableMoveElements*/ ctx[1].toString()
    				: undefined)) && {
    					"data-sortable-move-elements": div_data_sortable_move_elements_value
    				},
    				dirty[0] & /*$$restProps*/ 128 && restProps(/*$$restProps*/ ctx[7])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_list_slot, local);
    			transition_in(if_block);
    			transition_in(after_list_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_list_slot, local);
    			transition_out(if_block);
    			transition_out(after_list_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (before_list_slot) before_list_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (after_list_slot) after_list_slot.d(detaching);
    			/*div_binding*/ ctx[46](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(211:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (190:0) {#if form}
    function create_if_block$9(ctx) {
    	let form_1;
    	let t0;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let form_1_data_sortable_move_elements_value;
    	let current;
    	let mounted;
    	let dispose;
    	const before_list_slot_template = /*#slots*/ ctx[44]["before-list"];
    	const before_list_slot = create_slot(before_list_slot_template, ctx, /*$$scope*/ ctx[43], get_before_list_slot_context);
    	const if_block_creators = [create_if_block_1$5, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*hasUlSlots*/ ctx[5] && /*ul*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const after_list_slot_template = /*#slots*/ ctx[44]["after-list"];
    	const after_list_slot = create_slot(after_list_slot_template, ctx, /*$$scope*/ ctx[43], get_after_list_slot_context);

    	let form_1_levels = [
    		{ class: /*classes*/ ctx[4] },
    		{
    			"data-sortable-move-elements": form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== 'undefined'
    			? /*sortableMoveElements*/ ctx[1].toString()
    			: undefined
    		},
    		restProps(/*$$restProps*/ ctx[7])
    	];

    	let form_1_data = {};

    	for (let i = 0; i < form_1_levels.length; i += 1) {
    		form_1_data = assign(form_1_data, form_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			form_1 = element("form");
    			if (before_list_slot) before_list_slot.c();
    			t0 = space();
    			if_block.c();
    			t1 = space();
    			if (after_list_slot) after_list_slot.c();
    			set_attributes(form_1, form_1_data);
    			add_location(form_1, file$f, 190, 2, 5566);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form_1, anchor);

    			if (before_list_slot) {
    				before_list_slot.m(form_1, null);
    			}

    			append_dev(form_1, t0);
    			if_blocks[current_block_type_index].m(form_1, null);
    			append_dev(form_1, t1);

    			if (after_list_slot) {
    				after_list_slot.m(form_1, null);
    			}

    			/*form_1_binding*/ ctx[45](form_1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form_1, "submit", /*onSubmit*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (before_list_slot) {
    				if (before_list_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						before_list_slot,
    						before_list_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(before_list_slot_template, /*$$scope*/ ctx[43], dirty, get_before_list_slot_changes),
    						get_before_list_slot_context
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(form_1, t1);
    			}

    			if (after_list_slot) {
    				if (after_list_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						after_list_slot,
    						after_list_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(after_list_slot_template, /*$$scope*/ ctx[43], dirty, get_after_list_slot_changes),
    						get_after_list_slot_context
    					);
    				}
    			}

    			set_attributes(form_1, form_1_data = get_spread_update(form_1_levels, [
    				(!current || dirty[0] & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
    				(!current || dirty[0] & /*sortableMoveElements*/ 2 && form_1_data_sortable_move_elements_value !== (form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== 'undefined'
    				? /*sortableMoveElements*/ ctx[1].toString()
    				: undefined)) && {
    					"data-sortable-move-elements": form_1_data_sortable_move_elements_value
    				},
    				dirty[0] & /*$$restProps*/ 128 && restProps(/*$$restProps*/ ctx[7])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_list_slot, local);
    			transition_in(if_block);
    			transition_in(after_list_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_list_slot, local);
    			transition_out(if_block);
    			transition_out(after_list_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form_1);
    			if (before_list_slot) before_list_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (after_list_slot) after_list_slot.d(detaching);
    			/*form_1_binding*/ ctx[45](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(190:0) {#if form}",
    		ctx
    	});

    	return block;
    }

    // (226:4) {:else}
    function create_else_block_2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[44].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(226:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (221:4) {#if hasUlSlots && ul}
    function create_if_block_2$3(ctx) {
    	let ul_1;
    	let t;
    	let current;
    	const list_slot_template = /*#slots*/ ctx[44].list;
    	const list_slot = create_slot(list_slot_template, ctx, /*$$scope*/ ctx[43], get_list_slot_context_1);
    	const default_slot_template = /*#slots*/ ctx[44].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);

    	const block = {
    		c: function create() {
    			ul_1 = element("ul");
    			if (list_slot) list_slot.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			add_location(ul_1, file$f, 221, 6, 6305);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul_1, anchor);

    			if (list_slot) {
    				list_slot.m(ul_1, null);
    			}

    			append_dev(ul_1, t);

    			if (default_slot) {
    				default_slot.m(ul_1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (list_slot) {
    				if (list_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						list_slot,
    						list_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(list_slot_template, /*$$scope*/ ctx[43], dirty, get_list_slot_changes_1),
    						get_list_slot_context_1
    					);
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(list_slot, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(list_slot, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul_1);
    			if (list_slot) list_slot.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(221:4) {#if hasUlSlots && ul}",
    		ctx
    	});

    	return block;
    }

    // (206:4) {:else}
    function create_else_block$4(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[44].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(206:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (201:4) {#if hasUlSlots && ul}
    function create_if_block_1$5(ctx) {
    	let ul_1;
    	let t;
    	let current;
    	const list_slot_template = /*#slots*/ ctx[44].list;
    	const list_slot = create_slot(list_slot_template, ctx, /*$$scope*/ ctx[43], get_list_slot_context);
    	const default_slot_template = /*#slots*/ ctx[44].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);

    	const block = {
    		c: function create() {
    			ul_1 = element("ul");
    			if (list_slot) list_slot.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			add_location(ul_1, file$f, 201, 6, 5873);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul_1, anchor);

    			if (list_slot) {
    				list_slot.m(ul_1, null);
    			}

    			append_dev(ul_1, t);

    			if (default_slot) {
    				default_slot.m(ul_1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (list_slot) {
    				if (list_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						list_slot,
    						list_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(list_slot_template, /*$$scope*/ ctx[43], dirty, get_list_slot_changes),
    						get_list_slot_context
    					);
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(list_slot, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(list_slot, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul_1);
    			if (list_slot) list_slot.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(201:4) {#if hasUlSlots && ul}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$9, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*form*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let hasUlSlots;
    	let classes;

    	const omit_props_names = [
    		"class","ul","inset","xsmallInset","smallInset","mediumInset","largeInset","xlargeInset","mediaList","sortable","sortableTapHold","sortableEnabled","sortableMoveElements","sortableOpposite","accordionList","accordionOpposite","contactsList","simpleList","linksList","menuList","noHairlines","noHairlinesBetween","noHairlinesMd","noHairlinesBetweenMd","noHairlinesIos","noHairlinesBetweenIos","noHairlinesAurora","noHairlinesBetweenAurora","noChevron","chevronCenter","tab","tabActive","form","formStoreData","inlineLabels","virtualList","virtualListParams","virtualListInstance"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('List', slots, ['before-list','list','default','after-list']);
    	const $$slots = compute_slots(slots);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { ul = true } = $$props;
    	let { inset = false } = $$props;
    	let { xsmallInset = false } = $$props;
    	let { smallInset = false } = $$props;
    	let { mediumInset = false } = $$props;
    	let { largeInset = false } = $$props;
    	let { xlargeInset = false } = $$props;
    	let { mediaList = false } = $$props;
    	let { sortable = false } = $$props;
    	let { sortableTapHold = false } = $$props;
    	let { sortableEnabled = false } = $$props;
    	let { sortableMoveElements = undefined } = $$props;
    	let { sortableOpposite = false } = $$props;
    	let { accordionList = false } = $$props;
    	let { accordionOpposite = false } = $$props;
    	let { contactsList = false } = $$props;
    	let { simpleList = false } = $$props;
    	let { linksList = false } = $$props;
    	let { menuList = false } = $$props;
    	let { noHairlines = false } = $$props;
    	let { noHairlinesBetween = false } = $$props;
    	let { noHairlinesMd = false } = $$props;
    	let { noHairlinesBetweenMd = false } = $$props;
    	let { noHairlinesIos = false } = $$props;
    	let { noHairlinesBetweenIos = false } = $$props;
    	let { noHairlinesAurora = false } = $$props;
    	let { noHairlinesBetweenAurora = false } = $$props;
    	let { noChevron = false } = $$props;
    	let { chevronCenter = false } = $$props;
    	let { tab = false } = $$props;
    	let { tabActive = false } = $$props;
    	let { form = false } = $$props;
    	let { formStoreData = false } = $$props;
    	let { inlineLabels = false } = $$props;
    	let { virtualList = false } = $$props;
    	let { virtualListParams = undefined } = $$props;
    	let el;
    	let f7VirtualList;

    	function virtualListInstance() {
    		return f7VirtualList;
    	}

    	setReactiveContext('ListContext', () => ({
    		listIsMedia: mediaList,
    		listIsSimple: simpleList,
    		listIsSortable: sortable,
    		listIsSortableOpposite: sortableOpposite
    	}));

    	function onSubmit(event) {
    		emit('submit', [event]);
    	}

    	function onSortableEnable(sortableEl) {
    		if (sortableEl !== el) return;
    		emit('sortableEnable');
    	}

    	function onSortableDisable(sortableEl) {
    		if (sortableEl !== el) return;
    		emit('sortableDisable');
    	}

    	function onSortableSort(listItemEl, sortData, listEl) {
    		if (listEl !== el) return;
    		emit('sortableSort', [sortData]);
    	}

    	useTab(() => el, emit);

    	onMount(() => {
    		f7ready(() => {
    			app$1.f7.on('sortableEnable', onSortableEnable);
    			app$1.f7.on('sortableDisable', onSortableDisable);
    			app$1.f7.on('sortableSort', onSortableSort);
    			if (!virtualList) return;
    			const vlParams = virtualListParams || {};
    			if (!vlParams.renderItem && !vlParams.renderExternal) return;

    			f7VirtualList = app$1.f7.virtualList.create(extend(
    				{
    					el,
    					on: {
    						itemBeforeInsert(itemEl, item) {
    							const vl = this;
    							emit('virtualItemBeforeInsert', [vl, itemEl, item]);
    						},
    						beforeClear(fragment) {
    							const vl = this;
    							emit('virtualBeforeClear', [vl, fragment]);
    						},
    						itemsBeforeInsert(fragment) {
    							const vl = this;
    							emit('virtualItemsBeforeInsert', [vl, fragment]);
    						},
    						itemsAfterInsert(fragment) {
    							const vl = this;
    							emit('virtualItemsAfterInsert', [vl, fragment]);
    						}
    					}
    				},
    				vlParams
    			));
    		});
    	});

    	onDestroy(() => {
    		if (!app$1.f7) return;
    		app$1.f7.off('sortableEnable', onSortableEnable);
    		app$1.f7.off('sortableDisable', onSortableDisable);
    		app$1.f7.off('sortableSort', onSortableSort);

    		if (f7VirtualList && f7VirtualList.destroy) {
    			f7VirtualList.destroy();
    			f7VirtualList = null;
    		}
    	});

    	function form_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(3, el);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(3, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(52, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
    		if ('ul' in $$new_props) $$invalidate(0, ul = $$new_props.ul);
    		if ('inset' in $$new_props) $$invalidate(9, inset = $$new_props.inset);
    		if ('xsmallInset' in $$new_props) $$invalidate(10, xsmallInset = $$new_props.xsmallInset);
    		if ('smallInset' in $$new_props) $$invalidate(11, smallInset = $$new_props.smallInset);
    		if ('mediumInset' in $$new_props) $$invalidate(12, mediumInset = $$new_props.mediumInset);
    		if ('largeInset' in $$new_props) $$invalidate(13, largeInset = $$new_props.largeInset);
    		if ('xlargeInset' in $$new_props) $$invalidate(14, xlargeInset = $$new_props.xlargeInset);
    		if ('mediaList' in $$new_props) $$invalidate(15, mediaList = $$new_props.mediaList);
    		if ('sortable' in $$new_props) $$invalidate(16, sortable = $$new_props.sortable);
    		if ('sortableTapHold' in $$new_props) $$invalidate(17, sortableTapHold = $$new_props.sortableTapHold);
    		if ('sortableEnabled' in $$new_props) $$invalidate(18, sortableEnabled = $$new_props.sortableEnabled);
    		if ('sortableMoveElements' in $$new_props) $$invalidate(1, sortableMoveElements = $$new_props.sortableMoveElements);
    		if ('sortableOpposite' in $$new_props) $$invalidate(19, sortableOpposite = $$new_props.sortableOpposite);
    		if ('accordionList' in $$new_props) $$invalidate(20, accordionList = $$new_props.accordionList);
    		if ('accordionOpposite' in $$new_props) $$invalidate(21, accordionOpposite = $$new_props.accordionOpposite);
    		if ('contactsList' in $$new_props) $$invalidate(22, contactsList = $$new_props.contactsList);
    		if ('simpleList' in $$new_props) $$invalidate(23, simpleList = $$new_props.simpleList);
    		if ('linksList' in $$new_props) $$invalidate(24, linksList = $$new_props.linksList);
    		if ('menuList' in $$new_props) $$invalidate(25, menuList = $$new_props.menuList);
    		if ('noHairlines' in $$new_props) $$invalidate(26, noHairlines = $$new_props.noHairlines);
    		if ('noHairlinesBetween' in $$new_props) $$invalidate(27, noHairlinesBetween = $$new_props.noHairlinesBetween);
    		if ('noHairlinesMd' in $$new_props) $$invalidate(28, noHairlinesMd = $$new_props.noHairlinesMd);
    		if ('noHairlinesBetweenMd' in $$new_props) $$invalidate(29, noHairlinesBetweenMd = $$new_props.noHairlinesBetweenMd);
    		if ('noHairlinesIos' in $$new_props) $$invalidate(30, noHairlinesIos = $$new_props.noHairlinesIos);
    		if ('noHairlinesBetweenIos' in $$new_props) $$invalidate(31, noHairlinesBetweenIos = $$new_props.noHairlinesBetweenIos);
    		if ('noHairlinesAurora' in $$new_props) $$invalidate(32, noHairlinesAurora = $$new_props.noHairlinesAurora);
    		if ('noHairlinesBetweenAurora' in $$new_props) $$invalidate(33, noHairlinesBetweenAurora = $$new_props.noHairlinesBetweenAurora);
    		if ('noChevron' in $$new_props) $$invalidate(34, noChevron = $$new_props.noChevron);
    		if ('chevronCenter' in $$new_props) $$invalidate(35, chevronCenter = $$new_props.chevronCenter);
    		if ('tab' in $$new_props) $$invalidate(36, tab = $$new_props.tab);
    		if ('tabActive' in $$new_props) $$invalidate(37, tabActive = $$new_props.tabActive);
    		if ('form' in $$new_props) $$invalidate(2, form = $$new_props.form);
    		if ('formStoreData' in $$new_props) $$invalidate(38, formStoreData = $$new_props.formStoreData);
    		if ('inlineLabels' in $$new_props) $$invalidate(39, inlineLabels = $$new_props.inlineLabels);
    		if ('virtualList' in $$new_props) $$invalidate(40, virtualList = $$new_props.virtualList);
    		if ('virtualListParams' in $$new_props) $$invalidate(41, virtualListParams = $$new_props.virtualListParams);
    		if ('$$scope' in $$new_props) $$invalidate(43, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		colorClasses,
    		classNames,
    		extend,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		useTab,
    		setReactiveContext,
    		emit,
    		className,
    		ul,
    		inset,
    		xsmallInset,
    		smallInset,
    		mediumInset,
    		largeInset,
    		xlargeInset,
    		mediaList,
    		sortable,
    		sortableTapHold,
    		sortableEnabled,
    		sortableMoveElements,
    		sortableOpposite,
    		accordionList,
    		accordionOpposite,
    		contactsList,
    		simpleList,
    		linksList,
    		menuList,
    		noHairlines,
    		noHairlinesBetween,
    		noHairlinesMd,
    		noHairlinesBetweenMd,
    		noHairlinesIos,
    		noHairlinesBetweenIos,
    		noHairlinesAurora,
    		noHairlinesBetweenAurora,
    		noChevron,
    		chevronCenter,
    		tab,
    		tabActive,
    		form,
    		formStoreData,
    		inlineLabels,
    		virtualList,
    		virtualListParams,
    		el,
    		f7VirtualList,
    		virtualListInstance,
    		onSubmit,
    		onSortableEnable,
    		onSortableDisable,
    		onSortableSort,
    		classes,
    		hasUlSlots
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(52, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(8, className = $$new_props.className);
    		if ('ul' in $$props) $$invalidate(0, ul = $$new_props.ul);
    		if ('inset' in $$props) $$invalidate(9, inset = $$new_props.inset);
    		if ('xsmallInset' in $$props) $$invalidate(10, xsmallInset = $$new_props.xsmallInset);
    		if ('smallInset' in $$props) $$invalidate(11, smallInset = $$new_props.smallInset);
    		if ('mediumInset' in $$props) $$invalidate(12, mediumInset = $$new_props.mediumInset);
    		if ('largeInset' in $$props) $$invalidate(13, largeInset = $$new_props.largeInset);
    		if ('xlargeInset' in $$props) $$invalidate(14, xlargeInset = $$new_props.xlargeInset);
    		if ('mediaList' in $$props) $$invalidate(15, mediaList = $$new_props.mediaList);
    		if ('sortable' in $$props) $$invalidate(16, sortable = $$new_props.sortable);
    		if ('sortableTapHold' in $$props) $$invalidate(17, sortableTapHold = $$new_props.sortableTapHold);
    		if ('sortableEnabled' in $$props) $$invalidate(18, sortableEnabled = $$new_props.sortableEnabled);
    		if ('sortableMoveElements' in $$props) $$invalidate(1, sortableMoveElements = $$new_props.sortableMoveElements);
    		if ('sortableOpposite' in $$props) $$invalidate(19, sortableOpposite = $$new_props.sortableOpposite);
    		if ('accordionList' in $$props) $$invalidate(20, accordionList = $$new_props.accordionList);
    		if ('accordionOpposite' in $$props) $$invalidate(21, accordionOpposite = $$new_props.accordionOpposite);
    		if ('contactsList' in $$props) $$invalidate(22, contactsList = $$new_props.contactsList);
    		if ('simpleList' in $$props) $$invalidate(23, simpleList = $$new_props.simpleList);
    		if ('linksList' in $$props) $$invalidate(24, linksList = $$new_props.linksList);
    		if ('menuList' in $$props) $$invalidate(25, menuList = $$new_props.menuList);
    		if ('noHairlines' in $$props) $$invalidate(26, noHairlines = $$new_props.noHairlines);
    		if ('noHairlinesBetween' in $$props) $$invalidate(27, noHairlinesBetween = $$new_props.noHairlinesBetween);
    		if ('noHairlinesMd' in $$props) $$invalidate(28, noHairlinesMd = $$new_props.noHairlinesMd);
    		if ('noHairlinesBetweenMd' in $$props) $$invalidate(29, noHairlinesBetweenMd = $$new_props.noHairlinesBetweenMd);
    		if ('noHairlinesIos' in $$props) $$invalidate(30, noHairlinesIos = $$new_props.noHairlinesIos);
    		if ('noHairlinesBetweenIos' in $$props) $$invalidate(31, noHairlinesBetweenIos = $$new_props.noHairlinesBetweenIos);
    		if ('noHairlinesAurora' in $$props) $$invalidate(32, noHairlinesAurora = $$new_props.noHairlinesAurora);
    		if ('noHairlinesBetweenAurora' in $$props) $$invalidate(33, noHairlinesBetweenAurora = $$new_props.noHairlinesBetweenAurora);
    		if ('noChevron' in $$props) $$invalidate(34, noChevron = $$new_props.noChevron);
    		if ('chevronCenter' in $$props) $$invalidate(35, chevronCenter = $$new_props.chevronCenter);
    		if ('tab' in $$props) $$invalidate(36, tab = $$new_props.tab);
    		if ('tabActive' in $$props) $$invalidate(37, tabActive = $$new_props.tabActive);
    		if ('form' in $$props) $$invalidate(2, form = $$new_props.form);
    		if ('formStoreData' in $$props) $$invalidate(38, formStoreData = $$new_props.formStoreData);
    		if ('inlineLabels' in $$props) $$invalidate(39, inlineLabels = $$new_props.inlineLabels);
    		if ('virtualList' in $$props) $$invalidate(40, virtualList = $$new_props.virtualList);
    		if ('virtualListParams' in $$props) $$invalidate(41, virtualListParams = $$new_props.virtualListParams);
    		if ('el' in $$props) $$invalidate(3, el = $$new_props.el);
    		if ('f7VirtualList' in $$props) f7VirtualList = $$new_props.f7VirtualList;
    		if ('classes' in $$props) $$invalidate(4, classes = $$new_props.classes);
    		if ('hasUlSlots' in $$props) $$invalidate(5, hasUlSlots = $$new_props.hasUlSlots);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(4, classes = classNames(
    			className,
    			'list',
    			{
    				inset,
    				'xsmall-inset': xsmallInset,
    				'small-inset': smallInset,
    				'medium-inset': mediumInset,
    				'large-inset': largeInset,
    				'xlarge-inset': xlargeInset,
    				'media-list': mediaList,
    				'simple-list': simpleList,
    				'links-list': linksList,
    				'menu-list': menuList,
    				sortable,
    				'sortable-tap-hold': sortableTapHold,
    				'sortable-enabled': sortableEnabled,
    				'sortable-opposite': sortableOpposite,
    				'accordion-list': accordionList,
    				'accordion-opposite': accordionOpposite,
    				'contacts-list': contactsList,
    				'virtual-list': virtualList,
    				tab,
    				'tab-active': tabActive,
    				'no-hairlines': noHairlines,
    				'no-hairlines-md': noHairlinesMd,
    				'no-hairlines-ios': noHairlinesIos,
    				'no-hairlines-aurora': noHairlinesAurora,
    				'no-hairlines-between': noHairlinesBetween,
    				'no-hairlines-between-md': noHairlinesBetweenMd,
    				'no-hairlines-between-ios': noHairlinesBetweenIos,
    				'no-hairlines-between-aurora': noHairlinesBetweenAurora,
    				'form-store-data': formStoreData,
    				'inline-labels': inlineLabels,
    				'no-chevron': noChevron,
    				'chevron-center': chevronCenter
    			},
    			colorClasses($$props)
    		));
    	};

    	$$invalidate(5, hasUlSlots = $$slots.default || $$slots.list);
    	$$props = exclude_internal_props($$props);

    	return [
    		ul,
    		sortableMoveElements,
    		form,
    		el,
    		classes,
    		hasUlSlots,
    		onSubmit,
    		$$restProps,
    		className,
    		inset,
    		xsmallInset,
    		smallInset,
    		mediumInset,
    		largeInset,
    		xlargeInset,
    		mediaList,
    		sortable,
    		sortableTapHold,
    		sortableEnabled,
    		sortableOpposite,
    		accordionList,
    		accordionOpposite,
    		contactsList,
    		simpleList,
    		linksList,
    		menuList,
    		noHairlines,
    		noHairlinesBetween,
    		noHairlinesMd,
    		noHairlinesBetweenMd,
    		noHairlinesIos,
    		noHairlinesBetweenIos,
    		noHairlinesAurora,
    		noHairlinesBetweenAurora,
    		noChevron,
    		chevronCenter,
    		tab,
    		tabActive,
    		formStoreData,
    		inlineLabels,
    		virtualList,
    		virtualListParams,
    		virtualListInstance,
    		$$scope,
    		slots,
    		form_1_binding,
    		div_binding
    	];
    }

    class List extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$e,
    			create_fragment$g,
    			safe_not_equal,
    			{
    				class: 8,
    				ul: 0,
    				inset: 9,
    				xsmallInset: 10,
    				smallInset: 11,
    				mediumInset: 12,
    				largeInset: 13,
    				xlargeInset: 14,
    				mediaList: 15,
    				sortable: 16,
    				sortableTapHold: 17,
    				sortableEnabled: 18,
    				sortableMoveElements: 1,
    				sortableOpposite: 19,
    				accordionList: 20,
    				accordionOpposite: 21,
    				contactsList: 22,
    				simpleList: 23,
    				linksList: 24,
    				menuList: 25,
    				noHairlines: 26,
    				noHairlinesBetween: 27,
    				noHairlinesMd: 28,
    				noHairlinesBetweenMd: 29,
    				noHairlinesIos: 30,
    				noHairlinesBetweenIos: 31,
    				noHairlinesAurora: 32,
    				noHairlinesBetweenAurora: 33,
    				noChevron: 34,
    				chevronCenter: 35,
    				tab: 36,
    				tabActive: 37,
    				form: 2,
    				formStoreData: 38,
    				inlineLabels: 39,
    				virtualList: 40,
    				virtualListParams: 41,
    				virtualListInstance: 42
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get class() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ul() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ul(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inset() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inset(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xsmallInset() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xsmallInset(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smallInset() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smallInset(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mediumInset() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mediumInset(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get largeInset() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set largeInset(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xlargeInset() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xlargeInset(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mediaList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mediaList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortable() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortable(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortableTapHold() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortableTapHold(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortableEnabled() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortableEnabled(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortableMoveElements() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortableMoveElements(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortableOpposite() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortableOpposite(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accordionList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accordionList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accordionOpposite() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accordionOpposite(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get contactsList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contactsList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get simpleList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set simpleList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get linksList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set linksList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get menuList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set menuList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlines() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlines(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesBetween() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesBetween(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesMd() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesMd(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesBetweenMd() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesBetweenMd(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesIos() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesIos(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesBetweenIos() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesBetweenIos(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesAurora() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesAurora(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesBetweenAurora() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesBetweenAurora(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noChevron() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noChevron(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get chevronCenter() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set chevronCenter(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tab() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tab(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabActive() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabActive(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get form() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set form(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get formStoreData() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set formStoreData(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inlineLabels() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inlineLabels(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get virtualList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set virtualList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get virtualListParams() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set virtualListParams(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get virtualListInstance() {
    		return this.$$.ctx[42];
    	}

    	set virtualListInstance(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/nav-left.svelte generated by Svelte v3.44.0 */
    const file$e = "node_modules/framework7-svelte/esm/svelte/nav-left.svelte";

    // (46:2) {#if backLink}
    function create_if_block$8(ctx) {
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				href: /*backLinkUrl*/ ctx[1] || '#',
    				back: true,
    				icon: "icon-back",
    				force: /*backLinkForce*/ ctx[2] || undefined,
    				class: !/*backLinkText*/ ctx[3] ? 'icon-only' : undefined,
    				text: /*backLinkText*/ ctx[3],
    				onClick: /*onBackClick*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*backLinkUrl*/ 2) link_changes.href = /*backLinkUrl*/ ctx[1] || '#';
    			if (dirty & /*backLinkForce*/ 4) link_changes.force = /*backLinkForce*/ ctx[2] || undefined;
    			if (dirty & /*backLinkText*/ 8) link_changes.class = !/*backLinkText*/ ctx[3] ? 'icon-only' : undefined;
    			if (dirty & /*backLinkText*/ 8) link_changes.text = /*backLinkText*/ ctx[3];
    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(46:2) {#if backLink}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = /*backLink*/ ctx[0] && create_if_block$8(ctx);
    	const default_slot_template = /*#slots*/ ctx[13].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
    	let div_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$e, 44, 0, 1102);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*backLink*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*backLink*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[12],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
    				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let classes;
    	let needBackLinkText;
    	let backLinkText;
    	const omit_props_names = ["class","backLink","backLinkUrl","backLinkForce","backLinkShowText","sliding"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Nav_left', slots, ['default']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { backLink = undefined } = $$props;
    	let { backLinkUrl = undefined } = $$props;
    	let { backLinkForce = undefined } = $$props;
    	let { backLinkShowText = undefined } = $$props;
    	let { sliding = undefined } = $$props;

    	let theme = useTheme(t => {
    		$$invalidate(10, theme = t);
    	});

    	function onBackClick() {
    		emit('clickBack');
    		emit('backClick');
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(7, className = $$new_props.class);
    		if ('backLink' in $$new_props) $$invalidate(0, backLink = $$new_props.backLink);
    		if ('backLinkUrl' in $$new_props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
    		if ('backLinkForce' in $$new_props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
    		if ('backLinkShowText' in $$new_props) $$invalidate(8, backLinkShowText = $$new_props.backLinkShowText);
    		if ('sliding' in $$new_props) $$invalidate(9, sliding = $$new_props.sliding);
    		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		colorClasses,
    		classNames,
    		createEmitter,
    		restProps,
    		useTheme,
    		Link,
    		emit,
    		className,
    		backLink,
    		backLinkUrl,
    		backLinkForce,
    		backLinkShowText,
    		sliding,
    		theme,
    		onBackClick,
    		needBackLinkText,
    		backLinkText,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(7, className = $$new_props.className);
    		if ('backLink' in $$props) $$invalidate(0, backLink = $$new_props.backLink);
    		if ('backLinkUrl' in $$props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
    		if ('backLinkForce' in $$props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
    		if ('backLinkShowText' in $$props) $$invalidate(8, backLinkShowText = $$new_props.backLinkShowText);
    		if ('sliding' in $$props) $$invalidate(9, sliding = $$new_props.sliding);
    		if ('theme' in $$props) $$invalidate(10, theme = $$new_props.theme);
    		if ('needBackLinkText' in $$props) $$invalidate(11, needBackLinkText = $$new_props.needBackLinkText);
    		if ('backLinkText' in $$props) $$invalidate(3, backLinkText = $$new_props.backLinkText);
    		if ('classes' in $$props) $$invalidate(4, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(4, classes = classNames(className, 'left', { sliding }, colorClasses($$props)));

    		if ($$self.$$.dirty & /*backLinkShowText*/ 256) {
    			$$invalidate(11, needBackLinkText = backLinkShowText);
    		}

    		if ($$self.$$.dirty & /*needBackLinkText, theme*/ 3072) {
    			if (typeof needBackLinkText === 'undefined') $$invalidate(11, needBackLinkText = theme && !theme.md);
    		}

    		if ($$self.$$.dirty & /*backLink, needBackLinkText*/ 2049) {
    			$$invalidate(3, backLinkText = backLink !== true && needBackLinkText
    			? backLink
    			: undefined);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		backLink,
    		backLinkUrl,
    		backLinkForce,
    		backLinkText,
    		classes,
    		onBackClick,
    		$$restProps,
    		className,
    		backLinkShowText,
    		sliding,
    		theme,
    		needBackLinkText,
    		$$scope,
    		slots
    	];
    }

    class Nav_left extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$d, create_fragment$f, safe_not_equal, {
    			class: 7,
    			backLink: 0,
    			backLinkUrl: 1,
    			backLinkForce: 2,
    			backLinkShowText: 8,
    			sliding: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nav_left",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get class() {
    		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLink() {
    		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLink(value) {
    		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLinkUrl() {
    		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLinkUrl(value) {
    		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLinkForce() {
    		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLinkForce(value) {
    		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLinkShowText() {
    		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLinkShowText(value) {
    		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sliding() {
    		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sliding(value) {
    		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/nav-right.svelte generated by Svelte v3.44.0 */
    const file$d = "node_modules/framework7-svelte/esm/svelte/nav-right.svelte";

    function create_fragment$e(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
    	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$d, 20, 0, 385);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
    				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","sliding"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Nav_right', slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { sliding = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('sliding' in $$new_props) $$invalidate(3, sliding = $$new_props.sliding);
    		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		colorClasses,
    		classNames,
    		restProps,
    		className,
    		sliding,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('sliding' in $$props) $$invalidate(3, sliding = $$new_props.sliding);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(0, classes = classNames(className, 'right', { sliding }, colorClasses($$props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [classes, $$restProps, className, sliding, $$scope, slots];
    }

    class Nav_right extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$e, safe_not_equal, { class: 2, sliding: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nav_right",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get class() {
    		throw new Error("<Nav_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Nav_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sliding() {
    		throw new Error("<Nav_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sliding(value) {
    		throw new Error("<Nav_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/nav-title.svelte generated by Svelte v3.44.0 */
    const file$c = "node_modules/framework7-svelte/esm/svelte/nav-title.svelte";

    // (24:2) {#if typeof title !== 'undefined'}
    function create_if_block_1$4(ctx) {
    	let t_value = plainText(/*title*/ ctx[0]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 1 && t_value !== (t_value = plainText(/*title*/ ctx[0]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(24:2) {#if typeof title !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (25:2) {#if typeof subtitle !== 'undefined'}
    function create_if_block$7(ctx) {
    	let span;
    	let t_value = plainText(/*subtitle*/ ctx[1]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			attr_dev(span, "class", "subtitle");
    			add_location(span, file$c, 24, 39, 612);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*subtitle*/ 2 && t_value !== (t_value = plainText(/*subtitle*/ ctx[1]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(25:2) {#if typeof subtitle !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let current;
    	let if_block0 = typeof /*title*/ ctx[0] !== 'undefined' && create_if_block_1$4(ctx);
    	let if_block1 = typeof /*subtitle*/ ctx[1] !== 'undefined' && create_if_block$7(ctx);
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	let div_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$c, 22, 0, 463);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (typeof /*title*/ ctx[0] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$4(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*subtitle*/ ctx[1] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$7(ctx);
    					if_block1.c();
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
    				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","title","subtitle","sliding"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Nav_title', slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { title = undefined } = $$props;
    	let { subtitle = undefined } = $$props;
    	let { sliding = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ('title' in $$new_props) $$invalidate(0, title = $$new_props.title);
    		if ('subtitle' in $$new_props) $$invalidate(1, subtitle = $$new_props.subtitle);
    		if ('sliding' in $$new_props) $$invalidate(5, sliding = $$new_props.sliding);
    		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		colorClasses,
    		classNames,
    		plainText,
    		restProps,
    		className,
    		title,
    		subtitle,
    		sliding,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(4, className = $$new_props.className);
    		if ('title' in $$props) $$invalidate(0, title = $$new_props.title);
    		if ('subtitle' in $$props) $$invalidate(1, subtitle = $$new_props.subtitle);
    		if ('sliding' in $$props) $$invalidate(5, sliding = $$new_props.sliding);
    		if ('classes' in $$props) $$invalidate(2, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(2, classes = classNames(className, 'title', { sliding }, colorClasses($$props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [title, subtitle, classes, $$restProps, className, sliding, $$scope, slots];
    }

    class Nav_title extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$b, create_fragment$d, safe_not_equal, {
    			class: 4,
    			title: 0,
    			subtitle: 1,
    			sliding: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nav_title",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get class() {
    		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitle() {
    		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitle(value) {
    		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sliding() {
    		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sliding(value) {
    		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/navbar.svelte generated by Svelte v3.44.0 */
    const file$b = "node_modules/framework7-svelte/esm/svelte/navbar.svelte";
    const get_after_inner_slot_changes$1 = dirty => ({});
    const get_after_inner_slot_context$1 = ctx => ({});
    const get_title_large_slot_changes = dirty => ({});
    const get_title_large_slot_context = ctx => ({});
    const get_right_slot_changes = dirty => ({});
    const get_right_slot_context = ctx => ({});
    const get_nav_right_slot_changes = dirty => ({});
    const get_nav_right_slot_context = ctx => ({});
    const get_title_slot_changes = dirty => ({});
    const get_title_slot_context = ctx => ({});
    const get_left_slot_changes = dirty => ({});
    const get_left_slot_context = ctx => ({});
    const get_nav_left_slot_changes = dirty => ({});
    const get_nav_left_slot_context = ctx => ({});
    const get_before_inner_slot_changes$1 = dirty => ({});
    const get_before_inner_slot_context$1 = ctx => ({});

    // (197:4) {#if backLink || hasLeftSlots}
    function create_if_block_3$1(ctx) {
    	let navleft;
    	let current;

    	navleft = new Nav_left({
    			props: {
    				backLink: /*backLink*/ ctx[0],
    				backLinkUrl: /*backLinkUrl*/ ctx[1],
    				backLinkForce: /*backLinkForce*/ ctx[2],
    				backLinkShowText: /*backLinkShowText*/ ctx[3],
    				onBackClick: /*onBackClick*/ ctx[15],
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navleft.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navleft, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navleft_changes = {};
    			if (dirty[0] & /*backLink*/ 1) navleft_changes.backLink = /*backLink*/ ctx[0];
    			if (dirty[0] & /*backLinkUrl*/ 2) navleft_changes.backLinkUrl = /*backLinkUrl*/ ctx[1];
    			if (dirty[0] & /*backLinkForce*/ 4) navleft_changes.backLinkForce = /*backLinkForce*/ ctx[2];
    			if (dirty[0] & /*backLinkShowText*/ 8) navleft_changes.backLinkShowText = /*backLinkShowText*/ ctx[3];

    			if (dirty[1] & /*$$scope*/ 16384) {
    				navleft_changes.$$scope = { dirty, ctx };
    			}

    			navleft.$set(navleft_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navleft.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navleft.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navleft, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(197:4) {#if backLink || hasLeftSlots}",
    		ctx
    	});

    	return block;
    }

    // (198:6) <NavLeft {backLink} {backLinkUrl} {backLinkForce} {backLinkShowText} {onBackClick}>
    function create_default_slot_2$3(ctx) {
    	let t;
    	let current;
    	const nav_left_slot_template = /*#slots*/ ctx[43]["nav-left"];
    	const nav_left_slot = create_slot(nav_left_slot_template, ctx, /*$$scope*/ ctx[45], get_nav_left_slot_context);
    	const left_slot_template = /*#slots*/ ctx[43].left;
    	const left_slot = create_slot(left_slot_template, ctx, /*$$scope*/ ctx[45], get_left_slot_context);

    	const block = {
    		c: function create() {
    			if (nav_left_slot) nav_left_slot.c();
    			t = space();
    			if (left_slot) left_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (nav_left_slot) {
    				nav_left_slot.m(target, anchor);
    			}

    			insert_dev(target, t, anchor);

    			if (left_slot) {
    				left_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (nav_left_slot) {
    				if (nav_left_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						nav_left_slot,
    						nav_left_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(nav_left_slot_template, /*$$scope*/ ctx[45], dirty, get_nav_left_slot_changes),
    						get_nav_left_slot_context
    					);
    				}
    			}

    			if (left_slot) {
    				if (left_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						left_slot,
    						left_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(left_slot_template, /*$$scope*/ ctx[45], dirty, get_left_slot_changes),
    						get_left_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nav_left_slot, local);
    			transition_in(left_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nav_left_slot, local);
    			transition_out(left_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (nav_left_slot) nav_left_slot.d(detaching);
    			if (detaching) detach_dev(t);
    			if (left_slot) left_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(198:6) <NavLeft {backLink} {backLinkUrl} {backLinkForce} {backLinkShowText} {onBackClick}>",
    		ctx
    	});

    	return block;
    }

    // (203:4) {#if title || subtitle || hasTitleSlots}
    function create_if_block_2$2(ctx) {
    	let navtitle;
    	let current;

    	navtitle = new Nav_title({
    			props: {
    				title: /*title*/ ctx[4],
    				subtitle: /*subtitle*/ ctx[5],
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navtitle.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navtitle, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navtitle_changes = {};
    			if (dirty[0] & /*title*/ 16) navtitle_changes.title = /*title*/ ctx[4];
    			if (dirty[0] & /*subtitle*/ 32) navtitle_changes.subtitle = /*subtitle*/ ctx[5];

    			if (dirty[1] & /*$$scope*/ 16384) {
    				navtitle_changes.$$scope = { dirty, ctx };
    			}

    			navtitle.$set(navtitle_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navtitle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navtitle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navtitle, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(203:4) {#if title || subtitle || hasTitleSlots}",
    		ctx
    	});

    	return block;
    }

    // (204:6) <NavTitle {title} {subtitle}>
    function create_default_slot_1$3(ctx) {
    	let current;
    	const title_slot_template = /*#slots*/ ctx[43].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[45], get_title_slot_context);

    	const block = {
    		c: function create() {
    			if (title_slot) title_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (title_slot) {
    				title_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[45], dirty, get_title_slot_changes),
    						get_title_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(204:6) <NavTitle {title} {subtitle}>",
    		ctx
    	});

    	return block;
    }

    // (208:4) {#if hasRightSlots}
    function create_if_block_1$3(ctx) {
    	let navright;
    	let current;

    	navright = new Nav_right({
    			props: {
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navright.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navright, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navright_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				navright_changes.$$scope = { dirty, ctx };
    			}

    			navright.$set(navright_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navright.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navright.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navright, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(208:4) {#if hasRightSlots}",
    		ctx
    	});

    	return block;
    }

    // (209:6) <NavRight>
    function create_default_slot$8(ctx) {
    	let t;
    	let current;
    	const nav_right_slot_template = /*#slots*/ ctx[43]["nav-right"];
    	const nav_right_slot = create_slot(nav_right_slot_template, ctx, /*$$scope*/ ctx[45], get_nav_right_slot_context);
    	const right_slot_template = /*#slots*/ ctx[43].right;
    	const right_slot = create_slot(right_slot_template, ctx, /*$$scope*/ ctx[45], get_right_slot_context);

    	const block = {
    		c: function create() {
    			if (nav_right_slot) nav_right_slot.c();
    			t = space();
    			if (right_slot) right_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (nav_right_slot) {
    				nav_right_slot.m(target, anchor);
    			}

    			insert_dev(target, t, anchor);

    			if (right_slot) {
    				right_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (nav_right_slot) {
    				if (nav_right_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						nav_right_slot,
    						nav_right_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(nav_right_slot_template, /*$$scope*/ ctx[45], dirty, get_nav_right_slot_changes),
    						get_nav_right_slot_context
    					);
    				}
    			}

    			if (right_slot) {
    				if (right_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						right_slot,
    						right_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(right_slot_template, /*$$scope*/ ctx[45], dirty, get_right_slot_changes),
    						get_right_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nav_right_slot, local);
    			transition_in(right_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nav_right_slot, local);
    			transition_out(right_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (nav_right_slot) nav_right_slot.d(detaching);
    			if (detaching) detach_dev(t);
    			if (right_slot) right_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(209:6) <NavRight>",
    		ctx
    	});

    	return block;
    }

    // (214:4) {#if largeTitle || hasTitleLargeSlots}
    function create_if_block$6(ctx) {
    	let div1;
    	let div0;
    	let t0_value = plainText(/*largeTitle*/ ctx[11]) + "";
    	let t0;
    	let t1;
    	let current;
    	const title_large_slot_template = /*#slots*/ ctx[43]["title-large"];
    	const title_large_slot = create_slot(title_large_slot_template, ctx, /*$$scope*/ ctx[45], get_title_large_slot_context);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if (title_large_slot) title_large_slot.c();
    			attr_dev(div0, "class", "title-large-text");
    			add_location(div0, file$b, 215, 8, 6820);
    			attr_dev(div1, "class", "title-large");
    			add_location(div1, file$b, 214, 6, 6786);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div0, t1);

    			if (title_large_slot) {
    				title_large_slot.m(div0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*largeTitle*/ 2048) && t0_value !== (t0_value = plainText(/*largeTitle*/ ctx[11]) + "")) set_data_dev(t0, t0_value);

    			if (title_large_slot) {
    				if (title_large_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						title_large_slot,
    						title_large_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(title_large_slot_template, /*$$scope*/ ctx[45], dirty, get_title_large_slot_changes),
    						get_title_large_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_large_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_large_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (title_large_slot) title_large_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(214:4) {#if largeTitle || hasTitleLargeSlots}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let current;
    	const before_inner_slot_template = /*#slots*/ ctx[43]["before-inner"];
    	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[45], get_before_inner_slot_context$1);
    	let if_block0 = (/*backLink*/ ctx[0] || /*hasLeftSlots*/ ctx[14]) && create_if_block_3$1(ctx);
    	let if_block1 = (/*title*/ ctx[4] || /*subtitle*/ ctx[5] || /*hasTitleSlots*/ ctx[12]) && create_if_block_2$2(ctx);
    	let if_block2 = /*hasRightSlots*/ ctx[13] && create_if_block_1$3(ctx);
    	let if_block3 = (/*largeTitle*/ ctx[11] || /*hasTitleLargeSlots*/ ctx[10]) && create_if_block$6(ctx);
    	const default_slot_template = /*#slots*/ ctx[43].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[45], null);
    	const after_inner_slot_template = /*#slots*/ ctx[43]["after-inner"];
    	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[45], get_after_inner_slot_context$1);

    	let div2_levels = [
    		{ class: /*classes*/ ctx[9] },
    		{ "data-f7-slot": /*f7Slot*/ ctx[6] },
    		restProps(/*$$restProps*/ ctx[16])
    	];

    	let div2_data = {};

    	for (let i = 0; i < div2_levels.length; i += 1) {
    		div2_data = assign(div2_data, div2_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();
    			if (before_inner_slot) before_inner_slot.c();
    			t1 = space();
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (default_slot) default_slot.c();
    			t6 = space();
    			if (after_inner_slot) after_inner_slot.c();
    			attr_dev(div0, "class", "navbar-bg");
    			add_location(div0, file$b, 193, 2, 6165);
    			attr_dev(div1, "class", /*innerClasses*/ ctx[8]);
    			add_location(div1, file$b, 195, 2, 6224);
    			set_attributes(div2, div2_data);
    			add_location(div2, file$b, 192, 0, 6076);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t0);

    			if (before_inner_slot) {
    				before_inner_slot.m(div2, null);
    			}

    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t2);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t3);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div1, t4);
    			if (if_block3) if_block3.m(div1, null);
    			append_dev(div1, t5);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			append_dev(div2, t6);

    			if (after_inner_slot) {
    				after_inner_slot.m(div2, null);
    			}

    			/*div2_binding*/ ctx[44](div2);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_inner_slot) {
    				if (before_inner_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						before_inner_slot,
    						before_inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(before_inner_slot_template, /*$$scope*/ ctx[45], dirty, get_before_inner_slot_changes$1),
    						get_before_inner_slot_context$1
    					);
    				}
    			}

    			if (/*backLink*/ ctx[0] || /*hasLeftSlots*/ ctx[14]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*backLink, hasLeftSlots*/ 16385) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*title*/ ctx[4] || /*subtitle*/ ctx[5] || /*hasTitleSlots*/ ctx[12]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*title, subtitle, hasTitleSlots*/ 4144) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*hasRightSlots*/ ctx[13]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*hasRightSlots*/ 8192) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$3(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div1, t4);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*largeTitle*/ ctx[11] || /*hasTitleLargeSlots*/ ctx[10]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*largeTitle, hasTitleLargeSlots*/ 3072) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block$6(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div1, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[45], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty[0] & /*innerClasses*/ 256) {
    				attr_dev(div1, "class", /*innerClasses*/ ctx[8]);
    			}

    			if (after_inner_slot) {
    				if (after_inner_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						after_inner_slot,
    						after_inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(after_inner_slot_template, /*$$scope*/ ctx[45], dirty, get_after_inner_slot_changes$1),
    						get_after_inner_slot_context$1
    					);
    				}
    			}

    			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
    				(!current || dirty[0] & /*classes*/ 512) && { class: /*classes*/ ctx[9] },
    				(!current || dirty[0] & /*f7Slot*/ 64) && { "data-f7-slot": /*f7Slot*/ ctx[6] },
    				dirty[0] & /*$$restProps*/ 65536 && restProps(/*$$restProps*/ ctx[16])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_inner_slot, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(default_slot, local);
    			transition_in(after_inner_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_inner_slot, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(default_slot, local);
    			transition_out(after_inner_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (before_inner_slot) before_inner_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (default_slot) default_slot.d(detaching);
    			if (after_inner_slot) after_inner_slot.d(detaching);
    			/*div2_binding*/ ctx[44](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let hasLeftSlots;
    	let hasRightSlots;
    	let hasTitleSlots;
    	let largeTitle;
    	let hasTitleLargeSlots;
    	let addLeftTitleClass;
    	let addCenterTitleClass;
    	let isLarge;
    	let isTransparent;
    	let isTransparentVisible;
    	let classes;
    	let innerClasses;

    	const omit_props_names = [
    		"class","backLink","backLinkUrl","backLinkForce","backLinkShowText","sliding","title","subtitle","hidden","noShadow","noHairline","innerClass","innerClassName","large","largeTransparent","transparent","titleLarge","f7Slot","hide","show","size"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;

    	validate_slots('Navbar', slots, [
    		'before-inner','nav-left','left','title','nav-right','right','title-large','default','after-inner'
    	]);

    	const $$slots = compute_slots(slots);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { backLink = undefined } = $$props;
    	let { backLinkUrl = undefined } = $$props;
    	let { backLinkForce = false } = $$props;
    	let { backLinkShowText = undefined } = $$props;
    	let { sliding = true } = $$props;
    	let { title = undefined } = $$props;
    	let { subtitle = undefined } = $$props;
    	let { hidden = false } = $$props;
    	let { noShadow = false } = $$props;
    	let { noHairline = false } = $$props;
    	let { innerClass = undefined } = $$props;
    	let { innerClassName = undefined } = $$props;
    	let { large = false } = $$props;
    	let { largeTransparent = false } = $$props;
    	let { transparent = false } = $$props;
    	let { titleLarge = undefined } = $$props;
    	let { f7Slot = 'fixed' } = $$props;
    	let el;

    	let theme = useTheme(t => {
    		$$invalidate(31, theme = t);
    	});

    	let routerPositionClass = '';
    	let largeCollapsed = false;
    	let routerNavbarRole = null;
    	let routerNavbarRoleDetailRoot = false;
    	let routerNavbarMasterStack = false;
    	let transparentVisible = false;

    	function hide(animate) {
    		app$1.f7.navbar.hide(el, animate);
    	}

    	function show(animate) {
    		app$1.f7.navbar.show(el, animate);
    	}

    	function size() {
    		app$1.f7.navbar.size(el);
    	}

    	function onHide(navbarEl) {
    		if (el !== navbarEl) return;
    		emit('navbarHide');
    	}

    	function onShow(navbarEl) {
    		if (el !== navbarEl) return;
    		emit('navbarShow');
    	}

    	function onNavbarTransparentShow(navbarEl) {
    		if (el !== navbarEl) return;
    		$$invalidate(37, transparentVisible = true);
    		emit('navbarTransparentShow');
    	}

    	function onNavbarTransparentHide(navbarEl) {
    		if (el !== navbarEl) return;
    		$$invalidate(37, transparentVisible = false);
    		emit('navbarTransparentHide');
    	}

    	function onExpand(navbarEl) {
    		if (el !== navbarEl) return;
    		$$invalidate(33, largeCollapsed = false);
    		emit('navbarExpand');
    	}

    	function onCollapse(navbarEl) {
    		if (el !== navbarEl) return;
    		$$invalidate(33, largeCollapsed = true);
    		emit('navbarCollapse');
    	}

    	function onNavbarPosition(navbarEl, position) {
    		if (el !== navbarEl) return;
    		$$invalidate(32, routerPositionClass = position ? `navbar-${position}` : position);
    	}

    	function onNavbarRole(navbarEl, rolesData) {
    		if (el !== navbarEl) return;
    		$$invalidate(34, routerNavbarRole = rolesData.role);
    		$$invalidate(35, routerNavbarRoleDetailRoot = rolesData.detailRoot);
    	}

    	function onNavbarMasterStack(navbarEl) {
    		if (el !== navbarEl) return;
    		$$invalidate(36, routerNavbarMasterStack = true);
    	}

    	function onNavbarMasterUnstack(navbarEl) {
    		if (el !== navbarEl) return;
    		$$invalidate(36, routerNavbarMasterStack = false);
    	}

    	function onBackClick() {
    		emit('clickBack');
    	}

    	function mountNavbar() {
    		app$1.f7.on('navbarShow', onShow);
    		app$1.f7.on('navbarHide', onHide);
    		app$1.f7.on('navbarCollapse', onCollapse);
    		app$1.f7.on('navbarExpand', onExpand);
    		app$1.f7.on('navbarPosition', onNavbarPosition);
    		app$1.f7.on('navbarRole', onNavbarRole);
    		app$1.f7.on('navbarMasterStack', onNavbarMasterStack);
    		app$1.f7.on('navbarMasterUnstack', onNavbarMasterUnstack);
    		app$1.f7.on('navbarTransparentShow', onNavbarTransparentShow);
    		app$1.f7.on('navbarTransparentHide', onNavbarTransparentHide);
    	}

    	function destroyNavbar() {
    		app$1.f7.off('navbarShow', onShow);
    		app$1.f7.off('navbarHide', onHide);
    		app$1.f7.off('navbarCollapse', onCollapse);
    		app$1.f7.off('navbarExpand', onExpand);
    		app$1.f7.off('navbarPosition', onNavbarPosition);
    		app$1.f7.off('navbarRole', onNavbarRole);
    		app$1.f7.off('navbarMasterStack', onNavbarMasterStack);
    		app$1.f7.off('navbarMasterUnstack', onNavbarMasterUnstack);
    		app$1.f7.off('navbarTransparentShow', onNavbarTransparentShow);
    		app$1.f7.off('navbarTransparentHide', onNavbarTransparentHide);
    	}

    	onMount(() => {
    		f7ready(() => {
    			mountNavbar();
    		});
    	});

    	afterUpdate(() => {
    		if (!app$1.f7) return;
    		app$1.f7.navbar.size(el);
    	});

    	onDestroy(() => {
    		if (!app$1.f7) return;
    		destroyNavbar();
    	});

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(7, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(59, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(17, className = $$new_props.class);
    		if ('backLink' in $$new_props) $$invalidate(0, backLink = $$new_props.backLink);
    		if ('backLinkUrl' in $$new_props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
    		if ('backLinkForce' in $$new_props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
    		if ('backLinkShowText' in $$new_props) $$invalidate(3, backLinkShowText = $$new_props.backLinkShowText);
    		if ('sliding' in $$new_props) $$invalidate(18, sliding = $$new_props.sliding);
    		if ('title' in $$new_props) $$invalidate(4, title = $$new_props.title);
    		if ('subtitle' in $$new_props) $$invalidate(5, subtitle = $$new_props.subtitle);
    		if ('hidden' in $$new_props) $$invalidate(19, hidden = $$new_props.hidden);
    		if ('noShadow' in $$new_props) $$invalidate(20, noShadow = $$new_props.noShadow);
    		if ('noHairline' in $$new_props) $$invalidate(21, noHairline = $$new_props.noHairline);
    		if ('innerClass' in $$new_props) $$invalidate(22, innerClass = $$new_props.innerClass);
    		if ('innerClassName' in $$new_props) $$invalidate(23, innerClassName = $$new_props.innerClassName);
    		if ('large' in $$new_props) $$invalidate(24, large = $$new_props.large);
    		if ('largeTransparent' in $$new_props) $$invalidate(25, largeTransparent = $$new_props.largeTransparent);
    		if ('transparent' in $$new_props) $$invalidate(26, transparent = $$new_props.transparent);
    		if ('titleLarge' in $$new_props) $$invalidate(27, titleLarge = $$new_props.titleLarge);
    		if ('f7Slot' in $$new_props) $$invalidate(6, f7Slot = $$new_props.f7Slot);
    		if ('$$scope' in $$new_props) $$invalidate(45, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		afterUpdate,
    		colorClasses,
    		classNames,
    		plainText,
    		createEmitter,
    		restProps,
    		f7ready,
    		app: app$1,
    		useTheme,
    		NavLeft: Nav_left,
    		NavTitle: Nav_title,
    		NavRight: Nav_right,
    		emit,
    		className,
    		backLink,
    		backLinkUrl,
    		backLinkForce,
    		backLinkShowText,
    		sliding,
    		title,
    		subtitle,
    		hidden,
    		noShadow,
    		noHairline,
    		innerClass,
    		innerClassName,
    		large,
    		largeTransparent,
    		transparent,
    		titleLarge,
    		f7Slot,
    		el,
    		theme,
    		routerPositionClass,
    		largeCollapsed,
    		routerNavbarRole,
    		routerNavbarRoleDetailRoot,
    		routerNavbarMasterStack,
    		transparentVisible,
    		hide,
    		show,
    		size,
    		onHide,
    		onShow,
    		onNavbarTransparentShow,
    		onNavbarTransparentHide,
    		onExpand,
    		onCollapse,
    		onNavbarPosition,
    		onNavbarRole,
    		onNavbarMasterStack,
    		onNavbarMasterUnstack,
    		onBackClick,
    		mountNavbar,
    		destroyNavbar,
    		addCenterTitleClass,
    		addLeftTitleClass,
    		innerClasses,
    		isTransparentVisible,
    		isTransparent,
    		isLarge,
    		classes,
    		hasTitleLargeSlots,
    		largeTitle,
    		hasTitleSlots,
    		hasRightSlots,
    		hasLeftSlots
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(59, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(17, className = $$new_props.className);
    		if ('backLink' in $$props) $$invalidate(0, backLink = $$new_props.backLink);
    		if ('backLinkUrl' in $$props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
    		if ('backLinkForce' in $$props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
    		if ('backLinkShowText' in $$props) $$invalidate(3, backLinkShowText = $$new_props.backLinkShowText);
    		if ('sliding' in $$props) $$invalidate(18, sliding = $$new_props.sliding);
    		if ('title' in $$props) $$invalidate(4, title = $$new_props.title);
    		if ('subtitle' in $$props) $$invalidate(5, subtitle = $$new_props.subtitle);
    		if ('hidden' in $$props) $$invalidate(19, hidden = $$new_props.hidden);
    		if ('noShadow' in $$props) $$invalidate(20, noShadow = $$new_props.noShadow);
    		if ('noHairline' in $$props) $$invalidate(21, noHairline = $$new_props.noHairline);
    		if ('innerClass' in $$props) $$invalidate(22, innerClass = $$new_props.innerClass);
    		if ('innerClassName' in $$props) $$invalidate(23, innerClassName = $$new_props.innerClassName);
    		if ('large' in $$props) $$invalidate(24, large = $$new_props.large);
    		if ('largeTransparent' in $$props) $$invalidate(25, largeTransparent = $$new_props.largeTransparent);
    		if ('transparent' in $$props) $$invalidate(26, transparent = $$new_props.transparent);
    		if ('titleLarge' in $$props) $$invalidate(27, titleLarge = $$new_props.titleLarge);
    		if ('f7Slot' in $$props) $$invalidate(6, f7Slot = $$new_props.f7Slot);
    		if ('el' in $$props) $$invalidate(7, el = $$new_props.el);
    		if ('theme' in $$props) $$invalidate(31, theme = $$new_props.theme);
    		if ('routerPositionClass' in $$props) $$invalidate(32, routerPositionClass = $$new_props.routerPositionClass);
    		if ('largeCollapsed' in $$props) $$invalidate(33, largeCollapsed = $$new_props.largeCollapsed);
    		if ('routerNavbarRole' in $$props) $$invalidate(34, routerNavbarRole = $$new_props.routerNavbarRole);
    		if ('routerNavbarRoleDetailRoot' in $$props) $$invalidate(35, routerNavbarRoleDetailRoot = $$new_props.routerNavbarRoleDetailRoot);
    		if ('routerNavbarMasterStack' in $$props) $$invalidate(36, routerNavbarMasterStack = $$new_props.routerNavbarMasterStack);
    		if ('transparentVisible' in $$props) $$invalidate(37, transparentVisible = $$new_props.transparentVisible);
    		if ('addCenterTitleClass' in $$props) $$invalidate(38, addCenterTitleClass = $$new_props.addCenterTitleClass);
    		if ('addLeftTitleClass' in $$props) $$invalidate(39, addLeftTitleClass = $$new_props.addLeftTitleClass);
    		if ('innerClasses' in $$props) $$invalidate(8, innerClasses = $$new_props.innerClasses);
    		if ('isTransparentVisible' in $$props) $$invalidate(40, isTransparentVisible = $$new_props.isTransparentVisible);
    		if ('isTransparent' in $$props) $$invalidate(41, isTransparent = $$new_props.isTransparent);
    		if ('isLarge' in $$props) $$invalidate(42, isLarge = $$new_props.isLarge);
    		if ('classes' in $$props) $$invalidate(9, classes = $$new_props.classes);
    		if ('hasTitleLargeSlots' in $$props) $$invalidate(10, hasTitleLargeSlots = $$new_props.hasTitleLargeSlots);
    		if ('largeTitle' in $$props) $$invalidate(11, largeTitle = $$new_props.largeTitle);
    		if ('hasTitleSlots' in $$props) $$invalidate(12, hasTitleSlots = $$new_props.hasTitleSlots);
    		if ('hasRightSlots' in $$props) $$invalidate(13, hasRightSlots = $$new_props.hasRightSlots);
    		if ('hasLeftSlots' in $$props) $$invalidate(14, hasLeftSlots = $$new_props.hasLeftSlots);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*titleLarge, large, title*/ 150994960) {
    			$$invalidate(11, largeTitle = titleLarge || large && title);
    		}

    		if ($$self.$$.dirty[1] & /*theme*/ 1) {
    			$$invalidate(39, addLeftTitleClass = theme && theme.ios && app$1.f7 && !app$1.f7.params.navbar.iosCenterTitle);
    		}

    		if ($$self.$$.dirty[1] & /*theme*/ 1) {
    			$$invalidate(38, addCenterTitleClass = theme && theme.md && app$1.f7 && app$1.f7.params.navbar.mdCenterTitle || theme && theme.aurora && app$1.f7 && app$1.f7.params.navbar.auroraCenterTitle);
    		}

    		if ($$self.$$.dirty[0] & /*large, largeTransparent*/ 50331648) {
    			$$invalidate(42, isLarge = large || largeTransparent);
    		}

    		if ($$self.$$.dirty[0] & /*transparent, largeTransparent*/ 100663296 | $$self.$$.dirty[1] & /*isLarge*/ 2048) {
    			$$invalidate(41, isTransparent = transparent || isLarge && largeTransparent);
    		}

    		if ($$self.$$.dirty[1] & /*isTransparent, transparentVisible*/ 1088) {
    			$$invalidate(40, isTransparentVisible = isTransparent && transparentVisible);
    		}

    		$$invalidate(9, classes = classNames(
    			className,
    			'navbar',
    			routerPositionClass,
    			{
    				'navbar-hidden': hidden,
    				'navbar-large': isLarge,
    				'navbar-large-collapsed': isLarge && largeCollapsed,
    				'navbar-transparent': isTransparent,
    				'navbar-transparent-visible': isTransparentVisible,
    				'navbar-master': routerNavbarRole === 'master',
    				'navbar-master-detail': routerNavbarRole === 'detail',
    				'navbar-master-detail-root': routerNavbarRoleDetailRoot === true,
    				'navbar-master-stacked': routerNavbarMasterStack === true,
    				'no-shadow': noShadow,
    				'no-hairline': noHairline
    			},
    			colorClasses($$props)
    		));

    		if ($$self.$$.dirty[0] & /*innerClass, innerClassName, sliding*/ 12845056 | $$self.$$.dirty[1] & /*addLeftTitleClass, addCenterTitleClass*/ 384) {
    			$$invalidate(8, innerClasses = classNames('navbar-inner', innerClass, innerClassName, {
    				sliding,
    				'navbar-inner-left-title': addLeftTitleClass,
    				'navbar-inner-centered-title': addCenterTitleClass
    			}));
    		}
    	};

    	$$invalidate(14, hasLeftSlots = $$slots['nav-left'] || $$slots['left']);

    	// eslint-disable-next-line
    	$$invalidate(13, hasRightSlots = $$slots['nav-right'] || $$slots['right']);

    	// eslint-disable-next-line
    	$$invalidate(12, hasTitleSlots = $$slots['title']);

    	// eslint-disable-next-line
    	$$invalidate(10, hasTitleLargeSlots = $$slots['title-large']);

    	$$props = exclude_internal_props($$props);

    	return [
    		backLink,
    		backLinkUrl,
    		backLinkForce,
    		backLinkShowText,
    		title,
    		subtitle,
    		f7Slot,
    		el,
    		innerClasses,
    		classes,
    		hasTitleLargeSlots,
    		largeTitle,
    		hasTitleSlots,
    		hasRightSlots,
    		hasLeftSlots,
    		onBackClick,
    		$$restProps,
    		className,
    		sliding,
    		hidden,
    		noShadow,
    		noHairline,
    		innerClass,
    		innerClassName,
    		large,
    		largeTransparent,
    		transparent,
    		titleLarge,
    		hide,
    		show,
    		size,
    		theme,
    		routerPositionClass,
    		largeCollapsed,
    		routerNavbarRole,
    		routerNavbarRoleDetailRoot,
    		routerNavbarMasterStack,
    		transparentVisible,
    		addCenterTitleClass,
    		addLeftTitleClass,
    		isTransparentVisible,
    		isTransparent,
    		isLarge,
    		slots,
    		div2_binding,
    		$$scope
    	];
    }

    class Navbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$a,
    			create_fragment$c,
    			safe_not_equal,
    			{
    				class: 17,
    				backLink: 0,
    				backLinkUrl: 1,
    				backLinkForce: 2,
    				backLinkShowText: 3,
    				sliding: 18,
    				title: 4,
    				subtitle: 5,
    				hidden: 19,
    				noShadow: 20,
    				noHairline: 21,
    				innerClass: 22,
    				innerClassName: 23,
    				large: 24,
    				largeTransparent: 25,
    				transparent: 26,
    				titleLarge: 27,
    				f7Slot: 6,
    				hide: 28,
    				show: 29,
    				size: 30
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navbar",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get class() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLink() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLink(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLinkUrl() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLinkUrl(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLinkForce() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLinkForce(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLinkShowText() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLinkShowText(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sliding() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sliding(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitle() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitle(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hidden() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hidden(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noShadow() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noShadow(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairline() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairline(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get innerClass() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set innerClass(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get innerClassName() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set innerClassName(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get large() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set large(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get largeTransparent() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set largeTransparent(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transparent() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transparent(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleLarge() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleLarge(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get f7Slot() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set f7Slot(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hide() {
    		return this.$$.ctx[28];
    	}

    	set hide(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get show() {
    		return this.$$.ctx[29];
    	}

    	set show(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		return this.$$.ctx[30];
    	}

    	set size(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/page-content.svelte generated by Svelte v3.44.0 */
    const file$a = "node_modules/framework7-svelte/esm/svelte/page-content.svelte";

    // (125:2) {#if ptr && ptrPreloader && !ptrBottom}
    function create_if_block_3(ctx) {
    	let div1;
    	let preloader;
    	let t;
    	let div0;
    	let current;
    	preloader = new Preloader({ $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(preloader.$$.fragment);
    			t = space();
    			div0 = element("div");
    			attr_dev(div0, "class", "ptr-arrow");
    			add_location(div0, file$a, 127, 6, 3529);
    			attr_dev(div1, "class", "ptr-preloader");
    			add_location(div1, file$a, 125, 4, 3475);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(preloader, div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(preloader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(preloader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(preloader);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(125:2) {#if ptr && ptrPreloader && !ptrBottom}",
    		ctx
    	});

    	return block;
    }

    // (131:2) {#if infinite && infiniteTop && infinitePreloader}
    function create_if_block_2$1(ctx) {
    	let preloader;
    	let current;

    	preloader = new Preloader({
    			props: { class: "infinite-scroll-preloader" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(preloader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(preloader, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(preloader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(preloader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(preloader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(131:2) {#if infinite && infiniteTop && infinitePreloader}",
    		ctx
    	});

    	return block;
    }

    // (135:2) {#if infinite && !infiniteTop && infinitePreloader}
    function create_if_block_1$2(ctx) {
    	let preloader;
    	let current;

    	preloader = new Preloader({
    			props: { class: "infinite-scroll-preloader" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(preloader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(preloader, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(preloader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(preloader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(preloader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(135:2) {#if infinite && !infiniteTop && infinitePreloader}",
    		ctx
    	});

    	return block;
    }

    // (138:2) {#if ptr && ptrPreloader && ptrBottom}
    function create_if_block$5(ctx) {
    	let div1;
    	let preloader;
    	let t;
    	let div0;
    	let current;
    	preloader = new Preloader({ $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(preloader.$$.fragment);
    			t = space();
    			div0 = element("div");
    			attr_dev(div0, "class", "ptr-arrow");
    			add_location(div0, file$a, 140, 6, 3911);
    			attr_dev(div1, "class", "ptr-preloader");
    			add_location(div1, file$a, 138, 4, 3857);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(preloader, div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(preloader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(preloader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(preloader);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(138:2) {#if ptr && ptrPreloader && ptrBottom}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let div_data_ptr_mousewheel_value;
    	let div_data_infinite_distance_value;
    	let current;
    	let if_block0 = /*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && !/*ptrBottom*/ ctx[3] && create_if_block_3(ctx);
    	let if_block1 = /*infinite*/ ctx[5] && /*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8] && create_if_block_2$1(ctx);
    	const default_slot_template = /*#slots*/ ctx[21].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
    	let if_block2 = /*infinite*/ ctx[5] && !/*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8] && create_if_block_1$2(ctx);
    	let if_block3 = /*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && /*ptrBottom*/ ctx[3] && create_if_block$5(ctx);

    	let div_levels = [
    		{ class: /*pageContentClasses*/ ctx[10] },
    		{
    			"data-ptr-distance": /*ptrDistance*/ ctx[1]
    		},
    		{
    			"data-ptr-mousewheel": div_data_ptr_mousewheel_value = /*ptrMousewheel*/ ctx[4] || undefined
    		},
    		{
    			"data-infinite-distance": div_data_infinite_distance_value = /*infiniteDistance*/ ctx[7] || undefined
    		},
    		restProps(/*$$restProps*/ ctx[11])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			set_attributes(div, div_data);
    			add_location(div, file$a, 116, 0, 3193);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t2);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t3);
    			if (if_block3) if_block3.m(div, null);
    			/*div_binding*/ ctx[22](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && !/*ptrBottom*/ ctx[3]) {
    				if (if_block0) {
    					if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/ 13) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*infinite*/ ctx[5] && /*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8]) {
    				if (if_block1) {
    					if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/ 352) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1048576)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[20],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*infinite*/ ctx[5] && !/*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8]) {
    				if (if_block2) {
    					if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/ 352) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$2(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && /*ptrBottom*/ ctx[3]) {
    				if (if_block3) {
    					if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/ 13) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block$5(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty[0] & /*pageContentClasses*/ 1024) && { class: /*pageContentClasses*/ ctx[10] },
    				(!current || dirty[0] & /*ptrDistance*/ 2) && {
    					"data-ptr-distance": /*ptrDistance*/ ctx[1]
    				},
    				(!current || dirty[0] & /*ptrMousewheel*/ 16 && div_data_ptr_mousewheel_value !== (div_data_ptr_mousewheel_value = /*ptrMousewheel*/ ctx[4] || undefined)) && {
    					"data-ptr-mousewheel": div_data_ptr_mousewheel_value
    				},
    				(!current || dirty[0] & /*infiniteDistance*/ 128 && div_data_infinite_distance_value !== (div_data_infinite_distance_value = /*infiniteDistance*/ ctx[7] || undefined)) && {
    					"data-infinite-distance": div_data_infinite_distance_value
    				},
    				dirty[0] & /*$$restProps*/ 2048 && restProps(/*$$restProps*/ ctx[11])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(default_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(default_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			/*div_binding*/ ctx[22](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let pageContentClasses;

    	const omit_props_names = [
    		"tab","tabActive","ptr","ptrDistance","ptrPreloader","ptrBottom","ptrMousewheel","infinite","infiniteTop","infiniteDistance","infinitePreloader","hideBarsOnScroll","hideNavbarOnScroll","hideToolbarOnScroll","messagesContent","loginScreen","class"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Page_content', slots, ['default']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { tab = false } = $$props;
    	let { tabActive = false } = $$props;
    	let { ptr = false } = $$props;
    	let { ptrDistance = undefined } = $$props;
    	let { ptrPreloader = true } = $$props;
    	let { ptrBottom = false } = $$props;
    	let { ptrMousewheel = false } = $$props;
    	let { infinite = false } = $$props;
    	let { infiniteTop = false } = $$props;
    	let { infiniteDistance = undefined } = $$props;
    	let { infinitePreloader = true } = $$props;
    	let { hideBarsOnScroll = false } = $$props;
    	let { hideNavbarOnScroll = false } = $$props;
    	let { hideToolbarOnScroll = false } = $$props;
    	let { messagesContent = false } = $$props;
    	let { loginScreen = false } = $$props;
    	let { class: className = undefined } = $$props;
    	let pageContentEl;

    	// Event handlers
    	function onPtrPullStart(ptrEl) {
    		if (ptrEl !== pageContentEl) return;
    		emit('ptrPullStart');
    	}

    	function onPtrPullMove(ptrEl) {
    		if (ptrEl !== pageContentEl) return;
    		emit('ptrPullMove');
    	}

    	function onPtrPullEnd(ptrEl) {
    		if (ptrEl !== pageContentEl) return;
    		emit('ptrPullEnd');
    	}

    	function onPtrRefresh(ptrEl, done) {
    		if (ptrEl !== pageContentEl) return;
    		emit('ptrRefresh', [done]);
    	}

    	function onPtrDone(ptrEl) {
    		if (ptrEl !== pageContentEl) return;
    		emit('ptrDone');
    	}

    	function onInfinite(infEl) {
    		if (infEl !== pageContentEl) return;
    		emit('infinite');
    	}

    	function mountPageContent() {
    		if (ptr) {
    			app$1.f7.on('ptrPullStart', onPtrPullStart);
    			app$1.f7.on('ptrPullMove', onPtrPullMove);
    			app$1.f7.on('ptrPullEnd', onPtrPullEnd);
    			app$1.f7.on('ptrRefresh', onPtrRefresh);
    			app$1.f7.on('ptrDone', onPtrDone);
    		}

    		if (infinite) {
    			app$1.f7.on('infinite', onInfinite);
    		}
    	}

    	function destroyPageContent() {
    		if (ptr) {
    			app$1.f7.off('ptrPullStart', onPtrPullStart);
    			app$1.f7.off('ptrPullMove', onPtrPullMove);
    			app$1.f7.off('ptrPullEnd', onPtrPullEnd);
    			app$1.f7.off('ptrRefresh', onPtrRefresh);
    			app$1.f7.off('ptrDone', onPtrDone);
    		}

    		if (infinite) {
    			app$1.f7.off('infinite', onInfinite);
    		}
    	}

    	useTab(() => pageContentEl, emit);

    	onMount(() => {
    		f7ready(() => {
    			mountPageContent();
    		});
    	});

    	onDestroy(() => {
    		if (!app$1.f7) return;
    		destroyPageContent();
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			pageContentEl = $$value;
    			$$invalidate(9, pageContentEl);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('tab' in $$new_props) $$invalidate(12, tab = $$new_props.tab);
    		if ('tabActive' in $$new_props) $$invalidate(13, tabActive = $$new_props.tabActive);
    		if ('ptr' in $$new_props) $$invalidate(0, ptr = $$new_props.ptr);
    		if ('ptrDistance' in $$new_props) $$invalidate(1, ptrDistance = $$new_props.ptrDistance);
    		if ('ptrPreloader' in $$new_props) $$invalidate(2, ptrPreloader = $$new_props.ptrPreloader);
    		if ('ptrBottom' in $$new_props) $$invalidate(3, ptrBottom = $$new_props.ptrBottom);
    		if ('ptrMousewheel' in $$new_props) $$invalidate(4, ptrMousewheel = $$new_props.ptrMousewheel);
    		if ('infinite' in $$new_props) $$invalidate(5, infinite = $$new_props.infinite);
    		if ('infiniteTop' in $$new_props) $$invalidate(6, infiniteTop = $$new_props.infiniteTop);
    		if ('infiniteDistance' in $$new_props) $$invalidate(7, infiniteDistance = $$new_props.infiniteDistance);
    		if ('infinitePreloader' in $$new_props) $$invalidate(8, infinitePreloader = $$new_props.infinitePreloader);
    		if ('hideBarsOnScroll' in $$new_props) $$invalidate(14, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
    		if ('hideNavbarOnScroll' in $$new_props) $$invalidate(15, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
    		if ('hideToolbarOnScroll' in $$new_props) $$invalidate(16, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
    		if ('messagesContent' in $$new_props) $$invalidate(17, messagesContent = $$new_props.messagesContent);
    		if ('loginScreen' in $$new_props) $$invalidate(18, loginScreen = $$new_props.loginScreen);
    		if ('class' in $$new_props) $$invalidate(19, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		createEventDispatcher,
    		restProps,
    		colorClasses,
    		classNames,
    		createEmitter,
    		app: app$1,
    		f7ready,
    		useTab,
    		Preloader,
    		emit,
    		tab,
    		tabActive,
    		ptr,
    		ptrDistance,
    		ptrPreloader,
    		ptrBottom,
    		ptrMousewheel,
    		infinite,
    		infiniteTop,
    		infiniteDistance,
    		infinitePreloader,
    		hideBarsOnScroll,
    		hideNavbarOnScroll,
    		hideToolbarOnScroll,
    		messagesContent,
    		loginScreen,
    		className,
    		pageContentEl,
    		onPtrPullStart,
    		onPtrPullMove,
    		onPtrPullEnd,
    		onPtrRefresh,
    		onPtrDone,
    		onInfinite,
    		mountPageContent,
    		destroyPageContent,
    		pageContentClasses
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
    		if ('tab' in $$props) $$invalidate(12, tab = $$new_props.tab);
    		if ('tabActive' in $$props) $$invalidate(13, tabActive = $$new_props.tabActive);
    		if ('ptr' in $$props) $$invalidate(0, ptr = $$new_props.ptr);
    		if ('ptrDistance' in $$props) $$invalidate(1, ptrDistance = $$new_props.ptrDistance);
    		if ('ptrPreloader' in $$props) $$invalidate(2, ptrPreloader = $$new_props.ptrPreloader);
    		if ('ptrBottom' in $$props) $$invalidate(3, ptrBottom = $$new_props.ptrBottom);
    		if ('ptrMousewheel' in $$props) $$invalidate(4, ptrMousewheel = $$new_props.ptrMousewheel);
    		if ('infinite' in $$props) $$invalidate(5, infinite = $$new_props.infinite);
    		if ('infiniteTop' in $$props) $$invalidate(6, infiniteTop = $$new_props.infiniteTop);
    		if ('infiniteDistance' in $$props) $$invalidate(7, infiniteDistance = $$new_props.infiniteDistance);
    		if ('infinitePreloader' in $$props) $$invalidate(8, infinitePreloader = $$new_props.infinitePreloader);
    		if ('hideBarsOnScroll' in $$props) $$invalidate(14, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
    		if ('hideNavbarOnScroll' in $$props) $$invalidate(15, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
    		if ('hideToolbarOnScroll' in $$props) $$invalidate(16, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
    		if ('messagesContent' in $$props) $$invalidate(17, messagesContent = $$new_props.messagesContent);
    		if ('loginScreen' in $$props) $$invalidate(18, loginScreen = $$new_props.loginScreen);
    		if ('className' in $$props) $$invalidate(19, className = $$new_props.className);
    		if ('pageContentEl' in $$props) $$invalidate(9, pageContentEl = $$new_props.pageContentEl);
    		if ('pageContentClasses' in $$props) $$invalidate(10, pageContentClasses = $$new_props.pageContentClasses);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(10, pageContentClasses = classNames(
    			className,
    			'page-content',
    			{
    				tab,
    				'tab-active': tabActive,
    				'ptr-content': ptr,
    				'ptr-bottom': ptrBottom,
    				'infinite-scroll-content': infinite,
    				'infinite-scroll-top': infiniteTop,
    				'hide-bars-on-scroll': hideBarsOnScroll,
    				'hide-navbar-on-scroll': hideNavbarOnScroll,
    				'hide-toolbar-on-scroll': hideToolbarOnScroll,
    				'messages-content': messagesContent,
    				'login-screen-content': loginScreen
    			},
    			colorClasses($$props)
    		));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		ptr,
    		ptrDistance,
    		ptrPreloader,
    		ptrBottom,
    		ptrMousewheel,
    		infinite,
    		infiniteTop,
    		infiniteDistance,
    		infinitePreloader,
    		pageContentEl,
    		pageContentClasses,
    		$$restProps,
    		tab,
    		tabActive,
    		hideBarsOnScroll,
    		hideNavbarOnScroll,
    		hideToolbarOnScroll,
    		messagesContent,
    		loginScreen,
    		className,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class Page_content extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$9,
    			create_fragment$b,
    			safe_not_equal,
    			{
    				tab: 12,
    				tabActive: 13,
    				ptr: 0,
    				ptrDistance: 1,
    				ptrPreloader: 2,
    				ptrBottom: 3,
    				ptrMousewheel: 4,
    				infinite: 5,
    				infiniteTop: 6,
    				infiniteDistance: 7,
    				infinitePreloader: 8,
    				hideBarsOnScroll: 14,
    				hideNavbarOnScroll: 15,
    				hideToolbarOnScroll: 16,
    				messagesContent: 17,
    				loginScreen: 18,
    				class: 19
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Page_content",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get tab() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tab(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabActive() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabActive(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptr() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptr(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrDistance() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrDistance(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrPreloader() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrPreloader(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrBottom() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrBottom(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrMousewheel() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrMousewheel(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infinite() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infinite(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infiniteTop() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infiniteTop(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infiniteDistance() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infiniteDistance(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infinitePreloader() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infinitePreloader(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideBarsOnScroll() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideBarsOnScroll(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideNavbarOnScroll() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideNavbarOnScroll(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideToolbarOnScroll() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideToolbarOnScroll(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get messagesContent() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set messagesContent(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loginScreen() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loginScreen(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/page.svelte generated by Svelte v3.44.0 */
    const file$9 = "node_modules/framework7-svelte/esm/svelte/page.svelte";
    const get_static_slot_changes_1 = dirty => ({});
    const get_static_slot_context_1 = ctx => ({});
    const get_static_slot_changes = dirty => ({});
    const get_static_slot_context = ctx => ({});
    const get_fixed_slot_changes = dirty => ({});
    const get_fixed_slot_context = ctx => ({});

    // (342:2) {:else}
    function create_else_block$3(ctx) {
    	let t;
    	let current;
    	const static_slot_template = /*#slots*/ ctx[46].static;
    	const static_slot = create_slot(static_slot_template, ctx, /*$$scope*/ ctx[48], get_static_slot_context_1);
    	const default_slot_template = /*#slots*/ ctx[46].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[48], null);

    	const block = {
    		c: function create() {
    			if (static_slot) static_slot.c();
    			t = space();
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (static_slot) {
    				static_slot.m(target, anchor);
    			}

    			insert_dev(target, t, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (static_slot) {
    				if (static_slot.p && (!current || dirty[1] & /*$$scope*/ 131072)) {
    					update_slot_base(
    						static_slot,
    						static_slot_template,
    						ctx,
    						/*$$scope*/ ctx[48],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[48])
    						: get_slot_changes(static_slot_template, /*$$scope*/ ctx[48], dirty, get_static_slot_changes_1),
    						get_static_slot_context_1
    					);
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[48],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[48])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[48], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(static_slot, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(static_slot, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (static_slot) static_slot.d(detaching);
    			if (detaching) detach_dev(t);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(342:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (316:2) {#if pageContent}
    function create_if_block$4(ctx) {
    	let pagecontent;
    	let current;

    	pagecontent = new Page_content({
    			props: {
    				ptr: /*ptr*/ ctx[2],
    				ptrDistance: /*ptrDistance*/ ctx[3],
    				ptrPreloader: /*ptrPreloader*/ ctx[4],
    				ptrBottom: /*ptrBottom*/ ctx[5],
    				ptrMousewheel: /*ptrMousewheel*/ ctx[6],
    				infinite: /*infinite*/ ctx[7],
    				infiniteTop: /*infiniteTop*/ ctx[8],
    				infiniteDistance: /*infiniteDistance*/ ctx[9],
    				infinitePreloader: /*infinitePreloader*/ ctx[10],
    				hideBarsOnScroll: /*hideBarsOnScroll*/ ctx[11],
    				hideNavbarOnScroll: /*hideNavbarOnScroll*/ ctx[12],
    				hideToolbarOnScroll: /*hideToolbarOnScroll*/ ctx[13],
    				messagesContent: /*messagesContent*/ ctx[14],
    				loginScreen: /*loginScreen*/ ctx[15],
    				onPtrPullStart: /*onPtrPullStart*/ ctx[18],
    				onPtrPullMove: /*onPtrPullMove*/ ctx[19],
    				onPtrPullEnd: /*onPtrPullEnd*/ ctx[20],
    				onPtrRefresh: /*onPtrRefresh*/ ctx[21],
    				onPtrDone: /*onPtrDone*/ ctx[22],
    				onInfinite: /*onInfinite*/ ctx[23],
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pagecontent.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagecontent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pagecontent_changes = {};
    			if (dirty[0] & /*ptr*/ 4) pagecontent_changes.ptr = /*ptr*/ ctx[2];
    			if (dirty[0] & /*ptrDistance*/ 8) pagecontent_changes.ptrDistance = /*ptrDistance*/ ctx[3];
    			if (dirty[0] & /*ptrPreloader*/ 16) pagecontent_changes.ptrPreloader = /*ptrPreloader*/ ctx[4];
    			if (dirty[0] & /*ptrBottom*/ 32) pagecontent_changes.ptrBottom = /*ptrBottom*/ ctx[5];
    			if (dirty[0] & /*ptrMousewheel*/ 64) pagecontent_changes.ptrMousewheel = /*ptrMousewheel*/ ctx[6];
    			if (dirty[0] & /*infinite*/ 128) pagecontent_changes.infinite = /*infinite*/ ctx[7];
    			if (dirty[0] & /*infiniteTop*/ 256) pagecontent_changes.infiniteTop = /*infiniteTop*/ ctx[8];
    			if (dirty[0] & /*infiniteDistance*/ 512) pagecontent_changes.infiniteDistance = /*infiniteDistance*/ ctx[9];
    			if (dirty[0] & /*infinitePreloader*/ 1024) pagecontent_changes.infinitePreloader = /*infinitePreloader*/ ctx[10];
    			if (dirty[0] & /*hideBarsOnScroll*/ 2048) pagecontent_changes.hideBarsOnScroll = /*hideBarsOnScroll*/ ctx[11];
    			if (dirty[0] & /*hideNavbarOnScroll*/ 4096) pagecontent_changes.hideNavbarOnScroll = /*hideNavbarOnScroll*/ ctx[12];
    			if (dirty[0] & /*hideToolbarOnScroll*/ 8192) pagecontent_changes.hideToolbarOnScroll = /*hideToolbarOnScroll*/ ctx[13];
    			if (dirty[0] & /*messagesContent*/ 16384) pagecontent_changes.messagesContent = /*messagesContent*/ ctx[14];
    			if (dirty[0] & /*loginScreen*/ 32768) pagecontent_changes.loginScreen = /*loginScreen*/ ctx[15];

    			if (dirty[1] & /*$$scope*/ 131072) {
    				pagecontent_changes.$$scope = { dirty, ctx };
    			}

    			pagecontent.$set(pagecontent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagecontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagecontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagecontent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(316:2) {#if pageContent}",
    		ctx
    	});

    	return block;
    }

    // (317:4) <PageContent       {ptr}       {ptrDistance}       {ptrPreloader}       {ptrBottom}       {ptrMousewheel}       {infinite}       {infiniteTop}       {infiniteDistance}       {infinitePreloader}       {hideBarsOnScroll}       {hideNavbarOnScroll}       {hideToolbarOnScroll}       {messagesContent}       {loginScreen}       {onPtrPullStart}       {onPtrPullMove}       {onPtrPullEnd}       {onPtrRefresh}       {onPtrDone}       {onInfinite}     >
    function create_default_slot$7(ctx) {
    	let t;
    	let current;
    	const static_slot_template = /*#slots*/ ctx[46].static;
    	const static_slot = create_slot(static_slot_template, ctx, /*$$scope*/ ctx[48], get_static_slot_context);
    	const default_slot_template = /*#slots*/ ctx[46].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[48], null);

    	const block = {
    		c: function create() {
    			if (static_slot) static_slot.c();
    			t = space();
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (static_slot) {
    				static_slot.m(target, anchor);
    			}

    			insert_dev(target, t, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (static_slot) {
    				if (static_slot.p && (!current || dirty[1] & /*$$scope*/ 131072)) {
    					update_slot_base(
    						static_slot,
    						static_slot_template,
    						ctx,
    						/*$$scope*/ ctx[48],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[48])
    						: get_slot_changes(static_slot_template, /*$$scope*/ ctx[48], dirty, get_static_slot_changes),
    						get_static_slot_context
    					);
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[48],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[48])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[48], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(static_slot, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(static_slot, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (static_slot) static_slot.d(detaching);
    			if (detaching) detach_dev(t);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(317:4) <PageContent       {ptr}       {ptrDistance}       {ptrPreloader}       {ptrBottom}       {ptrMousewheel}       {infinite}       {infiniteTop}       {infiniteDistance}       {infinitePreloader}       {hideBarsOnScroll}       {hideNavbarOnScroll}       {hideToolbarOnScroll}       {messagesContent}       {loginScreen}       {onPtrPullStart}       {onPtrPullMove}       {onPtrPullEnd}       {onPtrRefresh}       {onPtrDone}       {onInfinite}     >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const fixed_slot_template = /*#slots*/ ctx[46].fixed;
    	const fixed_slot = create_slot(fixed_slot_template, ctx, /*$$scope*/ ctx[48], get_fixed_slot_context);
    	const if_block_creators = [create_if_block$4, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*pageContent*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	let div_levels = [
    		{ class: /*classes*/ ctx[17] },
    		{ "data-name": /*name*/ ctx[0] },
    		restProps(/*$$restProps*/ ctx[24])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (fixed_slot) fixed_slot.c();
    			t = space();
    			if_block.c();
    			set_attributes(div, div_data);
    			add_location(div, file$9, 313, 0, 9751);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (fixed_slot) {
    				fixed_slot.m(div, null);
    			}

    			append_dev(div, t);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding*/ ctx[47](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (fixed_slot) {
    				if (fixed_slot.p && (!current || dirty[1] & /*$$scope*/ 131072)) {
    					update_slot_base(
    						fixed_slot,
    						fixed_slot_template,
    						ctx,
    						/*$$scope*/ ctx[48],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[48])
    						: get_slot_changes(fixed_slot_template, /*$$scope*/ ctx[48], dirty, get_fixed_slot_changes),
    						get_fixed_slot_context
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty[0] & /*classes*/ 131072) && { class: /*classes*/ ctx[17] },
    				(!current || dirty[0] & /*name*/ 1) && { "data-name": /*name*/ ctx[0] },
    				dirty[0] & /*$$restProps*/ 16777216 && restProps(/*$$restProps*/ ctx[24])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fixed_slot, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fixed_slot, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (fixed_slot) fixed_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			/*div_binding*/ ctx[47](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let forceSubnavbar;
    	let forceNavbarLarge;
    	let classes;

    	const omit_props_names = [
    		"name","stacked","withSubnavbar","subnavbar","withNavbarLarge","navbarLarge","noNavbar","noToolbar","tabs","pageContent","noSwipeback","ptr","ptrDistance","ptrPreloader","ptrBottom","ptrMousewheel","infinite","infiniteTop","infiniteDistance","infinitePreloader","hideBarsOnScroll","hideNavbarOnScroll","hideToolbarOnScroll","messagesContent","loginScreen","class"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Page', slots, ['fixed','static','default']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { name = undefined } = $$props;
    	let { stacked = undefined } = $$props;
    	let { withSubnavbar = undefined } = $$props;
    	let { subnavbar = undefined } = $$props;
    	let { withNavbarLarge = undefined } = $$props;
    	let { navbarLarge = undefined } = $$props;
    	let { noNavbar = undefined } = $$props;
    	let { noToolbar = undefined } = $$props;
    	let { tabs = undefined } = $$props;
    	let { pageContent = true } = $$props;
    	let { noSwipeback = undefined } = $$props;
    	let { ptr = undefined } = $$props;
    	let { ptrDistance = undefined } = $$props;
    	let { ptrPreloader = true } = $$props;
    	let { ptrBottom = undefined } = $$props;
    	let { ptrMousewheel = undefined } = $$props;
    	let { infinite = undefined } = $$props;
    	let { infiniteTop = undefined } = $$props;
    	let { infiniteDistance = undefined } = $$props;
    	let { infinitePreloader = true } = $$props;
    	let { hideBarsOnScroll = undefined } = $$props;
    	let { hideNavbarOnScroll = undefined } = $$props;
    	let { hideToolbarOnScroll = undefined } = $$props;
    	let { messagesContent = undefined } = $$props;
    	let { loginScreen = undefined } = $$props;
    	let { class: className = undefined } = $$props;

    	// State
    	let el;

    	let hasSubnavbar = false;
    	let hasNavbarLarge = false;
    	let hasNavbarLargeCollapsed = false;
    	let hasCardExpandableOpened = false;
    	let routerPositionClass = '';
    	let routerForceUnstack = false;
    	let routerPageRole = null;
    	let routerPageRoleDetailRoot = false;
    	let routerPageMasterStack = false;

    	// Handlers
    	function onPtrPullStart() {
    		emit('ptrPullStart');
    	}

    	function onPtrPullMove() {
    		emit('ptrPullMove');
    	}

    	function onPtrPullEnd() {
    		emit('ptrPullEnd');
    	}

    	function onPtrRefresh(done) {
    		emit('ptrRefresh', [done]);
    	}

    	function onPtrDone() {
    		emit('ptrDone');
    	}

    	function onInfinite() {
    		emit('infinite');
    	}

    	// Main Page Events
    	function onPageMounted(page) {
    		if (el !== page.el) return;
    		emit('pageMounted', [page]);
    	}

    	function onPageInit(page) {
    		if (el !== page.el) return;

    		if (typeof withSubnavbar === 'undefined' && typeof subnavbar === 'undefined') {
    			if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find('.subnavbar').length || page.$el.children('.navbar').find('.subnavbar').length) {
    				$$invalidate(35, hasSubnavbar = true);
    			}
    		}

    		if (typeof withNavbarLarge === 'undefined' && typeof navbarLarge === 'undefined') {
    			if (page.$navbarEl && page.$navbarEl.hasClass('navbar-large') || page.$el.children('.navbar-large').length) {
    				$$invalidate(36, hasNavbarLarge = true);
    			}
    		}

    		emit('pageInit', [page]);
    	}

    	function onPageReinit(page) {
    		if (el !== page.el) return;
    		emit('pageReinit', [page]);
    	}

    	function onPageBeforeIn(page) {
    		if (el !== page.el) return;

    		if (!page.swipeBack) {
    			if (page.from === 'next') {
    				$$invalidate(39, routerPositionClass = 'page-next');
    			}

    			if (page.from === 'previous') {
    				$$invalidate(39, routerPositionClass = 'page-previous');
    			}
    		}

    		emit('pageBeforeIn', [page]);
    	}

    	function onPageBeforeOut(page) {
    		if (el !== page.el) return;
    		emit('pageBeforeOut', [page]);
    	}

    	function onPageAfterOut(page) {
    		if (el !== page.el) return;

    		if (page.to === 'next') {
    			$$invalidate(39, routerPositionClass = 'page-next');
    		}

    		if (page.to === 'previous') {
    			$$invalidate(39, routerPositionClass = 'page-previous');
    		}

    		emit('pageAfterOut', [page]);
    	}

    	function onPageAfterIn(page) {
    		if (el !== page.el) return;
    		$$invalidate(39, routerPositionClass = 'page-current');
    		emit('pageAfterIn', [page]);
    	}

    	function onPageBeforeRemove(page) {
    		if (el !== page.el) return;

    		if (page.$navbarEl && page.$navbarEl[0] && page.$navbarEl.parent()[0] && page.$navbarEl.parent()[0] !== el) {
    			page.$el.prepend(page.$navbarEl);
    		}

    		emit('pageBeforeRemove', [page]);
    	}

    	function onPageBeforeUnmount(page) {
    		if (el !== page.el) return;
    		emit('pageBeforeUnmount', [page]);
    	}

    	// Helper events
    	function onPageStack(pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(40, routerForceUnstack = false);
    	}

    	function onPageUnstack(pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(40, routerForceUnstack = true);
    	}

    	function onPagePosition(pageEl, position) {
    		if (el !== pageEl) return;
    		$$invalidate(39, routerPositionClass = `page-${position}`);
    	}

    	function onPageRole(pageEl, rolesData) {
    		if (el !== pageEl) return;
    		$$invalidate(41, routerPageRole = rolesData.role);
    		$$invalidate(42, routerPageRoleDetailRoot = rolesData.detailRoot);
    	}

    	function onPageMasterStack(pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(43, routerPageMasterStack = true);
    	}

    	function onPageMasterUnstack(pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(43, routerPageMasterStack = false);
    	}

    	function onPageNavbarLargeCollapsed(pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(37, hasNavbarLargeCollapsed = true);
    	}

    	function onPageNavbarLargeExpanded(pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(37, hasNavbarLargeCollapsed = false);
    	}

    	function onCardOpened(cardEl, pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(38, hasCardExpandableOpened = true);
    	}

    	function onCardClose(cardEl, pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(38, hasCardExpandableOpened = false);
    	}

    	function onPageTabShow(pageEl) {
    		if (el !== pageEl) return;
    		emit('pageTabShow');
    	}

    	function onPageTabHide(pageEl) {
    		if (el !== pageEl) return;
    		emit('pageTabHide');
    	}

    	// Mount/destroy
    	function mountPage() {
    		app$1.f7.on('pageMounted', onPageMounted);
    		app$1.f7.on('pageInit', onPageInit);
    		app$1.f7.on('pageReinit', onPageReinit);
    		app$1.f7.on('pageBeforeIn', onPageBeforeIn);
    		app$1.f7.on('pageBeforeOut', onPageBeforeOut);
    		app$1.f7.on('pageAfterOut', onPageAfterOut);
    		app$1.f7.on('pageAfterIn', onPageAfterIn);
    		app$1.f7.on('pageBeforeRemove', onPageBeforeRemove);
    		app$1.f7.on('pageBeforeUnmount', onPageBeforeUnmount);
    		app$1.f7.on('pageStack', onPageStack);
    		app$1.f7.on('pageUnstack', onPageUnstack);
    		app$1.f7.on('pagePosition', onPagePosition);
    		app$1.f7.on('pageRole', onPageRole);
    		app$1.f7.on('pageMasterStack', onPageMasterStack);
    		app$1.f7.on('pageMasterUnstack', onPageMasterUnstack);
    		app$1.f7.on('pageNavbarLargeCollapsed', onPageNavbarLargeCollapsed);
    		app$1.f7.on('pageNavbarLargeExpanded', onPageNavbarLargeExpanded);
    		app$1.f7.on('cardOpened', onCardOpened);
    		app$1.f7.on('cardClose', onCardClose);
    		app$1.f7.on('pageTabShow', onPageTabShow);
    		app$1.f7.on('pageTabHide', onPageTabHide);
    	}

    	function destroyPage() {
    		app$1.f7.off('pageMounted', onPageMounted);
    		app$1.f7.off('pageInit', onPageInit);
    		app$1.f7.off('pageReinit', onPageReinit);
    		app$1.f7.off('pageBeforeIn', onPageBeforeIn);
    		app$1.f7.off('pageBeforeOut', onPageBeforeOut);
    		app$1.f7.off('pageAfterOut', onPageAfterOut);
    		app$1.f7.off('pageAfterIn', onPageAfterIn);
    		app$1.f7.off('pageBeforeRemove', onPageBeforeRemove);
    		app$1.f7.off('pageBeforeUnmount', onPageBeforeUnmount);
    		app$1.f7.off('pageStack', onPageStack);
    		app$1.f7.off('pageUnstack', onPageUnstack);
    		app$1.f7.off('pagePosition', onPagePosition);
    		app$1.f7.off('pageRole', onPageRole);
    		app$1.f7.off('pageMasterStack', onPageMasterStack);
    		app$1.f7.off('pageMasterUnstack', onPageMasterUnstack);
    		app$1.f7.off('pageNavbarLargeCollapsed', onPageNavbarLargeCollapsed);
    		app$1.f7.off('pageNavbarLargeExpanded', onPageNavbarLargeExpanded);
    		app$1.f7.off('cardOpened', onCardOpened);
    		app$1.f7.off('cardClose', onCardClose);
    		app$1.f7.off('pageTabShow', onPageTabShow);
    		app$1.f7.off('pageTabHide', onPageTabHide);
    	}

    	onMount(() => {
    		f7ready(() => {
    			if (el) {
    				const dom7 = app$1.f7.$;
    				const fixedEls = dom7(el).children('.page-content').children('[data-f7-slot="fixed"]');

    				if (fixedEls.length) {
    					for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
    						dom7(el).prepend(fixedEls[i]);
    					}
    				}
    			}

    			mountPage();
    		});
    	});

    	afterUpdate(() => {
    		if (el && app$1.f7) {
    			const dom7 = app$1.f7.$;
    			const fixedEls = dom7(el).children('.page-content').children('[data-f7-slot="fixed"]');

    			if (fixedEls.length) {
    				for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
    					dom7(el).prepend(fixedEls[i]);
    				}
    			}
    		}
    	});

    	onDestroy(() => {
    		if (!app$1.f7) return;
    		destroyPage();
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(16, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(73, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('name' in $$new_props) $$invalidate(0, name = $$new_props.name);
    		if ('stacked' in $$new_props) $$invalidate(25, stacked = $$new_props.stacked);
    		if ('withSubnavbar' in $$new_props) $$invalidate(26, withSubnavbar = $$new_props.withSubnavbar);
    		if ('subnavbar' in $$new_props) $$invalidate(27, subnavbar = $$new_props.subnavbar);
    		if ('withNavbarLarge' in $$new_props) $$invalidate(28, withNavbarLarge = $$new_props.withNavbarLarge);
    		if ('navbarLarge' in $$new_props) $$invalidate(29, navbarLarge = $$new_props.navbarLarge);
    		if ('noNavbar' in $$new_props) $$invalidate(30, noNavbar = $$new_props.noNavbar);
    		if ('noToolbar' in $$new_props) $$invalidate(31, noToolbar = $$new_props.noToolbar);
    		if ('tabs' in $$new_props) $$invalidate(32, tabs = $$new_props.tabs);
    		if ('pageContent' in $$new_props) $$invalidate(1, pageContent = $$new_props.pageContent);
    		if ('noSwipeback' in $$new_props) $$invalidate(33, noSwipeback = $$new_props.noSwipeback);
    		if ('ptr' in $$new_props) $$invalidate(2, ptr = $$new_props.ptr);
    		if ('ptrDistance' in $$new_props) $$invalidate(3, ptrDistance = $$new_props.ptrDistance);
    		if ('ptrPreloader' in $$new_props) $$invalidate(4, ptrPreloader = $$new_props.ptrPreloader);
    		if ('ptrBottom' in $$new_props) $$invalidate(5, ptrBottom = $$new_props.ptrBottom);
    		if ('ptrMousewheel' in $$new_props) $$invalidate(6, ptrMousewheel = $$new_props.ptrMousewheel);
    		if ('infinite' in $$new_props) $$invalidate(7, infinite = $$new_props.infinite);
    		if ('infiniteTop' in $$new_props) $$invalidate(8, infiniteTop = $$new_props.infiniteTop);
    		if ('infiniteDistance' in $$new_props) $$invalidate(9, infiniteDistance = $$new_props.infiniteDistance);
    		if ('infinitePreloader' in $$new_props) $$invalidate(10, infinitePreloader = $$new_props.infinitePreloader);
    		if ('hideBarsOnScroll' in $$new_props) $$invalidate(11, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
    		if ('hideNavbarOnScroll' in $$new_props) $$invalidate(12, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
    		if ('hideToolbarOnScroll' in $$new_props) $$invalidate(13, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
    		if ('messagesContent' in $$new_props) $$invalidate(14, messagesContent = $$new_props.messagesContent);
    		if ('loginScreen' in $$new_props) $$invalidate(15, loginScreen = $$new_props.loginScreen);
    		if ('class' in $$new_props) $$invalidate(34, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(48, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		afterUpdate,
    		onDestroy,
    		createEventDispatcher,
    		restProps,
    		colorClasses,
    		classNames,
    		createEmitter,
    		app: app$1,
    		f7ready,
    		PageContent: Page_content,
    		emit,
    		name,
    		stacked,
    		withSubnavbar,
    		subnavbar,
    		withNavbarLarge,
    		navbarLarge,
    		noNavbar,
    		noToolbar,
    		tabs,
    		pageContent,
    		noSwipeback,
    		ptr,
    		ptrDistance,
    		ptrPreloader,
    		ptrBottom,
    		ptrMousewheel,
    		infinite,
    		infiniteTop,
    		infiniteDistance,
    		infinitePreloader,
    		hideBarsOnScroll,
    		hideNavbarOnScroll,
    		hideToolbarOnScroll,
    		messagesContent,
    		loginScreen,
    		className,
    		el,
    		hasSubnavbar,
    		hasNavbarLarge,
    		hasNavbarLargeCollapsed,
    		hasCardExpandableOpened,
    		routerPositionClass,
    		routerForceUnstack,
    		routerPageRole,
    		routerPageRoleDetailRoot,
    		routerPageMasterStack,
    		onPtrPullStart,
    		onPtrPullMove,
    		onPtrPullEnd,
    		onPtrRefresh,
    		onPtrDone,
    		onInfinite,
    		onPageMounted,
    		onPageInit,
    		onPageReinit,
    		onPageBeforeIn,
    		onPageBeforeOut,
    		onPageAfterOut,
    		onPageAfterIn,
    		onPageBeforeRemove,
    		onPageBeforeUnmount,
    		onPageStack,
    		onPageUnstack,
    		onPagePosition,
    		onPageRole,
    		onPageMasterStack,
    		onPageMasterUnstack,
    		onPageNavbarLargeCollapsed,
    		onPageNavbarLargeExpanded,
    		onCardOpened,
    		onCardClose,
    		onPageTabShow,
    		onPageTabHide,
    		mountPage,
    		destroyPage,
    		forceNavbarLarge,
    		forceSubnavbar,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(73, $$props = assign(assign({}, $$props), $$new_props));
    		if ('name' in $$props) $$invalidate(0, name = $$new_props.name);
    		if ('stacked' in $$props) $$invalidate(25, stacked = $$new_props.stacked);
    		if ('withSubnavbar' in $$props) $$invalidate(26, withSubnavbar = $$new_props.withSubnavbar);
    		if ('subnavbar' in $$props) $$invalidate(27, subnavbar = $$new_props.subnavbar);
    		if ('withNavbarLarge' in $$props) $$invalidate(28, withNavbarLarge = $$new_props.withNavbarLarge);
    		if ('navbarLarge' in $$props) $$invalidate(29, navbarLarge = $$new_props.navbarLarge);
    		if ('noNavbar' in $$props) $$invalidate(30, noNavbar = $$new_props.noNavbar);
    		if ('noToolbar' in $$props) $$invalidate(31, noToolbar = $$new_props.noToolbar);
    		if ('tabs' in $$props) $$invalidate(32, tabs = $$new_props.tabs);
    		if ('pageContent' in $$props) $$invalidate(1, pageContent = $$new_props.pageContent);
    		if ('noSwipeback' in $$props) $$invalidate(33, noSwipeback = $$new_props.noSwipeback);
    		if ('ptr' in $$props) $$invalidate(2, ptr = $$new_props.ptr);
    		if ('ptrDistance' in $$props) $$invalidate(3, ptrDistance = $$new_props.ptrDistance);
    		if ('ptrPreloader' in $$props) $$invalidate(4, ptrPreloader = $$new_props.ptrPreloader);
    		if ('ptrBottom' in $$props) $$invalidate(5, ptrBottom = $$new_props.ptrBottom);
    		if ('ptrMousewheel' in $$props) $$invalidate(6, ptrMousewheel = $$new_props.ptrMousewheel);
    		if ('infinite' in $$props) $$invalidate(7, infinite = $$new_props.infinite);
    		if ('infiniteTop' in $$props) $$invalidate(8, infiniteTop = $$new_props.infiniteTop);
    		if ('infiniteDistance' in $$props) $$invalidate(9, infiniteDistance = $$new_props.infiniteDistance);
    		if ('infinitePreloader' in $$props) $$invalidate(10, infinitePreloader = $$new_props.infinitePreloader);
    		if ('hideBarsOnScroll' in $$props) $$invalidate(11, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
    		if ('hideNavbarOnScroll' in $$props) $$invalidate(12, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
    		if ('hideToolbarOnScroll' in $$props) $$invalidate(13, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
    		if ('messagesContent' in $$props) $$invalidate(14, messagesContent = $$new_props.messagesContent);
    		if ('loginScreen' in $$props) $$invalidate(15, loginScreen = $$new_props.loginScreen);
    		if ('className' in $$props) $$invalidate(34, className = $$new_props.className);
    		if ('el' in $$props) $$invalidate(16, el = $$new_props.el);
    		if ('hasSubnavbar' in $$props) $$invalidate(35, hasSubnavbar = $$new_props.hasSubnavbar);
    		if ('hasNavbarLarge' in $$props) $$invalidate(36, hasNavbarLarge = $$new_props.hasNavbarLarge);
    		if ('hasNavbarLargeCollapsed' in $$props) $$invalidate(37, hasNavbarLargeCollapsed = $$new_props.hasNavbarLargeCollapsed);
    		if ('hasCardExpandableOpened' in $$props) $$invalidate(38, hasCardExpandableOpened = $$new_props.hasCardExpandableOpened);
    		if ('routerPositionClass' in $$props) $$invalidate(39, routerPositionClass = $$new_props.routerPositionClass);
    		if ('routerForceUnstack' in $$props) $$invalidate(40, routerForceUnstack = $$new_props.routerForceUnstack);
    		if ('routerPageRole' in $$props) $$invalidate(41, routerPageRole = $$new_props.routerPageRole);
    		if ('routerPageRoleDetailRoot' in $$props) $$invalidate(42, routerPageRoleDetailRoot = $$new_props.routerPageRoleDetailRoot);
    		if ('routerPageMasterStack' in $$props) $$invalidate(43, routerPageMasterStack = $$new_props.routerPageMasterStack);
    		if ('forceNavbarLarge' in $$props) $$invalidate(44, forceNavbarLarge = $$new_props.forceNavbarLarge);
    		if ('forceSubnavbar' in $$props) $$invalidate(45, forceSubnavbar = $$new_props.forceSubnavbar);
    		if ('classes' in $$props) $$invalidate(17, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*subnavbar, withSubnavbar*/ 201326592 | $$self.$$.dirty[1] & /*hasSubnavbar*/ 16) {
    			$$invalidate(45, forceSubnavbar = typeof subnavbar === 'undefined' && typeof withSubnavbar === 'undefined'
    			? hasSubnavbar
    			: false);
    		}

    		if ($$self.$$.dirty[0] & /*navbarLarge, withNavbarLarge*/ 805306368 | $$self.$$.dirty[1] & /*hasNavbarLarge*/ 32) {
    			$$invalidate(44, forceNavbarLarge = typeof navbarLarge === 'undefined' && typeof withNavbarLarge === 'undefined'
    			? hasNavbarLarge
    			: false);
    		}

    		$$invalidate(17, classes = classNames(
    			className,
    			'page',
    			routerPositionClass,
    			{
    				stacked: stacked && !routerForceUnstack,
    				tabs,
    				'page-with-subnavbar': subnavbar || withSubnavbar || forceSubnavbar,
    				'page-with-navbar-large': navbarLarge || withNavbarLarge || forceNavbarLarge,
    				'no-navbar': noNavbar,
    				'no-toolbar': noToolbar,
    				'no-swipeback': noSwipeback,
    				'page-master': routerPageRole === 'master',
    				'page-master-detail': routerPageRole === 'detail',
    				'page-master-detail-root': routerPageRoleDetailRoot === true,
    				'page-master-stacked': routerPageMasterStack === true,
    				'page-with-navbar-large-collapsed': hasNavbarLargeCollapsed === true,
    				'page-with-card-opened': hasCardExpandableOpened === true,
    				'login-screen-page': loginScreen
    			},
    			colorClasses($$props)
    		));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		name,
    		pageContent,
    		ptr,
    		ptrDistance,
    		ptrPreloader,
    		ptrBottom,
    		ptrMousewheel,
    		infinite,
    		infiniteTop,
    		infiniteDistance,
    		infinitePreloader,
    		hideBarsOnScroll,
    		hideNavbarOnScroll,
    		hideToolbarOnScroll,
    		messagesContent,
    		loginScreen,
    		el,
    		classes,
    		onPtrPullStart,
    		onPtrPullMove,
    		onPtrPullEnd,
    		onPtrRefresh,
    		onPtrDone,
    		onInfinite,
    		$$restProps,
    		stacked,
    		withSubnavbar,
    		subnavbar,
    		withNavbarLarge,
    		navbarLarge,
    		noNavbar,
    		noToolbar,
    		tabs,
    		noSwipeback,
    		className,
    		hasSubnavbar,
    		hasNavbarLarge,
    		hasNavbarLargeCollapsed,
    		hasCardExpandableOpened,
    		routerPositionClass,
    		routerForceUnstack,
    		routerPageRole,
    		routerPageRoleDetailRoot,
    		routerPageMasterStack,
    		forceNavbarLarge,
    		forceSubnavbar,
    		slots,
    		div_binding,
    		$$scope
    	];
    }

    class Page extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$8,
    			create_fragment$a,
    			safe_not_equal,
    			{
    				name: 0,
    				stacked: 25,
    				withSubnavbar: 26,
    				subnavbar: 27,
    				withNavbarLarge: 28,
    				navbarLarge: 29,
    				noNavbar: 30,
    				noToolbar: 31,
    				tabs: 32,
    				pageContent: 1,
    				noSwipeback: 33,
    				ptr: 2,
    				ptrDistance: 3,
    				ptrPreloader: 4,
    				ptrBottom: 5,
    				ptrMousewheel: 6,
    				infinite: 7,
    				infiniteTop: 8,
    				infiniteDistance: 9,
    				infinitePreloader: 10,
    				hideBarsOnScroll: 11,
    				hideNavbarOnScroll: 12,
    				hideToolbarOnScroll: 13,
    				messagesContent: 14,
    				loginScreen: 15,
    				class: 34
    			},
    			null,
    			[-1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Page",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get name() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stacked() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stacked(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withSubnavbar() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withSubnavbar(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subnavbar() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subnavbar(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withNavbarLarge() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withNavbarLarge(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get navbarLarge() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set navbarLarge(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noNavbar() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noNavbar(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noToolbar() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noToolbar(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabs() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabs(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pageContent() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pageContent(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noSwipeback() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noSwipeback(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptr() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptr(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrDistance() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrDistance(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrPreloader() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrPreloader(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrBottom() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrBottom(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrMousewheel() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrMousewheel(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infinite() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infinite(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infiniteTop() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infiniteTop(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infiniteDistance() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infiniteDistance(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infinitePreloader() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infinitePreloader(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideBarsOnScroll() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideBarsOnScroll(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideNavbarOnScroll() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideNavbarOnScroll(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideToolbarOnScroll() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideToolbarOnScroll(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get messagesContent() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set messagesContent(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loginScreen() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loginScreen(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/popup.svelte generated by Svelte v3.44.0 */
    const file$8 = "node_modules/framework7-svelte/esm/svelte/popup.svelte";
    const get_default_slot_changes$1 = dirty => ({ popup: dirty[0] & /*f7Popup*/ 2 });
    const get_default_slot_context$1 = ctx => ({ popup: /*f7Popup*/ ctx[1] });

    function create_fragment$9(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[18].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], get_default_slot_context$1);
    	let div_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$8, 137, 0, 3622);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[19](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope, f7Popup*/ 131074)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, get_default_slot_changes$1),
    						get_default_slot_context$1
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty[0] & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
    				dirty[0] & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[19](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance_1$1($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","tabletFullscreen","opened","animate","backdrop","backdropEl","closeByBackdropClick","closeOnEscape","swipeToClose","swipeHandler","push","containerEl","instance"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Popup', slots, ['default']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { tabletFullscreen = undefined } = $$props;
    	let { opened = undefined } = $$props;
    	let { animate = undefined } = $$props;
    	let { backdrop = undefined } = $$props;
    	let { backdropEl = undefined } = $$props;
    	let { closeByBackdropClick = undefined } = $$props;
    	let { closeOnEscape = undefined } = $$props;
    	let { swipeToClose = false } = $$props;
    	let { swipeHandler = undefined } = $$props;
    	let { push = undefined } = $$props;
    	let { containerEl = undefined } = $$props;
    	let el;
    	let f7Popup;
    	const state = { isOpened: opened, isClosing: false };

    	function instance() {
    		return f7Popup;
    	}

    	function onSwipeStart(instance) {
    		emit('popupSwipeStart', [instance]);
    	}

    	function onSwipeMove(instance) {
    		emit('popupSwipeMove', [instance]);
    	}

    	function onSwipeEnd(instance) {
    		emit('popupSwipeEnd', [instance]);
    	}

    	function onSwipeClose(instance) {
    		emit('popupSwipeClose', [instance]);
    	}

    	function onOpen(instance) {
    		Object.assign(state, { isOpened: true, isClosing: false });
    		emit('popupOpen', [instance]);
    		$$invalidate(4, opened = true);
    	}

    	function onOpened(instance) {
    		emit('popupOpened', [instance]);
    	}

    	function onClose(instance) {
    		Object.assign(state, { isOpened: false, isClosing: true });
    		emit('popupClose', [instance]);
    	}

    	function onClosed(instance) {
    		Object.assign(state, { isClosing: false });
    		emit('popupClosed', [instance]);
    		$$invalidate(4, opened = false);
    	}

    	let initialWatched = false;

    	function watchOpened(openedPassed) {
    		if (!initialWatched) {
    			initialWatched = true;
    			return;
    		}

    		if (!f7Popup) return;
    		if (openedPassed) f7Popup.open(); else f7Popup.close();
    	}

    	onMount(() => {
    		const popupParams = {
    			el,
    			on: {
    				swipeStart: onSwipeStart,
    				swipeMove: onSwipeMove,
    				swipeEnd: onSwipeEnd,
    				swipeClose: onSwipeClose,
    				open: onOpen,
    				opened: onOpened,
    				close: onClose,
    				closed: onClosed
    			}
    		};

    		if (typeof closeByBackdropClick !== 'undefined') popupParams.closeByBackdropClick = closeByBackdropClick;
    		if (typeof closeOnEscape !== 'undefined') popupParams.closeOnEscape = closeOnEscape;
    		if (typeof animate !== 'undefined') popupParams.animate = animate;
    		if (typeof backdrop !== 'undefined') popupParams.backdrop = backdrop;
    		if (typeof backdropEl !== 'undefined') popupParams.backdropEl = backdropEl;
    		if (typeof swipeToClose !== 'undefined') popupParams.swipeToClose = swipeToClose;
    		if (typeof swipeHandler !== 'undefined') popupParams.swipeHandler = swipeHandler;
    		if (typeof containerEl !== 'undefined') popupParams.containerEl = containerEl;

    		f7ready(() => {
    			$$invalidate(1, f7Popup = app$1.f7.popup.create(popupParams));

    			if (opened) {
    				f7Popup.open(false);
    			}
    		});
    	});

    	onDestroy(() => {
    		if (f7Popup) f7Popup.destroy();
    		$$invalidate(1, f7Popup = null);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(0, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
    		if ('tabletFullscreen' in $$new_props) $$invalidate(6, tabletFullscreen = $$new_props.tabletFullscreen);
    		if ('opened' in $$new_props) $$invalidate(4, opened = $$new_props.opened);
    		if ('animate' in $$new_props) $$invalidate(7, animate = $$new_props.animate);
    		if ('backdrop' in $$new_props) $$invalidate(8, backdrop = $$new_props.backdrop);
    		if ('backdropEl' in $$new_props) $$invalidate(9, backdropEl = $$new_props.backdropEl);
    		if ('closeByBackdropClick' in $$new_props) $$invalidate(10, closeByBackdropClick = $$new_props.closeByBackdropClick);
    		if ('closeOnEscape' in $$new_props) $$invalidate(11, closeOnEscape = $$new_props.closeOnEscape);
    		if ('swipeToClose' in $$new_props) $$invalidate(12, swipeToClose = $$new_props.swipeToClose);
    		if ('swipeHandler' in $$new_props) $$invalidate(13, swipeHandler = $$new_props.swipeHandler);
    		if ('push' in $$new_props) $$invalidate(14, push = $$new_props.push);
    		if ('containerEl' in $$new_props) $$invalidate(15, containerEl = $$new_props.containerEl);
    		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		colorClasses,
    		classNames,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		modalStateClasses,
    		emit,
    		className,
    		tabletFullscreen,
    		opened,
    		animate,
    		backdrop,
    		backdropEl,
    		closeByBackdropClick,
    		closeOnEscape,
    		swipeToClose,
    		swipeHandler,
    		push,
    		containerEl,
    		el,
    		f7Popup,
    		state,
    		instance,
    		onSwipeStart,
    		onSwipeMove,
    		onSwipeEnd,
    		onSwipeClose,
    		onOpen,
    		onOpened,
    		onClose,
    		onClosed,
    		initialWatched,
    		watchOpened,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(5, className = $$new_props.className);
    		if ('tabletFullscreen' in $$props) $$invalidate(6, tabletFullscreen = $$new_props.tabletFullscreen);
    		if ('opened' in $$props) $$invalidate(4, opened = $$new_props.opened);
    		if ('animate' in $$props) $$invalidate(7, animate = $$new_props.animate);
    		if ('backdrop' in $$props) $$invalidate(8, backdrop = $$new_props.backdrop);
    		if ('backdropEl' in $$props) $$invalidate(9, backdropEl = $$new_props.backdropEl);
    		if ('closeByBackdropClick' in $$props) $$invalidate(10, closeByBackdropClick = $$new_props.closeByBackdropClick);
    		if ('closeOnEscape' in $$props) $$invalidate(11, closeOnEscape = $$new_props.closeOnEscape);
    		if ('swipeToClose' in $$props) $$invalidate(12, swipeToClose = $$new_props.swipeToClose);
    		if ('swipeHandler' in $$props) $$invalidate(13, swipeHandler = $$new_props.swipeHandler);
    		if ('push' in $$props) $$invalidate(14, push = $$new_props.push);
    		if ('containerEl' in $$props) $$invalidate(15, containerEl = $$new_props.containerEl);
    		if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
    		if ('f7Popup' in $$props) $$invalidate(1, f7Popup = $$new_props.f7Popup);
    		if ('initialWatched' in $$props) initialWatched = $$new_props.initialWatched;
    		if ('classes' in $$props) $$invalidate(2, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(2, classes = classNames(
    			className,
    			'popup',
    			{
    				'popup-tablet-fullscreen': tabletFullscreen,
    				'popup-push': push
    			},
    			modalStateClasses(state),
    			colorClasses($$props)
    		));

    		if ($$self.$$.dirty[0] & /*opened*/ 16) {
    			watchOpened(opened);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		el,
    		f7Popup,
    		classes,
    		$$restProps,
    		opened,
    		className,
    		tabletFullscreen,
    		animate,
    		backdrop,
    		backdropEl,
    		closeByBackdropClick,
    		closeOnEscape,
    		swipeToClose,
    		swipeHandler,
    		push,
    		containerEl,
    		instance,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class Popup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance_1$1,
    			create_fragment$9,
    			safe_not_equal,
    			{
    				class: 5,
    				tabletFullscreen: 6,
    				opened: 4,
    				animate: 7,
    				backdrop: 8,
    				backdropEl: 9,
    				closeByBackdropClick: 10,
    				closeOnEscape: 11,
    				swipeToClose: 12,
    				swipeHandler: 13,
    				push: 14,
    				containerEl: 15,
    				instance: 16
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Popup",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get class() {
    		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabletFullscreen() {
    		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabletFullscreen(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opened() {
    		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opened(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get animate() {
    		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set animate(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backdrop() {
    		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backdrop(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backdropEl() {
    		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backdropEl(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeByBackdropClick() {
    		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeByBackdropClick(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeOnEscape() {
    		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeOnEscape(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get swipeToClose() {
    		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set swipeToClose(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get swipeHandler() {
    		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set swipeHandler(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get push() {
    		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set push(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get containerEl() {
    		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set containerEl(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get instance() {
    		return this.$$.ctx[16];
    	}

    	set instance(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/router-context-provider.svelte generated by Svelte v3.44.0 */

    function create_fragment$8(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Router_context_provider', slots, ['default']);
    	let { route = undefined } = $$props;
    	let { router = undefined } = $$props;
    	setContext('RouterContext', { route, router });
    	const writable_props = ['route', 'router'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Router_context_provider> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('route' in $$props) $$invalidate(0, route = $$props.route);
    		if ('router' in $$props) $$invalidate(1, router = $$props.router);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ setContext, route, router });

    	$$self.$inject_state = $$props => {
    		if ('route' in $$props) $$invalidate(0, route = $$props.route);
    		if ('router' in $$props) $$invalidate(1, router = $$props.router);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [route, router, $$scope, slots];
    }

    class Router_context_provider extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$8, safe_not_equal, { route: 0, router: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router_context_provider",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get route() {
    		throw new Error("<Router_context_provider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set route(value) {
    		throw new Error("<Router_context_provider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get router() {
    		throw new Error("<Router_context_provider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set router(value) {
    		throw new Error("<Router_context_provider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/toolbar.svelte generated by Svelte v3.44.0 */
    const file$7 = "node_modules/framework7-svelte/esm/svelte/toolbar.svelte";
    const get_after_inner_slot_changes = dirty => ({});
    const get_after_inner_slot_context = ctx => ({});
    const get_before_inner_slot_changes = dirty => ({});
    const get_before_inner_slot_context = ctx => ({});

    // (106:2) {:else}
    function create_else_block$2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[24].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[23],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[23], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(106:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (102:2) {#if inner}
    function create_if_block$3(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[24].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "toolbar-inner");
    			add_location(div, file$7, 102, 4, 2741);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[23],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[23], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(102:2) {#if inner}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div;
    	let t0;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let current;
    	const before_inner_slot_template = /*#slots*/ ctx[24]["before-inner"];
    	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[23], get_before_inner_slot_context);
    	const if_block_creators = [create_if_block$3, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*inner*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const after_inner_slot_template = /*#slots*/ ctx[24]["after-inner"];
    	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[23], get_after_inner_slot_context);

    	let div_levels = [
    		{ class: /*classes*/ ctx[3] },
    		{ "data-f7-slot": /*f7Slot*/ ctx[1] },
    		restProps(/*$$restProps*/ ctx[4])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (before_inner_slot) before_inner_slot.c();
    			t0 = space();
    			if_block.c();
    			t1 = space();
    			if (after_inner_slot) after_inner_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$7, 99, 0, 2605);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (before_inner_slot) {
    				before_inner_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if_blocks[current_block_type_index].m(div, null);
    			append_dev(div, t1);

    			if (after_inner_slot) {
    				after_inner_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[25](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (before_inner_slot) {
    				if (before_inner_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						before_inner_slot,
    						before_inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[23],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
    						: get_slot_changes(before_inner_slot_template, /*$$scope*/ ctx[23], dirty, get_before_inner_slot_changes),
    						get_before_inner_slot_context
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, t1);
    			}

    			if (after_inner_slot) {
    				if (after_inner_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						after_inner_slot,
    						after_inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[23],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
    						: get_slot_changes(after_inner_slot_template, /*$$scope*/ ctx[23], dirty, get_after_inner_slot_changes),
    						get_after_inner_slot_context
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
    				(!current || dirty & /*f7Slot*/ 2) && { "data-f7-slot": /*f7Slot*/ ctx[1] },
    				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_inner_slot, local);
    			transition_in(if_block);
    			transition_in(after_inner_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_inner_slot, local);
    			transition_out(if_block);
    			transition_out(after_inner_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (before_inner_slot) before_inner_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (after_inner_slot) after_inner_slot.d(detaching);
    			/*div_binding*/ ctx[25](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","tabbar","labels","scrollable","hidden","noShadow","noHairline","noBorder","position","topMd","topIos","topAurora","top","bottomMd","bottomIos","bottomAurora","bottom","inner","f7Slot"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Toolbar', slots, ['before-inner','default','after-inner']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { tabbar = false } = $$props;
    	let { labels = false } = $$props;
    	let { scrollable = false } = $$props;
    	let { hidden = false } = $$props;
    	let { noShadow = false } = $$props;
    	let { noHairline = false } = $$props;
    	let { noBorder = false } = $$props;
    	let { position = undefined } = $$props;
    	let { topMd = undefined } = $$props;
    	let { topIos = undefined } = $$props;
    	let { topAurora = undefined } = $$props;
    	let { top = undefined } = $$props;
    	let { bottomMd = undefined } = $$props;
    	let { bottomIos = undefined } = $$props;
    	let { bottomAurora = undefined } = $$props;
    	let { bottom = undefined } = $$props;
    	let { inner = true } = $$props;
    	let { f7Slot = 'fixed' } = $$props;
    	let el;

    	let theme = useTheme(t => {
    		$$invalidate(22, theme = t);
    	});

    	setReactiveContext('TabbarContext', () => ({ tabbarHasLabels: labels }));

    	function onShow(toolbarEl) {
    		if (el !== toolbarEl) return;
    		emit('toolbarShow');
    	}

    	function onHide(toolbarEl) {
    		if (el !== toolbarEl) return;
    		emit('toolbarHide');
    	}

    	onMount(() => {
    		f7ready(() => {
    			if (tabbar) app$1.f7.toolbar.setHighlight(el);
    			app$1.f7.on('toolbarShow', onShow);
    			app$1.f7.on('toolbarHide', onHide);
    		});
    	});

    	afterUpdate(() => {
    		if (tabbar && app$1.f7 && el) {
    			app$1.f7.toolbar.setHighlight(el);
    		}
    	});

    	onDestroy(() => {
    		if (!app$1.f7) return;
    		app$1.f7.off('toolbarShow', onShow);
    		app$1.f7.off('toolbarHide', onHide);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(2, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
    		if ('tabbar' in $$new_props) $$invalidate(6, tabbar = $$new_props.tabbar);
    		if ('labels' in $$new_props) $$invalidate(7, labels = $$new_props.labels);
    		if ('scrollable' in $$new_props) $$invalidate(8, scrollable = $$new_props.scrollable);
    		if ('hidden' in $$new_props) $$invalidate(9, hidden = $$new_props.hidden);
    		if ('noShadow' in $$new_props) $$invalidate(10, noShadow = $$new_props.noShadow);
    		if ('noHairline' in $$new_props) $$invalidate(11, noHairline = $$new_props.noHairline);
    		if ('noBorder' in $$new_props) $$invalidate(12, noBorder = $$new_props.noBorder);
    		if ('position' in $$new_props) $$invalidate(13, position = $$new_props.position);
    		if ('topMd' in $$new_props) $$invalidate(14, topMd = $$new_props.topMd);
    		if ('topIos' in $$new_props) $$invalidate(15, topIos = $$new_props.topIos);
    		if ('topAurora' in $$new_props) $$invalidate(16, topAurora = $$new_props.topAurora);
    		if ('top' in $$new_props) $$invalidate(17, top = $$new_props.top);
    		if ('bottomMd' in $$new_props) $$invalidate(18, bottomMd = $$new_props.bottomMd);
    		if ('bottomIos' in $$new_props) $$invalidate(19, bottomIos = $$new_props.bottomIos);
    		if ('bottomAurora' in $$new_props) $$invalidate(20, bottomAurora = $$new_props.bottomAurora);
    		if ('bottom' in $$new_props) $$invalidate(21, bottom = $$new_props.bottom);
    		if ('inner' in $$new_props) $$invalidate(0, inner = $$new_props.inner);
    		if ('f7Slot' in $$new_props) $$invalidate(1, f7Slot = $$new_props.f7Slot);
    		if ('$$scope' in $$new_props) $$invalidate(23, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		afterUpdate,
    		colorClasses,
    		classNames,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		useTheme,
    		setReactiveContext,
    		emit,
    		className,
    		tabbar,
    		labels,
    		scrollable,
    		hidden,
    		noShadow,
    		noHairline,
    		noBorder,
    		position,
    		topMd,
    		topIos,
    		topAurora,
    		top,
    		bottomMd,
    		bottomIos,
    		bottomAurora,
    		bottom,
    		inner,
    		f7Slot,
    		el,
    		theme,
    		onShow,
    		onHide,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(29, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(5, className = $$new_props.className);
    		if ('tabbar' in $$props) $$invalidate(6, tabbar = $$new_props.tabbar);
    		if ('labels' in $$props) $$invalidate(7, labels = $$new_props.labels);
    		if ('scrollable' in $$props) $$invalidate(8, scrollable = $$new_props.scrollable);
    		if ('hidden' in $$props) $$invalidate(9, hidden = $$new_props.hidden);
    		if ('noShadow' in $$props) $$invalidate(10, noShadow = $$new_props.noShadow);
    		if ('noHairline' in $$props) $$invalidate(11, noHairline = $$new_props.noHairline);
    		if ('noBorder' in $$props) $$invalidate(12, noBorder = $$new_props.noBorder);
    		if ('position' in $$props) $$invalidate(13, position = $$new_props.position);
    		if ('topMd' in $$props) $$invalidate(14, topMd = $$new_props.topMd);
    		if ('topIos' in $$props) $$invalidate(15, topIos = $$new_props.topIos);
    		if ('topAurora' in $$props) $$invalidate(16, topAurora = $$new_props.topAurora);
    		if ('top' in $$props) $$invalidate(17, top = $$new_props.top);
    		if ('bottomMd' in $$props) $$invalidate(18, bottomMd = $$new_props.bottomMd);
    		if ('bottomIos' in $$props) $$invalidate(19, bottomIos = $$new_props.bottomIos);
    		if ('bottomAurora' in $$props) $$invalidate(20, bottomAurora = $$new_props.bottomAurora);
    		if ('bottom' in $$props) $$invalidate(21, bottom = $$new_props.bottom);
    		if ('inner' in $$props) $$invalidate(0, inner = $$new_props.inner);
    		if ('f7Slot' in $$props) $$invalidate(1, f7Slot = $$new_props.f7Slot);
    		if ('el' in $$props) $$invalidate(2, el = $$new_props.el);
    		if ('theme' in $$props) $$invalidate(22, theme = $$new_props.theme);
    		if ('classes' in $$props) $$invalidate(3, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(3, classes = classNames(
    			className,
    			'toolbar',
    			{
    				tabbar,
    				'toolbar-bottom': theme && theme.md && bottomMd || theme && theme.ios && bottomIos || theme && theme.aurora && bottomAurora || bottom || position === 'bottom',
    				'toolbar-top': theme && theme.md && topMd || theme && theme.ios && topIos || theme && theme.aurora && topAurora || top || position === 'top',
    				'tabbar-labels': labels,
    				'tabbar-scrollable': scrollable,
    				'toolbar-hidden': hidden,
    				'no-shadow': noShadow,
    				'no-hairline': noHairline || noBorder
    			},
    			colorClasses($$props)
    		));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		inner,
    		f7Slot,
    		el,
    		classes,
    		$$restProps,
    		className,
    		tabbar,
    		labels,
    		scrollable,
    		hidden,
    		noShadow,
    		noHairline,
    		noBorder,
    		position,
    		topMd,
    		topIos,
    		topAurora,
    		top,
    		bottomMd,
    		bottomIos,
    		bottomAurora,
    		bottom,
    		theme,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class Toolbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$6, create_fragment$7, safe_not_equal, {
    			class: 5,
    			tabbar: 6,
    			labels: 7,
    			scrollable: 8,
    			hidden: 9,
    			noShadow: 10,
    			noHairline: 11,
    			noBorder: 12,
    			position: 13,
    			topMd: 14,
    			topIos: 15,
    			topAurora: 16,
    			top: 17,
    			bottomMd: 18,
    			bottomIos: 19,
    			bottomAurora: 20,
    			bottom: 21,
    			inner: 0,
    			f7Slot: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Toolbar",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get class() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabbar() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabbar(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labels() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labels(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollable() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollable(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hidden() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hidden(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noShadow() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noShadow(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairline() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairline(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noBorder() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noBorder(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get position() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get topMd() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set topMd(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get topIos() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set topIos(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get topAurora() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set topAurora(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get top() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set top(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bottomMd() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bottomMd(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bottomIos() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bottomIos(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bottomAurora() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bottomAurora(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bottom() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bottom(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inner() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inner(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get f7Slot() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set f7Slot(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
    var getRouterInitialComponent = function getRouterInitialComponent(router, initialComponent) {
      var initialComponentData;

      var _router$getInitialUrl = router.getInitialUrl(),
          initialUrl = _router$getInitialUrl.initialUrl;

      var initialRoute = router.findMatchingRoute(initialUrl);
      var routeProps = {};

      if (initialRoute && initialRoute.route && initialRoute.route.options) {
        routeProps = initialRoute.route.options.props;
      }

      var isMasterRoute = function isMasterRoute(route) {
        if (route.master === true) return true;
        if (typeof route.master === 'function') return route.master(router.app);
        return false;
      };

      if (initialRoute && initialRoute.route && (initialRoute.route.component || initialRoute.route.asyncComponent) && !isMasterRoute(initialRoute.route)) {
        initialComponentData = {
          component: initialRoute.route.component || initialRoute.route.asyncComponent,
          initialComponent: initialComponent,
          id: getComponentId(),
          isAsync: !!initialRoute.route.asyncComponent,
          props: _extends({
            f7route: initialRoute,
            f7router: router
          }, initialRoute.params, routeProps)
        };
      }

      return {
        initialPage: initialComponentData,
        initialRoute: initialRoute
      };
    };

    /* node_modules/framework7-svelte/esm/svelte/view.svelte generated by Svelte v3.44.0 */
    const file$6 = "node_modules/framework7-svelte/esm/svelte/view.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[29] = list[i];
    	return child_ctx;
    }

    const get_default_slot_changes = dirty => ({ view: dirty[0] & /*f7View*/ 8 });
    const get_default_slot_context = ctx => ({ view: /*f7View*/ ctx[3] });

    // (194:4) <RouterContextProvider route={page.props.f7route} router={page.props.f7router}>
    function create_default_slot$6(ctx) {
    	let switch_instance;
    	let t;
    	let current;
    	const switch_instance_spread_levels = [/*page*/ ctx[29].props];
    	var switch_value = /*page*/ ctx[29].component;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty[0] & /*pages*/ 16)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*page*/ ctx[29].props)])
    			: {};

    			if (switch_value !== (switch_value = /*page*/ ctx[29].component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, t.parentNode, t);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (switch_instance) destroy_component(switch_instance, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(194:4) <RouterContextProvider route={page.props.f7route} router={page.props.f7router}>",
    		ctx
    	});

    	return block;
    }

    // (193:2) {#each pages as page (page.id)}
    function create_each_block$1(key_1, ctx) {
    	let first;
    	let routercontextprovider;
    	let current;

    	routercontextprovider = new Router_context_provider({
    			props: {
    				route: /*page*/ ctx[29].props.f7route,
    				router: /*page*/ ctx[29].props.f7router,
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(routercontextprovider.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(routercontextprovider, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const routercontextprovider_changes = {};
    			if (dirty[0] & /*pages*/ 16) routercontextprovider_changes.route = /*page*/ ctx[29].props.f7route;
    			if (dirty[0] & /*pages*/ 16) routercontextprovider_changes.router = /*page*/ ctx[29].props.f7router;

    			if (dirty[0] & /*$$scope, pages*/ 4112) {
    				routercontextprovider_changes.$$scope = { dirty, ctx };
    			}

    			routercontextprovider.$set(routercontextprovider_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(routercontextprovider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(routercontextprovider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(routercontextprovider, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(193:2) {#each pages as page (page.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let div;
    	let t;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context);
    	let each_value = /*pages*/ ctx[4];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*page*/ ctx[29].id;
    	validate_each_keys(ctx, each_value, get_each_context$1, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$1(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", /*classes*/ ctx[5]);
    			attr_dev(div, "style", /*style*/ ctx[1]);
    			attr_dev(div, "id", /*id*/ ctx[0]);
    			add_location(div, file$6, 190, 0, 5403);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			/*div_binding*/ ctx[11](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope, f7View*/ 4104)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[12],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			}

    			if (dirty[0] & /*pages*/ 16) {
    				each_value = /*pages*/ ctx[4];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$1, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$1, null, get_each_context$1);
    				check_outros();
    			}

    			if (!current || dirty[0] & /*classes*/ 32) {
    				attr_dev(div, "class", /*classes*/ ctx[5]);
    			}

    			if (!current || dirty[0] & /*style*/ 2) {
    				attr_dev(div, "style", /*style*/ ctx[1]);
    			}

    			if (!current || dirty[0] & /*id*/ 1) {
    				attr_dev(div, "id", /*id*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*div_binding*/ ctx[11](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance_1($$self, $$props, $$invalidate) {
    	let classes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('View', slots, ['default']);
    	let { id = undefined } = $$props;
    	let { style = undefined } = $$props;
    	let { init = true } = $$props;
    	let { url = undefined } = $$props;
    	let { class: className = undefined } = $$props;
    	const emit = createEmitter(createEventDispatcher, $$props);
    	const { main, tab, tabActive, browserHistoryInitialMatch = true } = $$props;
    	let initialPage;
    	let initialRoute;
    	let el;
    	let routerData;
    	let f7View;

    	function instance() {
    		return f7View;
    	}

    	function onViewInit(view) {
    		emit('viewInit', [view]);

    		if (!init) {
    			$$invalidate(3, f7View = view);
    			routerData.instance = view;
    		}
    	}

    	if (app$1.f7 && !f7View && init) {
    		const routerId = getRouterId();

    		f7View = app$1.f7.views.create(el, {
    			routerId,
    			init: false,
    			...noUndefinedProps($$props),
    			browserHistoryInitialMatch,
    			on: { init: onViewInit }
    		});

    		routerData = { routerId, instance: f7View };
    		app$1.f7routers.views.push(routerData);

    		if (f7View && f7View.router && (url || main)) {
    			const initialData = getRouterInitialComponent(f7View.router);
    			initialPage = initialData.initialPage;
    			initialRoute = initialData.initialRoute;

    			if (initialRoute && initialRoute.route && initialRoute.route.masterRoute) {
    				initialPage = undefined;
    				initialRoute = undefined;
    			}
    		}
    	}

    	let pages = initialPage ? [initialPage] : [];

    	function onResize(view, width) {
    		emit('viewResize', [width]);
    	}

    	function onSwipeBackMove(data) {
    		emit('swipeBackMove', [data]);
    	}

    	function onSwipeBackBeforeChange(data) {
    		emit('swipeBackBeforeChange', [data]);
    	}

    	function onSwipeBackAfterChange(data) {
    		emit('swipeBackAfterChange', [data]);
    	}

    	function onSwipeBackBeforeReset(data) {
    		emit('swipeBackBeforeReset', [data]);
    	}

    	function onSwipeBackAfterReset(data) {
    		emit('swipeBackAfterReset', [data]);
    	}

    	useTab(() => el, emit);

    	onMount(() => {
    		f7ready(() => {
    			if (f7View) {
    				routerData.el = el;
    				routerData.pages = pages;

    				routerData.setPages = newPages => {
    					tick().then(() => {
    						$$invalidate(4, pages = newPages);
    					});
    				};

    				if (initialPage && initialPage.isAsync && !initialPage.initialComponent) {
    					initialPage.component().then(() => {
    						setTimeout(
    							() => {
    								f7View.init(el);

    								if (initialPage) {
    									initialPage.el = f7View.router.currentPageEl;

    									if (initialRoute && initialRoute.route && initialRoute.route.keepAlive) {
    										initialRoute.route.keepAliveData = { pageEl: initialPage.el };
    									}
    								}
    							},
    							100
    						);
    					});
    				} else {
    					f7View.init(el);

    					if (initialPage) {
    						initialPage.el = f7View.router.currentPageEl;

    						if (initialRoute && initialRoute.route && initialRoute.route.keepAlive) {
    							initialRoute.route.keepAliveData = { pageEl: initialPage.el };
    						}
    					}
    				}
    			} else {
    				const routerId = getRouterId();

    				routerData = {
    					el,
    					routerId,
    					pages,
    					instance: f7View,
    					setPages(newPages) {
    						tick().then(() => {
    							$$invalidate(4, pages = newPages);
    						});
    					}
    				};

    				app$1.f7routers.views.push(routerData);

    				routerData.instance = app$1.f7.views.create(el, {
    					routerId,
    					...noUndefinedProps($$props),
    					browserHistoryInitialMatch,
    					on: { init: onViewInit }
    				});

    				$$invalidate(3, f7View = routerData.instance);
    			}

    			if (!init) return;
    			f7View.on('resize', onResize);
    			f7View.on('swipebackMove', onSwipeBackMove);
    			f7View.on('swipebackBeforeChange', onSwipeBackBeforeChange);
    			f7View.on('swipebackAfterChange', onSwipeBackAfterChange);
    			f7View.on('swipebackBeforeReset', onSwipeBackBeforeReset);
    			f7View.on('swipebackAfterReset', onSwipeBackAfterReset);
    		});
    	});

    	afterUpdate(() => {
    		if (!routerData) return;
    		app$1.f7events.emit('viewRouterDidUpdate', routerData);
    	});

    	onDestroy(() => {
    		if (f7View) {
    			f7View.off('resize', onResize);
    			f7View.off('swipebackMove', onSwipeBackMove);
    			f7View.off('swipebackBeforeChange', onSwipeBackBeforeChange);
    			f7View.off('swipebackAfterChange', onSwipeBackAfterChange);
    			f7View.off('swipebackBeforeReset', onSwipeBackBeforeReset);
    			f7View.off('swipebackAfterReset', onSwipeBackAfterReset);
    			if (f7View.destroy) f7View.destroy();
    			$$invalidate(3, f7View = null);
    		}

    		app$1.f7routers.views.splice(app$1.f7routers.views.indexOf(routerData), 1);
    		routerData = null;
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(2, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(28, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('id' in $$new_props) $$invalidate(0, id = $$new_props.id);
    		if ('style' in $$new_props) $$invalidate(1, style = $$new_props.style);
    		if ('init' in $$new_props) $$invalidate(6, init = $$new_props.init);
    		if ('url' in $$new_props) $$invalidate(7, url = $$new_props.url);
    		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		afterUpdate,
    		createEventDispatcher,
    		tick,
    		app: app$1,
    		f7ready,
    		colorClasses,
    		classNames,
    		noUndefinedProps,
    		createEmitter,
    		getRouterId,
    		getRouterInitialComponent,
    		useTab,
    		RouterContextProvider: Router_context_provider,
    		id,
    		style,
    		init,
    		url,
    		className,
    		emit,
    		main,
    		tab,
    		tabActive,
    		browserHistoryInitialMatch,
    		initialPage,
    		initialRoute,
    		el,
    		routerData,
    		f7View,
    		instance,
    		onViewInit,
    		pages,
    		onResize,
    		onSwipeBackMove,
    		onSwipeBackBeforeChange,
    		onSwipeBackAfterChange,
    		onSwipeBackBeforeReset,
    		onSwipeBackAfterReset,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(28, $$props = assign(assign({}, $$props), $$new_props));
    		if ('id' in $$props) $$invalidate(0, id = $$new_props.id);
    		if ('style' in $$props) $$invalidate(1, style = $$new_props.style);
    		if ('init' in $$props) $$invalidate(6, init = $$new_props.init);
    		if ('url' in $$props) $$invalidate(7, url = $$new_props.url);
    		if ('className' in $$props) $$invalidate(8, className = $$new_props.className);
    		if ('initialPage' in $$props) initialPage = $$new_props.initialPage;
    		if ('initialRoute' in $$props) initialRoute = $$new_props.initialRoute;
    		if ('el' in $$props) $$invalidate(2, el = $$new_props.el);
    		if ('routerData' in $$props) routerData = $$new_props.routerData;
    		if ('f7View' in $$props) $$invalidate(3, f7View = $$new_props.f7View);
    		if ('pages' in $$props) $$invalidate(4, pages = $$new_props.pages);
    		if ('classes' in $$props) $$invalidate(5, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(5, classes = classNames(
    			className,
    			'view',
    			{
    				'view-main': main,
    				'tab-active': tabActive,
    				tab
    			},
    			colorClasses($$props)
    		));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		id,
    		style,
    		el,
    		f7View,
    		pages,
    		classes,
    		init,
    		url,
    		className,
    		instance,
    		slots,
    		div_binding,
    		$$scope
    	];
    }

    class View extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance_1,
    			create_fragment$6,
    			safe_not_equal,
    			{
    				id: 0,
    				style: 1,
    				init: 6,
    				url: 7,
    				class: 8,
    				instance: 9
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "View",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get id() {
    		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get init() {
    		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set init(value) {
    		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get instance() {
    		return this.$$.ctx[9];
    	}

    	set instance(value) {
    		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    const text = writable('Testo prova');

    window.setText = (t) => {
        text.set(t);
    };

    /* src/pages/NowPlaying.svelte generated by Svelte v3.44.0 */
    const file$5 = "src/pages/NowPlaying.svelte";

    // (38:12) {#if !isSpeaker}
    function create_if_block_2(ctx) {
    	let div;
    	let a;
    	let i;

    	const block = {
    		c: function create() {
    			div = element("div");
    			a = element("a");
    			i = element("i");
    			i.textContent = "expand_more";
    			attr_dev(i, "class", "icon material-icons");
    			attr_dev(i, "style", "");
    			add_location(i, file$5, 44, 25, 1377);
    			attr_dev(a, "class", "link icon-only popup-close");
    			attr_dev(a, "href", "#");
    			attr_dev(a, "iconmd", "material:expand_more");
    			add_location(a, file$5, 40, 20, 1203);
    			attr_dev(div, "class", "left");
    			add_location(div, file$5, 38, 16, 1098);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, a);
    			append_dev(a, i);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(38:12) {#if !isSpeaker}",
    		ctx
    	});

    	return block;
    }

    // (52:8) {#if isSpeaker}
    function create_if_block_1$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_style(div, "flex", "4");
    			add_location(div, file$5, 52, 12, 1587);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(52:8) {#if isSpeaker}",
    		ctx
    	});

    	return block;
    }

    // (77:20) {#if !isSpeaker}
    function create_if_block$2(ctx) {
    	let div0;
    	let a0;
    	let i0;
    	let t1;
    	let div1;
    	let a1;
    	let i1;
    	let t3;
    	let div2;
    	let a2;
    	let i2;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			a0 = element("a");
    			i0 = element("i");
    			i0.textContent = "skip_previous";
    			t1 = space();
    			div1 = element("div");
    			a1 = element("a");
    			i1 = element("i");
    			i1.textContent = "play_arrow";
    			t3 = space();
    			div2 = element("div");
    			a2 = element("a");
    			i2 = element("i");
    			i2.textContent = "skip_next";
    			attr_dev(i0, "class", "icon material-icons");
    			attr_dev(i0, "style", "");
    			add_location(i0, file$5, 80, 32, 2724);
    			add_location(a0, file$5, 79, 28, 2688);
    			attr_dev(div0, "class", "fab svelte-116kwuu");
    			add_location(div0, file$5, 77, 24, 2568);
    			attr_dev(i1, "class", "icon material-icons");
    			attr_dev(i1, "style", "");
    			add_location(i1, file$5, 88, 32, 3113);
    			attr_dev(a1, "class", "fab-play svelte-116kwuu");
    			add_location(a1, file$5, 87, 28, 3060);
    			attr_dev(div1, "class", "fab svelte-116kwuu");
    			add_location(div1, file$5, 85, 24, 2940);
    			attr_dev(i2, "class", "icon material-icons");
    			attr_dev(i2, "style", "");
    			add_location(i2, file$5, 96, 32, 3482);
    			add_location(a2, file$5, 95, 28, 3446);
    			attr_dev(div2, "class", "fab svelte-116kwuu");
    			add_location(div2, file$5, 93, 24, 3326);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, a0);
    			append_dev(a0, i0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, a1);
    			append_dev(a1, i1);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, a2);
    			append_dev(a2, i2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(77:20) {#if !isSpeaker}",
    		ctx
    	});

    	return block;
    }

    // (34:0) <Page>
    function create_default_slot$5(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div16;
    	let t2;
    	let div3;
    	let img;
    	let img_src_value;
    	let t3;
    	let div14;
    	let div13;
    	let div5;
    	let div4;
    	let t4;
    	let t5;
    	let div7;
    	let div6;
    	let t6;
    	let t7;
    	let div8;
    	let range;
    	let t8;
    	let div11;
    	let div9;
    	let t9;
    	let t10;
    	let div10;
    	let t11;
    	let t12;
    	let div12;
    	let t13;
    	let div15;
    	let current;
    	let if_block0 = !/*isSpeaker*/ ctx[5] && create_if_block_2(ctx);
    	let if_block1 = /*isSpeaker*/ ctx[5] && create_if_block_1$1(ctx);

    	range = new Range({
    			props: {
    				min: 0,
    				max: 100,
    				step: 0.1,
    				value: /*currentValue*/ ctx[3] * 100 / /*songDuration*/ ctx[4]
    			},
    			$$inline: true
    		});

    	let if_block2 = !/*isSpeaker*/ ctx[5] && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			div16 = element("div");
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div3 = element("div");
    			img = element("img");
    			t3 = space();
    			div14 = element("div");
    			div13 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			t4 = text$1(/*title*/ ctx[1]);
    			t5 = space();
    			div7 = element("div");
    			div6 = element("div");
    			t6 = text$1(/*artist*/ ctx[2]);
    			t7 = space();
    			div8 = element("div");
    			create_component(range.$$.fragment);
    			t8 = space();
    			div11 = element("div");
    			div9 = element("div");
    			t9 = text$1(/*leftTime*/ ctx[6]);
    			t10 = space();
    			div10 = element("div");
    			t11 = text$1(/*rightTime*/ ctx[7]);
    			t12 = space();
    			div12 = element("div");
    			if (if_block2) if_block2.c();
    			t13 = space();
    			div15 = element("div");
    			attr_dev(div0, "class", "navbar-bg svelte-116kwuu");
    			add_location(div0, file$5, 35, 8, 984);
    			attr_dev(div1, "class", "navbar-inner sliding");
    			add_location(div1, file$5, 36, 8, 1018);
    			attr_dev(div2, "class", "navbar");
    			attr_dev(div2, "data-f7-slot", "fixed");
    			add_location(div2, file$5, 34, 4, 934);
    			attr_dev(img, "alt", "Album");
    			if (!src_url_equal(img.src, img_src_value = /*imageUrl*/ ctx[0])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "svelte-116kwuu");
    			add_location(img, file$5, 55, 12, 1674);
    			attr_dev(div3, "class", "player-img svelte-116kwuu");
    			add_location(div3, file$5, 54, 8, 1637);
    			attr_dev(div4, "class", "song-title svelte-116kwuu");
    			add_location(div4, file$5, 63, 20, 1902);
    			attr_dev(div5, "class", "row-flex svelte-116kwuu");
    			add_location(div5, file$5, 62, 16, 1859);
    			attr_dev(div6, "class", "song-subtitle svelte-116kwuu");
    			add_location(div6, file$5, 66, 20, 2022);
    			attr_dev(div7, "class", "row-flex svelte-116kwuu");
    			add_location(div7, file$5, 65, 16, 1979);
    			attr_dev(div8, "class", "row-flex music-slider svelte-116kwuu");
    			add_location(div8, file$5, 68, 16, 2103);
    			set_style(div9, "margin-left", "17%");
    			add_location(div9, file$5, 72, 20, 2327);
    			set_style(div10, "margin-right", "17%");
    			add_location(div10, file$5, 73, 20, 2395);
    			attr_dev(div11, "class", "row-flex row-time svelte-116kwuu");
    			add_location(div11, file$5, 71, 16, 2275);
    			attr_dev(div12, "class", "row-flex svelte-116kwuu");
    			add_location(div12, file$5, 75, 16, 2484);
    			attr_dev(div13, "class", "column-flex svelte-116kwuu");
    			add_location(div13, file$5, 61, 12, 1817);
    			attr_dev(div14, "class", "player-buttons svelte-116kwuu");
    			add_location(div14, file$5, 60, 8, 1776);
    			attr_dev(div15, "class", "player-bottom svelte-116kwuu");
    			add_location(div15, file$5, 105, 8, 3761);
    			attr_dev(div16, "class", "player svelte-116kwuu");
    			add_location(div16, file$5, 50, 4, 1530);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			if (if_block0) if_block0.m(div1, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div16, anchor);
    			if (if_block1) if_block1.m(div16, null);
    			append_dev(div16, t2);
    			append_dev(div16, div3);
    			append_dev(div3, img);
    			append_dev(div16, t3);
    			append_dev(div16, div14);
    			append_dev(div14, div13);
    			append_dev(div13, div5);
    			append_dev(div5, div4);
    			append_dev(div4, t4);
    			append_dev(div13, t5);
    			append_dev(div13, div7);
    			append_dev(div7, div6);
    			append_dev(div6, t6);
    			append_dev(div13, t7);
    			append_dev(div13, div8);
    			mount_component(range, div8, null);
    			append_dev(div13, t8);
    			append_dev(div13, div11);
    			append_dev(div11, div9);
    			append_dev(div9, t9);
    			append_dev(div11, t10);
    			append_dev(div11, div10);
    			append_dev(div10, t11);
    			append_dev(div13, t12);
    			append_dev(div13, div12);
    			if (if_block2) if_block2.m(div12, null);
    			append_dev(div16, t13);
    			append_dev(div16, div15);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*isSpeaker*/ ctx[5]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_2(ctx);
    					if_block0.c();
    					if_block0.m(div1, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*isSpeaker*/ ctx[5]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_1$1(ctx);
    					if_block1.c();
    					if_block1.m(div16, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty & /*imageUrl*/ 1 && !src_url_equal(img.src, img_src_value = /*imageUrl*/ ctx[0])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty & /*title*/ 2) set_data_dev(t4, /*title*/ ctx[1]);
    			if (!current || dirty & /*artist*/ 4) set_data_dev(t6, /*artist*/ ctx[2]);
    			const range_changes = {};
    			if (dirty & /*currentValue, songDuration*/ 24) range_changes.value = /*currentValue*/ ctx[3] * 100 / /*songDuration*/ ctx[4];
    			range.$set(range_changes);
    			if (!current || dirty & /*leftTime*/ 64) set_data_dev(t9, /*leftTime*/ ctx[6]);
    			if (!current || dirty & /*rightTime*/ 128) set_data_dev(t11, /*rightTime*/ ctx[7]);

    			if (!/*isSpeaker*/ ctx[5]) {
    				if (if_block2) ; else {
    					if_block2 = create_if_block$2(ctx);
    					if_block2.c();
    					if_block2.m(div12, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(range.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(range.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div16);
    			if (if_block1) if_block1.d();
    			destroy_component(range);
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(34:0) <Page>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let page;
    	let current;

    	page = new Page({
    			props: {
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(page.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(page, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const page_changes = {};

    			if (dirty & /*$$scope, isSpeaker, rightTime, leftTime, currentValue, songDuration, artist, title, imageUrl*/ 511) {
    				page_changes.$$scope = { dirty, ctx };
    			}

    			page.$set(page_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(page.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(page.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(page, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function n(n) {
    	return n > 9 ? "" + n : "0" + n;
    }

    function getMinutesSecondsLeft(currentValue) {
    	let minutes = n(Math.floor(currentValue / 60));
    	let seconds = n(Math.floor(currentValue % 60));
    	return minutes + ":" + seconds;
    }

    function getMinutesSecondsRight(currentValue, songDuration) {
    	let minutes = n(Math.floor((songDuration - currentValue) / 60));
    	let seconds = n(Math.floor((songDuration - currentValue) % 60));
    	return "-" + minutes + ":" + seconds;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NowPlaying', slots, []);
    	let { imageUrl } = $$props;
    	let { title } = $$props;
    	let { artist } = $$props;
    	let { currentValue } = $$props;
    	let { songDuration } = $$props;
    	let { isSpeaker = false } = $$props;
    	let leftTime;
    	let rightTime;
    	const writable_props = ['imageUrl', 'title', 'artist', 'currentValue', 'songDuration', 'isSpeaker'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NowPlaying> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('imageUrl' in $$props) $$invalidate(0, imageUrl = $$props.imageUrl);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('artist' in $$props) $$invalidate(2, artist = $$props.artist);
    		if ('currentValue' in $$props) $$invalidate(3, currentValue = $$props.currentValue);
    		if ('songDuration' in $$props) $$invalidate(4, songDuration = $$props.songDuration);
    		if ('isSpeaker' in $$props) $$invalidate(5, isSpeaker = $$props.isSpeaker);
    	};

    	$$self.$capture_state = () => ({
    		Page,
    		Range,
    		imageUrl,
    		title,
    		artist,
    		currentValue,
    		songDuration,
    		isSpeaker,
    		leftTime,
    		rightTime,
    		n,
    		getMinutesSecondsLeft,
    		getMinutesSecondsRight
    	});

    	$$self.$inject_state = $$props => {
    		if ('imageUrl' in $$props) $$invalidate(0, imageUrl = $$props.imageUrl);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('artist' in $$props) $$invalidate(2, artist = $$props.artist);
    		if ('currentValue' in $$props) $$invalidate(3, currentValue = $$props.currentValue);
    		if ('songDuration' in $$props) $$invalidate(4, songDuration = $$props.songDuration);
    		if ('isSpeaker' in $$props) $$invalidate(5, isSpeaker = $$props.isSpeaker);
    		if ('leftTime' in $$props) $$invalidate(6, leftTime = $$props.leftTime);
    		if ('rightTime' in $$props) $$invalidate(7, rightTime = $$props.rightTime);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*currentValue*/ 8) {
    			$$invalidate(6, leftTime = getMinutesSecondsLeft(currentValue));
    		}

    		if ($$self.$$.dirty & /*currentValue, songDuration*/ 24) {
    			$$invalidate(7, rightTime = getMinutesSecondsRight(currentValue, songDuration));
    		}
    	};

    	return [
    		imageUrl,
    		title,
    		artist,
    		currentValue,
    		songDuration,
    		isSpeaker,
    		leftTime,
    		rightTime
    	];
    }

    class NowPlaying extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
    			imageUrl: 0,
    			title: 1,
    			artist: 2,
    			currentValue: 3,
    			songDuration: 4,
    			isSpeaker: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NowPlaying",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*imageUrl*/ ctx[0] === undefined && !('imageUrl' in props)) {
    			console.warn("<NowPlaying> was created without expected prop 'imageUrl'");
    		}

    		if (/*title*/ ctx[1] === undefined && !('title' in props)) {
    			console.warn("<NowPlaying> was created without expected prop 'title'");
    		}

    		if (/*artist*/ ctx[2] === undefined && !('artist' in props)) {
    			console.warn("<NowPlaying> was created without expected prop 'artist'");
    		}

    		if (/*currentValue*/ ctx[3] === undefined && !('currentValue' in props)) {
    			console.warn("<NowPlaying> was created without expected prop 'currentValue'");
    		}

    		if (/*songDuration*/ ctx[4] === undefined && !('songDuration' in props)) {
    			console.warn("<NowPlaying> was created without expected prop 'songDuration'");
    		}
    	}

    	get imageUrl() {
    		throw new Error("<NowPlaying>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageUrl(value) {
    		throw new Error("<NowPlaying>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<NowPlaying>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<NowPlaying>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get artist() {
    		throw new Error("<NowPlaying>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set artist(value) {
    		throw new Error("<NowPlaying>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentValue() {
    		throw new Error("<NowPlaying>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentValue(value) {
    		throw new Error("<NowPlaying>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get songDuration() {
    		throw new Error("<NowPlaying>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set songDuration(value) {
    		throw new Error("<NowPlaying>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isSpeaker() {
    		throw new Error("<NowPlaying>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isSpeaker(value) {
    		throw new Error("<NowPlaying>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/pages/MusicListPage.svelte generated by Svelte v3.44.0 */

    const { console: console_1$2 } = globals;
    const file$4 = "src/pages/MusicListPage.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (62:4) <NavRight>
    function create_default_slot_5$1(ctx) {
    	let link0;
    	let t;
    	let link1;
    	let current;

    	link0 = new Link({
    			props: {
    				iconMd: "material:leak_add",
    				iconOnly: true,
    				href: "/rooms/"
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				iconMd: "material:settings",
    				iconOnly: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link0.$$.fragment);
    			t = space();
    			create_component(link1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(link1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(link1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(62:4) <NavRight>",
    		ctx
    	});

    	return block;
    }

    // (61:2) <Navbar title="Multiroom Audio">
    function create_default_slot_4$1(ctx) {
    	let navright;
    	let current;

    	navright = new Nav_right({
    			props: {
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navright.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navright, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navright_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				navright_changes.$$scope = { dirty, ctx };
    			}

    			navright.$set(navright_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navright.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navright.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navright, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(61:2) <Navbar title=\\\"Multiroom Audio\\\">",
    		ctx
    	});

    	return block;
    }

    // (68:2) <Toolbar bottom >
    function create_default_slot_3$1(ctx) {
    	let div4;
    	let img;
    	let img_src_value;
    	let t0;
    	let div3;
    	let div1;
    	let div0;
    	let t2;
    	let div2;
    	let t4;
    	let div5;
    	let link;
    	let current;

    	link = new Link({
    			props: { iconMd: "material:play_arrow" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			img = element("img");
    			t0 = space();
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Yellow Submarine";
    			t2 = space();
    			div2 = element("div");
    			div2.textContent = "Beatles";
    			t4 = space();
    			div5 = element("div");
    			create_component(link.$$.fragment);
    			attr_dev(img, "id", "album");
    			attr_dev(img, "alt", "");
    			if (!src_url_equal(img.src, img_src_value = "https://www.nuovecanzoni.com/wp-content/uploads/2021/07/Una-Direzione-Giusta-supreme.jpg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "svelte-k2o4vf");
    			add_location(img, file$4, 69, 6, 1712);
    			attr_dev(div0, "class", "item-title svelte-k2o4vf");
    			add_location(div0, file$4, 76, 10, 1963);
    			attr_dev(div1, "class", "item-title-row");
    			set_style(div1, "display", "flex");
    			add_location(div1, file$4, 75, 8, 1902);
    			attr_dev(div2, "class", "item-subtitle");
    			add_location(div2, file$4, 78, 8, 2033);
    			attr_dev(div3, "class", "item-inner");
    			add_location(div3, file$4, 74, 6, 1869);
    			attr_dev(div4, "class", "toolbarBox svelte-k2o4vf");
    			add_location(div4, file$4, 68, 4, 1681);
    			set_style(div5, "margin-right", "14px");
    			add_location(div5, file$4, 81, 4, 2102);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, img);
    			append_dev(div4, t0);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div5, anchor);
    			mount_component(link, div5, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div5);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(68:2) <Toolbar bottom >",
    		ctx
    	});

    	return block;
    }

    // (116:8) 
    function create_media_slot$1(ctx) {
    	let img;
    	let img_alt_value;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "slot", "media");
    			attr_dev(img, "alt", img_alt_value = /*song*/ ctx[6].title);
    			if (!src_url_equal(img.src, img_src_value = /*song*/ ctx[6].albumImageUrl)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "width", "44");
    			attr_dev(img, "class", "svelte-k2o4vf");
    			add_location(img, file$4, 115, 8, 3164);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*songs*/ 1 && img_alt_value !== (img_alt_value = /*song*/ ctx[6].title)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if (dirty & /*songs*/ 1 && !src_url_equal(img.src, img_src_value = /*song*/ ctx[6].albumImageUrl)) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_media_slot$1.name,
    		type: "slot",
    		source: "(116:8) ",
    		ctx
    	});

    	return block;
    }

    // (129:10) {:else}
    function create_else_block$1(ctx) {
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				iconMd: "material:play_arrow",
    				iconOnly: true
    			},
    			$$inline: true
    		});

    	link.$on("click", function () {
    		if (is_function(/*palyPauseSong*/ ctx[2](/*song*/ ctx[6]))) /*palyPauseSong*/ ctx[2](/*song*/ ctx[6]).apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(129:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (123:10) {#if song.isPlaying}
    function create_if_block$1(ctx) {
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				iconMd: "material:pause_arrow",
    				iconOnly: true
    			},
    			$$inline: true
    		});

    	link.$on("click", function () {
    		if (is_function(/*palyPauseSong*/ ctx[2](/*song*/ ctx[6]))) /*palyPauseSong*/ ctx[2](/*song*/ ctx[6]).apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(123:10) {#if song.isPlaying}",
    		ctx
    	});

    	return block;
    }

    // (122:8) 
    function create_after_slot$1(ctx) {
    	let span;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let current;
    	const if_block_creators = [create_if_block$1, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*song*/ ctx[6].isPlaying) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block.c();
    			t = space();
    			attr_dev(span, "slot", "after");
    			add_location(span, file$4, 121, 8, 3294);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if_blocks[current_block_type_index].m(span, null);
    			append_dev(span, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(span, t);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_after_slot$1.name,
    		type: "slot",
    		source: "(122:8) ",
    		ctx
    	});

    	return block;
    }

    // (114:4) {#each songs as song}
    function create_each_block(ctx) {
    	let listitem;
    	let current;

    	listitem = new List_item({
    			props: {
    				title: /*song*/ ctx[6].title,
    				subtitle: /*song*/ ctx[6].artist,
    				$$slots: {
    					after: [create_after_slot$1],
    					media: [create_media_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(listitem.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(listitem, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listitem_changes = {};
    			if (dirty & /*songs*/ 1) listitem_changes.title = /*song*/ ctx[6].title;
    			if (dirty & /*songs*/ 1) listitem_changes.subtitle = /*song*/ ctx[6].artist;

    			if (dirty & /*$$scope, songs*/ 513) {
    				listitem_changes.$$scope = { dirty, ctx };
    			}

    			listitem.$set(listitem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listitem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(listitem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(114:4) {#each songs as song}",
    		ctx
    	});

    	return block;
    }

    // (87:2) <List mediaList>
    function create_default_slot_2$2(ctx) {
    	let div0;
    	let t1;
    	let li;
    	let div9;
    	let div1;
    	let link;
    	let t2;
    	let div2;
    	let t3;
    	let div3;
    	let t4;
    	let div4;
    	let t5;
    	let div5;
    	let t6;
    	let div6;
    	let t7;
    	let div7;
    	let t8;
    	let div8;
    	let t9;
    	let div10;
    	let t11;
    	let each_1_anchor;
    	let current;

    	link = new Link({
    			props: { iconMd: "material:add", iconOnly: true },
    			$$inline: true
    		});

    	let each_value = /*songs*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "Connected speakers";
    			t1 = space();
    			li = element("li");
    			div9 = element("div");
    			div1 = element("div");
    			create_component(link.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			t3 = space();
    			div3 = element("div");
    			t4 = space();
    			div4 = element("div");
    			t5 = space();
    			div5 = element("div");
    			t6 = space();
    			div6 = element("div");
    			t7 = space();
    			div7 = element("div");
    			t8 = space();
    			div8 = element("div");
    			t9 = space();
    			div10 = element("div");
    			div10.textContent = "SLAC songs";
    			t11 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			attr_dev(div0, "class", "block-title svelte-k2o4vf");
    			set_style(div0, "margin-bottom", "0px");
    			add_location(div0, file$4, 87, 4, 2226);
    			attr_dev(div1, "class", "item-speaker svelte-k2o4vf");
    			add_location(div1, file$4, 90, 8, 2379);
    			attr_dev(div2, "class", "item-speaker svelte-k2o4vf");
    			add_location(div2, file$4, 93, 8, 2479);
    			attr_dev(div3, "class", "item-speaker svelte-k2o4vf");
    			add_location(div3, file$4, 94, 8, 2516);
    			attr_dev(div4, "class", "item-speaker svelte-k2o4vf");
    			add_location(div4, file$4, 95, 8, 2553);
    			attr_dev(div5, "class", "item-speaker svelte-k2o4vf");
    			add_location(div5, file$4, 96, 8, 2590);
    			attr_dev(div6, "class", "item-speaker svelte-k2o4vf");
    			add_location(div6, file$4, 97, 8, 2627);
    			attr_dev(div7, "class", "item-speaker svelte-k2o4vf");
    			add_location(div7, file$4, 98, 8, 2664);
    			attr_dev(div8, "class", "item-speaker svelte-k2o4vf");
    			add_location(div8, file$4, 99, 8, 2701);
    			attr_dev(div9, "class", "list-speakers svelte-k2o4vf");
    			add_location(div9, file$4, 89, 6, 2343);
    			attr_dev(li, "class", "list-group-title svelte-k2o4vf");
    			add_location(li, file$4, 88, 4, 2307);
    			attr_dev(div10, "class", "block-title svelte-k2o4vf");
    			add_location(div10, file$4, 103, 4, 2758);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, li, anchor);
    			append_dev(li, div9);
    			append_dev(div9, div1);
    			mount_component(link, div1, null);
    			append_dev(div9, t2);
    			append_dev(div9, div2);
    			append_dev(div9, t3);
    			append_dev(div9, div3);
    			append_dev(div9, t4);
    			append_dev(div9, div4);
    			append_dev(div9, t5);
    			append_dev(div9, div5);
    			append_dev(div9, t6);
    			append_dev(div9, div6);
    			append_dev(div9, t7);
    			append_dev(div9, div7);
    			append_dev(div9, t8);
    			append_dev(div9, div8);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div10, anchor);
    			insert_dev(target, t11, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*songs, palyPauseSong*/ 5) {
    				each_value = /*songs*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(li);
    			destroy_component(link);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div10);
    			if (detaching) detach_dev(t11);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(87:2) <List mediaList>",
    		ctx
    	});

    	return block;
    }

    // (59:0) <Page>
    function create_default_slot_1$2(ctx) {
    	let navbar;
    	let t0;
    	let toolbar;
    	let t1;
    	let list;
    	let current;

    	navbar = new Navbar({
    			props: {
    				title: "Multiroom Audio",
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbar = new Toolbar({
    			props: {
    				bottom: true,
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	list = new List({
    			props: {
    				mediaList: true,
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			create_component(toolbar.$$.fragment);
    			t1 = space();
    			create_component(list.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(toolbar, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(list, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const toolbar_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				toolbar_changes.$$scope = { dirty, ctx };
    			}

    			toolbar.$set(toolbar_changes);
    			const list_changes = {};

    			if (dirty & /*$$scope, songs*/ 513) {
    				list_changes.$$scope = { dirty, ctx };
    			}

    			list.$set(list_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(toolbar.$$.fragment, local);
    			transition_in(list.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(toolbar.$$.fragment, local);
    			transition_out(list.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(toolbar, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(list, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(59:0) <Page>",
    		ctx
    	});

    	return block;
    }

    // (142:0) <Popup   opened={popupOpened}   onPopupClosed={() => (popupOpened = false)}   swipeToClose   >
    function create_default_slot$4(ctx) {
    	let nowplaying;
    	let current;
    	nowplaying = new NowPlaying({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(nowplaying.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(nowplaying, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nowplaying.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nowplaying.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(nowplaying, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(142:0) <Popup   opened={popupOpened}   onPopupClosed={() => (popupOpened = false)}   swipeToClose   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let page;
    	let t;
    	let popup;
    	let current;

    	page = new Page({
    			props: {
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	popup = new Popup({
    			props: {
    				opened: /*popupOpened*/ ctx[1],
    				onPopupClosed: /*func*/ ctx[3],
    				swipeToClose: true,
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(page.$$.fragment);
    			t = space();
    			create_component(popup.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(page, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(popup, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const page_changes = {};

    			if (dirty & /*$$scope, songs*/ 513) {
    				page_changes.$$scope = { dirty, ctx };
    			}

    			page.$set(page_changes);
    			const popup_changes = {};
    			if (dirty & /*popupOpened*/ 2) popup_changes.opened = /*popupOpened*/ ctx[1];
    			if (dirty & /*popupOpened*/ 2) popup_changes.onPopupClosed = /*func*/ ctx[3];

    			if (dirty & /*$$scope*/ 512) {
    				popup_changes.$$scope = { dirty, ctx };
    			}

    			popup.$set(popup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(page.$$.fragment, local);
    			transition_in(popup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(page.$$.fragment, local);
    			transition_out(popup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(page, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(popup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MusicListPage', slots, []);
    	let songs = [];
    	let popupOpened = false;
    	let playingSong;

    	async function fetchSongs() {
    		let res = await fetch("http://" + location.hostname + ":8080/player/list", { method: "GET", mode: "cors" });
    		$$invalidate(0, songs = await res.json());

    		songs.forEach(song => {
    			if (song.albumImageUrl != null) song.albumImageUrl = "http://" + location.hostname + ":8080/" + song.albumImageUrl.replace("./", ""); else song.albumImageUrl = "./imgs/blank_album.png";
    			song.songUrl = "http://" + location.hostname + ":8080/" + song.songUrl.replace("./", "");
    			song.isPlaying = false;
    		});

    		console.log(songs);
    	}

    	function palyPauseSong(song) {
    		console.log(song);

    		if (!song.isPlaying) {
    			if (playingSong != null) playingSong.pause();
    			playingSong = new Audio(song.songUrl);
    			playingSong.play();
    		} else {
    			playingSong.pause();
    		}

    		song.isPlaying = !song.isPlaying;
    		$$invalidate(0, songs); // Update for svelte
    	}

    	onMount(async () => {
    		fetchSongs();
    		document.getElementsByClassName("toolbar-bottom")[0].onclick = () => $$invalidate(1, popupOpened = true);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<MusicListPage> was created with unknown prop '${key}'`);
    	});

    	const func = () => $$invalidate(1, popupOpened = false);

    	$$self.$capture_state = () => ({
    		onMount,
    		Page,
    		Navbar,
    		Toolbar,
    		Link,
    		NavRight: Nav_right,
    		ListItem: List_item,
    		List,
    		Popup,
    		text,
    		NowPlaying,
    		songs,
    		popupOpened,
    		playingSong,
    		fetchSongs,
    		palyPauseSong
    	});

    	$$self.$inject_state = $$props => {
    		if ('songs' in $$props) $$invalidate(0, songs = $$props.songs);
    		if ('popupOpened' in $$props) $$invalidate(1, popupOpened = $$props.popupOpened);
    		if ('playingSong' in $$props) playingSong = $$props.playingSong;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [songs, popupOpened, palyPauseSong, func];
    }

    class MusicListPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MusicListPage",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src/pages/RoomsPage.svelte generated by Svelte v3.44.0 */
    const file$3 = "src/pages/RoomsPage.svelte";

    // (8:4) <Fab position="right-bottom" href="/calibration/">
    function create_default_slot_2$1(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { md: "material:add" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(8:4) <Fab position=\\\"right-bottom\\\" href=\\\"/calibration/\\\">",
    		ctx
    	});

    	return block;
    }

    // (14:12) 
    function create_after_slot_2(ctx) {
    	let span;
    	let link;
    	let current;

    	link = new Link({
    			props: { iconMd: "material:delete", color: "red" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(link.$$.fragment);
    			attr_dev(span, "slot", "after");
    			add_location(span, file$3, 13, 12, 353);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(link, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_after_slot_2.name,
    		type: "slot",
    		source: "(14:12) ",
    		ctx
    	});

    	return block;
    }

    // (19:12) 
    function create_after_slot_1(ctx) {
    	let span;
    	let link;
    	let current;

    	link = new Link({
    			props: { iconMd: "material:delete", color: "red" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(link.$$.fragment);
    			attr_dev(span, "slot", "after");
    			add_location(span, file$3, 18, 12, 532);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(link, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_after_slot_1.name,
    		type: "slot",
    		source: "(19:12) ",
    		ctx
    	});

    	return block;
    }

    // (24:12) 
    function create_after_slot(ctx) {
    	let span;
    	let link;
    	let current;

    	link = new Link({
    			props: { iconMd: "material:delete", color: "red" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(link.$$.fragment);
    			attr_dev(span, "slot", "after");
    			add_location(span, file$3, 23, 12, 722);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(link, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_after_slot.name,
    		type: "slot",
    		source: "(24:12) ",
    		ctx
    	});

    	return block;
    }

    // (12:4) <List>
    function create_default_slot_1$1(ctx) {
    	let listitem0;
    	let t0;
    	let listitem1;
    	let t1;
    	let listitem2;
    	let current;

    	listitem0 = new List_item({
    			props: {
    				title: "Cucina",
    				$$slots: { after: [create_after_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	listitem1 = new List_item({
    			props: {
    				title: "Camera Luca",
    				$$slots: { after: [create_after_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	listitem2 = new List_item({
    			props: {
    				title: "Cammera Andrea",
    				$$slots: { after: [create_after_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(listitem0.$$.fragment);
    			t0 = space();
    			create_component(listitem1.$$.fragment);
    			t1 = space();
    			create_component(listitem2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(listitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(listitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(listitem2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listitem0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				listitem0_changes.$$scope = { dirty, ctx };
    			}

    			listitem0.$set(listitem0_changes);
    			const listitem1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				listitem1_changes.$$scope = { dirty, ctx };
    			}

    			listitem1.$set(listitem1_changes);
    			const listitem2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				listitem2_changes.$$scope = { dirty, ctx };
    			}

    			listitem2.$set(listitem2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listitem0.$$.fragment, local);
    			transition_in(listitem1.$$.fragment, local);
    			transition_in(listitem2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listitem0.$$.fragment, local);
    			transition_out(listitem1.$$.fragment, local);
    			transition_out(listitem2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(listitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(listitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(listitem2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(12:4) <List>",
    		ctx
    	});

    	return block;
    }

    // (5:0) <Page>
    function create_default_slot$3(ctx) {
    	let navbar;
    	let t0;
    	let fab;
    	let t1;
    	let list;
    	let current;

    	navbar = new Navbar({
    			props: { title: "House rooms", backLink: true },
    			$$inline: true
    		});

    	fab = new Fab({
    			props: {
    				position: "right-bottom",
    				href: "/calibration/",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	list = new List({
    			props: {
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			create_component(fab.$$.fragment);
    			t1 = space();
    			create_component(list.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fab, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(list, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fab_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				fab_changes.$$scope = { dirty, ctx };
    			}

    			fab.$set(fab_changes);
    			const list_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				list_changes.$$scope = { dirty, ctx };
    			}

    			list.$set(list_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(fab.$$.fragment, local);
    			transition_in(list.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(fab.$$.fragment, local);
    			transition_out(list.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fab, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(list, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(5:0) <Page>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let page;
    	let current;

    	page = new Page({
    			props: {
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(page.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(page, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const page_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				page_changes.$$scope = { dirty, ctx };
    			}

    			page.$set(page_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(page.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(page.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(page, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RoomsPage', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RoomsPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Page,
    		Navbar,
    		Fab,
    		Icon,
    		Link,
    		ListItem: List_item,
    		List
    	});

    	return [];
    }

    class RoomsPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RoomsPage",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src/pages/SpeakerPage.svelte generated by Svelte v3.44.0 */

    const { console: console_1$1 } = globals;
    const file$2 = "src/pages/SpeakerPage.svelte";

    // (126:0) <Page>
    function create_default_slot$2(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let div2;
    	let div1;
    	let t2;
    	let nowplaying;
    	let current;

    	nowplaying = new NowPlaying({
    			props: {
    				imageUrl: /*imageUrl*/ ctx[2],
    				title: /*title*/ ctx[3],
    				artist: /*artist*/ ctx[4],
    				currentValue: /*currentTimeSec*/ ctx[0],
    				songDuration: /*songDurationSec*/ ctx[1],
    				isSpeaker: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div2 = element("div");
    			div1 = element("div");
    			div1.textContent = "Multiroom Audio";
    			t2 = space();
    			create_component(nowplaying.$$.fragment);
    			attr_dev(div0, "class", "navbar-bg svelte-2u5o7c");
    			add_location(div0, file$2, 127, 8, 3360);
    			attr_dev(div1, "class", "title svelte-2u5o7c");
    			add_location(div1, file$2, 129, 12, 3441);
    			attr_dev(div2, "class", "navbar-inner sliding svelte-2u5o7c");
    			add_location(div2, file$2, 128, 8, 3394);
    			attr_dev(div3, "class", "navbar");
    			attr_dev(div3, "data-f7-slot", "fixed");
    			add_location(div3, file$2, 126, 4, 3310);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t0);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			insert_dev(target, t2, anchor);
    			mount_component(nowplaying, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const nowplaying_changes = {};
    			if (dirty & /*imageUrl*/ 4) nowplaying_changes.imageUrl = /*imageUrl*/ ctx[2];
    			if (dirty & /*title*/ 8) nowplaying_changes.title = /*title*/ ctx[3];
    			if (dirty & /*artist*/ 16) nowplaying_changes.artist = /*artist*/ ctx[4];
    			if (dirty & /*currentTimeSec*/ 1) nowplaying_changes.currentValue = /*currentTimeSec*/ ctx[0];
    			if (dirty & /*songDurationSec*/ 2) nowplaying_changes.songDuration = /*songDurationSec*/ ctx[1];
    			nowplaying.$set(nowplaying_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nowplaying.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nowplaying.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t2);
    			destroy_component(nowplaying, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(126:0) <Page>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let page;
    	let current;

    	page = new Page({
    			props: {
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(page.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(page, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const page_changes = {};

    			if (dirty & /*$$scope, imageUrl, title, artist, currentTimeSec, songDurationSec*/ 262175) {
    				page_changes.$$scope = { dirty, ctx };
    			}

    			page.$set(page_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(page.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(page.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(page, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SpeakerPage', slots, []);
    	let socket = null;
    	const audio = new Audio();
    	console.log(audio);
    	audio.mute = true;
    	let songList = [];
    	let songId = -1;
    	let currentTimeSec = 0;
    	let songDurationSec = 0;
    	let imageUrl = "http://" + location.hostname + ":80/imgs/blank_album.png";
    	let title = "Waiting for music...";
    	let artist = "";
    	let speakerId;
    	let speakerName = "Sandro";

    	onMount(() => {
    		f7ready(() => {
    			loadId();
    			socketSetup();
    		});
    	});

    	function loadId() {
    		console.log("okookkook");
    		speakerId = localStorage.getItem("id");
    		console.log(speakerId);

    		if (speakerId == null) {
    			speakerId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    			localStorage.setItem("id", speakerId);
    		}
    	}

    	function socketSetup() {
    		socket = new WebSocket("ws://" + location.hostname + "/websocket");

    		socket.onopen = () => {
    			sendInitMessage();
    			f7.dialog.alert('Speaker connected');
    		};

    		socket.onmessage = event => {
    			processMessage(JSON.parse(event.data));
    		};

    		socket.onclose = event => {
    			console.log(event);
    			window.clearTimeout(intervalResponse);
    		};
    	}

    	function sendInitMessage() {
    		socket.send(JSON.stringify({
    			type: "HELLO",
    			deviceType: 1, // speaker type
    			id: speakerId,
    			name: speakerName
    		}));
    	}

    	function processMessage(message) {
    		console.log(message);

    		switch (message.type) {
    			case "PLAY":
    				playSong(message);
    				break;
    			case "CURRENT_PLAYING":
    				$$invalidate(0, currentTimeSec = message.currentTimeSec);
    				break;
    		}
    	}

    	function playSong(message) {
    		songList = message.songList;
    		songId = message.songId;
    		let song = songList[songId];
    		$$invalidate(2, imageUrl = "http://" + location.hostname + ":8080/" + song.albumImageUrl.replace("./", ""));
    		$$invalidate(3, title = song.title);
    		$$invalidate(4, artist = song.artist);
    		audio.src = "http://" + location.hostname + ":8080/" + song.songUrl.replace("./", "");
    		console.log(song);
    		audio.currentTime = message.fromTimeSec;
    		audio.load();

    		audio.onloadeddata = () => {
    			$$invalidate(1, songDurationSec = audio.duration);
    			audio.play();
    		};

    		sendCurrentTime();
    	}

    	audio.onplay = () => {
    		
    	};

    	audio.onended = () => {
    		console.log("Audio ended");
    	};

    	let intervalResponse;

    	function sendCurrentTime() {
    		intervalResponse = window.setInterval(
    			() => {
    				socket.send(JSON.stringify({
    					type: "CURRENT_PLAYING",
    					songId,
    					currentTimeSec: audio.currentTime
    				}));
    			},
    			1000
    		);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<SpeakerPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		NowPlaying,
    		Page,
    		f7,
    		onMount,
    		f7ready,
    		socket,
    		audio,
    		songList,
    		songId,
    		currentTimeSec,
    		songDurationSec,
    		imageUrl,
    		title,
    		artist,
    		speakerId,
    		speakerName,
    		loadId,
    		socketSetup,
    		sendInitMessage,
    		processMessage,
    		playSong,
    		intervalResponse,
    		sendCurrentTime
    	});

    	$$self.$inject_state = $$props => {
    		if ('socket' in $$props) socket = $$props.socket;
    		if ('songList' in $$props) songList = $$props.songList;
    		if ('songId' in $$props) songId = $$props.songId;
    		if ('currentTimeSec' in $$props) $$invalidate(0, currentTimeSec = $$props.currentTimeSec);
    		if ('songDurationSec' in $$props) $$invalidate(1, songDurationSec = $$props.songDurationSec);
    		if ('imageUrl' in $$props) $$invalidate(2, imageUrl = $$props.imageUrl);
    		if ('title' in $$props) $$invalidate(3, title = $$props.title);
    		if ('artist' in $$props) $$invalidate(4, artist = $$props.artist);
    		if ('speakerId' in $$props) speakerId = $$props.speakerId;
    		if ('speakerName' in $$props) speakerName = $$props.speakerName;
    		if ('intervalResponse' in $$props) intervalResponse = $$props.intervalResponse;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentTimeSec, songDurationSec, imageUrl, title, artist];
    }

    class SpeakerPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SpeakerPage",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/pages/CalibrationPage.svelte generated by Svelte v3.44.0 */

    const { console: console_1 } = globals;

    const file$1 = "src/pages/CalibrationPage.svelte";

    // (15:4) <Fab position="center-bottom" text="Save">
    function create_default_slot_6(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { md: "material:done" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(15:4) <Fab position=\\\"center-bottom\\\" text=\\\"Save\\\">",
    		ctx
    	});

    	return block;
    }

    // (18:4) <List noHairlinesMd>
    function create_default_slot_5(ctx) {
    	let listinput;
    	let current;

    	listinput = new List_input({
    			props: {
    				outline: true,
    				label: "Room name",
    				floatingLabel: true,
    				type: "text",
    				placeholder: "Bed room"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(listinput.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(listinput, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(listinput, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(18:4) <List noHairlinesMd>",
    		ctx
    	});

    	return block;
    }

    // (27:4) <BlockTitle>
    function create_default_slot_4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Calibration nuovo");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(27:4) <BlockTitle>",
    		ctx
    	});

    	return block;
    }

    // (29:6) <Button fill preloader loading={isLoading} onClick={saveReference}>
    function create_default_slot_3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Save reference");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(29:6) <Button fill preloader loading={isLoading} onClick={saveReference}>",
    		ctx
    	});

    	return block;
    }

    // (28:4) <Block strong>
    function create_default_slot_2(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				fill: true,
    				preloader: true,
    				loading: /*isLoading*/ ctx[0],
    				onClick: saveReference,
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(28:4) <Block strong>",
    		ctx
    	});

    	return block;
    }

    // (37:8) 
    function create_media_slot_2(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "slot", "media");
    			if (!src_url_equal(img.src, img_src_value = "https://cdn.framework7.io/placeholder/fashion-88x88-1.jpg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "width", "44");
    			add_location(img, file$1, 36, 8, 955);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_media_slot_2.name,
    		type: "slot",
    		source: "(37:8) ",
    		ctx
    	});

    	return block;
    }

    // (43:8) 
    function create_media_slot_1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "slot", "media");
    			if (!src_url_equal(img.src, img_src_value = "https://cdn.framework7.io/placeholder/fashion-88x88-2.jpg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "width", "44");
    			add_location(img, file$1, 42, 8, 1170);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_media_slot_1.name,
    		type: "slot",
    		source: "(43:8) ",
    		ctx
    	});

    	return block;
    }

    // (48:8) 
    function create_media_slot(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "slot", "media");
    			if (!src_url_equal(img.src, img_src_value = "https://cdn.framework7.io/placeholder/fashion-88x88-3.jpg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "width", "44");
    			add_location(img, file$1, 47, 8, 1372);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_media_slot.name,
    		type: "slot",
    		source: "(48:8) ",
    		ctx
    	});

    	return block;
    }

    // (33:4) <List mediaList>
    function create_default_slot_1(ctx) {
    	let listitem0;
    	let t0;
    	let listitem1;
    	let t1;
    	let listitem2;
    	let current;

    	listitem0 = new List_item({
    			props: {
    				title: "Yellow Submarine",
    				subtitle: "Beatles",
    				$$slots: { media: [create_media_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	listitem1 = new List_item({
    			props: {
    				link: "#",
    				title: "Don't Stop Me Now",
    				subtitle: "Queen",
    				$$slots: { media: [create_media_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	listitem2 = new List_item({
    			props: {
    				title: "Billie Jean",
    				subtitle: "Michael Jackson",
    				$$slots: { media: [create_media_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(listitem0.$$.fragment);
    			t0 = space();
    			create_component(listitem1.$$.fragment);
    			t1 = space();
    			create_component(listitem2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(listitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(listitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(listitem2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listitem0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				listitem0_changes.$$scope = { dirty, ctx };
    			}

    			listitem0.$set(listitem0_changes);
    			const listitem1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				listitem1_changes.$$scope = { dirty, ctx };
    			}

    			listitem1.$set(listitem1_changes);
    			const listitem2_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				listitem2_changes.$$scope = { dirty, ctx };
    			}

    			listitem2.$set(listitem2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listitem0.$$.fragment, local);
    			transition_in(listitem1.$$.fragment, local);
    			transition_in(listitem2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listitem0.$$.fragment, local);
    			transition_out(listitem1.$$.fragment, local);
    			transition_out(listitem2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(listitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(listitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(listitem2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(33:4) <List mediaList>",
    		ctx
    	});

    	return block;
    }

    // (12:0) <Page>
    function create_default_slot$1(ctx) {
    	let navbar;
    	let t0;
    	let fab;
    	let t1;
    	let list0;
    	let t2;
    	let blocktitle;
    	let t3;
    	let block;
    	let t4;
    	let list1;
    	let current;

    	navbar = new Navbar({
    			props: { title: "Add room", backLink: true },
    			$$inline: true
    		});

    	fab = new Fab({
    			props: {
    				position: "center-bottom",
    				text: "Save",
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	list0 = new List({
    			props: {
    				noHairlinesMd: true,
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	blocktitle = new Block_title({
    			props: {
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	block = new Block({
    			props: {
    				strong: true,
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	list1 = new List({
    			props: {
    				mediaList: true,
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block_1 = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			create_component(fab.$$.fragment);
    			t1 = space();
    			create_component(list0.$$.fragment);
    			t2 = space();
    			create_component(blocktitle.$$.fragment);
    			t3 = space();
    			create_component(block.$$.fragment);
    			t4 = space();
    			create_component(list1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fab, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(list0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(blocktitle, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(block, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(list1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fab_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				fab_changes.$$scope = { dirty, ctx };
    			}

    			fab.$set(fab_changes);
    			const list0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				list0_changes.$$scope = { dirty, ctx };
    			}

    			list0.$set(list0_changes);
    			const blocktitle_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				blocktitle_changes.$$scope = { dirty, ctx };
    			}

    			blocktitle.$set(blocktitle_changes);
    			const block_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				block_changes.$$scope = { dirty, ctx };
    			}

    			block.$set(block_changes);
    			const list1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				list1_changes.$$scope = { dirty, ctx };
    			}

    			list1.$set(list1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(fab.$$.fragment, local);
    			transition_in(list0.$$.fragment, local);
    			transition_in(blocktitle.$$.fragment, local);
    			transition_in(block.$$.fragment, local);
    			transition_in(list1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(fab.$$.fragment, local);
    			transition_out(list0.$$.fragment, local);
    			transition_out(blocktitle.$$.fragment, local);
    			transition_out(block.$$.fragment, local);
    			transition_out(list1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fab, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(list0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(blocktitle, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(block, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(list1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(12:0) <Page>",
    		ctx
    	});

    	return block_1;
    }

    function create_fragment$1(ctx) {
    	let page;
    	let current;

    	page = new Page({
    			props: {
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(page.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(page, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const page_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				page_changes.$$scope = { dirty, ctx };
    			}

    			page.$set(page_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(page.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(page.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(page, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    async function saveReference() {
    	console.log(await JSInterface.saveReferencePoint());
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CalibrationPage', slots, []);
    	let isLoading = false;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<CalibrationPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Page,
    		Navbar,
    		Fab,
    		Icon,
    		List,
    		ListInput: List_input,
    		BlockTitle: Block_title,
    		Block,
    		Button,
    		ListItem: List_item,
    		isLoading,
    		saveReference
    	});

    	$$self.$inject_state = $$props => {
    		if ('isLoading' in $$props) $$invalidate(0, isLoading = $$props.isLoading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isLoading];
    }

    class CalibrationPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CalibrationPage",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.44.0 */
    const file = "src/App.svelte";

    // (47:2) {:else}
    function create_else_block(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Open Multiroom Audio on your pc";
    			add_location(h1, file, 47, 4, 1205);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(47:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (45:22) 
    function create_if_block_1(ctx) {
    	let view;
    	let current;

    	view = new View({
    			props: {
    				url: "/speaker",
    				stackPages: true,
    				main: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(view.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(view, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(view.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(view.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(view, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(45:22) ",
    		ctx
    	});

    	return block;
    }

    // (43:2) {#if isClient}
    function create_if_block(ctx) {
    	let view;
    	let current;

    	view = new View({
    			props: {
    				url: "/musiclist",
    				stackPages: true,
    				main: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(view.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(view, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(view.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(view.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(view, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(43:2) {#if isClient}",
    		ctx
    	});

    	return block;
    }

    // (42:0) <App {...f7Params} themeDark={themeDark}>
    function create_default_slot(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_if_block_1, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isClient*/ ctx[0]) return 0;
    		if (/*isSpeaker*/ ctx[1]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(42:0) <App {...f7Params} themeDark={themeDark}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let app;
    	let current;
    	const app_spread_levels = [/*f7Params*/ ctx[2], { themeDark: /*themeDark*/ ctx[3] }];

    	let app_props = {
    		$$slots: { default: [create_default_slot] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < app_spread_levels.length; i += 1) {
    		app_props = assign(app_props, app_spread_levels[i]);
    	}

    	app = new App({ props: app_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(app.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(app, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const app_changes = (dirty & /*f7Params, themeDark*/ 12)
    			? get_spread_update(app_spread_levels, [
    					dirty & /*f7Params*/ 4 && get_spread_object(/*f7Params*/ ctx[2]),
    					dirty & /*themeDark*/ 8 && { themeDark: /*themeDark*/ ctx[3] }
    				])
    			: {};

    			if (dirty & /*$$scope, isClient, isSpeaker*/ 35) {
    				app_changes.$$scope = { dirty, ctx };
    			}

    			app.$set(app_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(app.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(app.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(app, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);

    	const f7Params = {
    		routes: [
    			{
    				path: '/musiclist',
    				component: MusicListPage
    			},
    			{ path: '/rooms', component: RoomsPage },
    			{
    				path: '/calibration',
    				component: CalibrationPage
    			},
    			{ path: '/speaker', component: SpeakerPage }
    		]
    	};

    	const urlParams = new URLSearchParams(window.location.search);
    	let isClient = false;
    	let isSpeaker = false;

    	if (urlParams.get('type') != null && urlParams.get('type') === 'client') {
    		isClient = true;
    	} else if (urlParams.get('type') != null && urlParams.get('type') === 'speaker') {
    		isSpeaker = true;
    	}

    	let themeDark = false;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		App,
    		View,
    		MusicListPage,
    		RoomsPage,
    		SpeakerPage,
    		CalibrationPage,
    		f7Params,
    		urlParams,
    		isClient,
    		isSpeaker,
    		themeDark
    	});

    	$$self.$inject_state = $$props => {
    		if ('isClient' in $$props) $$invalidate(0, isClient = $$props.isClient);
    		if ('isSpeaker' in $$props) $$invalidate(1, isSpeaker = $$props.isSpeaker);
    		if ('themeDark' in $$props) $$invalidate(3, themeDark = $$props.themeDark);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isClient, isSpeaker, f7Params, themeDark];
    }

    class App_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App_1",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    Framework7$1.use([Dialog, Framework7Svelte]);


    // Init Svelte App
    const app = new App_1({
      target: document.getElementById('app'),
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
