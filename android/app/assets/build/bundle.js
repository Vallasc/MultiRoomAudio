
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35731/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var MultiRoomAudio = (function () {
    'use strict';

    /**
     * SSR Window 3.0.0
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2020, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: November 9, 2020
     */
    /* eslint-disable no-param-reassign */
    function isObject$2(obj) {
        return (obj !== null &&
            typeof obj === 'object' &&
            'constructor' in obj &&
            obj.constructor === Object);
    }
    function extend$2(target, src) {
        if (target === void 0) { target = {}; }
        if (src === void 0) { src = {}; }
        Object.keys(src).forEach(function (key) {
            if (typeof target[key] === 'undefined')
                target[key] = src[key];
            else if (isObject$2(src[key]) &&
                isObject$2(target[key]) &&
                Object.keys(src[key]).length > 0) {
                extend$2(target[key], src[key]);
            }
        });
    }

    var ssrDocument = {
        body: {},
        addEventListener: function () { },
        removeEventListener: function () { },
        activeElement: {
            blur: function () { },
            nodeName: '',
        },
        querySelector: function () {
            return null;
        },
        querySelectorAll: function () {
            return [];
        },
        getElementById: function () {
            return null;
        },
        createEvent: function () {
            return {
                initEvent: function () { },
            };
        },
        createElement: function () {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute: function () { },
                getElementsByTagName: function () {
                    return [];
                },
            };
        },
        createElementNS: function () {
            return {};
        },
        importNode: function () {
            return null;
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: '',
        },
    };
    function getDocument() {
        var doc = typeof document !== 'undefined' ? document : {};
        extend$2(doc, ssrDocument);
        return doc;
    }

    var ssrWindow = {
        document: ssrDocument,
        navigator: {
            userAgent: '',
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: '',
        },
        history: {
            replaceState: function () { },
            pushState: function () { },
            go: function () { },
            back: function () { },
        },
        CustomEvent: function CustomEvent() {
            return this;
        },
        addEventListener: function () { },
        removeEventListener: function () { },
        getComputedStyle: function () {
            return {
                getPropertyValue: function () {
                    return '';
                },
            };
        },
        Image: function () { },
        Date: function () { },
        screen: {},
        setTimeout: function () { },
        clearTimeout: function () { },
        matchMedia: function () {
            return {};
        },
        requestAnimationFrame: function (callback) {
            if (typeof setTimeout === 'undefined') {
                callback();
                return null;
            }
            return setTimeout(callback, 0);
        },
        cancelAnimationFrame: function (id) {
            if (typeof setTimeout === 'undefined') {
                return;
            }
            clearTimeout(id);
        },
    };
    function getWindow() {
        var win = typeof window !== 'undefined' ? window : {};
        extend$2(win, ssrWindow);
        return win;
    }

    /**
     * Dom7 3.0.0
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * https://framework7.io/docs/dom7.html
     *
     * Copyright 2020, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: November 9, 2020
     */

    function _inheritsLoose$7(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }

    function _getPrototypeOf$1(o) {
      _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$1(o);
    }

    function _setPrototypeOf$9(o, p) {
      _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$9(o, p);
    }

    function _isNativeReflectConstruct$3() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _construct$3(Parent, args, Class) {
      if (_isNativeReflectConstruct$3()) {
        _construct$3 = Reflect.construct;
      } else {
        _construct$3 = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf$9(instance, Class.prototype);
          return instance;
        };
      }

      return _construct$3.apply(null, arguments);
    }

    function _isNativeFunction$1(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }

    function _wrapNativeSuper$1(Class) {
      var _cache = typeof Map === "function" ? new Map() : undefined;

      _wrapNativeSuper$1 = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction$1(Class)) return Class;

        if (typeof Class !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }

        if (typeof _cache !== "undefined") {
          if (_cache.has(Class)) return _cache.get(Class);

          _cache.set(Class, Wrapper);
        }

        function Wrapper() {
          return _construct$3(Class, arguments, _getPrototypeOf$1(this).constructor);
        }

        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf$9(Wrapper, Class);
      };

      return _wrapNativeSuper$1(Class);
    }

    function _assertThisInitialized$7(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    /* eslint-disable no-proto */
    function makeReactive(obj) {
      var proto = obj.__proto__;
      Object.defineProperty(obj, '__proto__', {
        get: function get() {
          return proto;
        },
        set: function set(value) {
          proto.__proto__ = value;
        }
      });
    }

    var Dom7 = /*#__PURE__*/function (_Array) {
      _inheritsLoose$7(Dom7, _Array);

      function Dom7(items) {
        var _this;

        _this = _Array.call.apply(_Array, [this].concat(items)) || this;
        makeReactive(_assertThisInitialized$7(_this));
        return _this;
      }

      return Dom7;
    }( /*#__PURE__*/_wrapNativeSuper$1(Array));

    function arrayFlat(arr) {
      if (arr === void 0) {
        arr = [];
      }

      var res = [];
      arr.forEach(function (el) {
        if (Array.isArray(el)) {
          res.push.apply(res, arrayFlat(el));
        } else {
          res.push(el);
        }
      });
      return res;
    }
    function arrayFilter(arr, callback) {
      return Array.prototype.filter.call(arr, callback);
    }
    function arrayUnique(arr) {
      var uniqueArray = [];

      for (var i = 0; i < arr.length; i += 1) {
        if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
      }

      return uniqueArray;
    }
    function toCamelCase$1(string) {
      return string.toLowerCase().replace(/-(.)/g, function (match, group) {
        return group.toUpperCase();
      });
    }

    function qsa(selector, context) {
      if (typeof selector !== 'string') {
        return [selector];
      }

      var a = [];
      var res = context.querySelectorAll(selector);

      for (var i = 0; i < res.length; i += 1) {
        a.push(res[i]);
      }

      return a;
    }

    function $$1(selector, context) {
      var window = getWindow();
      var document = getDocument();
      var arr = [];

      if (!context && selector instanceof Dom7) {
        return selector;
      }

      if (!selector) {
        return new Dom7(arr);
      }

      if (typeof selector === 'string') {
        var html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          var toCreate = 'div';
          if (html.indexOf('<li') === 0) toCreate = 'ul';
          if (html.indexOf('<tr') === 0) toCreate = 'tbody';
          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
          if (html.indexOf('<tbody') === 0) toCreate = 'table';
          if (html.indexOf('<option') === 0) toCreate = 'select';
          var tempParent = document.createElement(toCreate);
          tempParent.innerHTML = html;

          for (var i = 0; i < tempParent.childNodes.length; i += 1) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          arr = qsa(selector.trim(), context || document);
        } // arr = qsa(selector, document);

      } else if (selector.nodeType || selector === window || selector === document) {
        arr.push(selector);
      } else if (Array.isArray(selector)) {
        if (selector instanceof Dom7) return selector;
        arr = selector;
      }

      return new Dom7(arrayUnique(arr));
    }

    $$1.fn = Dom7.prototype;

    function addClass() {
      for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
        classes[_key] = arguments[_key];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        var _el$classList;

        (_el$classList = el.classList).add.apply(_el$classList, classNames);
      });
      return this;
    }

    function removeClass() {
      for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        classes[_key2] = arguments[_key2];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        var _el$classList2;

        (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
      });
      return this;
    }

    function toggleClass() {
      for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        classes[_key3] = arguments[_key3];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        classNames.forEach(function (className) {
          el.classList.toggle(className);
        });
      });
    }

    function hasClass() {
      for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        classes[_key4] = arguments[_key4];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      return arrayFilter(this, function (el) {
        return classNames.filter(function (className) {
          return el.classList.contains(className);
        }).length > 0;
      }).length > 0;
    }

    function attr$1(attrs, value) {
      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this[0]) return this[0].getAttribute(attrs);
        return undefined;
      } // Set attrs


      for (var i = 0; i < this.length; i += 1) {
        if (arguments.length === 2) {
          // String
          this[i].setAttribute(attrs, value);
        } else {
          // Object
          for (var attrName in attrs) {
            this[i][attrName] = attrs[attrName];
            this[i].setAttribute(attrName, attrs[attrName]);
          }
        }
      }

      return this;
    }

    function removeAttr(attr) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].removeAttribute(attr);
      }

      return this;
    }

    function prop(props, value) {
      if (arguments.length === 1 && typeof props === 'string') {
        // Get prop
        if (this[0]) return this[0][props];
      } else {
        // Set props
        for (var i = 0; i < this.length; i += 1) {
          if (arguments.length === 2) {
            // String
            this[i][props] = value;
          } else {
            // Object
            for (var propName in props) {
              this[i][propName] = props[propName];
            }
          }
        }

        return this;
      }

      return this;
    }

    function data(key, value) {
      var el;

      if (typeof value === 'undefined') {
        el = this[0];
        if (!el) return undefined; // Get value

        if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
          return el.dom7ElementDataStorage[key];
        }

        var dataKey = el.getAttribute("data-" + key);

        if (dataKey) {
          return dataKey;
        }

        return undefined;
      } // Set value


      for (var i = 0; i < this.length; i += 1) {
        el = this[i];
        if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
        el.dom7ElementDataStorage[key] = value;
      }

      return this;
    }

    function removeData(key) {
      for (var i = 0; i < this.length; i += 1) {
        var el = this[i];

        if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
          el.dom7ElementDataStorage[key] = null;
          delete el.dom7ElementDataStorage[key];
        }
      }
    }

    function dataset() {
      var el = this[0];
      if (!el) return undefined;
      var dataset = {}; // eslint-disable-line

      if (el.dataset) {
        for (var dataKey in el.dataset) {
          dataset[dataKey] = el.dataset[dataKey];
        }
      } else {
        for (var i = 0; i < el.attributes.length; i += 1) {
          var _attr = el.attributes[i];

          if (_attr.name.indexOf('data-') >= 0) {
            dataset[toCamelCase$1(_attr.name.split('data-')[1])] = _attr.value;
          }
        }
      }

      for (var key in dataset) {
        if (dataset[key] === 'false') dataset[key] = false;else if (dataset[key] === 'true') dataset[key] = true;else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
      }

      return dataset;
    }

    function val(value) {
      if (typeof value === 'undefined') {
        // get value
        var el = this[0];
        if (!el) return undefined;

        if (el.multiple && el.nodeName.toLowerCase() === 'select') {
          var values = [];

          for (var i = 0; i < el.selectedOptions.length; i += 1) {
            values.push(el.selectedOptions[i].value);
          }

          return values;
        }

        return el.value;
      } // set value


      for (var _i = 0; _i < this.length; _i += 1) {
        var _el = this[_i];

        if (Array.isArray(value) && _el.multiple && _el.nodeName.toLowerCase() === 'select') {
          for (var j = 0; j < _el.options.length; j += 1) {
            _el.options[j].selected = value.indexOf(_el.options[j].value) >= 0;
          }
        } else {
          _el.value = value;
        }
      }

      return this;
    }

    function value(value) {
      return this.val(value);
    }

    function transform(transform) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].style.transform = transform;
      }

      return this;
    }

    function transition(duration) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].style.transitionDuration = typeof duration !== 'string' ? duration + "ms" : duration;
      }

      return this;
    }

    function on() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      var eventType = args[0],
          targetSelector = args[1],
          listener = args[2],
          capture = args[3];

      if (typeof args[1] === 'function') {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = undefined;
      }

      if (!capture) capture = false;

      function handleLiveEvent(e) {
        var target = e.target;
        if (!target) return;
        var eventData = e.target.dom7EventData || [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        if ($$1(target).is(targetSelector)) listener.apply(target, eventData);else {
          var _parents = $$1(target).parents(); // eslint-disable-line


          for (var k = 0; k < _parents.length; k += 1) {
            if ($$1(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
          }
        }
      }

      function handleEvent(e) {
        var eventData = e && e.target ? e.target.dom7EventData || [] : [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        listener.apply(this, eventData);
      }

      var events = eventType.split(' ');
      var j;

      for (var i = 0; i < this.length; i += 1) {
        var el = this[i];

        if (!targetSelector) {
          for (j = 0; j < events.length; j += 1) {
            var event = events[j];
            if (!el.dom7Listeners) el.dom7Listeners = {};
            if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
            el.dom7Listeners[event].push({
              listener: listener,
              proxyListener: handleEvent
            });
            el.addEventListener(event, handleEvent, capture);
          }
        } else {
          // Live events
          for (j = 0; j < events.length; j += 1) {
            var _event = events[j];
            if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
            if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];

            el.dom7LiveListeners[_event].push({
              listener: listener,
              proxyListener: handleLiveEvent
            });

            el.addEventListener(_event, handleLiveEvent, capture);
          }
        }
      }

      return this;
    }

    function off() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      var eventType = args[0],
          targetSelector = args[1],
          listener = args[2],
          capture = args[3];

      if (typeof args[1] === 'function') {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = undefined;
      }

      if (!capture) capture = false;
      var events = eventType.split(' ');

      for (var i = 0; i < events.length; i += 1) {
        var event = events[i];

        for (var j = 0; j < this.length; j += 1) {
          var el = this[j];
          var handlers = void 0;

          if (!targetSelector && el.dom7Listeners) {
            handlers = el.dom7Listeners[event];
          } else if (targetSelector && el.dom7LiveListeners) {
            handlers = el.dom7LiveListeners[event];
          }

          if (handlers && handlers.length) {
            for (var k = handlers.length - 1; k >= 0; k -= 1) {
              var handler = handlers[k];

              if (listener && handler.listener === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (!listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              }
            }
          }
        }
      }

      return this;
    }

    function once() {
      var dom = this;

      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      var eventName = args[0],
          targetSelector = args[1],
          listener = args[2],
          capture = args[3];

      if (typeof args[1] === 'function') {
        eventName = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = undefined;
      }

      function onceHandler() {
        for (var _len8 = arguments.length, eventArgs = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
          eventArgs[_key8] = arguments[_key8];
        }

        listener.apply(this, eventArgs);
        dom.off(eventName, targetSelector, onceHandler, capture);

        if (onceHandler.dom7proxy) {
          delete onceHandler.dom7proxy;
        }
      }

      onceHandler.dom7proxy = listener;
      return dom.on(eventName, targetSelector, onceHandler, capture);
    }

    function trigger() {
      var window = getWindow();

      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }

      var events = args[0].split(' ');
      var eventData = args[1];

      for (var i = 0; i < events.length; i += 1) {
        var event = events[i];

        for (var j = 0; j < this.length; j += 1) {
          var el = this[j];

          if (window.CustomEvent) {
            var evt = new window.CustomEvent(event, {
              detail: eventData,
              bubbles: true,
              cancelable: true
            });
            el.dom7EventData = args.filter(function (data, dataIndex) {
              return dataIndex > 0;
            });
            el.dispatchEvent(evt);
            el.dom7EventData = [];
            delete el.dom7EventData;
          }
        }
      }

      return this;
    }

    function transitionEnd(callback) {
      var dom = this;

      function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off('transitionend', fireCallBack);
      }

      if (callback) {
        dom.on('transitionend', fireCallBack);
      }

      return this;
    }

    function animationEnd(callback) {
      var dom = this;

      function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off('animationend', fireCallBack);
      }

      if (callback) {
        dom.on('animationend', fireCallBack);
      }

      return this;
    }

    function width() {
      var window = getWindow();

      if (this[0] === window) {
        return window.innerWidth;
      }

      if (this.length > 0) {
        return parseFloat(this.css('width'));
      }

      return null;
    }

    function outerWidth(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          var _styles = this.styles();

          return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));
        }

        return this[0].offsetWidth;
      }

      return null;
    }

    function height() {
      var window = getWindow();

      if (this[0] === window) {
        return window.innerHeight;
      }

      if (this.length > 0) {
        return parseFloat(this.css('height'));
      }

      return null;
    }

    function outerHeight(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          var _styles2 = this.styles();

          return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));
        }

        return this[0].offsetHeight;
      }

      return null;
    }

    function offset() {
      if (this.length > 0) {
        var window = getWindow();
        var document = getDocument();
        var el = this[0];
        var box = el.getBoundingClientRect();
        var body = document.body;
        var clientTop = el.clientTop || body.clientTop || 0;
        var clientLeft = el.clientLeft || body.clientLeft || 0;
        var scrollTop = el === window ? window.scrollY : el.scrollTop;
        var scrollLeft = el === window ? window.scrollX : el.scrollLeft;
        return {
          top: box.top + scrollTop - clientTop,
          left: box.left + scrollLeft - clientLeft
        };
      }

      return null;
    }

    function hide() {
      for (var i = 0; i < this.length; i += 1) {
        this[i].style.display = 'none';
      }

      return this;
    }

    function show() {
      var window = getWindow();

      for (var i = 0; i < this.length; i += 1) {
        var el = this[i];

        if (el.style.display === 'none') {
          el.style.display = '';
        }

        if (window.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
          // Still not visible
          el.style.display = 'block';
        }
      }

      return this;
    }

    function styles() {
      var window = getWindow();
      if (this[0]) return window.getComputedStyle(this[0], null);
      return {};
    }

    function css(props, value) {
      var window = getWindow();
      var i;

      if (arguments.length === 1) {
        if (typeof props === 'string') {
          // .css('width')
          if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
          // .css({ width: '100px' })
          for (i = 0; i < this.length; i += 1) {
            for (var _prop in props) {
              this[i].style[_prop] = props[_prop];
            }
          }

          return this;
        }
      }

      if (arguments.length === 2 && typeof props === 'string') {
        // .css('width', '100px')
        for (i = 0; i < this.length; i += 1) {
          this[i].style[props] = value;
        }

        return this;
      }

      return this;
    }

    function each(callback) {
      if (!callback) return this;
      this.forEach(function (el, index) {
        callback.apply(el, [el, index]);
      });
      return this;
    }

    function filter(callback) {
      var result = arrayFilter(this, callback);
      return $$1(result);
    }

    function html(html) {
      if (typeof html === 'undefined') {
        return this[0] ? this[0].innerHTML : null;
      }

      for (var i = 0; i < this.length; i += 1) {
        this[i].innerHTML = html;
      }

      return this;
    }

    function text$1(text) {
      if (typeof text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      }

      for (var i = 0; i < this.length; i += 1) {
        this[i].textContent = text;
      }

      return this;
    }

    function is(selector) {
      var window = getWindow();
      var document = getDocument();
      var el = this[0];
      var compareWith;
      var i;
      if (!el || typeof selector === 'undefined') return false;

      if (typeof selector === 'string') {
        if (el.matches) return el.matches(selector);
        if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
        if (el.msMatchesSelector) return el.msMatchesSelector(selector);
        compareWith = $$1(selector);

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      if (selector === document) {
        return el === document;
      }

      if (selector === window) {
        return el === window;
      }

      if (selector.nodeType || selector instanceof Dom7) {
        compareWith = selector.nodeType ? [selector] : selector;

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      return false;
    }

    function index() {
      var child = this[0];
      var i;

      if (child) {
        i = 0; // eslint-disable-next-line

        while ((child = child.previousSibling) !== null) {
          if (child.nodeType === 1) i += 1;
        }

        return i;
      }

      return undefined;
    }

    function eq(index) {
      if (typeof index === 'undefined') return this;
      var length = this.length;

      if (index > length - 1) {
        return $$1([]);
      }

      if (index < 0) {
        var returnIndex = length + index;
        if (returnIndex < 0) return $$1([]);
        return $$1([this[returnIndex]]);
      }

      return $$1([this[index]]);
    }

    function append$1() {
      var newChild;
      var document = getDocument();

      for (var k = 0; k < arguments.length; k += 1) {
        newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];

        for (var i = 0; i < this.length; i += 1) {
          if (typeof newChild === 'string') {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;

            while (tempDiv.firstChild) {
              this[i].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom7) {
            for (var j = 0; j < newChild.length; j += 1) {
              this[i].appendChild(newChild[j]);
            }
          } else {
            this[i].appendChild(newChild);
          }
        }
      }

      return this;
    }

    function appendTo(parent) {
      $$1(parent).append(this);
      return this;
    }

    function prepend(newChild) {
      var document = getDocument();
      var i;
      var j;

      for (i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          }
        } else if (newChild instanceof Dom7) {
          for (j = 0; j < newChild.length; j += 1) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }

      return this;
    }

    function prependTo(parent) {
      $$1(parent).prepend(this);
      return this;
    }

    function insertBefore$1(selector) {
      var before = $$1(selector);

      for (var i = 0; i < this.length; i += 1) {
        if (before.length === 1) {
          before[0].parentNode.insertBefore(this[i], before[0]);
        } else if (before.length > 1) {
          for (var j = 0; j < before.length; j += 1) {
            before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
          }
        }
      }
    }

    function insertAfter(selector) {
      var after = $$1(selector);

      for (var i = 0; i < this.length; i += 1) {
        if (after.length === 1) {
          after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
        } else if (after.length > 1) {
          for (var j = 0; j < after.length; j += 1) {
            after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
          }
        }
      }
    }

    function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $$1(this[0].nextElementSibling).is(selector)) {
            return $$1([this[0].nextElementSibling]);
          }

          return $$1([]);
        }

        if (this[0].nextElementSibling) return $$1([this[0].nextElementSibling]);
        return $$1([]);
      }

      return $$1([]);
    }

    function nextAll(selector) {
      var nextEls = [];
      var el = this[0];
      if (!el) return $$1([]);

      while (el.nextElementSibling) {
        var _next = el.nextElementSibling; // eslint-disable-line

        if (selector) {
          if ($$1(_next).is(selector)) nextEls.push(_next);
        } else nextEls.push(_next);

        el = _next;
      }

      return $$1(nextEls);
    }

    function prev(selector) {
      if (this.length > 0) {
        var el = this[0];

        if (selector) {
          if (el.previousElementSibling && $$1(el.previousElementSibling).is(selector)) {
            return $$1([el.previousElementSibling]);
          }

          return $$1([]);
        }

        if (el.previousElementSibling) return $$1([el.previousElementSibling]);
        return $$1([]);
      }

      return $$1([]);
    }

    function prevAll(selector) {
      var prevEls = [];
      var el = this[0];
      if (!el) return $$1([]);

      while (el.previousElementSibling) {
        var _prev = el.previousElementSibling; // eslint-disable-line

        if (selector) {
          if ($$1(_prev).is(selector)) prevEls.push(_prev);
        } else prevEls.push(_prev);

        el = _prev;
      }

      return $$1(prevEls);
    }

    function siblings(selector) {
      return this.nextAll(selector).add(this.prevAll(selector));
    }

    function parent(selector) {
      var parents = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($$1(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }

      return $$1(parents);
    }

    function parents(selector) {
      var parents = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        var _parent = this[i].parentNode; // eslint-disable-line

        while (_parent) {
          if (selector) {
            if ($$1(_parent).is(selector)) parents.push(_parent);
          } else {
            parents.push(_parent);
          }

          _parent = _parent.parentNode;
        }
      }

      return $$1(parents);
    }

    function closest(selector) {
      var closest = this; // eslint-disable-line

      if (typeof selector === 'undefined') {
        return $$1([]);
      }

      if (!closest.is(selector)) {
        closest = closest.parents(selector).eq(0);
      }

      return closest;
    }

    function find(selector) {
      var foundElements = [];

      for (var i = 0; i < this.length; i += 1) {
        var found = this[i].querySelectorAll(selector);

        for (var j = 0; j < found.length; j += 1) {
          foundElements.push(found[j]);
        }
      }

      return $$1(foundElements);
    }

    function children$1(selector) {
      var children = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        var childNodes = this[i].children;

        for (var j = 0; j < childNodes.length; j += 1) {
          if (!selector || $$1(childNodes[j]).is(selector)) {
            children.push(childNodes[j]);
          }
        }
      }

      return $$1(children);
    }

    function remove() {
      for (var i = 0; i < this.length; i += 1) {
        if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
      }

      return this;
    }

    function detach$1() {
      return this.remove();
    }

    function add() {
      var dom = this;
      var i;
      var j;

      for (var _len10 = arguments.length, els = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        els[_key10] = arguments[_key10];
      }

      for (i = 0; i < els.length; i += 1) {
        var toAdd = $$1(els[i]);

        for (j = 0; j < toAdd.length; j += 1) {
          dom.push(toAdd[j]);
        }
      }

      return dom;
    }

    function empty$1() {
      for (var i = 0; i < this.length; i += 1) {
        var el = this[i];

        if (el.nodeType === 1) {
          for (var j = 0; j < el.childNodes.length; j += 1) {
            if (el.childNodes[j].parentNode) {
              el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
            }
          }

          el.textContent = '';
        }
      }

      return this;
    }

    function scrollTo() {
      var window = getWindow();

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var left = args[0],
          top = args[1],
          duration = args[2],
          easing = args[3],
          callback = args[4];

      if (args.length === 4 && typeof easing === 'function') {
        callback = easing;
        left = args[0];
        top = args[1];
        duration = args[2];
        callback = args[3];
        easing = args[4];
      }

      if (typeof easing === 'undefined') easing = 'swing';
      return this.each(function animate() {
        var el = this;
        var currentTop;
        var currentLeft;
        var maxTop;
        var maxLeft;
        var newTop;
        var newLeft;
        var scrollTop; // eslint-disable-line

        var scrollLeft; // eslint-disable-line

        var animateTop = top > 0 || top === 0;
        var animateLeft = left > 0 || left === 0;

        if (typeof easing === 'undefined') {
          easing = 'swing';
        }

        if (animateTop) {
          currentTop = el.scrollTop;

          if (!duration) {
            el.scrollTop = top;
          }
        }

        if (animateLeft) {
          currentLeft = el.scrollLeft;

          if (!duration) {
            el.scrollLeft = left;
          }
        }

        if (!duration) return;

        if (animateTop) {
          maxTop = el.scrollHeight - el.offsetHeight;
          newTop = Math.max(Math.min(top, maxTop), 0);
        }

        if (animateLeft) {
          maxLeft = el.scrollWidth - el.offsetWidth;
          newLeft = Math.max(Math.min(left, maxLeft), 0);
        }

        var startTime = null;
        if (animateTop && newTop === currentTop) animateTop = false;
        if (animateLeft && newLeft === currentLeft) animateLeft = false;

        function render(time) {
          if (time === void 0) {
            time = new Date().getTime();
          }

          if (startTime === null) {
            startTime = time;
          }

          var progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
          var easeProgress = easing === 'linear' ? progress : 0.5 - Math.cos(progress * Math.PI) / 2;
          var done;
          if (animateTop) scrollTop = currentTop + easeProgress * (newTop - currentTop);
          if (animateLeft) scrollLeft = currentLeft + easeProgress * (newLeft - currentLeft);

          if (animateTop && newTop > currentTop && scrollTop >= newTop) {
            el.scrollTop = newTop;
            done = true;
          }

          if (animateTop && newTop < currentTop && scrollTop <= newTop) {
            el.scrollTop = newTop;
            done = true;
          }

          if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
            el.scrollLeft = newLeft;
            done = true;
          }

          if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
            el.scrollLeft = newLeft;
            done = true;
          }

          if (done) {
            if (callback) callback();
            return;
          }

          if (animateTop) el.scrollTop = scrollTop;
          if (animateLeft) el.scrollLeft = scrollLeft;
          window.requestAnimationFrame(render);
        }

        window.requestAnimationFrame(render);
      });
    } // scrollTop(top, duration, easing, callback) {


    function scrollTop() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var top = args[0],
          duration = args[1],
          easing = args[2],
          callback = args[3];

      if (args.length === 3 && typeof easing === 'function') {
        top = args[0];
        duration = args[1];
        callback = args[2];
        easing = args[3];
      }

      var dom = this;

      if (typeof top === 'undefined') {
        if (dom.length > 0) return dom[0].scrollTop;
        return null;
      }

      return dom.scrollTo(undefined, top, duration, easing, callback);
    }

    function scrollLeft() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var left = args[0],
          duration = args[1],
          easing = args[2],
          callback = args[3];

      if (args.length === 3 && typeof easing === 'function') {
        left = args[0];
        duration = args[1];
        callback = args[2];
        easing = args[3];
      }

      var dom = this;

      if (typeof left === 'undefined') {
        if (dom.length > 0) return dom[0].scrollLeft;
        return null;
      }

      return dom.scrollTo(left, undefined, duration, easing, callback);
    }

    function animate(initialProps, initialParams) {
      var window = getWindow();
      var els = this;
      var a = {
        props: Object.assign({}, initialProps),
        params: Object.assign({
          duration: 300,
          easing: 'swing' // or 'linear'

          /* Callbacks
          begin(elements)
          complete(elements)
          progress(elements, complete, remaining, start, tweenValue)
          */

        }, initialParams),
        elements: els,
        animating: false,
        que: [],
        easingProgress: function easingProgress(easing, progress) {
          if (easing === 'swing') {
            return 0.5 - Math.cos(progress * Math.PI) / 2;
          }

          if (typeof easing === 'function') {
            return easing(progress);
          }

          return progress;
        },
        stop: function stop() {
          if (a.frameId) {
            window.cancelAnimationFrame(a.frameId);
          }

          a.animating = false;
          a.elements.each(function (el) {
            var element = el;
            delete element.dom7AnimateInstance;
          });
          a.que = [];
        },
        done: function done(complete) {
          a.animating = false;
          a.elements.each(function (el) {
            var element = el;
            delete element.dom7AnimateInstance;
          });
          if (complete) complete(els);

          if (a.que.length > 0) {
            var que = a.que.shift();
            a.animate(que[0], que[1]);
          }
        },
        animate: function animate(props, params) {
          if (a.animating) {
            a.que.push([props, params]);
            return a;
          }

          var elements = []; // Define & Cache Initials & Units

          a.elements.each(function (el, index) {
            var initialFullValue;
            var initialValue;
            var unit;
            var finalValue;
            var finalFullValue;
            if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;
            elements[index] = {
              container: el
            };
            Object.keys(props).forEach(function (prop) {
              initialFullValue = window.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
              initialValue = parseFloat(initialFullValue);
              unit = initialFullValue.replace(initialValue, '');
              finalValue = parseFloat(props[prop]);
              finalFullValue = props[prop] + unit;
              elements[index][prop] = {
                initialFullValue: initialFullValue,
                initialValue: initialValue,
                unit: unit,
                finalValue: finalValue,
                finalFullValue: finalFullValue,
                currentValue: initialValue
              };
            });
          });
          var startTime = null;
          var time;
          var elementsDone = 0;
          var propsDone = 0;
          var done;
          var began = false;
          a.animating = true;

          function render() {
            time = new Date().getTime();
            var progress;
            var easeProgress; // let el;

            if (!began) {
              began = true;
              if (params.begin) params.begin(els);
            }

            if (startTime === null) {
              startTime = time;
            }

            if (params.progress) {
              // eslint-disable-next-line
              params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), startTime + params.duration - time < 0 ? 0 : startTime + params.duration - time, startTime);
            }

            elements.forEach(function (element) {
              var el = element;
              if (done || el.done) return;
              Object.keys(props).forEach(function (prop) {
                if (done || el.done) return;
                progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
                easeProgress = a.easingProgress(params.easing, progress);
                var _el$prop = el[prop],
                    initialValue = _el$prop.initialValue,
                    finalValue = _el$prop.finalValue,
                    unit = _el$prop.unit;
                el[prop].currentValue = initialValue + easeProgress * (finalValue - initialValue);
                var currentValue = el[prop].currentValue;

                if (finalValue > initialValue && currentValue >= finalValue || finalValue < initialValue && currentValue <= finalValue) {
                  el.container.style[prop] = finalValue + unit;
                  propsDone += 1;

                  if (propsDone === Object.keys(props).length) {
                    el.done = true;
                    elementsDone += 1;
                  }

                  if (elementsDone === elements.length) {
                    done = true;
                  }
                }

                if (done) {
                  a.done(params.complete);
                  return;
                }

                el.container.style[prop] = currentValue + unit;
              });
            });
            if (done) return; // Then call

            a.frameId = window.requestAnimationFrame(render);
          }

          a.frameId = window.requestAnimationFrame(render);
          return a;
        }
      };

      if (a.elements.length === 0) {
        return els;
      }

      var animateInstance;

      for (var i = 0; i < a.elements.length; i += 1) {
        if (a.elements[i].dom7AnimateInstance) {
          animateInstance = a.elements[i].dom7AnimateInstance;
        } else a.elements[i].dom7AnimateInstance = a;
      }

      if (!animateInstance) {
        animateInstance = a;
      }

      if (initialProps === 'stop') {
        animateInstance.stop();
      } else {
        animateInstance.animate(a.props, a.params);
      }

      return els;
    }

    function stop() {
      var els = this;

      for (var i = 0; i < els.length; i += 1) {
        if (els[i].dom7AnimateInstance) {
          els[i].dom7AnimateInstance.stop();
        }
      }
    }

    var noTrigger = 'resize scroll'.split(' ');

    function shortcut(name) {
      function eventHandler() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (typeof args[0] === 'undefined') {
          for (var i = 0; i < this.length; i += 1) {
            if (noTrigger.indexOf(name) < 0) {
              if (name in this[i]) this[i][name]();else {
                $$1(this[i]).trigger(name);
              }
            }
          }

          return this;
        }

        return this.on.apply(this, [name].concat(args));
      }

      return eventHandler;
    }

    var click = shortcut('click');
    var blur = shortcut('blur');
    var focus = shortcut('focus');
    var focusin = shortcut('focusin');
    var focusout = shortcut('focusout');
    var keyup = shortcut('keyup');
    var keydown = shortcut('keydown');
    var keypress = shortcut('keypress');
    var submit = shortcut('submit');
    var change = shortcut('change');
    var mousedown = shortcut('mousedown');
    var mousemove = shortcut('mousemove');
    var mouseup = shortcut('mouseup');
    var mouseenter = shortcut('mouseenter');
    var mouseleave = shortcut('mouseleave');
    var mouseout = shortcut('mouseout');
    var mouseover = shortcut('mouseover');
    var touchstart = shortcut('touchstart');
    var touchend = shortcut('touchend');
    var touchmove = shortcut('touchmove');
    var resize = shortcut('resize');
    var scroll = shortcut('scroll');

    var methods = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': $$1,
        $: $$1,
        add: add,
        addClass: addClass,
        animate: animate,
        animationEnd: animationEnd,
        append: append$1,
        appendTo: appendTo,
        attr: attr$1,
        blur: blur,
        change: change,
        children: children$1,
        click: click,
        closest: closest,
        css: css,
        data: data,
        dataset: dataset,
        detach: detach$1,
        each: each,
        empty: empty$1,
        eq: eq,
        filter: filter,
        find: find,
        focus: focus,
        focusin: focusin,
        focusout: focusout,
        hasClass: hasClass,
        height: height,
        hide: hide,
        html: html,
        index: index,
        insertAfter: insertAfter,
        insertBefore: insertBefore$1,
        is: is,
        keydown: keydown,
        keypress: keypress,
        keyup: keyup,
        mousedown: mousedown,
        mouseenter: mouseenter,
        mouseleave: mouseleave,
        mousemove: mousemove,
        mouseout: mouseout,
        mouseover: mouseover,
        mouseup: mouseup,
        next: next,
        nextAll: nextAll,
        off: off,
        offset: offset,
        on: on,
        once: once,
        outerHeight: outerHeight,
        outerWidth: outerWidth,
        parent: parent,
        parents: parents,
        prepend: prepend,
        prependTo: prependTo,
        prev: prev,
        prevAll: prevAll,
        prop: prop,
        remove: remove,
        removeAttr: removeAttr,
        removeClass: removeClass,
        removeData: removeData,
        resize: resize,
        scroll: scroll,
        scrollLeft: scrollLeft,
        scrollTo: scrollTo,
        scrollTop: scrollTop,
        show: show,
        siblings: siblings,
        stop: stop,
        styles: styles,
        submit: submit,
        text: text$1,
        toggleClass: toggleClass,
        touchend: touchend,
        touchmove: touchmove,
        touchstart: touchstart,
        transform: transform,
        transition: transition,
        transitionEnd: transitionEnd,
        trigger: trigger,
        val: val,
        value: value,
        width: width
    });

    Object.keys(methods).forEach(function (methodName) {
      if (methodName === '$') return;
      $$1.fn[methodName] = methods[methodName];
    });
    var $ = $$1;

    var uniqueNum = 0;
    function uniqueNumber() {
      uniqueNum += 1;
      return uniqueNum;
    }
    function id(mask, map) {
      if (mask === void 0) {
        mask = 'xxxxxxxxxx';
      }

      if (map === void 0) {
        map = '0123456789abcdef';
      }

      var length = map.length;
      return mask.replace(/x/g, function () {
        return map[Math.floor(Math.random() * length)];
      });
    }
    var mdPreloaderContent = "\n  <span class=\"preloader-inner\">\n    <svg viewBox=\"0 0 36 36\">\n      <circle cx=\"18\" cy=\"18\" r=\"16\"></circle>\n    </svg>\n  </span>\n".trim();
    var iosPreloaderContent = ("\n  <span class=\"preloader-inner\">\n    " + [0, 1, 2, 3, 4, 5, 6, 7].map(function () {
      return '<span class="preloader-inner-line"></span>';
    }).join('') + "\n  </span>\n").trim();
    var auroraPreloaderContent = "\n  <span class=\"preloader-inner\">\n    <span class=\"preloader-inner-circle\"></span>\n  </span>\n";
    function eventNameToColonCase(eventName) {
      var hasColon;
      return eventName.split('').map(function (char, index) {
        if (char.match(/[A-Z]/) && index !== 0 && !hasColon) {
          hasColon = true;
          return ":" + char.toLowerCase();
        }

        return char.toLowerCase();
      }).join('');
    }
    function deleteProps(obj) {
      var object = obj;
      Object.keys(object).forEach(function (key) {
        try {
          object[key] = null;
        } catch (e) {// no setter for object
        }

        try {
          delete object[key];
        } catch (e) {// something got wrong
        }
      });
    }
    function requestAnimationFrame(callback) {
      var window = getWindow();
      return window.requestAnimationFrame(callback);
    }
    function cancelAnimationFrame(frameId) {
      var window = getWindow();
      return window.cancelAnimationFrame(frameId);
    }
    function nextTick(callback, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      return setTimeout(callback, delay);
    }
    function nextFrame$1(callback) {
      return requestAnimationFrame(function () {
        requestAnimationFrame(callback);
      });
    }
    function now$1() {
      return Date.now();
    }
    function parseUrlQuery(url) {
      var window = getWindow();
      var query = {};
      var urlToParse = url || window.location.href;
      var i;
      var params;
      var param;
      var length;

      if (typeof urlToParse === 'string' && urlToParse.length) {
        urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
        params = urlToParse.split('&').filter(function (paramsPart) {
          return paramsPart !== '';
        });
        length = params.length;

        for (i = 0; i < length; i += 1) {
          param = params[i].replace(/#\S+/g, '').split('=');
          query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param.slice(1).join('=')) || '';
        }
      }

      return query;
    }
    function getTranslate(el, axis) {
      if (axis === void 0) {
        axis = 'x';
      }

      var window = getWindow();
      var matrix;
      var curTransform;
      var transformMatrix;
      var curStyle = window.getComputedStyle(el, null);

      if (window.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;

        if (curTransform.split(',').length > 6) {
          curTransform = curTransform.split(', ').map(function (a) {
            return a.replace(',', '.');
          }).join(', ');
        } // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case


        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }

      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
          else curTransform = parseFloat(matrix[4]);
      }

      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
          else curTransform = parseFloat(matrix[5]);
      }

      return curTransform || 0;
    }
    function serializeObject(obj, parents) {
      if (parents === void 0) {
        parents = [];
      }

      if (typeof obj === 'string') return obj;
      var resultArray = [];
      var separator = '&';
      var newParents;

      function varName(name) {
        if (parents.length > 0) {
          var parentParts = '';

          for (var j = 0; j < parents.length; j += 1) {
            if (j === 0) parentParts += parents[j];else parentParts += "[" + encodeURIComponent(parents[j]) + "]";
          }

          return parentParts + "[" + encodeURIComponent(name) + "]";
        }

        return encodeURIComponent(name);
      }

      function varValue(value) {
        return encodeURIComponent(value);
      }

      Object.keys(obj).forEach(function (prop) {
        var toPush;

        if (Array.isArray(obj[prop])) {
          toPush = [];

          for (var i = 0; i < obj[prop].length; i += 1) {
            if (!Array.isArray(obj[prop][i]) && typeof obj[prop][i] === 'object') {
              newParents = parents.slice();
              newParents.push(prop);
              newParents.push(String(i));
              toPush.push(serializeObject(obj[prop][i], newParents));
            } else {
              toPush.push(varName(prop) + "[]=" + varValue(obj[prop][i]));
            }
          }

          if (toPush.length > 0) resultArray.push(toPush.join(separator));
        } else if (obj[prop] === null || obj[prop] === '') {
          resultArray.push(varName(prop) + "=");
        } else if (typeof obj[prop] === 'object') {
          // Object, convert to named array
          newParents = parents.slice();
          newParents.push(prop);
          toPush = serializeObject(obj[prop], newParents);
          if (toPush !== '') resultArray.push(toPush);
        } else if (typeof obj[prop] !== 'undefined' && obj[prop] !== '') {
          // Should be string or plain value
          resultArray.push(varName(prop) + "=" + varValue(obj[prop]));
        } else if (obj[prop] === '') resultArray.push(varName(prop));
      });
      return resultArray.join(separator);
    }
    function isObject$1(o) {
      return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
    }
    function merge() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var to = args[0];
      args.splice(0, 1);
      var from = args;

      for (var i = 0; i < from.length; i += 1) {
        var nextSource = args[i];

        if (nextSource !== undefined && nextSource !== null) {
          var keysArray = Object.keys(Object(nextSource));

          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }

      return to;
    }
    function extend$1() {
      var deep = true;
      var to;
      var from;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (typeof args[0] === 'boolean') {
        deep = args[0];
        to = args[1];
        args.splice(0, 2);
        from = args;
      } else {
        to = args[0];
        args.splice(0, 1);
        from = args;
      }

      for (var i = 0; i < from.length; i += 1) {
        var nextSource = args[i];

        if (nextSource !== undefined && nextSource !== null) {
          var keysArray = Object.keys(Object(nextSource));

          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              if (!deep) {
                to[nextKey] = nextSource[nextKey];
              } else if (isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
                extend$1(to[nextKey], nextSource[nextKey]);
              } else if (!isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
                to[nextKey] = {};
                extend$1(to[nextKey], nextSource[nextKey]);
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }

      return to;
    }
    function colorHexToRgb(hex) {
      var h = hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);
      return result ? result.slice(1).map(function (n) {
        return parseInt(n, 16);
      }) : null;
    }
    function colorRgbToHex(r, g, b) {
      var result = [r, g, b].map(function (n) {
        var hex = n.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      }).join('');
      return "#" + result;
    }
    function colorRgbToHsl(r, g, b) {
      r /= 255; // eslint-disable-line

      g /= 255; // eslint-disable-line

      b /= 255; // eslint-disable-line

      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var d = max - min;
      var h;
      if (d === 0) h = 0;else if (max === r) h = (g - b) / d % 6;else if (max === g) h = (b - r) / d + 2;else if (max === b) h = (r - g) / d + 4;
      var l = (min + max) / 2;
      var s = d === 0 ? 0 : d / (1 - Math.abs(2 * l - 1));
      if (h < 0) h = 360 / 60 + h;
      return [h * 60, s, l];
    }
    function colorHslToRgb(h, s, l) {
      var c = (1 - Math.abs(2 * l - 1)) * s;
      var hp = h / 60;
      var x = c * (1 - Math.abs(hp % 2 - 1));
      var rgb1;

      if (Number.isNaN(h) || typeof h === 'undefined') {
        rgb1 = [0, 0, 0];
      } else if (hp <= 1) rgb1 = [c, x, 0];else if (hp <= 2) rgb1 = [x, c, 0];else if (hp <= 3) rgb1 = [0, c, x];else if (hp <= 4) rgb1 = [0, x, c];else if (hp <= 5) rgb1 = [x, 0, c];else if (hp <= 6) rgb1 = [c, 0, x];

      var m = l - c / 2;
      return rgb1.map(function (n) {
        return Math.max(0, Math.min(255, Math.round(255 * (n + m))));
      });
    }
    function colorHsbToHsl(h, s, b) {
      var HSL = {
        h: h,
        s: 0,
        l: 0
      };
      var HSB = {
        h: h,
        s: s,
        b: b
      };
      HSL.l = (2 - HSB.s) * HSB.b / 2;
      HSL.s = HSL.l && HSL.l < 1 ? HSB.s * HSB.b / (HSL.l < 0.5 ? HSL.l * 2 : 2 - HSL.l * 2) : HSL.s;
      return [HSL.h, HSL.s, HSL.l];
    }
    function colorHslToHsb(h, s, l) {
      var HSB = {
        h: h,
        s: 0,
        b: 0
      };
      var HSL = {
        h: h,
        s: s,
        l: l
      };
      var t = HSL.s * (HSL.l < 0.5 ? HSL.l : 1 - HSL.l);
      HSB.b = HSL.l + t;
      HSB.s = HSL.l > 0 ? 2 * t / HSB.b : HSB.s;
      return [HSB.h, HSB.s, HSB.b];
    }
    function colorThemeCSSProperties() {
      var hex;
      var rgb;

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      if (args.length === 1) {
        hex = args[0];
        rgb = colorHexToRgb(hex);
      } else if (args.length === 3) {
        rgb = args;
        hex = colorRgbToHex.apply(void 0, rgb);
      }

      if (!rgb) return {};
      var hsl = colorRgbToHsl.apply(void 0, rgb);
      var hslShade = [hsl[0], hsl[1], Math.max(0, hsl[2] - 0.08)];
      var hslTint = [hsl[0], hsl[1], Math.max(0, hsl[2] + 0.08)];
      var shade = colorRgbToHex.apply(void 0, colorHslToRgb.apply(void 0, hslShade));
      var tint = colorRgbToHex.apply(void 0, colorHslToRgb.apply(void 0, hslTint));
      return {
        '--f7-theme-color': hex,
        '--f7-theme-color-rgb': rgb.join(', '),
        '--f7-theme-color-shade': shade,
        '--f7-theme-color-tint': tint
      };
    }
    function bindMethods(instance, obj) {
      Object.keys(obj).forEach(function (key) {
        if (isObject$1(obj[key])) {
          Object.keys(obj[key]).forEach(function (subKey) {
            if (typeof obj[key][subKey] === 'function') {
              obj[key][subKey] = obj[key][subKey].bind(instance);
            }
          });
        }

        instance[key] = obj[key];
      });
    }
    function flattenArray() {
      var arr = [];

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      args.forEach(function (arg) {
        if (Array.isArray(arg)) arr.push.apply(arr, flattenArray.apply(void 0, arg));else arr.push(arg);
      });
      return arr;
    }

    var utils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        uniqueNumber: uniqueNumber,
        id: id,
        mdPreloaderContent: mdPreloaderContent,
        iosPreloaderContent: iosPreloaderContent,
        auroraPreloaderContent: auroraPreloaderContent,
        eventNameToColonCase: eventNameToColonCase,
        deleteProps: deleteProps,
        requestAnimationFrame: requestAnimationFrame,
        cancelAnimationFrame: cancelAnimationFrame,
        nextTick: nextTick,
        nextFrame: nextFrame$1,
        now: now$1,
        parseUrlQuery: parseUrlQuery,
        getTranslate: getTranslate,
        serializeObject: serializeObject,
        isObject: isObject$1,
        merge: merge,
        extend: extend$1,
        colorHexToRgb: colorHexToRgb,
        colorRgbToHex: colorRgbToHex,
        colorRgbToHsl: colorRgbToHsl,
        colorHslToRgb: colorHslToRgb,
        colorHsbToHsl: colorHsbToHsl,
        colorHslToHsb: colorHslToHsb,
        colorThemeCSSProperties: colorThemeCSSProperties,
        bindMethods: bindMethods,
        flattenArray: flattenArray
    });

    var support;

    function calcSupport() {
      var window = getWindow();
      var document = getDocument();
      return {
        touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
        pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,
        passiveListener: function checkPassiveListener() {
          var supportsPassive = false;

          try {
            var opts = Object.defineProperty({}, 'passive', {
              // eslint-disable-next-line
              get: function get() {
                supportsPassive = true;
              }
            });
            window.addEventListener('testPassiveListener', null, opts);
          } catch (e) {// No support
          }

          return supportsPassive;
        }(),
        intersectionObserver: function checkObserver() {
          return 'IntersectionObserver' in window;
        }()
      };
    }

    function getSupport() {
      if (!support) {
        support = calcSupport();
      }

      return support;
    }

    var deviceCalculated;

    function calcDevice(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          userAgent = _ref.userAgent;

      var support = getSupport();
      var window = getWindow();
      var platform = window.navigator.platform;
      var ua = userAgent || window.navigator.userAgent;
      var device = {
        ios: false,
        android: false,
        androidChrome: false,
        desktop: false,
        iphone: false,
        ipod: false,
        ipad: false,
        edge: false,
        ie: false,
        firefox: false,
        macos: false,
        windows: false,
        cordova: !!(window.cordova || window.phonegap),
        phonegap: !!(window.cordova || window.phonegap),
        electron: false,
        capacitor: !!window.Capacitor,
        nwjs: false
      };
      var screenWidth = window.screen.width;
      var screenHeight = window.screen.height;
      var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

      var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      var iphone = !ipad && ua.match(/(iPhone\sOS|iOS|iPhone;\sCPU\sOS)\s([\d_]+)/);
      var ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
      var edge = ua.indexOf('Edge/') >= 0;
      var firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;
      var windows = platform === 'Win32';
      var electron = ua.toLowerCase().indexOf('electron') >= 0;
      var nwjs = typeof nw !== 'undefined' && typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.nw !== 'undefined';
      var macos = platform === 'MacIntel'; // iPadOs 13 fix

      var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

      if (!ipad && macos && support.touch && iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [0, 1, '13_0_0'];
        macos = false;
      }

      device.ie = ie;
      device.edge = edge;
      device.firefox = firefox; // Android

      if (android) {
        device.os = 'android';
        device.osVersion = android[2];
        device.android = true;
        device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
      }

      if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
      } // iOS


      if (iphone && !ipod) {
        device.osVersion = iphone[2].replace(/_/g, '.');
        device.iphone = true;
      }

      if (ipad) {
        device.osVersion = ipad[2].replace(/_/g, '.');
        device.ipad = true;
      }

      if (ipod) {
        device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
        device.ipod = true;
      } // iOS 8+ changed UA


      if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
        if (device.osVersion.split('.')[0] === '10') {
          device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
        }
      } // Webview


      device.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || window.navigator.standalone)) || window.matchMedia && window.matchMedia('(display-mode: standalone)').matches;
      device.webview = device.webView;
      device.standalone = device.webView; // Desktop

      device.desktop = !(device.ios || device.android) || electron || nwjs;

      if (device.desktop) {
        device.electron = electron;
        device.nwjs = nwjs;
        device.macos = macos;
        device.windows = windows;

        if (device.macos) {
          device.os = 'macos';
        }

        if (device.windows) {
          device.os = 'windows';
        }
      } // Pixel Ratio


      device.pixelRatio = window.devicePixelRatio || 1; // Color Scheme

      var DARK = '(prefers-color-scheme: dark)';
      var LIGHT = '(prefers-color-scheme: light)';

      device.prefersColorScheme = function prefersColorTheme() {
        var theme;

        if (window.matchMedia && window.matchMedia(LIGHT).matches) {
          theme = 'light';
        }

        if (window.matchMedia && window.matchMedia(DARK).matches) {
          theme = 'dark';
        }

        return theme;
      }; // Export object


      return device;
    }

    function getDevice(overrides, reset) {
      if (overrides === void 0) {
        overrides = {};
      }

      if (!deviceCalculated || reset) {
        deviceCalculated = calcDevice(overrides);
      }

      return deviceCalculated;
    }

    var EventsClass = /*#__PURE__*/function () {
      function EventsClass(parents) {
        if (parents === void 0) {
          parents = [];
        }

        var self = this;
        self.eventsParents = parents;
        self.eventsListeners = {};
      }

      var _proto = EventsClass.prototype;

      _proto.on = function on(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;
        var method = priority ? 'unshift' : 'push';
        events.split(' ').forEach(function (event) {
          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
          self.eventsListeners[event][method](handler);
        });
        return self;
      };

      _proto.once = function once(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;

        function onceHandler() {
          self.off(events, onceHandler);

          if (onceHandler.f7proxy) {
            delete onceHandler.f7proxy;
          }

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          handler.apply(self, args);
        }

        onceHandler.f7proxy = handler;
        return self.on(events, onceHandler, priority);
      };

      _proto.off = function off(events, handler) {
        var self = this;
        if (!self.eventsListeners) return self;
        events.split(' ').forEach(function (event) {
          if (typeof handler === 'undefined') {
            self.eventsListeners[event] = [];
          } else if (self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(function (eventHandler, index) {
              if (eventHandler === handler || eventHandler.f7proxy && eventHandler.f7proxy === handler) {
                self.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self;
      };

      _proto.emit = function emit() {
        var self = this;
        if (!self.eventsListeners) return self;
        var events;
        var data;
        var context;
        var eventsParents;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          events = args[0];
          data = args.slice(1, args.length);
          context = self;
          eventsParents = self.eventsParents;
        } else {
          events = args[0].events;
          data = args[0].data;
          context = args[0].context || self;
          eventsParents = args[0].local ? [] : args[0].parents || self.eventsParents;
        }

        var eventsArray = Array.isArray(events) ? events : events.split(' ');
        var localEvents = eventsArray.map(function (eventName) {
          return eventName.replace('local::', '');
        });
        var parentEvents = eventsArray.filter(function (eventName) {
          return eventName.indexOf('local::') < 0;
        });
        localEvents.forEach(function (event) {
          if (self.eventsListeners && self.eventsListeners[event]) {
            var handlers = [];
            self.eventsListeners[event].forEach(function (eventHandler) {
              handlers.push(eventHandler);
            });
            handlers.forEach(function (eventHandler) {
              eventHandler.apply(context, data);
            });
          }
        });

        if (eventsParents && eventsParents.length > 0) {
          eventsParents.forEach(function (eventsParent) {
            eventsParent.emit.apply(eventsParent, [parentEvents].concat(data));
          });
        }

        return self;
      };

      return EventsClass;
    }();

    var EventsClass$1 = EventsClass;

    function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }

    function _assertThisInitialized$6(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$6(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$8(subClass, superClass); }

    function _setPrototypeOf$8(o, p) { _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$8(o, p); }

    var Framework7Class = /*#__PURE__*/function (_EventsClass) {
      _inheritsLoose$6(Framework7Class, _EventsClass);

      function Framework7Class(params, parents) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        if (parents === void 0) {
          parents = [];
        }

        _this = _EventsClass.call(this, parents) || this;

        var self = _assertThisInitialized$6(_this);

        self.params = params;

        if (self.params && self.params.on) {
          Object.keys(self.params.on).forEach(function (eventName) {
            self.on(eventName, self.params.on[eventName]);
          });
        }

        return _this;
      } // eslint-disable-next-line


      var _proto = Framework7Class.prototype;

      _proto.useModuleParams = function useModuleParams(module, instanceParams) {
        if (module.params) {
          var originalParams = {};
          Object.keys(module.params).forEach(function (paramKey) {
            if (typeof instanceParams[paramKey] === 'undefined') return;
            originalParams[paramKey] = extend$1({}, instanceParams[paramKey]);
          });
          extend$1(instanceParams, module.params);
          Object.keys(originalParams).forEach(function (paramKey) {
            extend$1(instanceParams[paramKey], originalParams[paramKey]);
          });
        }
      };

      _proto.useModulesParams = function useModulesParams(instanceParams) {
        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function (moduleName) {
          var module = instance.modules[moduleName]; // Extend params

          if (module.params) {
            extend$1(instanceParams, module.params);
          }
        });
      };

      _proto.useModule = function useModule(moduleName, moduleParams) {
        if (moduleName === void 0) {
          moduleName = '';
        }

        if (moduleParams === void 0) {
          moduleParams = {};
        }

        var instance = this;
        if (!instance.modules) return;
        var module = typeof moduleName === 'string' ? instance.modules[moduleName] : moduleName;
        if (!module) return; // Extend instance methods and props

        if (module.instance) {
          Object.keys(module.instance).forEach(function (modulePropName) {
            var moduleProp = module.instance[modulePropName];

            if (typeof moduleProp === 'function') {
              instance[modulePropName] = moduleProp.bind(instance);
            } else {
              instance[modulePropName] = moduleProp;
            }
          });
        } // Add event listeners


        if (module.on && instance.on) {
          Object.keys(module.on).forEach(function (moduleEventName) {
            instance.on(moduleEventName, module.on[moduleEventName]);
          });
        } // Add vnode hooks


        if (module.vnode) {
          if (!instance.vnodeHooks) instance.vnodeHooks = {};
          Object.keys(module.vnode).forEach(function (vnodeId) {
            Object.keys(module.vnode[vnodeId]).forEach(function (hookName) {
              var handler = module.vnode[vnodeId][hookName];
              if (!instance.vnodeHooks[hookName]) instance.vnodeHooks[hookName] = {};
              if (!instance.vnodeHooks[hookName][vnodeId]) instance.vnodeHooks[hookName][vnodeId] = [];
              instance.vnodeHooks[hookName][vnodeId].push(handler.bind(instance));
            });
          });
        } // Module create callback


        if (module.create) {
          module.create.bind(instance)(moduleParams);
        }
      };

      _proto.useModules = function useModules(modulesParams) {
        if (modulesParams === void 0) {
          modulesParams = {};
        }

        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function (moduleName) {
          var moduleParams = modulesParams[moduleName] || {};
          instance.useModule(moduleName, moduleParams);
        });
      };

      Framework7Class.installModule = function installModule(module) {
        var Class = this;
        if (!Class.prototype.modules) Class.prototype.modules = {};
        var name = module.name || Object.keys(Class.prototype.modules).length + "_" + now$1();
        Class.prototype.modules[name] = module; // Prototype

        if (module.proto) {
          Object.keys(module.proto).forEach(function (key) {
            Class.prototype[key] = module.proto[key];
          });
        } // Class


        if (module.static) {
          Object.keys(module.static).forEach(function (key) {
            Class[key] = module.static[key];
          });
        } // Callback


        if (module.install) {
          for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            params[_key - 1] = arguments[_key];
          }

          module.install.apply(Class, params);
        }

        return Class;
      };

      Framework7Class.use = function use(module) {
        var Class = this;

        if (Array.isArray(module)) {
          module.forEach(function (m) {
            return Class.installModule(m);
          });
          return Class;
        }

        for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          params[_key2 - 1] = arguments[_key2];
        }

        return Class.installModule.apply(Class, [module].concat(params));
      };

      _createClass$1(Framework7Class, null, [{
        key: "components",
        set: function set(components) {
          var Class = this;
          if (!Class.use) return;
          Class.use(components);
        }
      }]);

      return Framework7Class;
    }(EventsClass$1);

    var Framework7Class$1 = Framework7Class;

    function _construct$2(Parent, args, Class) { if (_isNativeReflectConstruct$2()) { _construct$2 = Reflect.construct; } else { _construct$2 = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf$7(instance, Class.prototype); return instance; }; } return _construct$2.apply(null, arguments); }

    function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

    function _setPrototypeOf$7(o, p) { _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$7(o, p); }
    function ConstructorMethods(parameters) {
      if (parameters === void 0) {
        parameters = {};
      }

      var _parameters = parameters,
          defaultSelector = _parameters.defaultSelector,
          Constructor = _parameters.constructor,
          domProp = _parameters.domProp,
          app = _parameters.app,
          addMethods = _parameters.addMethods;
      var methods = {
        create: function create() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (app) return _construct$2(Constructor, [app].concat(args));
          return _construct$2(Constructor, args);
        },
        get: function get(el) {
          if (el === void 0) {
            el = defaultSelector;
          }

          if (el instanceof Constructor) return el;
          var $el = $(el);
          if ($el.length === 0) return undefined;
          return $el[0][domProp];
        },
        destroy: function destroy(el) {
          var instance = methods.get(el);
          if (instance && instance.destroy) return instance.destroy();
          return undefined;
        }
      };

      if (addMethods && Array.isArray(addMethods)) {
        addMethods.forEach(function (methodName) {
          methods[methodName] = function (el) {
            if (el === void 0) {
              el = defaultSelector;
            }

            var instance = methods.get(el);

            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }

            if (instance && instance[methodName]) return instance[methodName].apply(instance, args);
            return undefined;
          };
        });
      }

      return methods;
    }

    function _extends$3() { _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }
    function ModalMethods(parameters) {
      if (parameters === void 0) {
        parameters = {};
      }

      var _parameters = parameters,
          defaultSelector = _parameters.defaultSelector,
          Constructor = _parameters.constructor,
          app = _parameters.app;
      var methods = extend$1(ConstructorMethods({
        defaultSelector: defaultSelector,
        constructor: Constructor,
        app: app,
        domProp: 'f7Modal'
      }), {
        open: function open(el, animate, targetEl) {
          var $el = $(el);

          if ($el.length > 1 && targetEl) {
            // check if same modal in other page
            var $targetPage = $(targetEl).parents('.page');

            if ($targetPage.length) {
              $el.each(function (modalEl) {
                var $modalEl = $(modalEl);

                if ($modalEl.parents($targetPage)[0] === $targetPage[0]) {
                  $el = $modalEl;
                }
              });
            }
          }

          if ($el.length > 1) {
            $el = $el.eq($el.length - 1);
          }

          if (!$el.length) return undefined;
          var instance = $el[0].f7Modal;

          if (!instance) {
            var params = $el.dataset();
            instance = new Constructor(app, _extends$3({
              el: $el
            }, params));
          }

          return instance.open(animate);
        },
        close: function close(el, animate, targetEl) {
          if (el === void 0) {
            el = defaultSelector;
          }

          var $el = $(el);
          if (!$el.length) return undefined;

          if ($el.length > 1) {
            // check if close link (targetEl) in this modal
            var $parentEl;

            if (targetEl) {
              var $targetEl = $(targetEl);

              if ($targetEl.length) {
                $parentEl = $targetEl.parents($el);
              }
            }

            if ($parentEl && $parentEl.length > 0) {
              $el = $parentEl;
            } else {
              $el = $el.eq($el.length - 1);
            }
          }

          var instance = $el[0].f7Modal;

          if (!instance) {
            var params = $el.dataset();
            instance = new Constructor(app, _extends$3({
              el: $el
            }, params));
          }

          return instance.close(animate);
        }
      });
      return methods;
    }

    var fetchedModules = [];

    function loadModule(moduleToLoad) {
      var Framework7 = this;
      var window = getWindow();
      var document = getDocument();
      return new Promise(function (resolve, reject) {
        var app = Framework7.instance;
        var modulePath;
        var moduleObj;
        var moduleFunc;

        if (!moduleToLoad) {
          reject(new Error('Framework7: Lazy module must be specified'));
          return;
        }

        function install(module) {
          Framework7.use(module);

          if (app) {
            app.useModuleParams(module, app.params);
            app.useModule(module);
          }
        }

        if (typeof moduleToLoad === 'string') {
          var matchNamePattern = moduleToLoad.match(/([a-z0-9-]*)/i);

          if (moduleToLoad.indexOf('.') < 0 && matchNamePattern && matchNamePattern[0].length === moduleToLoad.length) {
            if (!app || app && !app.params.lazyModulesPath) {
              reject(new Error('Framework7: "lazyModulesPath" app parameter must be specified to fetch module by name'));
              return;
            }

            modulePath = app.params.lazyModulesPath + "/" + moduleToLoad + "/" + moduleToLoad + ".js";
          } else {
            modulePath = moduleToLoad;
          }
        } else if (typeof moduleToLoad === 'function') {
          moduleFunc = moduleToLoad;
        } else {
          // considering F7-Plugin object
          moduleObj = moduleToLoad;
        }

        if (moduleFunc) {
          var module = moduleFunc(Framework7, false);

          if (!module) {
            reject(new Error("Framework7: Can't find Framework7 component in specified component function"));
            return;
          } // Check if it was added


          if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
            resolve();
            return;
          } // Install It


          install(module);
          resolve();
        }

        if (moduleObj) {
          var _module = moduleObj;

          if (!_module) {
            reject(new Error("Framework7: Can't find Framework7 component in specified component"));
            return;
          } // Check if it was added


          if (Framework7.prototype.modules && Framework7.prototype.modules[_module.name]) {
            resolve();
            return;
          } // Install It


          install(_module);
          resolve();
        }

        if (modulePath) {
          if (fetchedModules.indexOf(modulePath) >= 0) {
            resolve();
            return;
          }

          fetchedModules.push(modulePath);
          var scriptLoad = new Promise(function (resolveScript, rejectScript) {
            Framework7.request.get(modulePath, function (scriptContent) {
              var callbackId = id();
              var callbackLoadName = "f7_component_loader_callback_" + callbackId;
              var scriptEl = document.createElement('script');
              scriptEl.innerHTML = "window." + callbackLoadName + " = function (Framework7, Framework7AutoInstallComponent) {return " + scriptContent.trim() + "}";
              $('head').append(scriptEl);
              var componentLoader = window[callbackLoadName];
              delete window[callbackLoadName];
              $(scriptEl).remove();
              var module = componentLoader(Framework7, false);

              if (!module) {
                rejectScript(new Error("Framework7: Can't find Framework7 component in " + modulePath + " file"));
                return;
              } // Check if it was added


              if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
                resolveScript();
                return;
              } // Install It


              install(module);
              resolveScript();
            }, function (xhr, status) {
              rejectScript(xhr, status);
            });
          });
          var styleLoad = new Promise(function (resolveStyle) {
            Framework7.request.get(modulePath.replace('.js', app.rtl ? '.rtl.css' : '.css'), function (styleContent) {
              var styleEl = document.createElement('style');
              styleEl.innerHTML = styleContent;
              $('head').append(styleEl);
              resolveStyle();
            }, function () {
              resolveStyle();
            });
          });
          Promise.all([scriptLoad, styleLoad]).then(function () {
            resolve();
          }).catch(function (err) {
            reject(err);
          });
        }
      });
    }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    function _assertThisInitialized$5(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$5(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$6(subClass, superClass); }

    function _setPrototypeOf$6(o, p) { _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$6(o, p); }

    var Framework7 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$5(Framework7, _Framework7Class);

      function Framework7(params) {
        var _this;

        if (params === void 0) {
          params = {};
        }

        _this = _Framework7Class.call(this, params) || this; // eslint-disable-next-line

        if (Framework7.instance && typeof window !== 'undefined') {
          throw new Error("Framework7 is already initialized and can't be initialized more than once");
        }

        var device = getDevice({
          userAgent: params.userAgent || undefined
        });
        var support = getSupport();
        var passedParams = extend$1({}, params); // App Instance

        var app = _assertThisInitialized$5(_this);

        app.device = device;
        app.support = support;
        var w = getWindow();
        var d = getDocument();
        Framework7.instance = app; // Default

        var defaults = {
          version: '1.0.0',
          id: 'io.framework7.myapp',
          el: 'body',
          theme: 'auto',
          language: w.navigator.language,
          routes: [],
          name: 'Framework7',
          lazyModulesPath: null,
          initOnDeviceReady: true,
          init: true,
          autoDarkTheme: false,
          iosTranslucentBars: true,
          iosTranslucentModals: true,
          component: undefined,
          componentUrl: undefined,
          userAgent: null,
          url: null
        }; // Extend defaults with modules params

        app.useModulesParams(defaults); // Extend defaults with passed params

        app.params = extend$1(defaults, params);
        extend$1(app, {
          // App Id
          id: app.params.id,
          // App Name
          name: app.params.name,
          // App version
          version: app.params.version,
          // Routes
          routes: app.params.routes,
          // Lang
          language: app.params.language,
          // Theme
          theme: function getTheme() {
            if (app.params.theme === 'auto') {
              if (device.ios) return 'ios';
              if (device.desktop && device.electron) return 'aurora';
              return 'md';
            }

            return app.params.theme;
          }(),
          // Initially passed parameters
          passedParams: passedParams,
          online: w.navigator.onLine
        });
        if (params.store) app.params.store = params.store; // Save Root

        if (app.$el && app.$el[0]) {
          app.$el[0].f7 = app;
        } // Install Modules


        app.useModules(); // Init Store

        app.initStore(); // Init

        if (app.params.init) {
          if (device.cordova && app.params.initOnDeviceReady) {
            $(d).on('deviceready', function () {
              app.init();
            });
          } else {
            app.init();
          }
        } // Return app instance


        return app || _assertThisInitialized$5(_this);
      }

      var _proto = Framework7.prototype;

      _proto.mount = function mount(rootEl) {
        var app = this;
        var window = getWindow();
        var document = getDocument();
        var $rootEl = $(rootEl || app.params.el).eq(0);
        app.$el = $rootEl;

        if (app.$el && app.$el[0]) {
          app.el = app.$el[0];
          app.el.f7 = app;
          app.rtl = $rootEl.css('direction') === 'rtl';
        } // Auto Dark Theme


        var DARK = '(prefers-color-scheme: dark)';
        var LIGHT = '(prefers-color-scheme: light)';
        app.mq = {};

        if (window.matchMedia) {
          app.mq.dark = window.matchMedia(DARK);
          app.mq.light = window.matchMedia(LIGHT);
        }

        app.colorSchemeListener = function colorSchemeListener(_ref) {
          var matches = _ref.matches,
              media = _ref.media;

          if (!matches) {
            return;
          }

          var html = document.querySelector('html');

          if (media === DARK) {
            html.classList.add('theme-dark');
            app.darkTheme = true;
            app.emit('darkThemeChange', true);
          } else if (media === LIGHT) {
            html.classList.remove('theme-dark');
            app.darkTheme = false;
            app.emit('darkThemeChange', false);
          }
        };

        app.emit('mount');
      };

      _proto.initStore = function initStore() {
        var app = this;

        if (typeof app.params.store !== 'undefined' && app.params.store.__store) {
          app.store = app.params.store;
        } else {
          app.store = app.createStore(app.params.store);
        }
      };

      _proto.enableAutoDarkTheme = function enableAutoDarkTheme() {
        var window = getWindow();
        var document = getDocument();
        if (!window.matchMedia) return;
        var app = this;
        var html = document.querySelector('html');

        if (app.mq.dark && app.mq.light) {
          app.mq.dark.addListener(app.colorSchemeListener);
          app.mq.light.addListener(app.colorSchemeListener);
        }

        if (app.mq.dark && app.mq.dark.matches) {
          html.classList.add('theme-dark');
          app.darkTheme = true;
          app.emit('darkThemeChange', true);
        } else if (app.mq.light && app.mq.light.matches) {
          html.classList.remove('theme-dark');
          app.darkTheme = false;
          app.emit('darkThemeChange', false);
        }
      };

      _proto.disableAutoDarkTheme = function disableAutoDarkTheme() {
        var window = getWindow();
        if (!window.matchMedia) return;
        var app = this;
        if (app.mq.dark) app.mq.dark.removeListener(app.colorSchemeListener);
        if (app.mq.light) app.mq.light.removeListener(app.colorSchemeListener);
      };

      _proto.initAppComponent = function initAppComponent(callback) {
        var app = this;
        app.router.componentLoader(app.params.component, app.params.componentUrl, {
          componentOptions: {
            el: app.$el[0]
          }
        }, function (el) {
          app.$el = $(el);
          app.$el[0].f7 = app;
          app.$elComponent = el.f7Component;
          app.el = app.$el[0];
          if (callback) callback();
        }, function () {});
      };

      _proto.init = function init(rootEl) {
        var app = this;
        app.mount(rootEl);

        var init = function init() {
          if (app.initialized) return;
          app.$el.addClass('framework7-initializing'); // RTL attr

          if (app.rtl) {
            $('html').attr('dir', 'rtl');
          } // Auto Dark Theme


          if (app.params.autoDarkTheme) {
            app.enableAutoDarkTheme();
          } // Watch for online/offline state


          var window = getWindow();
          window.addEventListener('offline', function () {
            app.online = false;
            app.emit('offline');
            app.emit('connection', false);
          });
          window.addEventListener('online', function () {
            app.online = true;
            app.emit('online');
            app.emit('connection', true);
          }); // Root class

          app.$el.addClass('framework7-root'); // Theme class

          $('html').removeClass('ios md aurora').addClass(app.theme); // iOS Translucent

          var device = app.device;

          if (app.params.iosTranslucentBars && app.theme === 'ios' && device.ios) {
            $('html').addClass('ios-translucent-bars');
          }

          if (app.params.iosTranslucentModals && app.theme === 'ios' && device.ios) {
            $('html').addClass('ios-translucent-modals');
          } // Init class


          nextFrame$1(function () {
            app.$el.removeClass('framework7-initializing');
          }); // Emit, init other modules

          app.initialized = true;
          app.emit('init');
        };

        if (app.params.component || app.params.componentUrl) {
          app.initAppComponent(function () {
            init();
          });
        } else {
          init();
        }

        return app;
      } // eslint-disable-next-line
      ;

      _proto.loadModule = function loadModule() {
        return Framework7.loadModule.apply(Framework7, arguments);
      } // eslint-disable-next-line
      ;

      _proto.loadModules = function loadModules() {
        return Framework7.loadModules.apply(Framework7, arguments);
      };

      _proto.getVnodeHooks = function getVnodeHooks(hook, id) {
        var app = this;
        if (!app.vnodeHooks || !app.vnodeHooks[hook]) return [];
        return app.vnodeHooks[hook][id] || [];
      } // eslint-disable-next-line
      ;

      _createClass(Framework7, [{
        key: "$",
        get: function get() {
          return $;
        }
      }], [{
        key: "Dom7",
        get: function get() {
          return $;
        }
      }, {
        key: "$",
        get: function get() {
          return $;
        }
      }, {
        key: "device",
        get: function get() {
          return getDevice();
        }
      }, {
        key: "support",
        get: function get() {
          return getSupport();
        }
      }, {
        key: "Class",
        get: function get() {
          return Framework7Class$1;
        }
      }, {
        key: "Events",
        get: function get() {
          return EventsClass$1;
        }
      }]);

      return Framework7;
    }(Framework7Class$1);

    Framework7.ModalMethods = ModalMethods;
    Framework7.ConstructorMethods = ConstructorMethods;
    Framework7.loadModule = loadModule;

    Framework7.loadModules = function loadModules(modules) {
      return Promise.all(modules.map(function (module) {
        return Framework7.loadModule(module);
      }));
    };

    var Framework7$1 = Framework7;

    function _assertThisInitialized$4(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$4(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$5(subClass, superClass); }

    function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct$1(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf$5(Wrapper, Class); }; return _wrapNativeSuper(Class); }

    function _construct$1(Parent, args, Class) { if (_isNativeReflectConstruct$1()) { _construct$1 = Reflect.construct; } else { _construct$1 = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf$5(instance, Class.prototype); return instance; }; } return _construct$1.apply(null, arguments); }

    function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

    function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

    function _setPrototypeOf$5(o, p) { _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$5(o, p); }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
    var globals = {};
    var jsonpRequests = 0;

    var RequestResponse = function RequestResponse(obj) {
      Object.assign(this, obj);
    };

    var RequestError = /*#__PURE__*/function (_Error) {
      _inheritsLoose$4(RequestError, _Error);

      function RequestError(obj) {
        var _this;

        _this = _Error.call(this) || this;
        Object.assign(_assertThisInitialized$4(_this), obj);
        return _this;
      }

      return RequestError;
    }( /*#__PURE__*/_wrapNativeSuper(Error));

    var request = function request(requestOptions) {
      return new Promise(function (resolve, reject) {
        var window = getWindow();
        var document = getDocument();
        var globalsNoCallbacks = extend$1({}, globals);
        'beforeCreate beforeOpen beforeSend error complete success statusCode'.split(' ').forEach(function (callbackName) {
          delete globalsNoCallbacks[callbackName];
        });
        var defaults = extend$1({
          url: window.location.toString(),
          method: 'GET',
          data: false,
          async: true,
          cache: true,
          user: '',
          password: '',
          headers: {},
          xhrFields: {},
          statusCode: {},
          processData: true,
          dataType: 'text',
          contentType: 'application/x-www-form-urlencoded',
          timeout: 0
        }, globalsNoCallbacks);
        var proceedRequest;
        var options = extend$1({}, defaults, requestOptions);

        if (requestOptions.abortController) {
          options.abortController = requestOptions.abortController;
        }

        if (options.abortController && options.abortController.canceled) {
          reject(new RequestError({
            options: options,
            status: 'canceled',
            message: 'canceled'
          }));
          return;
        } // Function to run XHR callbacks and events


        function fireCallback(callbackName) {
          /*
          Callbacks:
          beforeCreate (options),
          beforeOpen (xhr, options),
          beforeSend (xhr, options),
          error (xhr, status, message),
          complete (xhr, status),
          success (response, status, xhr),
          statusCode ()
          */
          var globalCallbackValue;
          var optionCallbackValue;

          for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            data[_key - 1] = arguments[_key];
          }

          if (globals[callbackName]) {
            globalCallbackValue = globals[callbackName].apply(globals, data);
          }

          if (options[callbackName]) {
            optionCallbackValue = options[callbackName].apply(options, data);
          }

          if (typeof globalCallbackValue !== 'boolean') globalCallbackValue = true;
          if (typeof optionCallbackValue !== 'boolean') optionCallbackValue = true;

          if (options.abortController && options.abortController.canceled && (callbackName === 'beforeCreate' || callbackName === 'beforeOpen' || callbackName === 'beforeSend')) {
            return false;
          }

          return globalCallbackValue && optionCallbackValue;
        } // Before create callback


        proceedRequest = fireCallback('beforeCreate', options);

        if (proceedRequest === false) {
          reject(new RequestError({
            options: options,
            status: 'canceled',
            message: 'canceled'
          }));
          return;
        } // For jQuery guys


        if (options.type) options.method = options.type; // Parameters Prefix

        var paramsPrefix = options.url.indexOf('?') >= 0 ? '&' : '?'; // UC method

        var method = options.method.toUpperCase(); // Data to modify GET URL

        if ((method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') && options.data) {
          var stringData;

          if (typeof options.data === 'string') {
            // Should be key=value string
            if (options.data.indexOf('?') >= 0) stringData = options.data.split('?')[1];else stringData = options.data;
          } else {
            // Should be key=value object
            stringData = serializeObject(options.data);
          }

          if (stringData.length) {
            options.url += paramsPrefix + stringData;
            if (paramsPrefix === '?') paramsPrefix = '&';
          }
        } // JSONP


        if (options.dataType === 'json' && options.url.indexOf('callback=') >= 0) {
          var callbackName = "f7jsonp_" + (Date.now() + (jsonpRequests += 1));
          var abortTimeout;
          var callbackSplit = options.url.split('callback=');
          var requestUrl = callbackSplit[0] + "callback=" + callbackName;

          if (callbackSplit[1].indexOf('&') >= 0) {
            var addVars = callbackSplit[1].split('&').filter(function (el) {
              return el.indexOf('=') > 0;
            }).join('&');
            if (addVars.length > 0) requestUrl += "&" + addVars;
          } // Create script


          var script = document.createElement('script');
          script.type = 'text/javascript';

          script.onerror = function onerror() {
            clearTimeout(abortTimeout);
            fireCallback('error', null, 'scripterror', 'scripterror');
            reject(new RequestError({
              options: options,
              status: 'scripterror',
              message: 'scripterror'
            }));
            fireCallback('complete', null, 'scripterror');
          };

          script.src = requestUrl; // Handler

          window[callbackName] = function jsonpCallback(data) {
            clearTimeout(abortTimeout);
            fireCallback('success', data);
            script.parentNode.removeChild(script);
            script = null;
            delete window[callbackName];
            resolve(new RequestResponse({
              options: options,
              data: data
            }));
          };

          document.querySelector('head').appendChild(script);

          if (options.timeout > 0) {
            abortTimeout = setTimeout(function () {
              script.parentNode.removeChild(script);
              script = null;
              fireCallback('error', null, 'timeout', 'timeout');
              reject(new RequestError({
                options: options,
                status: 'timeout',
                message: 'timeout'
              }));
            }, options.timeout);
          }

          return;
        } // Cache for GET/HEAD requests


        if (method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') {
          if (options.cache === false) {
            options.url += paramsPrefix + "_nocache" + Date.now();
          }
        } // Create XHR


        var xhr = new XMLHttpRequest();

        if (options.abortController) {
          var aborted = false;

          options.abortController.onAbort = function () {
            if (aborted) return;
            aborted = true;
            xhr.abort();
            reject(new RequestError({
              options: options,
              xhr: xhr,
              status: 'canceled',
              message: 'canceled'
            }));
          };
        } // Save Request URL


        xhr.requestUrl = options.url;
        xhr.requestParameters = options; // Before open callback

        proceedRequest = fireCallback('beforeOpen', xhr, options);

        if (proceedRequest === false) {
          reject(new RequestError({
            options: options,
            xhr: xhr,
            status: 'canceled',
            message: 'canceled'
          }));
          return;
        } // Open XHR


        xhr.open(method, options.url, options.async, options.user, options.password); // Create POST Data

        var postData = null;

        if ((method === 'POST' || method === 'PUT' || method === 'PATCH') && options.data) {
          if (options.processData) {
            var postDataInstances = [ArrayBuffer, Blob, Document, FormData]; // Post Data

            if (postDataInstances.indexOf(options.data.constructor) >= 0) {
              postData = options.data;
            } else {
              // POST Headers
              var boundary = "---------------------------" + Date.now().toString(16);

              if (options.contentType === 'multipart/form-data') {
                xhr.setRequestHeader('Content-Type', "multipart/form-data; boundary=" + boundary);
              } else {
                xhr.setRequestHeader('Content-Type', options.contentType);
              }

              postData = '';
              var data = serializeObject(options.data);

              if (options.contentType === 'multipart/form-data') {
                data = data.split('&');
                var newData = [];

                for (var i = 0; i < data.length; i += 1) {
                  newData.push("Content-Disposition: form-data; name=\"" + data[i].split('=')[0] + "\"\r\n\r\n" + data[i].split('=')[1] + "\r\n");
                }

                postData = "--" + boundary + "\r\n" + newData.join("--" + boundary + "\r\n") + "--" + boundary + "--\r\n";
              } else if (options.contentType === 'application/json') {
                postData = JSON.stringify(options.data);
              } else {
                postData = data;
              }
            }
          } else {
            postData = options.data;
            xhr.setRequestHeader('Content-Type', options.contentType);
          }
        }

        if (options.dataType === 'json' && (!options.headers || !options.headers.Accept)) {
          xhr.setRequestHeader('Accept', 'application/json');
        } // Additional headers


        if (options.headers) {
          Object.keys(options.headers).forEach(function (headerName) {
            if (typeof options.headers[headerName] === 'undefined') return;
            xhr.setRequestHeader(headerName, options.headers[headerName]);
          });
        } // Check for crossDomain


        if (typeof options.crossDomain === 'undefined') {
          options.crossDomain = // eslint-disable-next-line
          /^([\w-]+:)?\/\/([^\/]+)/.test(options.url) && RegExp.$2 !== window.location.host;
        }

        if (!options.crossDomain) {
          xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
        }

        if (options.xhrFields) {
          extend$1(xhr, options.xhrFields);
        } // Handle XHR


        xhr.onload = function onload() {
          if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) {
            var responseData;

            if (options.dataType === 'json') {
              var parseError;

              try {
                responseData = JSON.parse(xhr.responseText);
              } catch (err) {
                parseError = true;
              }

              if (!parseError) {
                fireCallback('success', responseData, xhr.status, xhr);
                resolve(new RequestResponse({
                  options: options,
                  data: responseData,
                  status: xhr.status,
                  xhr: xhr
                }));
              } else {
                fireCallback('error', xhr, 'parseerror', 'parseerror');
                reject(new RequestError({
                  options: options,
                  xhr: xhr,
                  status: 'parseerror',
                  message: 'parseerror'
                }));
              }
            } else {
              responseData = xhr.responseType === 'text' || xhr.responseType === '' ? xhr.responseText : xhr.response;
              fireCallback('success', responseData, xhr.status, xhr);
              resolve(new RequestResponse({
                options: options,
                data: responseData,
                status: xhr.status,
                xhr: xhr
              }));
            }
          } else {
            fireCallback('error', xhr, xhr.status, xhr.statusText);
            reject(new RequestError({
              options: options,
              xhr: xhr,
              status: xhr.status,
              message: xhr.statusText
            }));
          }

          if (options.statusCode) {
            if (globals.statusCode && globals.statusCode[xhr.status]) globals.statusCode[xhr.status](xhr);
            if (options.statusCode[xhr.status]) options.statusCode[xhr.status](xhr);
          }

          fireCallback('complete', xhr, xhr.status);
        };

        xhr.onerror = function onerror() {
          fireCallback('error', xhr, xhr.status, xhr.status);
          reject(new RequestError({
            options: options,
            xhr: xhr,
            status: xhr.status,
            message: xhr.statusText
          }));
          fireCallback('complete', xhr, 'error');
        }; // Timeout


        if (options.timeout > 0) {
          xhr.timeout = options.timeout;

          xhr.ontimeout = function () {
            fireCallback('error', xhr, 'timeout', 'timeout');
            reject(new RequestError({
              options: options,
              xhr: xhr,
              status: 'timeout',
              message: 'timeout'
            }));
            fireCallback('complete', xhr, 'timeout');
          };
        } // Ajax start callback


        proceedRequest = fireCallback('beforeSend', xhr, options);

        if (proceedRequest === false) {
          reject(new RequestError({
            options: options,
            xhr: xhr,
            status: 'canceled',
            message: 'canceled'
          }));
          return;
        } // Send XHR


        xhr.send(postData);
      });
    };

    function requestShortcut(method) {
      var _ref = [],
          url = _ref[0],
          data = _ref[1],
          success = _ref[2],
          error = _ref[3],
          dataType = _ref[4];

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      if (typeof args[1] === 'function') {
        url = args[0];
        success = args[1];
        error = args[2];
        dataType = args[3];
      } else {
        url = args[0];
        data = args[1];
        success = args[2];
        error = args[3];
        dataType = args[4];
      }

      [success, error].forEach(function (callback) {
        if (typeof callback === 'string') {
          dataType = callback;
          if (callback === success) success = undefined;else error = undefined;
        }
      });
      dataType = dataType || (method === 'json' || method === 'postJSON' ? 'json' : undefined);
      var requestOptions = {
        url: url,
        method: method === 'post' || method === 'postJSON' ? 'POST' : 'GET',
        data: data,
        success: success,
        error: error,
        dataType: dataType
      };

      if (method === 'postJSON') {
        extend$1(requestOptions, {
          contentType: 'application/json',
          processData: false,
          crossDomain: true,
          data: typeof data === 'string' ? data : JSON.stringify(data)
        });
      }

      return request(requestOptions);
    }

    Object.assign(request, {
      get: function get() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return requestShortcut.apply(void 0, ['get'].concat(args));
      },
      post: function post() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return requestShortcut.apply(void 0, ['post'].concat(args));
      },
      json: function json() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        return requestShortcut.apply(void 0, ['json'].concat(args));
      },
      getJSON: function getJSON() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }

        return requestShortcut.apply(void 0, ['json'].concat(args));
      },
      postJSON: function postJSON() {
        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          args[_key7] = arguments[_key7];
        }

        return requestShortcut.apply(void 0, ['postJSON'].concat(args));
      }
    });

    request.abortController = function () {
      var contoller = {
        canceled: false,
        onAbort: null,
        abort: function abort() {
          contoller.canceled = true;
          if (contoller.onAbort) contoller.onAbort();
        }
      };
      return contoller;
    };

    request.setup = function setup(options) {
      if (options.type && !options.method) {
        extend$1(options, {
          method: options.type
        });
      }

      extend$1(globals, options);
    };

    var request$1 = request;

    var DeviceModule = {
      name: 'device',
      static: {
        getDevice: getDevice
      },
      on: {
        init: function init() {
          var document = getDocument();
          var device = getDevice();
          var classNames = [];
          var html = document.querySelector('html');
          var metaStatusbar = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
          if (!html) return;

          if (device.standalone && device.ios && metaStatusbar && metaStatusbar.content === 'black-translucent') {
            classNames.push('device-full-viewport');
          } // Pixel Ratio


          classNames.push("device-pixel-ratio-" + Math.floor(device.pixelRatio)); // OS classes

          if (device.os && !device.desktop) {
            classNames.push("device-" + device.os);
          } else if (device.desktop) {
            classNames.push('device-desktop');

            if (device.os) {
              classNames.push("device-" + device.os);
            }
          }

          if (device.cordova || device.phonegap) {
            classNames.push('device-cordova');
          }

          if (device.capacitor) {
            classNames.push('device-capacitor');
          } // Add html classes


          classNames.forEach(function (className) {
            html.classList.add(className);
          });
        }
      }
    };

    var SupportModule = {
      name: 'support',
      static: {
        getSupport: getSupport
      }
    };

    var UtilsModule = {
      name: 'utils',
      proto: {
        utils: utils
      },
      static: {
        utils: utils
      }
    };

    var ResizeModule = {
      name: 'resize',
      create: function create() {
        var app = this;

        app.getSize = function () {
          if (!app.el) return {
            width: 0,
            height: 0,
            left: 0,
            top: 0
          };
          var offset = app.$el.offset();
          var _ref = [app.el.offsetWidth, app.el.offsetHeight, offset.left, offset.top],
              width = _ref[0],
              height = _ref[1],
              left = _ref[2],
              top = _ref[3];
          app.width = width;
          app.height = height;
          app.left = left;
          app.top = top;
          return {
            width: width,
            height: height,
            left: left,
            top: top
          };
        };
      },
      on: {
        init: function init() {
          var app = this;
          var window = getWindow(); // Get Size

          app.getSize(); // Emit resize

          window.addEventListener('resize', function () {
            app.emit('resize');
          }, false); // Emit orientationchange

          window.addEventListener('orientationchange', function () {
            app.emit('orientationchange');
          });
        },
        orientationchange: function orientationchange() {
          var document = getDocument();
          var device = getDevice(); // Fix iPad weird body scroll

          if (device.ipad) {
            document.body.scrollLeft = 0;
            setTimeout(function () {
              document.body.scrollLeft = 0;
            }, 0);
          }
        },
        resize: function resize() {
          var app = this;
          app.getSize();
        }
      }
    };

    /* eslint no-param-reassign: "off" */
    var RequestModule = {
      name: 'request',
      proto: {
        request: request$1
      },
      static: {
        request: request$1
      }
    };

    /* eslint-disable no-nested-ternary */

    function initTouch() {
      var app = this;
      var device = getDevice();
      var support = getSupport();
      var window = getWindow();
      var document = getDocument();
      var params = app.params.touch;
      var useRipple = params[app.theme + "TouchRipple"];

      if (device.ios && device.webView) {
        // Strange hack required for iOS 8 webview to work on inputs
        window.addEventListener('touchstart', function () {});
      }

      var touchStartX;
      var touchStartY;
      var targetElement;
      var isMoved;
      var tapHoldFired;
      var tapHoldTimeout;
      var preventClick;
      var activableElement;
      var activeTimeout;
      var rippleWave;
      var rippleTarget;
      var rippleTimeout;

      function findActivableElement(el) {
        var target = $(el);
        var parents = target.parents(params.activeStateElements);

        if (target.closest('.no-active-state').length) {
          return null;
        }

        var activable;

        if (target.is(params.activeStateElements)) {
          activable = target;
        }

        if (parents.length > 0) {
          activable = activable ? activable.add(parents) : parents;
        }

        if (activable && activable.length > 1) {
          var newActivable = [];
          var preventPropagation;

          for (var i = 0; i < activable.length; i += 1) {
            if (!preventPropagation) {
              newActivable.push(activable[i]);

              if (activable.eq(i).hasClass('prevent-active-state-propagation') || activable.eq(i).hasClass('no-active-state-propagation')) {
                preventPropagation = true;
              }
            }
          }

          activable = $(newActivable);
        }

        return activable || target;
      }

      function isInsideScrollableView(el) {
        var pageContent = el.parents('.page-content');
        return pageContent.length > 0;
      }

      function addActive() {
        if (!activableElement) return;
        activableElement.addClass('active-state');
      }

      function removeActive() {
        if (!activableElement) return;
        activableElement.removeClass('active-state');
        activableElement = null;
      } // Ripple handlers


      function findRippleElement(el) {
        var rippleElements = params.touchRippleElements;
        var $el = $(el);

        if ($el.is(rippleElements)) {
          if ($el.hasClass('no-ripple')) {
            return false;
          }

          return $el;
        }

        if ($el.parents(rippleElements).length > 0) {
          var rippleParent = $el.parents(rippleElements).eq(0);

          if (rippleParent.hasClass('no-ripple')) {
            return false;
          }

          return rippleParent;
        }

        return false;
      }

      function createRipple($el, x, y) {
        if (!$el) return;
        rippleWave = app.touchRipple.create(app, $el, x, y);
      }

      function removeRipple() {
        if (!rippleWave) return;
        rippleWave.remove();
        rippleWave = undefined;
        rippleTarget = undefined;
      }

      function rippleTouchStart(el) {
        rippleTarget = findRippleElement(el);

        if (!rippleTarget || rippleTarget.length === 0) {
          rippleTarget = undefined;
          return;
        }

        var inScrollable = isInsideScrollableView(rippleTarget);

        if (!inScrollable) {
          removeRipple();
          createRipple(rippleTarget, touchStartX, touchStartY);
        } else {
          clearTimeout(rippleTimeout);
          rippleTimeout = setTimeout(function () {
            removeRipple();
            createRipple(rippleTarget, touchStartX, touchStartY);
          }, 80);
        }
      }

      function rippleTouchMove() {
        clearTimeout(rippleTimeout);
        removeRipple();
      }

      function rippleTouchEnd() {
        if (!rippleWave && rippleTarget && !isMoved) {
          clearTimeout(rippleTimeout);
          createRipple(rippleTarget, touchStartX, touchStartY);
          setTimeout(removeRipple, 0);
        } else {
          removeRipple();
        }
      } // Mouse Handlers


      function handleMouseDown(e) {
        var $activableEl = findActivableElement(e.target);

        if ($activableEl) {
          $activableEl.addClass('active-state');

          if ('which' in e && e.which === 3) {
            setTimeout(function () {
              $('.active-state').removeClass('active-state');
            }, 0);
          }
        }

        if (useRipple) {
          touchStartX = e.pageX;
          touchStartY = e.pageY;
          rippleTouchStart(e.target, e.pageX, e.pageY);
        }
      }

      function handleMouseMove() {
        if (!params.activeStateOnMouseMove) {
          $('.active-state').removeClass('active-state');
        }

        if (useRipple) {
          rippleTouchMove();
        }
      }

      function handleMouseUp() {
        $('.active-state').removeClass('active-state');

        if (useRipple) {
          rippleTouchEnd();
        }
      }

      function handleTouchCancel() {
        targetElement = null; // Remove Active State

        clearTimeout(activeTimeout);
        clearTimeout(tapHoldTimeout);

        if (params.activeState) {
          removeActive();
        } // Remove Ripple


        if (useRipple) {
          rippleTouchEnd();
        }
      }

      var isScrolling;
      var isSegmentedStrong = false;
      var segmentedStrongEl = null;
      var touchMoveActivableIos = '.dialog-button, .actions-button';
      var isTouchMoveActivable = false;
      var touchmoveActivableEl = null;

      function handleTouchStart(e) {
        isMoved = false;
        tapHoldFired = false;
        preventClick = false;
        isScrolling = undefined;

        if (e.targetTouches.length > 1) {
          if (activableElement) removeActive();
          return true;
        }

        if (e.touches.length > 1 && activableElement) {
          removeActive();
        }

        if (params.tapHold) {
          if (tapHoldTimeout) clearTimeout(tapHoldTimeout);
          tapHoldTimeout = setTimeout(function () {
            if (e && e.touches && e.touches.length > 1) return;
            tapHoldFired = true;
            e.preventDefault();
            preventClick = true;
            $(e.target).trigger('taphold', e);
            app.emit('taphold', e);
          }, params.tapHoldDelay);
        }

        targetElement = e.target;
        touchStartX = e.targetTouches[0].pageX;
        touchStartY = e.targetTouches[0].pageY;
        isSegmentedStrong = e.target.closest('.segmented-strong .button-active, .segmented-strong .tab-link-active');
        isTouchMoveActivable = app.theme === 'ios' && e.target.closest(touchMoveActivableIos);

        if (isSegmentedStrong) {
          segmentedStrongEl = isSegmentedStrong.closest('.segmented-strong');
        }

        if (params.activeState) {
          activableElement = findActivableElement(targetElement);

          if (activableElement && !isInsideScrollableView(activableElement)) {
            addActive();
          } else if (activableElement) {
            activeTimeout = setTimeout(addActive, 80);
          }
        }

        if (useRipple) {
          rippleTouchStart(targetElement);
        }

        return true;
      }

      function handleTouchMove(e) {
        var touch;
        var distance;
        var shouldRemoveActive = true;

        if (e.type === 'touchmove') {
          touch = e.targetTouches[0];
          distance = params.touchClicksDistanceThreshold;
        }

        var touchCurrentX = e.targetTouches[0].pageX;
        var touchCurrentY = e.targetTouches[0].pageY;

        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
        }

        if (isTouchMoveActivable || !isScrolling && isSegmentedStrong && segmentedStrongEl) {
          if (e.cancelable) e.preventDefault();
        }

        if (!isScrolling && isSegmentedStrong && segmentedStrongEl) {
          var elementFromPoint = document.elementFromPoint(e.targetTouches[0].clientX, e.targetTouches[0].clientY);
          var buttonEl = elementFromPoint.closest('.segmented-strong .button:not(.button-active):not(.tab-link-active)');

          if (buttonEl && segmentedStrongEl.contains(buttonEl)) {
            $(buttonEl).trigger('click', 'f7Segmented');
            targetElement = buttonEl;
          }
        }

        if (distance && touch) {
          var pageX = touch.pageX;
          var pageY = touch.pageY;

          if (Math.abs(pageX - touchStartX) > distance || Math.abs(pageY - touchStartY) > distance) {
            isMoved = true;
          }
        } else {
          isMoved = true;
        }

        if (isMoved) {
          preventClick = true; // Keep active state on touchMove (for dialog and actions buttons)

          if (isTouchMoveActivable) {
            var _elementFromPoint = document.elementFromPoint(e.targetTouches[0].clientX, e.targetTouches[0].clientY);

            touchmoveActivableEl = _elementFromPoint.closest(touchMoveActivableIos);

            if (touchmoveActivableEl && activableElement && activableElement[0] === touchmoveActivableEl) {
              shouldRemoveActive = false;
            } else if (touchmoveActivableEl) {
              setTimeout(function () {
                activableElement = findActivableElement(touchmoveActivableEl);
                addActive();
              });
            }
          }

          if (params.tapHold) {
            clearTimeout(tapHoldTimeout);
          }

          if (params.activeState && shouldRemoveActive) {
            clearTimeout(activeTimeout);
            removeActive();
          }

          if (useRipple) {
            rippleTouchMove();
          }
        }
      }

      function handleTouchEnd(e) {
        isScrolling = undefined;
        isSegmentedStrong = false;
        segmentedStrongEl = null;
        isTouchMoveActivable = false;
        clearTimeout(activeTimeout);
        clearTimeout(tapHoldTimeout);

        if (touchmoveActivableEl) {
          $(touchmoveActivableEl).trigger('click', 'f7TouchMoveActivable');
          touchmoveActivableEl = null;
        }

        if (document.activeElement === e.target) {
          if (params.activeState) removeActive();

          if (useRipple) {
            rippleTouchEnd();
          }

          return true;
        }

        if (params.activeState) {
          addActive();
          setTimeout(removeActive, 0);
        }

        if (useRipple) {
          rippleTouchEnd();
        }

        if (params.tapHoldPreventClicks && tapHoldFired || preventClick) {
          if (e.cancelable) e.preventDefault();
          preventClick = true;
          return false;
        }

        return true;
      }

      function handleClick(e) {
        var isOverswipe = e && e.detail && e.detail === 'f7Overswipe';
        var isSegmented = e && e.detail && e.detail === 'f7Segmented'; // eslint-disable-next-line

        var isTouchMoveActivable = e && e.detail && e.detail === 'f7TouchMoveActivable';
        var localPreventClick = preventClick;

        if (targetElement && e.target !== targetElement) {
          if (isOverswipe || isSegmented || isTouchMoveActivable) {
            localPreventClick = false;
          } else {
            localPreventClick = true;
          }
        } else if (isTouchMoveActivable) {
          localPreventClick = false;
        }

        if (params.tapHold && params.tapHoldPreventClicks && tapHoldFired) {
          localPreventClick = true;
        }

        if (localPreventClick) {
          e.stopImmediatePropagation();
          e.stopPropagation();
          e.preventDefault();
        }

        if (params.tapHold) {
          tapHoldTimeout = setTimeout(function () {
            tapHoldFired = false;
          }, device.ios || device.androidChrome ? 100 : 400);
        }

        preventClick = false;
        targetElement = null;
        return !localPreventClick;
      }

      function emitAppTouchEvent(name, e) {
        app.emit({
          events: name,
          data: [e]
        });
      }

      function appClick(e) {
        emitAppTouchEvent('click', e);
      }

      function appTouchStartActive(e) {
        emitAppTouchEvent('touchstart touchstart:active', e);
      }

      function appTouchMoveActive(e) {
        emitAppTouchEvent('touchmove touchmove:active', e);
      }

      function appTouchEndActive(e) {
        emitAppTouchEvent('touchend touchend:active', e);
      }

      function appTouchStartPassive(e) {
        emitAppTouchEvent('touchstart:passive', e);
      }

      function appTouchMovePassive(e) {
        emitAppTouchEvent('touchmove:passive', e);
      }

      function appTouchEndPassive(e) {
        emitAppTouchEvent('touchend:passive', e);
      }

      var passiveListener = support.passiveListener ? {
        passive: true
      } : false;
      var passiveListenerCapture = support.passiveListener ? {
        passive: true,
        capture: true
      } : true;
      var activeListener = support.passiveListener ? {
        passive: false
      } : false;
      var activeListenerCapture = support.passiveListener ? {
        passive: false,
        capture: true
      } : true;
      document.addEventListener('click', appClick, true);

      if (support.passiveListener) {
        document.addEventListener(app.touchEvents.start, appTouchStartActive, activeListenerCapture);
        document.addEventListener(app.touchEvents.move, appTouchMoveActive, activeListener);
        document.addEventListener(app.touchEvents.end, appTouchEndActive, activeListener);
        document.addEventListener(app.touchEvents.start, appTouchStartPassive, passiveListenerCapture);
        document.addEventListener(app.touchEvents.move, appTouchMovePassive, passiveListener);
        document.addEventListener(app.touchEvents.end, appTouchEndPassive, passiveListener);
      } else {
        document.addEventListener(app.touchEvents.start, function (e) {
          appTouchStartActive(e);
          appTouchStartPassive(e);
        }, true);
        document.addEventListener(app.touchEvents.move, function (e) {
          appTouchMoveActive(e);
          appTouchMovePassive(e);
        }, false);
        document.addEventListener(app.touchEvents.end, function (e) {
          appTouchEndActive(e);
          appTouchEndPassive(e);
        }, false);
      }

      if (support.touch) {
        app.on('click', handleClick);
        app.on('touchstart', handleTouchStart);
        app.on('touchmove', handleTouchMove);
        app.on('touchend', handleTouchEnd);
        document.addEventListener('touchcancel', handleTouchCancel, {
          passive: true
        });
      } else if (params.activeState) {
        app.on('touchstart', handleMouseDown);
        app.on('touchmove', handleMouseMove);
        app.on('touchend', handleMouseUp);
        document.addEventListener('pointercancel', handleMouseUp, {
          passive: true
        });
      }

      document.addEventListener('contextmenu', function (e) {
        if (params.disableContextMenu && (device.ios || device.android || device.cordova || window.Capacitor && window.Capacitor.isNative)) {
          e.preventDefault();
        }

        if (useRipple) {
          if (activableElement) removeActive();
          rippleTouchEnd();
        }
      });
    }

    var TouchModule = {
      name: 'touch',
      params: {
        touch: {
          // Clicks
          touchClicksDistanceThreshold: 5,
          // ContextMenu
          disableContextMenu: false,
          // Tap Hold
          tapHold: false,
          tapHoldDelay: 750,
          tapHoldPreventClicks: true,
          // Active State
          activeState: true,
          activeStateElements: 'a, button, label, span, .actions-button, .stepper-button, .stepper-button-plus, .stepper-button-minus, .card-expandable, .menu-item, .link, .item-link, .accordion-item-toggle',
          activeStateOnMouseMove: false,
          mdTouchRipple: true,
          iosTouchRipple: false,
          auroraTouchRipple: false,
          touchRippleElements: '.ripple, .link, .item-link, .list-button, .links-list a, .button, button, .input-clear-button, .dialog-button, .tab-link, .item-radio, .item-checkbox, .actions-button, .searchbar-disable-button, .fab a, .checkbox, .radio, .data-table .sortable-cell:not(.input-cell), .notification-close-button, .stepper-button, .stepper-button-minus, .stepper-button-plus, .menu-item-content, .list.accordion-list .accordion-item-toggle',
          touchRippleInsetElements: '.ripple-inset, .icon-only, .searchbar-disable-button, .input-clear-button, .notification-close-button, .md .navbar .link.back'
        }
      },
      create: function create() {
        var app = this;
        var support = getSupport();
        extend$1(app, {
          touchEvents: {
            start: support.touch ? 'touchstart' : support.pointerEvents ? 'pointerdown' : 'mousedown',
            move: support.touch ? 'touchmove' : support.pointerEvents ? 'pointermove' : 'mousemove',
            end: support.touch ? 'touchend' : support.pointerEvents ? 'pointerup' : 'mouseup'
          }
        });
      },
      on: {
        init: initTouch
      }
    };

    /**
     * Tokenize input string.
     */
    function lexer(str) {
        var tokens = [];
        var i = 0;
        while (i < str.length) {
            var char = str[i];
            if (char === "*" || char === "+" || char === "?") {
                tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
                continue;
            }
            if (char === "\\") {
                tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
                continue;
            }
            if (char === "{") {
                tokens.push({ type: "OPEN", index: i, value: str[i++] });
                continue;
            }
            if (char === "}") {
                tokens.push({ type: "CLOSE", index: i, value: str[i++] });
                continue;
            }
            if (char === ":") {
                var name = "";
                var j = i + 1;
                while (j < str.length) {
                    var code = str.charCodeAt(j);
                    if (
                    // `0-9`
                    (code >= 48 && code <= 57) ||
                        // `A-Z`
                        (code >= 65 && code <= 90) ||
                        // `a-z`
                        (code >= 97 && code <= 122) ||
                        // `_`
                        code === 95) {
                        name += str[j++];
                        continue;
                    }
                    break;
                }
                if (!name)
                    throw new TypeError("Missing parameter name at " + i);
                tokens.push({ type: "NAME", index: i, value: name });
                i = j;
                continue;
            }
            if (char === "(") {
                var count = 1;
                var pattern = "";
                var j = i + 1;
                if (str[j] === "?") {
                    throw new TypeError("Pattern cannot start with \"?\" at " + j);
                }
                while (j < str.length) {
                    if (str[j] === "\\") {
                        pattern += str[j++] + str[j++];
                        continue;
                    }
                    if (str[j] === ")") {
                        count--;
                        if (count === 0) {
                            j++;
                            break;
                        }
                    }
                    else if (str[j] === "(") {
                        count++;
                        if (str[j + 1] !== "?") {
                            throw new TypeError("Capturing groups are not allowed at " + j);
                        }
                    }
                    pattern += str[j++];
                }
                if (count)
                    throw new TypeError("Unbalanced pattern at " + i);
                if (!pattern)
                    throw new TypeError("Missing pattern at " + i);
                tokens.push({ type: "PATTERN", index: i, value: pattern });
                i = j;
                continue;
            }
            tokens.push({ type: "CHAR", index: i, value: str[i++] });
        }
        tokens.push({ type: "END", index: i, value: "" });
        return tokens;
    }
    /**
     * Parse a string for the raw tokens.
     */
    function parse(str, options) {
        if (options === void 0) { options = {}; }
        var tokens = lexer(str);
        var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
        var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
        var result = [];
        var key = 0;
        var i = 0;
        var path = "";
        var tryConsume = function (type) {
            if (i < tokens.length && tokens[i].type === type)
                return tokens[i++].value;
        };
        var mustConsume = function (type) {
            var value = tryConsume(type);
            if (value !== undefined)
                return value;
            var _a = tokens[i], nextType = _a.type, index = _a.index;
            throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
        };
        var consumeText = function () {
            var result = "";
            var value;
            // tslint:disable-next-line
            while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
                result += value;
            }
            return result;
        };
        while (i < tokens.length) {
            var char = tryConsume("CHAR");
            var name = tryConsume("NAME");
            var pattern = tryConsume("PATTERN");
            if (name || pattern) {
                var prefix = char || "";
                if (prefixes.indexOf(prefix) === -1) {
                    path += prefix;
                    prefix = "";
                }
                if (path) {
                    result.push(path);
                    path = "";
                }
                result.push({
                    name: name || key++,
                    prefix: prefix,
                    suffix: "",
                    pattern: pattern || defaultPattern,
                    modifier: tryConsume("MODIFIER") || ""
                });
                continue;
            }
            var value = char || tryConsume("ESCAPED_CHAR");
            if (value) {
                path += value;
                continue;
            }
            if (path) {
                result.push(path);
                path = "";
            }
            var open = tryConsume("OPEN");
            if (open) {
                var prefix = consumeText();
                var name_1 = tryConsume("NAME") || "";
                var pattern_1 = tryConsume("PATTERN") || "";
                var suffix = consumeText();
                mustConsume("CLOSE");
                result.push({
                    name: name_1 || (pattern_1 ? key++ : ""),
                    pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                    prefix: prefix,
                    suffix: suffix,
                    modifier: tryConsume("MODIFIER") || ""
                });
                continue;
            }
            mustConsume("END");
        }
        return result;
    }
    /**
     * Compile a string to a template function for the path.
     */
    function compile(str, options) {
        return tokensToFunction(parse(str, options), options);
    }
    /**
     * Expose a method for transforming tokens into the path function.
     */
    function tokensToFunction(tokens, options) {
        if (options === void 0) { options = {}; }
        var reFlags = flags(options);
        var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
        // Compile all the tokens into regexps.
        var matches = tokens.map(function (token) {
            if (typeof token === "object") {
                return new RegExp("^(?:" + token.pattern + ")$", reFlags);
            }
        });
        return function (data) {
            var path = "";
            for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if (typeof token === "string") {
                    path += token;
                    continue;
                }
                var value = data ? data[token.name] : undefined;
                var optional = token.modifier === "?" || token.modifier === "*";
                var repeat = token.modifier === "*" || token.modifier === "+";
                if (Array.isArray(value)) {
                    if (!repeat) {
                        throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                    }
                    if (value.length === 0) {
                        if (optional)
                            continue;
                        throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                    }
                    for (var j = 0; j < value.length; j++) {
                        var segment = encode(value[j], token);
                        if (validate && !matches[i].test(segment)) {
                            throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                        }
                        path += token.prefix + segment + token.suffix;
                    }
                    continue;
                }
                if (typeof value === "string" || typeof value === "number") {
                    var segment = encode(String(value), token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                    continue;
                }
                if (optional)
                    continue;
                var typeOfMessage = repeat ? "an array" : "a string";
                throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
            }
            return path;
        };
    }
    /**
     * Escape a regular expression string.
     */
    function escapeString(str) {
        return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    }
    /**
     * Get the flags for a regexp from the options.
     */
    function flags(options) {
        return options && options.sensitive ? "" : "i";
    }
    /**
     * Pull out keys from a regexp.
     */
    function regexpToRegexp(path, keys) {
        if (!keys)
            return path;
        var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
        var index = 0;
        var execResult = groupsRegex.exec(path.source);
        while (execResult) {
            keys.push({
                // Use parenthesized substring match if available, index otherwise
                name: execResult[1] || index++,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
            execResult = groupsRegex.exec(path.source);
        }
        return path;
    }
    /**
     * Transform an array into a regexp.
     */
    function arrayToRegexp(paths, keys, options) {
        var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
        return new RegExp("(?:" + parts.join("|") + ")", flags(options));
    }
    /**
     * Create a path regexp from string input.
     */
    function stringToRegexp(path, keys, options) {
        return tokensToRegexp(parse(path, options), keys, options);
    }
    /**
     * Expose a function for taking tokens and returning a RegExp.
     */
    function tokensToRegexp(tokens, keys, options) {
        if (options === void 0) { options = {}; }
        var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
        var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
        var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
        var route = start ? "^" : "";
        // Iterate over the tokens and create our regexp string.
        for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
            var token = tokens_1[_i];
            if (typeof token === "string") {
                route += escapeString(encode(token));
            }
            else {
                var prefix = escapeString(encode(token.prefix));
                var suffix = escapeString(encode(token.suffix));
                if (token.pattern) {
                    if (keys)
                        keys.push(token);
                    if (prefix || suffix) {
                        if (token.modifier === "+" || token.modifier === "*") {
                            var mod = token.modifier === "*" ? "?" : "";
                            route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                        }
                        else {
                            route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                        }
                    }
                    else {
                        route += "(" + token.pattern + ")" + token.modifier;
                    }
                }
                else {
                    route += "(?:" + prefix + suffix + ")" + token.modifier;
                }
            }
        }
        if (end) {
            if (!strict)
                route += delimiter + "?";
            route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
        }
        else {
            var endToken = tokens[tokens.length - 1];
            var isEndDelimited = typeof endToken === "string"
                ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
                : // tslint:disable-next-line
                    endToken === undefined;
            if (!strict) {
                route += "(?:" + delimiter + "(?=" + endsWith + "))?";
            }
            if (!isEndDelimited) {
                route += "(?=" + delimiter + "|" + endsWith + ")";
            }
        }
        return new RegExp(route, flags(options));
    }
    /**
     * Normalize the given path string, returning a regular expression.
     *
     * An empty array can be passed in for the keys, which will hold the
     * placeholder key descriptions. For example, using `/user/:id`, `keys` will
     * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
     */
    function pathToRegexp(path, keys, options) {
        if (path instanceof RegExp)
            return regexpToRegexp(path, keys);
        if (Array.isArray(path))
            return arrayToRegexp(path, keys, options);
        return stringToRegexp(path, keys, options);
    }

    var History = {
      queue: [],
      clearQueue: function clearQueue() {
        if (History.queue.length === 0) return;
        var currentQueue = History.queue.shift();
        currentQueue();
      },
      routerQueue: [],
      clearRouterQueue: function clearRouterQueue() {
        if (History.routerQueue.length === 0) return;
        var currentQueue = History.routerQueue.pop();
        var router = currentQueue.router,
            stateUrl = currentQueue.stateUrl,
            action = currentQueue.action;
        var animate = router.params.animate;
        if (router.params.browserHistoryAnimate === false) animate = false;

        if (action === 'back') {
          router.back({
            animate: animate,
            browserHistory: false
          });
        }

        if (action === 'load') {
          router.navigate(stateUrl, {
            animate: animate,
            browserHistory: false
          });
        }
      },
      handle: function handle(e) {
        if (History.blockPopstate) return;
        var app = this; // const mainView = app.views.main;

        var state = e.state;
        History.previousState = History.state;
        History.state = state;
        History.allowChange = true;
        History.clearQueue();
        state = History.state;
        if (!state) state = {};
        app.views.forEach(function (view) {
          var router = view.router;
          var viewState = state[view.id];

          if (!viewState && view.params.browserHistory) {
            viewState = {
              url: view.router.history[0]
            };
          }

          if (!viewState) return;
          var stateUrl = viewState.url || undefined;
          var animate = router.params.animate;
          if (router.params.browserHistoryAnimate === false) animate = false;

          if (stateUrl !== router.url) {
            if (router.history.indexOf(stateUrl) >= 0) {
              // Go Back
              if (router.allowPageChange) {
                router.back({
                  animate: animate,
                  browserHistory: false
                });
              } else {
                History.routerQueue.push({
                  action: 'back',
                  router: router
                });
              }
            } else if (router.allowPageChange) {
              // Load page
              router.navigate(stateUrl, {
                animate: animate,
                browserHistory: false
              });
            } else {
              History.routerQueue.unshift({
                action: 'load',
                stateUrl: stateUrl,
                router: router
              });
            }
          }
        });
      },
      initViewState: function initViewState(viewId, viewState) {
        var _extend;

        var window = getWindow();
        var newState = extend$1({}, History.state || {}, (_extend = {}, _extend[viewId] = viewState, _extend));
        History.state = newState;
        window.history.replaceState(newState, '');
      },
      push: function push(viewId, viewState, url) {
        var _extend2;

        var window = getWindow();

        if (url.substr(-3) === '#!/') {
          // eslint-disable-next-line
          url = url.replace('#!/', '');
        }

        if (!History.allowChange) {
          History.queue.push(function () {
            History.push(viewId, viewState, url);
          });
          return;
        }

        History.previousState = History.state;
        var newState = extend$1({}, History.previousState || {}, (_extend2 = {}, _extend2[viewId] = viewState, _extend2));
        History.state = newState;
        window.history.pushState(newState, '', url);
      },
      replace: function replace(viewId, viewState, url) {
        var _extend3;

        var window = getWindow();

        if (url.substr(-3) === '#!/') {
          // eslint-disable-next-line
          url = url.replace('#!/', '');
        }

        if (!History.allowChange) {
          History.queue.push(function () {
            History.replace(viewId, viewState, url);
          });
          return;
        }

        History.previousState = History.state;
        var newState = extend$1({}, History.previousState || {}, (_extend3 = {}, _extend3[viewId] = viewState, _extend3));
        History.state = newState;
        window.history.replaceState(newState, '', url);
      },
      go: function go(index) {
        var window = getWindow();
        History.allowChange = false;
        window.history.go(index);
      },
      back: function back() {
        var window = getWindow();
        History.allowChange = false;
        window.history.back();
      },
      allowChange: true,
      previousState: {},
      state: {},
      blockPopstate: true,
      init: function init(app) {
        var window = getWindow();
        var document = getDocument();
        History.state = window.history.state;
        $(window).on('load', function () {
          setTimeout(function () {
            History.blockPopstate = false;
          }, 0);
        });

        if (document.readyState && document.readyState === 'complete') {
          History.blockPopstate = false;
        }

        $(window).on('popstate', History.handle.bind(app));
      }
    };
    var History$1 = History;

    function SwipeBack(r) {
      var router = r;
      var $el = router.$el,
          $navbarsEl = router.$navbarsEl,
          app = router.app,
          params = router.params;
      var support = getSupport();
      var device = getDevice();
      var isTouched = false;
      var isMoved = false;
      var touchesStart = {};
      var isScrolling;
      var $currentPageEl = [];
      var $previousPageEl = [];
      var viewContainerWidth;
      var touchesDiff;
      var allowViewTouchMove = true;
      var touchStartTime;
      var $currentNavbarEl = [];
      var $previousNavbarEl = [];
      var dynamicNavbar;
      var $pageShadowEl;
      var $pageOpacityEl;
      var animatableNavEls;
      var paramsSwipeBackAnimateShadow = params[app.theme + "SwipeBackAnimateShadow"];
      var paramsSwipeBackAnimateOpacity = params[app.theme + "SwipeBackAnimateOpacity"];
      var paramsSwipeBackActiveArea = params[app.theme + "SwipeBackActiveArea"];
      var paramsSwipeBackThreshold = params[app.theme + "SwipeBackThreshold"];
      var transformOrigin = app.rtl ? 'right center' : 'left center';
      var transformOriginTitleLarge = app.rtl ? 'calc(100% - var(--f7-navbar-large-title-padding-left) - var(--f7-safe-area-left)) center' : 'calc(var(--f7-navbar-large-title-padding-left) + var(--f7-safe-area-left)) center';

      function animatableNavElements() {
        var els = [];
        var inverter = app.rtl ? -1 : 1;
        var currentNavIsTransparent = $currentNavbarEl.hasClass('navbar-transparent') && !$currentNavbarEl.hasClass('navbar-large') && !$currentNavbarEl.hasClass('navbar-transparent-visible');
        var currentNavIsLarge = $currentNavbarEl.hasClass('navbar-large');
        var currentNavIsCollapsed = $currentNavbarEl.hasClass('navbar-large-collapsed');
        var currentNavIsLargeTransparent = $currentNavbarEl.hasClass('navbar-large-transparent') || $currentNavbarEl.hasClass('navbar-large') && $currentNavbarEl.hasClass('navbar-transparent');
        var previousNavIsTransparent = $previousNavbarEl.hasClass('navbar-transparent') && !$previousNavbarEl.hasClass('navbar-large') && !$previousNavbarEl.hasClass('navbar-transparent-visible');
        var previousNavIsLarge = $previousNavbarEl.hasClass('navbar-large');
        var previousNavIsCollapsed = $previousNavbarEl.hasClass('navbar-large-collapsed');
        var previousNavIsLargeTransparent = $previousNavbarEl.hasClass('navbar-large-transparent') || $previousNavbarEl.hasClass('navbar-large') && $previousNavbarEl.hasClass('navbar-transparent');
        var fromLarge = currentNavIsLarge && !currentNavIsCollapsed;
        var toLarge = previousNavIsLarge && !previousNavIsCollapsed;
        var $currentNavElements = $currentNavbarEl.find('.left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg');
        var $previousNavElements = $previousNavbarEl.find('.left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg');
        var activeNavBackIconText;
        var previousNavBackIconText;

        if (params.iosAnimateNavbarBackIcon) {
          if ($currentNavbarEl.hasClass('sliding') || $currentNavbarEl.find('.navbar-inner.sliding').length) {
            activeNavBackIconText = $currentNavbarEl.find('.left').find('.back .icon + span').eq(0);
          } else {
            activeNavBackIconText = $currentNavbarEl.find('.left.sliding').find('.back .icon + span').eq(0);
          }

          if ($previousNavbarEl.hasClass('sliding') || $previousNavbarEl.find('.navbar-inner.sliding').length) {
            previousNavBackIconText = $previousNavbarEl.find('.left').find('.back .icon + span').eq(0);
          } else {
            previousNavBackIconText = $previousNavbarEl.find('.left.sliding').find('.back .icon + span').eq(0);
          }

          if (activeNavBackIconText.length) {
            $previousNavElements.each(function (el) {
              if (!$(el).hasClass('title')) return;
              el.f7NavbarLeftOffset += activeNavBackIconText.prev('.icon')[0].offsetWidth;
            });
          }
        }

        $currentNavElements.each(function (navEl) {
          var $navEl = $(navEl);
          var isSubnavbar = $navEl.hasClass('subnavbar');
          var isLeft = $navEl.hasClass('left');
          var isTitle = $navEl.hasClass('title');
          var isBg = $navEl.hasClass('navbar-bg');
          if ((isTitle || isBg) && currentNavIsTransparent) return;
          if (!fromLarge && $navEl.hasClass('.title-large')) return;
          var el = {
            el: navEl
          };

          if (fromLarge) {
            if (isTitle) return;

            if ($navEl.hasClass('title-large')) {
              if (els.indexOf(el) < 0) els.push(el);
              el.overflow = 'visible';
              $navEl.find('.title-large-text').each(function (subNavEl) {
                els.push({
                  el: subNavEl,
                  transform: function transform(progress) {
                    return "translateX(" + progress * 100 * inverter + "%)";
                  }
                });
              });
              return;
            }
          }

          if (toLarge) {
            if (!fromLarge) {
              if ($navEl.hasClass('title-large')) {
                if (els.indexOf(el) < 0) els.push(el);
                el.opacity = 0;
              }
            }

            if (isLeft) {
              if (els.indexOf(el) < 0) els.push(el);

              el.opacity = function (progress) {
                return 1 - Math.pow(progress, 0.33);
              };

              $navEl.find('.back span').each(function (subNavEl) {
                els.push({
                  el: subNavEl,
                  'transform-origin': transformOrigin,
                  transform: function transform(progress) {
                    return "translateX(calc(" + progress + " * (var(--f7-navbarTitleLargeOffset) - var(--f7-navbarLeftTextOffset)))) translateY(calc(" + progress + " * (var(--f7-navbar-large-title-height) - var(--f7-navbar-large-title-padding-vertical) / 2))) scale(" + (1 + 1 * progress) + ")";
                  }
                });
              });
              return;
            }
          }

          if (isBg) {
            if (els.indexOf(el) < 0) els.push(el);

            if (!fromLarge && !toLarge) {
              if (currentNavIsCollapsed) {
                if (currentNavIsLargeTransparent) {
                  el.className = 'ios-swipeback-navbar-bg-large';
                }

                el.transform = function (progress) {
                  return "translateX(" + 100 * progress * inverter + "%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))";
                };
              } else {
                el.transform = function (progress) {
                  return "translateX(" + 100 * progress * inverter + "%)";
                };
              }
            }

            if (!fromLarge && toLarge) {
              el.className = 'ios-swipeback-navbar-bg-large';

              el.transform = function (progress) {
                return "translateX(" + 100 * progress * inverter + "%) translateY(calc(-1 * " + (1 - progress) + " * var(--f7-navbar-large-title-height)))";
              };
            }

            if (fromLarge && toLarge) {
              el.transform = function (progress) {
                return "translateX(" + 100 * progress * inverter + "%)";
              };
            }

            if (fromLarge && !toLarge) {
              el.transform = function (progress) {
                return "translateX(" + 100 * progress * inverter + "%) translateY(calc(-" + progress + " * var(--f7-navbar-large-title-height)))";
              };
            }

            return;
          }

          if ($navEl.hasClass('title-large')) return;
          var isSliding = $navEl.hasClass('sliding') || $navEl.parents('.navbar-inner.sliding').length;
          if (els.indexOf(el) < 0) els.push(el);

          if (!isSubnavbar || isSubnavbar && !isSliding) {
            el.opacity = function (progress) {
              return 1 - Math.pow(progress, 0.33);
            };
          }

          if (isSliding) {
            var transformTarget = el;

            if (isLeft && activeNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
              var textEl = {
                el: activeNavBackIconText[0]
              };
              transformTarget = textEl;
              els.push(textEl);
            }

            transformTarget.transform = function (progress) {
              var activeNavTranslate = progress * transformTarget.el.f7NavbarRightOffset;
              if (device.pixelRatio === 1) activeNavTranslate = Math.round(activeNavTranslate);

              if (isSubnavbar && currentNavIsLarge) {
                return "translate3d(" + activeNavTranslate + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)";
              }

              return "translate3d(" + activeNavTranslate + "px,0,0)";
            };
          }
        });
        $previousNavElements.each(function (navEl) {
          var $navEl = $(navEl);
          var isSubnavbar = $navEl.hasClass('subnavbar');
          var isLeft = $navEl.hasClass('left');
          var isTitle = $navEl.hasClass('title');
          var isBg = $navEl.hasClass('navbar-bg');
          if ((isTitle || isBg) && previousNavIsTransparent) return;
          var el = {
            el: navEl
          };

          if (toLarge) {
            if (isTitle) return;
            if (els.indexOf(el) < 0) els.push(el);

            if ($navEl.hasClass('title-large')) {
              el.opacity = 1;
              el.overflow = 'visible';
              $navEl.find('.title-large-text').each(function (subNavEl) {
                els.push({
                  el: subNavEl,
                  'transform-origin': transformOriginTitleLarge,
                  opacity: function opacity(progress) {
                    return Math.pow(progress, 3);
                  },
                  transform: function transform(progress) {
                    return "translateX(calc(" + (1 - progress) + " * (var(--f7-navbarLeftTextOffset) - var(--f7-navbarTitleLargeOffset)))) translateY(calc(" + (progress - 1) + " * var(--f7-navbar-large-title-height) + " + (1 - progress) + " * var(--f7-navbar-large-title-padding-vertical))) scale(" + (0.5 + progress * 0.5) + ")";
                  }
                });
              });
              return;
            }
          }

          if (isBg) {
            if (els.indexOf(el) < 0) els.push(el);

            if (!fromLarge && !toLarge) {
              if (previousNavIsCollapsed) {
                if (previousNavIsLargeTransparent) {
                  el.className = 'ios-swipeback-navbar-bg-large';
                }

                el.transform = function (progress) {
                  return "translateX(" + (-100 + 100 * progress) * inverter + "%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))";
                };
              } else {
                el.transform = function (progress) {
                  return "translateX(" + (-100 + 100 * progress) * inverter + "%)";
                };
              }
            }

            if (!fromLarge && toLarge) {
              el.transform = function (progress) {
                return "translateX(" + (-100 + 100 * progress) * inverter + "%) translateY(calc(-1 * " + (1 - progress) + " * var(--f7-navbar-large-title-height)))";
              };
            }

            if (fromLarge && !toLarge) {
              el.className = 'ios-swipeback-navbar-bg-large';

              el.transform = function (progress) {
                return "translateX(" + (-100 + 100 * progress) * inverter + "%) translateY(calc(-" + progress + " * var(--f7-navbar-large-title-height)))";
              };
            }

            if (fromLarge && toLarge) {
              el.transform = function (progress) {
                return "translateX(" + (-100 + 100 * progress) * inverter + "%)";
              };
            }

            return;
          }

          if ($navEl.hasClass('title-large')) return;
          var isSliding = $navEl.hasClass('sliding') || $previousNavbarEl.children('.navbar-inner.sliding').length;
          if (els.indexOf(el) < 0) els.push(el);

          if (!isSubnavbar || isSubnavbar && !isSliding) {
            el.opacity = function (progress) {
              return Math.pow(progress, 3);
            };
          }

          if (isSliding) {
            var transformTarget = el;

            if (isLeft && previousNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
              var textEl = {
                el: previousNavBackIconText[0]
              };
              transformTarget = textEl;
              els.push(textEl);
            }

            transformTarget.transform = function (progress) {
              var previousNavTranslate = transformTarget.el.f7NavbarLeftOffset * (1 - progress);
              if (device.pixelRatio === 1) previousNavTranslate = Math.round(previousNavTranslate);

              if (isSubnavbar && previousNavIsLarge) {
                return "translate3d(" + previousNavTranslate + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)";
              }

              return "translate3d(" + previousNavTranslate + "px,0,0)";
            };
          }
        });
        return els;
      }

      function setAnimatableNavElements(_temp) {
        var _ref = _temp === void 0 ? {} : _temp,
            progress = _ref.progress,
            reset = _ref.reset,
            transition = _ref.transition,
            reflow = _ref.reflow;

        var styles = ['overflow', 'transform', 'transform-origin', 'opacity'];

        if (transition === true || transition === false) {
          for (var i = 0; i < animatableNavEls.length; i += 1) {
            var el = animatableNavEls[i];

            if (el && el.el) {
              if (transition === true) el.el.classList.add('navbar-page-transitioning');
              if (transition === false) el.el.classList.remove('navbar-page-transitioning');
            }
          }
        }

        if (reflow && animatableNavEls.length && animatableNavEls[0] && animatableNavEls[0].el) {
          // eslint-disable-next-line
          animatableNavEls[0].el._clientLeft = animatableNavEls[0].el.clientLeft;
        }

        for (var _i = 0; _i < animatableNavEls.length; _i += 1) {
          var _el = animatableNavEls[_i];

          if (_el && _el.el) {
            if (_el.className && !_el.classNameSet && !reset) {
              _el.el.classList.add(_el.className);

              _el.classNameSet = true;
            }

            if (_el.className && reset) {
              _el.el.classList.remove(_el.className);
            }

            for (var j = 0; j < styles.length; j += 1) {
              var styleProp = styles[j];

              if (_el[styleProp]) {
                if (reset) {
                  _el.el.style[styleProp] = '';
                } else if (typeof _el[styleProp] === 'function') {
                  _el.el.style[styleProp] = _el[styleProp](progress);
                } else {
                  _el.el.style[styleProp] = _el[styleProp];
                }
              }
            }
          }
        }
      }

      function handleTouchStart(e) {
        var swipeBackEnabled = params[app.theme + "SwipeBack"];
        if (!allowViewTouchMove || !swipeBackEnabled || isTouched || app.swipeout && app.swipeout.el || !router.allowPageChange) return;
        if ($(e.target).closest('.range-slider, .calendar-months').length > 0) return;
        if ($(e.target).closest('.page-master, .page-master-detail').length > 0 && params.masterDetailBreakpoint > 0 && app.width >= params.masterDetailBreakpoint) return;
        isMoved = false;
        isTouched = true;
        isScrolling = undefined;
        touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        touchStartTime = now$1();
        dynamicNavbar = router.dynamicNavbar;
      }

      function handleTouchMove(e) {
        if (!isTouched) return;
        var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x)) || pageX < touchesStart.x && !app.rtl || pageX > touchesStart.x && app.rtl;
        }

        if (isScrolling || e.f7PreventSwipeBack || app.preventSwipeBack) {
          isTouched = false;
          return;
        }

        if (!isMoved) {
          // Calc values during first move fired
          var cancel = false;
          var target = $(e.target);
          var swipeout = target.closest('.swipeout');

          if (swipeout.length > 0) {
            if (!app.rtl && swipeout.find('.swipeout-actions-left').length > 0) cancel = true;
            if (app.rtl && swipeout.find('.swipeout-actions-right').length > 0) cancel = true;
          }

          $currentPageEl = target.closest('.page');
          if ($currentPageEl.hasClass('no-swipeback') || target.closest('.no-swipeback, .card-opened').length > 0) cancel = true;
          $previousPageEl = $el.find('.page-previous:not(.stacked)');

          if ($previousPageEl.length > 1) {
            $previousPageEl = $previousPageEl.eq($previousPageEl.length - 1);
          }

          var notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
          viewContainerWidth = $el.width();

          if (app.rtl) {
            notFromBorder = touchesStart.x < $el.offset().left - $el[0].scrollLeft + (viewContainerWidth - paramsSwipeBackActiveArea);
          } else {
            notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
          }

          if (notFromBorder) cancel = true;
          if ($previousPageEl.length === 0 || $currentPageEl.length === 0) cancel = true;

          if (cancel) {
            isTouched = false;
            return;
          }

          if (paramsSwipeBackAnimateShadow) {
            $pageShadowEl = $currentPageEl.find('.page-shadow-effect');

            if ($pageShadowEl.length === 0) {
              $pageShadowEl = $('<div class="page-shadow-effect"></div>');
              $currentPageEl.append($pageShadowEl);
            }
          }

          if (paramsSwipeBackAnimateOpacity) {
            $pageOpacityEl = $previousPageEl.find('.page-opacity-effect');

            if ($pageOpacityEl.length === 0) {
              $pageOpacityEl = $('<div class="page-opacity-effect"></div>');
              $previousPageEl.append($pageOpacityEl);
            }
          }

          if (dynamicNavbar) {
            $currentNavbarEl = $navbarsEl.find('.navbar-current:not(.stacked)');
            $previousNavbarEl = $navbarsEl.find('.navbar-previous:not(.stacked)');

            if ($previousNavbarEl.length > 1) {
              $previousNavbarEl = $previousNavbarEl.eq($previousNavbarEl.length - 1);
            }

            animatableNavEls = animatableNavElements();
          } // Close/Hide Any Picker


          if ($('.sheet.modal-in').length > 0 && app.sheet) {
            app.sheet.close($('.sheet.modal-in'));
          }
        }

        e.f7PreventSwipePanel = true;
        isMoved = true;
        app.preventSwipePanelBySwipeBack = true;
        e.preventDefault(); // RTL inverter

        var inverter = app.rtl ? -1 : 1; // Touches diff

        touchesDiff = (pageX - touchesStart.x - paramsSwipeBackThreshold) * inverter;
        if (touchesDiff < 0) touchesDiff = 0;
        var percentage = Math.min(Math.max(touchesDiff / viewContainerWidth, 0), 1); // Swipe Back Callback

        var callbackData = {
          percentage: percentage,
          progress: percentage,
          currentPageEl: $currentPageEl[0],
          previousPageEl: $previousPageEl[0],
          currentNavbarEl: $currentNavbarEl[0],
          previousNavbarEl: $previousNavbarEl[0]
        };
        $el.trigger('swipeback:move', callbackData);
        router.emit('swipebackMove', callbackData); // Transform pages

        var currentPageTranslate = touchesDiff * inverter;
        var previousPageTranslate = (touchesDiff / 5 - viewContainerWidth / 5) * inverter;

        if (!app.rtl) {
          currentPageTranslate = Math.min(currentPageTranslate, viewContainerWidth);
          previousPageTranslate = Math.min(previousPageTranslate, 0);
        } else {
          currentPageTranslate = Math.max(currentPageTranslate, -viewContainerWidth);
          previousPageTranslate = Math.max(previousPageTranslate, 0);
        }

        if (device.pixelRatio === 1) {
          currentPageTranslate = Math.round(currentPageTranslate);
          previousPageTranslate = Math.round(previousPageTranslate);
        }

        router.swipeBackActive = true;
        $([$currentPageEl[0], $previousPageEl[0]]).addClass('page-swipeback-active');
        $currentPageEl.transform("translate3d(" + currentPageTranslate + "px,0,0)");
        if (paramsSwipeBackAnimateShadow) $pageShadowEl[0].style.opacity = 1 - 1 * percentage;

        if (app.theme === 'ios') {
          $previousPageEl.transform("translate3d(" + previousPageTranslate + "px,0,0)");
        }

        if (paramsSwipeBackAnimateOpacity) $pageOpacityEl[0].style.opacity = 1 - 1 * percentage; // Dynamic Navbars Animation

        if (!dynamicNavbar) return;
        setAnimatableNavElements({
          progress: percentage
        });
      }

      function handleTouchEnd() {
        app.preventSwipePanelBySwipeBack = false;

        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }

        isTouched = false;
        isMoved = false;
        router.swipeBackActive = false;
        var $pages = $([$currentPageEl[0], $previousPageEl[0]]);
        $pages.removeClass('page-swipeback-active');

        if (touchesDiff === 0) {
          $pages.transform('');
          if ($pageShadowEl && $pageShadowEl.length > 0) $pageShadowEl.remove();
          if ($pageOpacityEl && $pageOpacityEl.length > 0) $pageOpacityEl.remove();

          if (dynamicNavbar) {
            setAnimatableNavElements({
              reset: true
            });
          }

          return;
        }

        var timeDiff = now$1() - touchStartTime;
        var pageChanged = false; // Swipe back to previous page

        if (timeDiff < 300 && touchesDiff > 10 || timeDiff >= 300 && touchesDiff > viewContainerWidth / 2) {
          $currentPageEl.removeClass('page-current').addClass("page-next" + (app.theme !== 'ios' ? ' page-next-on-right' : ''));
          $previousPageEl.removeClass('page-previous').addClass('page-current').removeAttr('aria-hidden');
          if ($pageShadowEl) $pageShadowEl[0].style.opacity = '';
          if ($pageOpacityEl) $pageOpacityEl[0].style.opacity = '';

          if (dynamicNavbar) {
            router.setNavbarPosition($currentNavbarEl, 'next');
            router.setNavbarPosition($previousNavbarEl, 'current', false);
          }

          pageChanged = true;
        } // Reset custom styles
        // Add transitioning class for transition-duration


        $pages.addClass('page-transitioning page-transitioning-swipeback');

        if (device.ios) {
          // eslint-disable-next-line
          $currentPageEl[0]._clientLeft = $currentPageEl[0].clientLeft;
        }

        $pages.transform('');

        if (dynamicNavbar) {
          setAnimatableNavElements({
            progress: pageChanged ? 1 : 0,
            transition: true,
            reflow: !!device.ios
          });
        }

        allowViewTouchMove = false;
        router.allowPageChange = false; // Swipe Back Callback

        var callbackData = {
          currentPageEl: $currentPageEl[0],
          previousPageEl: $previousPageEl[0],
          currentNavbarEl: $currentNavbarEl[0],
          previousNavbarEl: $previousNavbarEl[0]
        };

        if (pageChanged) {
          // Update Route
          router.currentRoute = $previousPageEl[0].f7Page.route;
          router.currentPage = $previousPageEl[0]; // Page before animation callback

          router.pageCallback('beforeOut', $currentPageEl, $currentNavbarEl, 'current', 'next', {
            route: $currentPageEl[0].f7Page.route,
            swipeBack: true
          });
          router.pageCallback('beforeIn', $previousPageEl, $previousNavbarEl, 'previous', 'current', {
            route: $previousPageEl[0].f7Page.route,
            swipeBack: true
          }, $currentPageEl[0]);
          $el.trigger('swipeback:beforechange', callbackData);
          router.emit('swipebackBeforeChange', callbackData);
        } else {
          $el.trigger('swipeback:beforereset', callbackData);
          router.emit('swipebackBeforeReset', callbackData);
        }

        $currentPageEl.transitionEnd(function () {
          $pages.removeClass('page-transitioning page-transitioning-swipeback');

          if (dynamicNavbar) {
            setAnimatableNavElements({
              reset: true,
              transition: false
            });
          }

          allowViewTouchMove = true;
          router.allowPageChange = true;

          if (pageChanged) {
            // Update History
            if (router.history.length === 1) {
              router.history.unshift(router.url);
            }

            router.history.pop();
            router.saveHistory(); // Update push state

            if (params.browserHistory) {
              History$1.back();
            } // Page after animation callback


            router.pageCallback('afterOut', $currentPageEl, $currentNavbarEl, 'current', 'next', {
              route: $currentPageEl[0].f7Page.route,
              swipeBack: true
            });
            router.pageCallback('afterIn', $previousPageEl, $previousNavbarEl, 'previous', 'current', {
              route: $previousPageEl[0].f7Page.route,
              swipeBack: true
            }); // Remove Old Page

            if (params.stackPages && router.initialPages.indexOf($currentPageEl[0]) >= 0) {
              $currentPageEl.addClass('stacked');

              if (dynamicNavbar) {
                $currentNavbarEl.addClass('stacked');
              }
            } else {
              router.pageCallback('beforeRemove', $currentPageEl, $currentNavbarEl, 'next', {
                swipeBack: true
              });
              router.removePage($currentPageEl);

              if (dynamicNavbar) {
                router.removeNavbar($currentNavbarEl);
              }
            }

            $el.trigger('swipeback:afterchange', callbackData);
            router.emit('swipebackAfterChange', callbackData);
            router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

            if (params.preloadPreviousPage) {
              router.back(router.history[router.history.length - 2], {
                preload: true
              });
            }
          } else {
            $el.trigger('swipeback:afterreset', callbackData);
            router.emit('swipebackAfterReset', callbackData);
          }

          if ($pageShadowEl && $pageShadowEl.length > 0) $pageShadowEl.remove();
          if ($pageOpacityEl && $pageOpacityEl.length > 0) $pageOpacityEl.remove();
        });
      }

      function attachEvents() {
        var passiveListener = app.touchEvents.start === 'touchstart' && support.passiveListener ? {
          passive: true,
          capture: false
        } : false;
        $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
        app.on('touchmove:active', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
      }

      function detachEvents() {
        var passiveListener = app.touchEvents.start === 'touchstart' && support.passiveListener ? {
          passive: true,
          capture: false
        } : false;
        $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
        app.off('touchmove:active', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
      }

      attachEvents();
      router.on('routerDestroy', detachEvents);
    }

    function redirect(direction, route, options) {
      var router = this;
      var r = route.route.redirect;
      var method = direction === 'forward' ? 'navigate' : 'back';

      if (options.initial && router.params.browserHistory) {
        options.replaceState = true; // eslint-disable-line

        options.history = true; // eslint-disable-line
      }

      function redirectResolve(redirectUrl, redirectOptions) {
        if (redirectOptions === void 0) {
          redirectOptions = {};
        }

        router.allowPageChange = true;
        router[method](redirectUrl, extend$1({}, options, redirectOptions));
      }

      function redirectReject() {
        router.allowPageChange = true;
      }

      if (typeof r === 'function') {
        router.allowPageChange = false;
        var redirectUrl = r.call(router, {
          router: router,
          to: route,
          resolve: redirectResolve,
          reject: redirectReject,
          direction: direction,
          app: router.app
        });

        if (redirectUrl && typeof redirectUrl === 'string') {
          router.allowPageChange = true;
          return router[method](redirectUrl, options);
        }

        return router;
      }

      return router[method](r, options);
    }

    function processQueue(router, routerQueue, routeQueue, to, from, resolve, _reject, direction) {
      var queue = [];

      if (Array.isArray(routeQueue)) {
        queue.push.apply(queue, routeQueue);
      } else if (routeQueue && typeof routeQueue === 'function') {
        queue.push(routeQueue);
      }

      if (routerQueue) {
        if (Array.isArray(routerQueue)) {
          queue.push.apply(queue, routerQueue);
        } else {
          queue.push(routerQueue);
        }
      }

      function next() {
        if (queue.length === 0) {
          resolve();
          return;
        }

        var queueItem = queue.shift();
        queueItem.call(router, {
          router: router,
          to: to,
          from: from,
          resolve: function resolve() {
            next();
          },
          reject: function reject() {
            _reject();
          },
          direction: direction,
          app: router.app
        });
      }

      next();
    }

    function processRouteQueue(to, from, resolve, reject, direction) {
      var router = this;

      function enterNextRoute() {
        if (to && to.route && (router.params.routesBeforeEnter || to.route.beforeEnter)) {
          router.allowPageChange = false;
          processQueue(router, router.params.routesBeforeEnter, to.route.beforeEnter, to, from, function () {
            router.allowPageChange = true;
            resolve();
          }, function () {
            reject();
          }, direction);
        } else {
          resolve();
        }
      }

      function leaveCurrentRoute() {
        if (from && from.route && (router.params.routesBeforeLeave || from.route.beforeLeave)) {
          router.allowPageChange = false;
          processQueue(router, router.params.routesBeforeLeave, from.route.beforeLeave, to, from, function () {
            router.allowPageChange = true;
            enterNextRoute();
          }, function () {
            reject();
          }, direction);
        } else {
          enterNextRoute();
        }
      }

      leaveCurrentRoute();
    }

    function appRouterCheck(router, method) {
      if (!router.view) {
        throw new Error("Framework7: it is not allowed to use router methods on global app router. Use router methods only on related View, e.g. app.views.main.router." + method + "(...)");
      }
    }

    function asyncComponent(router, component, resolve, reject) {
      function resolvePromise(componentPromise) {
        componentPromise.then(function (c) {
          // eslint-disable-next-line
          resolve({
            component: c.default || c._default || c
          });
        }).catch(function (err) {
          reject();
          throw new Error(err);
        });
      }

      if (component instanceof Promise) {
        resolvePromise(component);
        return;
      }

      var asyncComponentResult = component.call(router);

      if (asyncComponentResult instanceof Promise) {
        resolvePromise(asyncComponentResult);
      } else {
        resolve({
          component: asyncComponentResult
        });
      }
    }

    function _extends$2() { _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }

    function refreshPage() {
      var router = this;
      appRouterCheck(router, 'refreshPage');
      return router.navigate(router.currentRoute.url, {
        ignoreCache: true,
        reloadCurrent: true
      });
    }

    function forward(router, el, forwardOptions) {
      if (forwardOptions === void 0) {
        forwardOptions = {};
      }

      var document = getDocument();
      var $el = $(el);
      var app = router.app;
      var view = router.view;
      var options = extend$1(false, {
        animate: router.params.animate,
        browserHistory: true,
        replaceState: false,
        history: true,
        reloadCurrent: router.params.reloadPages,
        reloadPrevious: false,
        reloadAll: false,
        clearPreviousHistory: false,
        reloadDetail: router.params.reloadDetail,
        on: {}
      }, forwardOptions);
      var masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
      var isMaster = masterDetailEnabled && options.route && options.route.route && (options.route.route.master === true || typeof options.route.route.master === 'function' && options.route.route.master(app, router));
      var masterPageEl;
      var otherDetailPageEl;
      var detailsInBetweenRemoved = 0;
      var currentRouteIsModal = router.currentRoute.modal;
      var modalType;

      if (!currentRouteIsModal) {
        'popup popover sheet loginScreen actions customModal panel'.split(' ').forEach(function (modalLoadProp) {
          if (router.currentRoute && router.currentRoute.route && router.currentRoute.route[modalLoadProp]) {
            currentRouteIsModal = true;
            modalType = modalLoadProp;
          }
        });
      }

      if (currentRouteIsModal) {
        var modalToClose = router.currentRoute.modal || router.currentRoute.route.modalInstance || app[modalType].get();
        var previousUrl = router.history[router.history.length - 2];
        var previousRoute = router.findMatchingRoute(previousUrl);

        if (!previousRoute && previousUrl) {
          previousRoute = {
            url: previousUrl,
            path: previousUrl.split('?')[0],
            query: parseUrlQuery(previousUrl),
            route: {
              path: previousUrl.split('?')[0],
              url: previousUrl
            }
          };
        }

        router.modalRemove(modalToClose);
      }

      var dynamicNavbar = router.dynamicNavbar;
      var $viewEl = router.$el;
      var $newPage = $el;
      var reload = options.reloadPrevious || options.reloadCurrent || options.reloadAll;
      var $oldPage;
      var $navbarsEl;
      var $newNavbarEl;
      var $oldNavbarEl;
      router.allowPageChange = false;

      if ($newPage.length === 0) {
        router.allowPageChange = true;
        return router;
      }

      if ($newPage.length) {
        // Remove theme elements
        router.removeThemeElements($newPage);
      }

      if (dynamicNavbar) {
        $newNavbarEl = $newPage.children('.navbar');
        $navbarsEl = router.$navbarsEl;

        if ($newNavbarEl.length === 0 && $newPage[0] && $newPage[0].f7Page) {
          // Try from pageData
          $newNavbarEl = $newPage[0].f7Page.$navbarEl;
        }
      } // Save Keep Alive Cache


      if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
        options.route.route.keepAliveData = {
          pageEl: $el[0]
        };
      } // Pages In View


      var $pagesInView = $viewEl.children('.page:not(.stacked)').filter(function (pageInView) {
        return pageInView !== $newPage[0];
      }); // Navbars In View

      var $navbarsInView;

      if (dynamicNavbar) {
        $navbarsInView = $navbarsEl.children('.navbar:not(.stacked)').filter(function (navbarInView) {
          return navbarInView !== $newNavbarEl[0];
        });
      } // Exit when reload previous and only 1 page in view so nothing ro reload


      if (options.reloadPrevious && $pagesInView.length < 2) {
        router.allowPageChange = true;
        return router;
      } // Find Detail' master page


      var isDetail;
      var reloadDetail;
      var isDetailRoot;

      if (masterDetailEnabled && !options.reloadAll) {
        for (var i = 0; i < $pagesInView.length; i += 1) {
          if (!masterPageEl && $pagesInView[i].classList.contains('page-master')) {
            masterPageEl = $pagesInView[i];
            continue; // eslint-disable-line
          }
        }

        isDetail = !isMaster && masterPageEl;

        if (isDetail) {
          // Find Other Detail
          if (masterPageEl) {
            for (var _i = 0; _i < $pagesInView.length; _i += 1) {
              if ($pagesInView[_i].classList.contains('page-master-detail')) {
                otherDetailPageEl = $pagesInView[_i];
                continue; // eslint-disable-line
              }
            }
          }
        }

        reloadDetail = isDetail && options.reloadDetail && app.width >= router.params.masterDetailBreakpoint && masterPageEl;
      }

      if (isDetail) {
        isDetailRoot = !otherDetailPageEl || reloadDetail || options.reloadAll || options.reloadCurrent;
      } // New Page


      var newPagePosition = 'next';

      if (options.reloadCurrent || options.reloadAll || reloadDetail) {
        newPagePosition = 'current';
      } else if (options.reloadPrevious) {
        newPagePosition = 'previous';
      }

      $newPage.removeClass('page-previous page-current page-next').addClass("page-" + newPagePosition + (isMaster ? ' page-master' : '') + (isDetail ? ' page-master-detail' : '') + (isDetailRoot ? ' page-master-detail-root' : '')).removeClass('stacked').trigger('page:unstack').trigger('page:position', {
        position: newPagePosition
      });
      router.emit('pageUnstack', $newPage[0]);
      router.emit('pagePosition', $newPage[0], newPagePosition);

      if (isMaster || isDetail) {
        $newPage.trigger('page:role', {
          role: isMaster ? 'master' : 'detail',
          root: !!isDetailRoot
        });
        router.emit('pageRole', $newPage[0], {
          role: isMaster ? 'master' : 'detail',
          detailRoot: !!isDetailRoot
        });
      }

      if (dynamicNavbar && $newNavbarEl.length) {
        $newNavbarEl.removeClass('navbar-previous navbar-current navbar-next').addClass("navbar-" + newPagePosition + (isMaster ? ' navbar-master' : '') + (isDetail ? ' navbar-master-detail' : '') + (isDetailRoot ? ' navbar-master-detail-root' : '')).removeClass('stacked');
        $newNavbarEl.trigger('navbar:position', {
          position: newPagePosition
        });
        router.emit('navbarPosition', $newNavbarEl[0], newPagePosition);

        if (isMaster || isDetail) {
          router.emit('navbarRole', $newNavbarEl[0], {
            role: isMaster ? 'master' : 'detail',
            detailRoot: !!isDetailRoot
          });
        }
      } // Find Old Page


      if (options.reloadCurrent || reloadDetail) {
        if (reloadDetail) {
          $oldPage = $pagesInView.filter(function (pageEl) {
            return !pageEl.classList.contains('page-master');
          });

          if (dynamicNavbar) {
            $oldNavbarEl = $($oldPage.map(function (pageEl) {
              return app.navbar.getElByPage(pageEl);
            }));
          }

          if ($oldPage.length > 1 && masterPageEl) {
            detailsInBetweenRemoved = $oldPage.length - 1;
            $(masterPageEl).removeClass('page-master-stacked').trigger('page:masterunstack');
            router.emit('pageMasterUnstack', masterPageEl);

            if (dynamicNavbar) {
              $(app.navbar.getElByPage(masterPageEl)).removeClass('navbar-master-stacked');
              router.emit('navbarMasterUnstack', app.navbar.getElByPage(masterPageEl));
            }
          }
        } else {
          $oldPage = $pagesInView.eq($pagesInView.length - 1);

          if (dynamicNavbar) {
            $oldNavbarEl = $(app.navbar.getElByPage($oldPage));
          }
        }
      } else if (options.reloadPrevious) {
        $oldPage = $pagesInView.eq($pagesInView.length - 2);

        if (dynamicNavbar) {
          // $oldNavbarEl = $navbarsInView.eq($pagesInView.length - 2);
          $oldNavbarEl = $(app.navbar.getElByPage($oldPage));
        }
      } else if (options.reloadAll) {
        $oldPage = $pagesInView.filter(function (pageEl) {
          return pageEl !== $newPage[0];
        });

        if (dynamicNavbar) {
          $oldNavbarEl = $navbarsInView.filter(function (navbarEl) {
            return navbarEl !== $newNavbarEl[0];
          });
        }
      } else {
        var removedPageEls = [];
        var removedNavbarEls = [];

        if ($pagesInView.length > 1) {
          var _i2 = 0;

          for (_i2 = 0; _i2 < $pagesInView.length - 1; _i2 += 1) {
            if (masterPageEl && $pagesInView[_i2] === masterPageEl) {
              $pagesInView.eq(_i2).addClass('page-master-stacked');
              $pagesInView.eq(_i2).trigger('page:masterstack');
              router.emit('pageMasterStack', $pagesInView[_i2]);

              if (dynamicNavbar) {
                $(app.navbar.getElByPage(masterPageEl)).addClass('navbar-master-stacked');
                router.emit('navbarMasterStack', app.navbar.getElByPage(masterPageEl));
              }

              continue; // eslint-disable-line
            }

            var oldNavbarEl = app.navbar.getElByPage($pagesInView.eq(_i2));

            if (router.params.stackPages) {
              $pagesInView.eq(_i2).addClass('stacked');
              $pagesInView.eq(_i2).trigger('page:stack');
              router.emit('pageStack', $pagesInView[_i2]);

              if (dynamicNavbar) {
                $(oldNavbarEl).addClass('stacked');
              }
            } else {
              // Page remove event
              removedPageEls.push($pagesInView[_i2]);
              router.pageCallback('beforeRemove', $pagesInView[_i2], $navbarsInView && $navbarsInView[_i2], 'previous', undefined, options);
              router.removePage($pagesInView[_i2]);

              if (dynamicNavbar && oldNavbarEl) {
                removedNavbarEls.push(oldNavbarEl);
                router.removeNavbar(oldNavbarEl);
              }
            }
          }
        }

        $oldPage = $viewEl.children('.page:not(.stacked)').filter(function (pageEl) {
          return pageEl !== $newPage[0] && removedPageEls.indexOf(pageEl) < 0;
        });

        if (dynamicNavbar) {
          $oldNavbarEl = $navbarsEl.children('.navbar:not(.stacked)').filter(function (navbarEl) {
            return navbarEl !== $newNavbarEl[0] && removedNavbarEls.indexOf(removedNavbarEls) < 0;
          });
        }

        removedPageEls = [];
        removedNavbarEls = [];
      }

      if (isDetail && !options.reloadAll) {
        if ($oldPage.length > 1 || reloadDetail) {
          $oldPage = $oldPage.filter(function (pageEl) {
            return !pageEl.classList.contains('page-master');
          });
        }

        if ($oldNavbarEl && ($oldNavbarEl.length > 1 || reloadDetail)) {
          $oldNavbarEl = $oldNavbarEl.filter(function (navbarEl) {
            return !navbarEl.classList.contains('navbar-master');
          });
        }
      } // Push State


      if (router.params.browserHistory && (options.browserHistory || options.replaceState) && !options.reloadPrevious) {
        var browserHistoryRoot = router.params.browserHistoryRoot || '';
        History$1[options.reloadCurrent || reloadDetail && otherDetailPageEl || options.reloadAll || options.replaceState ? 'replace' : 'push'](view.id, {
          url: options.route.url
        }, browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
      }

      if (!options.reloadPrevious) {
        // Current Page & Navbar
        router.currentPageEl = $newPage[0];

        if (dynamicNavbar && $newNavbarEl.length) {
          router.currentNavbarEl = $newNavbarEl[0];
        } else {
          delete router.currentNavbarEl;
        } // Current Route


        router.currentRoute = options.route;
      } // Update router history


      var url = options.route.url;

      if (options.history) {
        if (((options.reloadCurrent || reloadDetail && otherDetailPageEl) && router.history.length) > 0 || options.replaceState) {
          if (reloadDetail && detailsInBetweenRemoved > 0) {
            router.history = router.history.slice(0, router.history.length - detailsInBetweenRemoved);
          }

          router.history[router.history.length - (options.reloadPrevious ? 2 : 1)] = url;
        } else if (options.reloadPrevious) {
          router.history[router.history.length - 2] = url;
        } else if (options.reloadAll) {
          router.history = [url];
        } else {
          router.history.push(url);
        }
      }

      router.saveHistory(); // Insert new page and navbar

      var newPageInDom = $newPage.parents(document).length > 0;
      var f7Component = $newPage[0].f7Component;

      if (options.reloadPrevious) {
        if (f7Component && !newPageInDom) {
          f7Component.mount(function (componentEl) {
            $(componentEl).insertBefore($oldPage);
          });
        } else {
          $newPage.insertBefore($oldPage);
        }

        if (dynamicNavbar && $newNavbarEl.length) {
          if ($newNavbarEl.find('.title-large').length) {
            $newNavbarEl.addClass('navbar-large');
          }

          if ($oldNavbarEl.length) {
            $newNavbarEl.insertBefore($oldNavbarEl);
          } else {
            if (!router.$navbarsEl.parents(document).length) {
              router.$el.prepend(router.$navbarsEl);
            }

            $navbarsEl.append($newNavbarEl);
          }
        }
      } else {
        if ($oldPage.next('.page')[0] !== $newPage[0]) {
          if (f7Component && !newPageInDom) {
            f7Component.mount(function (componentEl) {
              $viewEl.append(componentEl);
            });
          } else {
            $viewEl.append($newPage[0]);
          }
        }

        if (dynamicNavbar && $newNavbarEl.length) {
          if ($newNavbarEl.find('.title-large').length) {
            $newNavbarEl.addClass('navbar-large');
          }

          if (!router.$navbarsEl.parents(document).length) {
            router.$el.prepend(router.$navbarsEl);
          }

          $navbarsEl.append($newNavbarEl[0]);
        }
      }

      if (!newPageInDom) {
        router.pageCallback('mounted', $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);
      } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
        $newPage[0].f7PageMounted = true;
        router.pageCallback('mounted', $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);
      } // Remove old page


      if ((options.reloadCurrent || reloadDetail) && $oldPage.length > 0) {
        if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
          $oldPage.addClass('stacked');
          $oldPage.trigger('page:stack');
          router.emit('pageStack', $oldPage[0]);

          if (dynamicNavbar) {
            $oldNavbarEl.addClass('stacked');
          }
        } else {
          // Page remove event
          router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
          router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
          router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'current', undefined, options);
          router.removePage($oldPage);

          if (dynamicNavbar && $oldNavbarEl && $oldNavbarEl.length) {
            router.removeNavbar($oldNavbarEl);
          }
        }
      } else if (options.reloadAll) {
        $oldPage.each(function (pageEl, index) {
          var $oldPageEl = $(pageEl);
          var $oldNavbarElEl = $(app.navbar.getElByPage($oldPageEl));

          if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
            $oldPageEl.addClass('stacked');
            $oldPageEl.trigger('page:stack');
            router.emit('pageStack', $oldPageEl[0]);

            if (dynamicNavbar) {
              $oldNavbarElEl.addClass('stacked');
            }
          } else {
            // Page remove event
            if ($oldPageEl.hasClass('page-current')) {
              router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
              router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
            }

            router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarEl && $oldNavbarEl.eq(index), 'previous', undefined, options);
            router.removePage($oldPageEl);

            if (dynamicNavbar && $oldNavbarElEl.length) {
              router.removeNavbar($oldNavbarElEl);
            }
          }
        });
      } else if (options.reloadPrevious) {
        if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
          $oldPage.addClass('stacked');
          $oldPage.trigger('page:stack');
          router.emit('pageStack', $oldPage[0]);

          if (dynamicNavbar) {
            $oldNavbarEl.addClass('stacked');
          }
        } else {
          // Page remove event
          router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'previous', undefined, options);
          router.removePage($oldPage);

          if (dynamicNavbar && $oldNavbarEl && $oldNavbarEl.length) {
            router.removeNavbar($oldNavbarEl);
          }
        }
      } // Load Tab


      if (options.route.route.tab) {
        router.tabLoad(options.route.route.tab, extend$1({}, options, {
          history: false,
          browserHistory: false
        }));
      } // Check master detail


      if (masterDetailEnabled) {
        view.checkMasterDetailBreakpoint();
      } // Page init and before init events


      router.pageCallback('init', $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);

      if (options.reloadCurrent || options.reloadAll || reloadDetail) {
        router.allowPageChange = true;
        router.pageCallback('beforeIn', $newPage, $newNavbarEl, newPagePosition, 'current', options);
        $newPage.removeAttr('aria-hidden');

        if (dynamicNavbar && $newNavbarEl) {
          $newNavbarEl.removeAttr('aria-hidden');
        }

        router.pageCallback('afterIn', $newPage, $newNavbarEl, newPagePosition, 'current', options);
        if (options.reloadCurrent && options.clearPreviousHistory) router.clearPreviousHistory();

        if (reloadDetail) {
          router.setPagePosition($(masterPageEl), 'previous');

          if (masterPageEl.f7Page && masterPageEl.f7Page.navbarEl) {
            router.setNavbarPosition($(masterPageEl.f7Page.navbarEl), 'previous');
          }
        }

        return router;
      }

      if (options.reloadPrevious) {
        router.allowPageChange = true;
        return router;
      } // Before animation event


      router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', 'previous', options);
      router.pageCallback('beforeIn', $newPage, $newNavbarEl, 'next', 'current', options); // Animation

      function afterAnimation() {
        router.setPagePosition($newPage, 'current', false);
        router.setPagePosition($oldPage, 'previous', !$oldPage.hasClass('page-master'));

        if (dynamicNavbar) {
          router.setNavbarPosition($newNavbarEl, 'current', false);
          router.setNavbarPosition($oldNavbarEl, 'previous', !$oldNavbarEl.hasClass('navbar-master'));
        } // After animation event


        router.allowPageChange = true;
        router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', 'previous', options);
        router.pageCallback('afterIn', $newPage, $newNavbarEl, 'next', 'current', options);
        var keepOldPage = (router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"]) && !isMaster;

        if (!keepOldPage) {
          if ($newPage.hasClass('smart-select-page') || $newPage.hasClass('photo-browser-page') || $newPage.hasClass('autocomplete-page') || $newPage.hasClass('color-picker-page')) {
            keepOldPage = true;
          }
        }

        if (!keepOldPage) {
          if (router.params.stackPages) {
            $oldPage.addClass('stacked');
            $oldPage.trigger('page:stack');
            router.emit('pageStack', $oldPage[0]);

            if (dynamicNavbar) {
              $oldNavbarEl.addClass('stacked');
            }
          } else if (!($newPage.attr('data-name') && $newPage.attr('data-name') === 'smart-select-page')) {
            // Remove event
            router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'previous', undefined, options);
            router.removePage($oldPage);

            if (dynamicNavbar && $oldNavbarEl.length) {
              router.removeNavbar($oldNavbarEl);
            }
          }
        }

        if (options.clearPreviousHistory) router.clearPreviousHistory();
        router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

        if (router.params.browserHistory) {
          History$1.clearRouterQueue();
        }
      }

      function setPositionClasses() {
        router.setPagePosition($oldPage, 'current', false);
        router.setPagePosition($newPage, 'next', false);

        if (dynamicNavbar) {
          router.setNavbarPosition($oldNavbarEl, 'current', false);
          router.setNavbarPosition($newNavbarEl, 'next', false);
        }
      }

      if (options.animate && !(isMaster && app.width >= router.params.masterDetailBreakpoint)) {
        var delay = router.params[router.app.theme + "PageLoadDelay"];
        var transition = router.params.transition;
        if (options.transition) transition = options.transition;

        if (!transition && router.currentRoute && router.currentRoute.route) {
          transition = router.currentRoute.route.transition;
        }

        if (!transition && router.currentRoute && router.currentRoute.route.options) {
          transition = router.currentRoute.route.options.transition;
        }

        if (transition) {
          $newPage[0].f7PageTransition = transition;
        }

        if (delay) {
          setTimeout(function () {
            setPositionClasses();
            router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'forward', transition, function () {
              afterAnimation();
            });
          }, delay);
        } else {
          setPositionClasses();
          router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'forward', transition, function () {
            afterAnimation();
          });
        }
      } else {
        afterAnimation();
      }

      return router;
    }

    function load(router, loadParams, loadOptions, ignorePageChange) {
      if (loadParams === void 0) {
        loadParams = {};
      }

      if (loadOptions === void 0) {
        loadOptions = {};
      }

      if (!router.allowPageChange && !ignorePageChange) return router;
      var params = loadParams;
      var options = loadOptions;
      var url = params.url,
          content = params.content,
          el = params.el,
          pageName = params.pageName,
          component = params.component,
          componentUrl = params.componentUrl;

      if (!options.reloadCurrent && options.route && options.route.route && options.route.route.parentPath && router.currentRoute.route && router.currentRoute.route.parentPath === options.route.route.parentPath) {
        // Do something nested
        if (options.route.url === router.url) {
          router.allowPageChange = true;
          return false;
        } // Check for same params


        var sameParams = Object.keys(options.route.params).length === Object.keys(router.currentRoute.params).length;

        if (sameParams) {
          // Check for equal params name
          Object.keys(options.route.params).forEach(function (paramName) {
            if (!(paramName in router.currentRoute.params) || router.currentRoute.params[paramName] !== options.route.params[paramName]) {
              sameParams = false;
            }
          });
        }

        if (sameParams) {
          if (options.route.route.tab) {
            return router.tabLoad(options.route.route.tab, options);
          }

          return false;
        }

        if (!sameParams && options.route.route.tab && router.currentRoute.route.tab && router.currentRoute.parentPath === options.route.parentPath) {
          return router.tabLoad(options.route.route.tab, options);
        }
      }

      if (options.route && options.route.url && router.url === options.route.url && !(options.reloadCurrent || options.reloadPrevious) && !router.params.allowDuplicateUrls) {
        router.allowPageChange = true;
        return false;
      }

      if (!options.route && url) {
        options.route = router.parseRouteUrl(url);
        extend$1(options.route, {
          route: {
            url: url,
            path: url
          }
        });
      } // Component Callbacks


      function resolve(pageEl, newOptions) {
        return forward(router, pageEl, extend$1(options, newOptions));
      }

      function reject() {
        router.allowPageChange = true;
        return router;
      }

      if (url || componentUrl || component) {
        router.allowPageChange = false;
      } // Proceed


      if (content) {
        forward(router, router.getPageEl(content), options);
      } else if (el) {
        // Load page from specified HTMLElement or by page name in pages container
        forward(router, router.getPageEl(el), options);
      } else if (pageName) {
        // Load page by page name in pages container
        forward(router, router.$el.children(".page[data-name=\"" + pageName + "\"]").eq(0), options);
      } else if (component || componentUrl) {
        // Load from component (F7/Vue/React/...)
        try {
          router.pageComponentLoader({
            routerEl: router.el,
            component: component,
            componentUrl: componentUrl,
            options: options,
            resolve: resolve,
            reject: reject
          });
        } catch (err) {
          router.allowPageChange = true;
          throw err;
        }
      } else if (url) {
        // Load using XHR
        if (router.xhrAbortController) {
          router.xhrAbortController.abort();
          router.xhrAbortController = false;
        }

        router.xhrRequest(url, options).then(function (pageContent) {
          forward(router, router.getPageEl(pageContent), options);
        }).catch(function () {
          router.allowPageChange = true;
        });
      }

      return router;
    }

    function openIn(router, url, options) {
      var navigateOptions = {
        url: url,
        route: {
          path: url,
          options: _extends$2({}, options, {
            openIn: undefined
          })
        }
      };

      var params = _extends$2({}, options);

      if (options.openIn === 'popup') {
        params.content = "<div class=\"popup popup-router-open-in\" data-url=\"" + url + "\"><div class=\"view view-init\" data-links-view=\"" + router.view.selector + "\" data-url=\"" + url + "\" data-ignore-open-in=\"true\"></div></div>";
        navigateOptions.route.popup = params;
      }

      if (options.openIn === 'loginScreen') {
        params.content = "<div class=\"login-screen login-screen-router-open-in\" data-url=\"" + url + "\"><div class=\"view view-init\" data-links-view=\"" + router.view.selector + "\" data-url=\"" + url + "\" data-ignore-open-in=\"true\"></div></div>";
        navigateOptions.route.loginScreen = params;
      }

      if (options.openIn === 'sheet') {
        params.content = "<div class=\"sheet-modal sheet-modal-router-open-in\" data-url=\"" + url + "\"><div class=\"sheet-modal-inner\"><div class=\"view view-init\" data-links-view=\"" + router.view.selector + "\" data-url=\"" + url + "\" data-ignore-open-in=\"true\"></div></div></div>";
        navigateOptions.route.sheet = params;
      }

      if (options.openIn === 'popover') {
        params.targetEl = options.clickedEl || options.targetEl;
        params.content = "<div class=\"popover popover-router-open-in\" data-url=\"" + url + "\"><div class=\"popover-inner\"><div class=\"view view-init\" data-links-view=\"" + router.view.selector + "\" data-url=\"" + url + "\" data-ignore-open-in=\"true\"></div></div></div>";
        navigateOptions.route.popover = params;
      }

      if (options.openIn.indexOf('panel') >= 0) {
        var parts = options.openIn.split(':');
        var side = parts[1] || 'left';
        var effect = parts[2] || 'cover';
        params.targetEl = options.clickedEl || options.targetEl;
        params.content = "<div class=\"panel panel-router-open-in panel-" + side + " panel-" + effect + "\" data-url=\"" + url + "\"><div class=\"view view-init\" data-links-view=\"" + router.view.selector + "\" data-url=\"" + url + "\" data-ignore-open-in=\"true\"></div></div>";
        navigateOptions.route.panel = params;
      }

      return router.navigate(navigateOptions);
    }

    function navigate(navigateParams, navigateOptions) {
      if (navigateOptions === void 0) {
        navigateOptions = {};
      }

      var router = this;
      if (router.swipeBackActive) return router;
      var url;
      var createRoute;
      var name;
      var path;
      var query;
      var params;
      var route;

      if (typeof navigateParams === 'string') {
        url = navigateParams;
      } else {
        url = navigateParams.url;
        createRoute = navigateParams.route;
        name = navigateParams.name;
        path = navigateParams.path;
        query = navigateParams.query;
        params = navigateParams.params;
      }

      if (name || path) {
        url = router.generateUrl({
          path: path,
          name: name,
          params: params,
          query: query
        });

        if (url) {
          return router.navigate(url, navigateOptions);
        }

        return router;
      }

      var app = router.app;
      appRouterCheck(router, 'navigate');

      if (url === '#' || url === '') {
        return router;
      }

      var navigateUrl = url.replace('./', '');

      if (navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
        var currentPath = router.currentRoute.parentPath || router.currentRoute.path;
        navigateUrl = ((currentPath ? currentPath + "/" : '/') + navigateUrl).replace('///', '/').replace('//', '/');
      }

      if (createRoute) {
        route = extend$1(router.parseRouteUrl(navigateUrl), {
          route: extend$1({}, createRoute)
        });
      } else {
        route = router.findMatchingRoute(navigateUrl);
      }

      if (!route) {
        return router;
      }

      if (route.route && route.route.viewName) {
        var anotherViewName = route.route.viewName;
        var anotherView = app.views[anotherViewName];

        if (!anotherView) {
          throw new Error("Framework7: There is no View with \"" + anotherViewName + "\" name that was specified in this route");
        }

        if (anotherView !== router.view) {
          return anotherView.router.navigate(navigateParams, navigateOptions);
        }
      }

      if (route.route.redirect) {
        return redirect.call(router, 'forward', route, navigateOptions);
      }

      var options = {};

      if (route.route.options) {
        extend$1(options, route.route.options, navigateOptions);
      } else {
        extend$1(options, navigateOptions);
      }

      if (options.openIn && (!router.params.ignoreOpenIn || router.params.ignoreOpenIn && router.history.length > 0)) {
        return openIn(router, navigateUrl, options);
      }

      options.route = route;

      function resolve() {
        var routerLoaded = false;
        'popup popover sheet loginScreen actions customModal panel'.split(' ').forEach(function (modalLoadProp) {
          if (route.route[modalLoadProp] && !routerLoaded) {
            routerLoaded = true;
            router.modalLoad(modalLoadProp, route, options, 'forward');
          }
        });

        if (route.route.keepAlive && route.route.keepAliveData) {
          load(router, {
            el: route.route.keepAliveData.pageEl
          }, options, false);
          routerLoaded = true;
        }

        'url content component pageName el componentUrl'.split(' ').forEach(function (pageLoadProp) {
          if (route.route[pageLoadProp] && !routerLoaded) {
            var _load;

            routerLoaded = true;
            load(router, (_load = {}, _load[pageLoadProp] = route.route[pageLoadProp], _load), options, false);
          }
        });
        if (routerLoaded) return; // Async

        function asyncResolve(resolveParams, resolveOptions) {
          router.allowPageChange = false;
          var resolvedAsModal = false;
          'popup popover sheet loginScreen actions customModal panel'.split(' ').forEach(function (modalLoadProp) {
            if (resolveParams[modalLoadProp]) {
              resolvedAsModal = true;
              var modalRoute = extend$1({}, route, {
                route: resolveParams
              });
              router.allowPageChange = true;
              router.modalLoad(modalLoadProp, modalRoute, extend$1(options, resolveOptions), 'forward');
            }
          });
          if (resolvedAsModal) return;
          load(router, resolveParams, extend$1(options, resolveOptions), true);
        }

        function asyncReject() {
          router.allowPageChange = true;
        }

        if (route.route.async) {
          router.allowPageChange = false;
          route.route.async.call(router, {
            router: router,
            to: options.route,
            from: router.currentRoute,
            resolve: asyncResolve,
            reject: asyncReject,
            direction: 'forward',
            app: app
          });
        }

        if (route.route.asyncComponent) {
          asyncComponent(router, route.route.asyncComponent, asyncResolve, asyncReject);
        }
      }

      function reject() {
        router.allowPageChange = true;
      }

      if (router.params.masterDetailBreakpoint > 0 && route.route.masterRoute) {
        // load detail route
        var preloadMaster = true;
        var masterLoaded = false;

        if (router.currentRoute && router.currentRoute.route) {
          if ((router.currentRoute.route.master === true || typeof router.currentRoute.route.master === 'function' && router.currentRoute.route.master(app, router)) && (router.currentRoute.route === route.route.masterRoute || router.currentRoute.route.path === route.route.masterRoute.path)) {
            preloadMaster = false;
          }

          if (router.currentRoute.route.masterRoute && (router.currentRoute.route.masterRoute === route.route.masterRoute || router.currentRoute.route.masterRoute.path === route.route.masterRoute.path)) {
            preloadMaster = false;
            masterLoaded = true;
          }
        }

        if (preloadMaster || masterLoaded && navigateOptions.reloadAll) {
          router.navigate({
            path: route.route.masterRoute.path,
            params: route.params || {}
          }, {
            animate: false,
            reloadAll: navigateOptions.reloadAll,
            reloadCurrent: navigateOptions.reloadCurrent,
            reloadPrevious: navigateOptions.reloadPrevious,
            browserHistory: !navigateOptions.initial,
            history: !navigateOptions.initial,
            once: {
              pageAfterIn: function pageAfterIn() {
                router.navigate(navigateParams, extend$1({}, navigateOptions, {
                  animate: false,
                  reloadAll: false,
                  reloadCurrent: false,
                  reloadPrevious: false,
                  history: !navigateOptions.initial,
                  browserHistory: !navigateOptions.initial
                }));
              }
            }
          });
          return router;
        }
      }

      processRouteQueue.call(router, route, router.currentRoute, function () {
        if (route.route.modules) {
          app.loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules]).then(function () {
            resolve();
          }).catch(function () {
            reject();
          });
        } else {
          resolve();
        }
      }, function () {
        reject();
      }, 'forward'); // Return Router

      return router;
    }

    function tabLoad(tabRoute, loadOptions) {
      if (loadOptions === void 0) {
        loadOptions = {};
      }

      var router = this;
      var options = extend$1({
        animate: router.params.animate,
        browserHistory: true,
        history: true,
        parentPageEl: null,
        preload: false,
        on: {}
      }, loadOptions);
      var currentRoute;
      var previousRoute;

      if (options.route) {
        // Set Route
        if (!options.preload && options.route !== router.currentRoute) {
          previousRoute = router.previousRoute;
          router.currentRoute = options.route;
        }

        if (options.preload) {
          currentRoute = options.route;
          previousRoute = router.currentRoute;
        } else {
          currentRoute = router.currentRoute;
          if (!previousRoute) previousRoute = router.previousRoute;
        } // Update Browser History


        if (router.params.browserHistory && options.browserHistory && !options.reloadPrevious) {
          History$1.replace(router.view.id, {
            url: options.route.url
          }, (router.params.browserHistoryRoot || '') + router.params.browserHistorySeparator + options.route.url);
        } // Update Router History


        if (options.history) {
          router.history[Math.max(router.history.length - 1, 0)] = options.route.url;
          router.saveHistory();
        }
      } // Show Tab


      var $parentPageEl = $(options.parentPageEl || router.currentPageEl);
      var tabEl;

      if ($parentPageEl.length && $parentPageEl.find("#" + tabRoute.id).length) {
        tabEl = $parentPageEl.find("#" + tabRoute.id).eq(0);
      } else if (router.view.selector) {
        tabEl = router.view.selector + " #" + tabRoute.id;
      } else {
        tabEl = "#" + tabRoute.id;
      }

      var tabShowResult = router.app.tab.show({
        tabEl: tabEl,
        animate: options.animate,
        tabRoute: options.route
      });
      var $newTabEl = tabShowResult.$newTabEl,
          $oldTabEl = tabShowResult.$oldTabEl,
          animated = tabShowResult.animated,
          onTabsChanged = tabShowResult.onTabsChanged;

      if ($newTabEl && $newTabEl.parents('.page').length > 0 && options.route) {
        var tabParentPageData = $newTabEl.parents('.page')[0].f7Page;

        if (tabParentPageData && options.route) {
          tabParentPageData.route = options.route;
        }
      } // Tab Content Loaded


      function onTabLoaded(contentEl) {
        // Remove theme elements
        router.removeThemeElements($newTabEl);
        var tabEventTarget = $newTabEl;
        if (typeof contentEl !== 'string') tabEventTarget = $(contentEl);
        tabEventTarget.trigger('tab:init tab:mounted', tabRoute);
        router.emit('tabInit tabMounted', $newTabEl[0], tabRoute);

        if ($oldTabEl && $oldTabEl.length) {
          if (animated) {
            onTabsChanged(function () {
              router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

              if (router.params.unloadTabContent) {
                router.tabRemove($oldTabEl, $newTabEl, tabRoute);
              }
            });
          } else {
            router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

            if (router.params.unloadTabContent) {
              router.tabRemove($oldTabEl, $newTabEl, tabRoute);
            }
          }
        }
      }

      if ($newTabEl[0].f7RouterTabLoaded) {
        if (!$oldTabEl || !$oldTabEl.length) return router;

        if (animated) {
          onTabsChanged(function () {
            router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
          });
        } else {
          router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
        }

        return router;
      } // Load Tab Content


      function loadTab(loadTabParams, loadTabOptions) {
        // Load Tab Props
        var url = loadTabParams.url,
            content = loadTabParams.content,
            el = loadTabParams.el,
            component = loadTabParams.component,
            componentUrl = loadTabParams.componentUrl; // Component/Template Callbacks

        function resolve(contentEl) {
          router.allowPageChange = true;
          if (!contentEl) return;

          if (typeof contentEl === 'string') {
            $newTabEl.html(contentEl);
          } else {
            $newTabEl.html('');

            if (contentEl.f7Component) {
              contentEl.f7Component.mount(function (componentEl) {
                $newTabEl.append(componentEl);
              });
            } else {
              $newTabEl.append(contentEl);
            }
          }

          $newTabEl[0].f7RouterTabLoaded = true;
          onTabLoaded(contentEl);
        }

        function reject() {
          router.allowPageChange = true;
          return router;
        }

        if (content) {
          resolve(content);
        } else if (el) {
          resolve(el);
        } else if (component || componentUrl) {
          // Load from component (F7/Vue/React/...)
          try {
            router.tabComponentLoader({
              tabEl: $newTabEl[0],
              component: component,
              componentUrl: componentUrl,
              options: loadTabOptions,
              resolve: resolve,
              reject: reject
            });
          } catch (err) {
            router.allowPageChange = true;
            throw err;
          }
        } else if (url) {
          // Load using XHR
          if (router.xhrAbortController) {
            router.xhrAbortController.abort();
            router.xhrAbortController = false;
          }

          router.xhrRequest(url, loadTabOptions).then(function (tabContent) {
            resolve(tabContent);
          }).catch(function () {
            router.allowPageChange = true;
          });
        }
      }

      var hasContentLoadProp;
      'url content component el componentUrl'.split(' ').forEach(function (tabLoadProp) {
        if (tabRoute[tabLoadProp]) {
          var _loadTab;

          hasContentLoadProp = true;
          loadTab((_loadTab = {}, _loadTab[tabLoadProp] = tabRoute[tabLoadProp], _loadTab), options);
        }
      }); // Async

      function asyncResolve(resolveParams, resolveOptions) {
        loadTab(resolveParams, extend$1(options, resolveOptions));
      }

      function asyncReject() {
        router.allowPageChange = true;
      }

      if (tabRoute.async) {
        tabRoute.async.call(router, {
          router: router,
          to: currentRoute,
          from: previousRoute,
          resolve: asyncResolve,
          reject: asyncReject,
          app: router.app
        });
      } else if (tabRoute.asyncComponent) {
        asyncComponent(router, tabRoute.asyncComponent, asyncResolve, asyncReject);
      } else if (!hasContentLoadProp) {
        router.allowPageChange = true;
      }

      return router;
    }

    function tabRemove($oldTabEl, $newTabEl, tabRoute) {
      var router = this;
      var hasTabComponentChild;

      if ($oldTabEl[0]) {
        $oldTabEl[0].f7RouterTabLoaded = false;
        delete $oldTabEl[0].f7RouterTabLoaded;
      }

      $oldTabEl.children().each(function (tabChild) {
        if (tabChild.f7Component) {
          hasTabComponentChild = true;
          $(tabChild).trigger('tab:beforeremove', tabRoute);
          tabChild.f7Component.destroy();
        }
      });

      if (!hasTabComponentChild) {
        $oldTabEl.trigger('tab:beforeremove', tabRoute);
      }

      router.emit('tabBeforeRemove', $oldTabEl[0], $newTabEl[0], tabRoute);
      router.removeTabContent($oldTabEl[0], tabRoute);
    }

    function modalLoad(modalType, route, loadOptions, direction) {
      if (loadOptions === void 0) {
        loadOptions = {};
      }

      var router = this;
      var app = router.app;
      var isPanel = modalType === 'panel';
      var modalOrPanel = isPanel ? 'panel' : 'modal';
      var options = extend$1({
        animate: router.params.animate,
        browserHistory: true,
        history: true,
        on: {},
        once: {}
      }, loadOptions);
      var modalParams = extend$1({}, route.route[modalType]);
      var modalRoute = route.route;

      var routeCallback = function routeCallback(modal, name) {
        var on = options.on,
            once = options.once;
        var callback;

        if (name === 'open') {
          callback = on.modalOpen || once.modalOpen || on.panelOpen || once.panelOpen;
        }

        if (name === 'close') {
          callback = on.modalClose || once.modalClose || on.panelClose || once.panelClose;
        }

        if (name === 'closed') {
          callback = on.modalClosed || once.modalClosed || on.panelClosed || once.panelClosed;
        }

        if (callback) callback(modal);
      };

      function onModalLoaded() {
        // Create Modal
        var modal = app[modalType].create(modalParams);
        modalRoute.modalInstance = modal;
        var hasEl = modal.el;

        function closeOnSwipeBack() {
          modal.close();
        }

        modal.on(modalOrPanel + "Open", function () {
          if (!hasEl) {
            // Remove theme elements
            router.removeThemeElements(modal.el); // Emit events

            modal.$el.trigger(modalType.toLowerCase() + ":init " + modalType.toLowerCase() + ":mounted", route, modal);
            router.emit((!isPanel ? 'modalInit' : '') + " " + modalType + "Init " + modalType + "Mounted", modal.el, route, modal);
          }

          router.once('swipeBackMove', closeOnSwipeBack);
          routeCallback(modal, 'open');
        });
        modal.on(modalOrPanel + "Close", function () {
          router.off('swipeBackMove', closeOnSwipeBack);

          if (!modal.closeByRouter) {
            router.back();
          }

          routeCallback(modal, 'close');
        });
        modal.on(modalOrPanel + "Closed", function () {
          modal.$el.trigger(modalType.toLowerCase() + ":beforeremove", route, modal);
          modal.emit("" + (!isPanel ? 'modalBeforeRemove ' : '') + modalType + "BeforeRemove", modal.el, route, modal);
          var modalComponent = modal.el.f7Component;
          routeCallback(modal, 'closed');

          if (modalComponent) {
            modalComponent.destroy();
          }

          nextTick(function () {
            if (modalComponent || modalParams.component || modalParams.asyncComponent) {
              router.removeModal(modal.el);
            }

            modal.destroy();
            delete modal.route;
            delete modalRoute.modalInstance;
          });
        });

        if (options.route) {
          // Update Browser History
          if (router.params.browserHistory && options.browserHistory) {
            History$1.push(router.view.id, {
              url: options.route.url,
              modal: modalType
            }, (router.params.browserHistoryRoot || '') + router.params.browserHistorySeparator + options.route.url);
          } // Set Route


          if (options.route !== router.currentRoute) {
            modal.route = extend$1(options.route, {
              modal: modal
            });
            router.currentRoute = modal.route;
          } // Update Router History


          if (options.history && !options.reloadCurrent) {
            router.history.push(options.route.url);
            router.saveHistory();
          }
        }

        if (hasEl) {
          // Remove theme elements
          router.removeThemeElements(modal.el); // Emit events

          modal.$el.trigger(modalType.toLowerCase() + ":init " + modalType.toLowerCase() + ":mounted", route, modal);
          router.emit(modalOrPanel + "Init " + modalType + "Init " + modalType + "Mounted", modal.el, route, modal);
        } // Open


        modal.open(options.animate === false || options.animate === true ? options.animate : undefined);
      } // Load Modal Content


      function loadModal(loadModalParams, loadModalOptions) {
        // Load Modal Props
        var url = loadModalParams.url,
            content = loadModalParams.content,
            component = loadModalParams.component,
            componentUrl = loadModalParams.componentUrl; // Component/Template Callbacks

        function resolve(contentEl) {
          if (contentEl) {
            if (typeof contentEl === 'string') {
              modalParams.content = contentEl;
            } else if (contentEl.f7Component) {
              contentEl.f7Component.mount(function (componentEl) {
                modalParams.el = componentEl;
                app.$el.append(componentEl);
              });
            } else {
              modalParams.el = contentEl;
            }

            onModalLoaded();
          }
        }

        function reject() {
          router.allowPageChange = true;
          return router;
        }

        if (content) {
          resolve(content);
        } else if (component || componentUrl) {
          // Load from component (F7/Vue/React/...)
          try {
            router.modalComponentLoader({
              rootEl: app.el,
              component: component,
              componentUrl: componentUrl,
              options: loadModalOptions,
              resolve: resolve,
              reject: reject
            });
          } catch (err) {
            router.allowPageChange = true;
            throw err;
          }
        } else if (url) {
          // Load using XHR
          if (router.xhrAbortController) {
            router.xhrAbortController.abort();
            router.xhrAbortController = false;
          }

          router.xhrRequest(url, loadModalOptions).then(function (modalContent) {
            modalParams.content = modalContent;
            onModalLoaded();
          }).catch(function () {
            router.allowPageChange = true;
          });
        } else {
          onModalLoaded();
        }
      }

      var foundLoadProp;
      'url content component el componentUrl template'.split(' ').forEach(function (modalLoadProp) {
        if (modalParams[modalLoadProp] && !foundLoadProp) {
          var _loadModal;

          foundLoadProp = true;
          loadModal((_loadModal = {}, _loadModal[modalLoadProp] = modalParams[modalLoadProp], _loadModal), options);
        }
      });

      if (!foundLoadProp && modalType === 'actions') {
        onModalLoaded();
      } // Async


      function asyncResolve(resolveParams, resolveOptions) {
        loadModal(resolveParams, extend$1(options, resolveOptions));
      }

      function asyncReject() {
        router.allowPageChange = true;
      }

      if (modalParams.async) {
        modalParams.async.call(router, {
          router: router,
          to: options.route,
          from: router.currentRoute,
          resolve: asyncResolve,
          reject: asyncReject,
          direction: direction,
          app: app
        });
      }

      if (modalParams.asyncComponent) {
        asyncComponent(router, modalParams.asyncComponent, asyncResolve, asyncReject);
      }

      return router;
    }

    function modalRemove(modal) {
      extend$1(modal, {
        closeByRouter: true
      });
      modal.close();
    }

    function backward(router, el, backwardOptions) {
      var device = getDevice();
      var document = getDocument();
      var $el = $(el);
      var app = router.app;
      var view = router.view;
      var options = extend$1({
        animate: router.params.animate,
        browserHistory: true,
        replaceState: false
      }, backwardOptions);
      var masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
      var isMaster = masterDetailEnabled && options.route && options.route.route && (options.route.route.master === true || typeof options.route.route.master === 'function' && options.route.route.master(app, router));
      var masterPageEl;
      var masterPageRemoved;
      var dynamicNavbar = router.dynamicNavbar;
      var $newPage = $el;
      var $oldPage = router.$el.children('.page-current');
      var initialPreload = $oldPage.length === 0 && options.preload;
      var currentIsMaster = masterDetailEnabled && $oldPage.hasClass('page-master');

      if ($newPage.length) {
        // Remove theme elements
        router.removeThemeElements($newPage);
      }

      var $navbarsEl;
      var $newNavbarEl;
      var $oldNavbarEl;

      if (dynamicNavbar) {
        $newNavbarEl = $newPage.children('.navbar');
        $navbarsEl = router.$navbarsEl;

        if ($newNavbarEl.length === 0 && $newPage[0] && $newPage[0].f7Page) {
          // Try from pageData
          $newNavbarEl = $newPage[0].f7Page.$navbarEl;
        }

        $oldNavbarEl = $navbarsEl.find('.navbar-current');
      }

      router.allowPageChange = false;

      if ($newPage.length === 0 || $oldPage.length === 0 && !options.preload) {
        router.allowPageChange = true;
        return router;
      } // Remove theme elements


      router.removeThemeElements($newPage); // Save Keep Alive Cache

      if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
        options.route.route.keepAliveData = {
          pageEl: $el[0]
        };
      } // Pages In View


      var isDetail;
      var isDetailRoot;

      if (masterDetailEnabled) {
        var $pagesInView = router.$el.children('.page:not(.stacked)').filter(function (pageInView) {
          return pageInView !== $newPage[0];
        }); // Find Detail' master page

        for (var i = 0; i < $pagesInView.length; i += 1) {
          if (!masterPageEl && $pagesInView[i].classList.contains('page-master')) {
            masterPageEl = $pagesInView[i];
            continue; // eslint-disable-line
          }
        }

        isDetail = !isMaster && masterPageEl && router.history.indexOf(options.route.url) > router.history.indexOf(masterPageEl.f7Page.route.url);

        if (!isDetail && !isMaster && masterPageEl && masterPageEl.f7Page && options.route.route.masterRoute) {
          isDetail = options.route.route.masterRoute.path === masterPageEl.f7Page.route.route.path;
        }
      }

      if (isDetail && masterPageEl && masterPageEl.f7Page) {
        isDetailRoot = router.history.indexOf(options.route.url) - router.history.indexOf(masterPageEl.f7Page.route.url) === 1;
      } // New Page


      $newPage.addClass("page-" + (initialPreload ? 'current' : 'previous') + (isMaster ? ' page-master' : '') + (isDetail ? ' page-master-detail' : '') + (isDetailRoot ? ' page-master-detail-root' : '')).removeClass('stacked').removeAttr('aria-hidden').trigger('page:unstack').trigger('page:position', {
        position: initialPreload ? 'current' : 'previous'
      });
      router.emit('pageUnstack', $newPage[0]);
      router.emit('pagePosition', $newPage[0], initialPreload ? 'current' : 'previous');

      if (isMaster || isDetail) {
        $newPage.trigger('page:role', {
          role: isMaster ? 'master' : 'detail',
          root: !!isDetailRoot
        });
        router.emit('pageRole', $newPage[0], {
          role: isMaster ? 'master' : 'detail',
          detailRoot: !!isDetailRoot
        });
      }

      if (dynamicNavbar && $newNavbarEl.length > 0) {
        $newNavbarEl.addClass("navbar-" + (initialPreload ? 'current' : 'previous') + (isMaster ? ' navbar-master' : '') + (isDetail ? ' navbar-master-detail' : '') + (isDetailRoot ? ' navbar-master-detail-root' : '')).removeClass('stacked').removeAttr('aria-hidden');
        $newNavbarEl.trigger('navbar:position', {
          position: initialPreload ? 'current' : 'previous'
        });
        router.emit('navbarPosition', $newNavbarEl[0], initialPreload ? 'current' : 'previous');

        if (isMaster || isDetailRoot) {
          router.emit('navbarRole', $newNavbarEl[0], {
            role: isMaster ? 'master' : 'detail',
            detailRoot: !!isDetailRoot
          });
        }
      } // Remove previous page in case of "forced"


      var backIndex;

      if (options.force) {
        if ($oldPage.prev('.page-previous:not(.stacked)').length > 0 || $oldPage.prev('.page-previous').length === 0) {
          if (router.history.indexOf(options.route.url) >= 0) {
            backIndex = router.history.length - router.history.indexOf(options.route.url) - 1;
            router.history = router.history.slice(0, router.history.indexOf(options.route.url) + 2);
            view.history = router.history;
          } else if (router.history[[router.history.length - 2]]) {
            router.history[router.history.length - 2] = options.route.url;
          } else {
            router.history.unshift(router.url);
          }

          if (backIndex && router.params.stackPages) {
            $oldPage.prevAll('.page-previous').each(function (pageToRemove) {
              var $pageToRemove = $(pageToRemove);
              var $navbarToRemove;

              if (dynamicNavbar) {
                // $navbarToRemove = $oldNavbarEl.prevAll('.navbar-previous').eq(index);
                $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
              }

              if ($pageToRemove[0] !== $newPage[0] && $pageToRemove.index() > $newPage.index()) {
                if (router.initialPages.indexOf($pageToRemove[0]) >= 0) {
                  $pageToRemove.addClass('stacked');
                  $pageToRemove.trigger('page:stack');
                  router.emit('pageStack', $pageToRemove[0]);

                  if (dynamicNavbar) {
                    $navbarToRemove.addClass('stacked');
                  }
                } else {
                  router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);

                  if ($pageToRemove[0] === masterPageEl) {
                    masterPageRemoved = true;
                  }

                  router.removePage($pageToRemove);

                  if (dynamicNavbar && $navbarToRemove.length > 0) {
                    router.removeNavbar($navbarToRemove);
                  }
                }
              }
            });
          } else {
            var $pageToRemove = $oldPage.prev('.page-previous:not(.stacked)');
            var $navbarToRemove;

            if (dynamicNavbar) {
              // $navbarToRemove = $oldNavbarEl.prev('.navbar-inner:not(.stacked)');
              $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
            }

            if (router.params.stackPages && router.initialPages.indexOf($pageToRemove[0]) >= 0) {
              $pageToRemove.addClass('stacked');
              $pageToRemove.trigger('page:stack');
              router.emit('pageStack', $pageToRemove[0]);
              $navbarToRemove.addClass('stacked');
            } else if ($pageToRemove.length > 0) {
              router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);

              if ($pageToRemove[0] === masterPageEl) {
                masterPageRemoved = true;
              }

              router.removePage($pageToRemove);

              if (dynamicNavbar && $navbarToRemove.length) {
                router.removeNavbar($navbarToRemove);
              }
            }
          }
        }
      } // Insert new page


      var newPageInDom = $newPage.parents(document).length > 0;
      var f7Component = $newPage[0].f7Component;

      function insertPage() {
        if (initialPreload) {
          if (!newPageInDom && f7Component) {
            f7Component.mount(function (componentEl) {
              router.$el.append(componentEl);
            });
          } else {
            router.$el.append($newPage);
          }
        }

        if ($newPage.next($oldPage).length === 0) {
          if (!newPageInDom && f7Component) {
            f7Component.mount(function (componentEl) {
              $(componentEl).insertBefore($oldPage);
            });
          } else {
            $newPage.insertBefore($oldPage);
          }
        }

        if (dynamicNavbar && $newNavbarEl.length) {
          if ($newNavbarEl.find('.title-large').length) {
            $newNavbarEl.addClass('navbar-large');
          }

          $newNavbarEl.insertBefore($oldNavbarEl);

          if ($oldNavbarEl.length > 0) {
            $newNavbarEl.insertBefore($oldNavbarEl);
          } else {
            if (!router.$navbarsEl.parents(document).length) {
              router.$el.prepend(router.$navbarsEl);
            }

            $navbarsEl.append($newNavbarEl);
          }
        }

        if (!newPageInDom) {
          router.pageCallback('mounted', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);
        } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
          $newPage[0].f7PageMounted = true;
          router.pageCallback('mounted', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);
        }
      }

      if (options.preload) {
        // Insert Page
        insertPage(); // Tab route

        if (options.route.route.tab) {
          router.tabLoad(options.route.route.tab, extend$1({}, options, {
            history: false,
            browserHistory: false,
            preload: true
          }));
        }

        if (isMaster) {
          $newPage.removeClass('page-master-stacked').trigger('page:masterunstack');
          router.emit('pageMasterUnstack', $newPage[0]);

          if (dynamicNavbar) {
            $(app.navbar.getElByPage($newPage)).removeClass('navbar-master-stacked');
            router.emit('navbarMasterUnstack', app.navbar.getElByPage($newPage));
          }
        } // Page init and before init events


        router.pageCallback('init', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);

        if (initialPreload) {
          router.pageCallback('beforeIn', $newPage, $newNavbarEl, 'current', undefined, options);
          router.pageCallback('afterIn', $newPage, $newNavbarEl, 'current', undefined, options);
        }

        var $previousPages = $newPage.prevAll('.page-previous:not(.stacked):not(.page-master)');

        if ($previousPages.length > 0) {
          $previousPages.each(function (pageToRemove) {
            var $pageToRemove = $(pageToRemove);
            var $navbarToRemove;

            if (dynamicNavbar) {
              // $navbarToRemove = $newNavbarEl.prevAll('.navbar-previous:not(.stacked)').eq(index);
              $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
            }

            if (router.params.stackPages && router.initialPages.indexOf(pageToRemove) >= 0) {
              $pageToRemove.addClass('stacked');
              $pageToRemove.trigger('page:stack');
              router.emit('pageStack', $pageToRemove[0]);

              if (dynamicNavbar) {
                $navbarToRemove.addClass('stacked');
              }
            } else {
              router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined);
              router.removePage($pageToRemove);

              if (dynamicNavbar && $navbarToRemove.length) {
                router.removeNavbar($navbarToRemove);
              }
            }
          });
        }

        router.allowPageChange = true;
        return router;
      } // History State


      if (!(device.ie || device.edge || device.firefox && !device.ios)) {
        if (router.params.browserHistory && options.browserHistory) {
          if (options.replaceState) {
            var browserHistoryRoot = router.params.browserHistoryRoot || '';
            History$1.replace(view.id, {
              url: options.route.url
            }, browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
          } else if (backIndex) {
            History$1.go(-backIndex);
          } else {
            History$1.back();
          }
        }
      } // Update History


      if (options.replaceState) {
        router.history[router.history.length - 1] = options.route.url;
      } else {
        if (router.history.length === 1) {
          router.history.unshift(router.url);
        }

        router.history.pop();
      }

      router.saveHistory(); // Current Page & Navbar

      router.currentPageEl = $newPage[0];

      if (dynamicNavbar && $newNavbarEl.length) {
        router.currentNavbarEl = $newNavbarEl[0];
      } else {
        delete router.currentNavbarEl;
      } // Current Route


      router.currentRoute = options.route; // History State

      if (device.ie || device.edge || device.firefox && !device.ios) {
        if (router.params.browserHistory && options.browserHistory) {
          if (options.replaceState) {
            var _browserHistoryRoot = router.params.browserHistoryRoot || '';

            History$1.replace(view.id, {
              url: options.route.url
            }, _browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
          } else if (backIndex) {
            History$1.go(-backIndex);
          } else {
            History$1.back();
          }
        }
      } // Insert Page


      insertPage(); // Load Tab

      if (options.route.route.tab) {
        router.tabLoad(options.route.route.tab, extend$1({}, options, {
          history: false,
          browserHistory: false
        }));
      } // Check master detail


      if (masterDetailEnabled && (currentIsMaster || masterPageRemoved)) {
        view.checkMasterDetailBreakpoint(false);
      } // Page init and before init events


      router.pageCallback('init', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage); // Before animation callback

      router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', 'next', options);
      router.pageCallback('beforeIn', $newPage, $newNavbarEl, 'previous', 'current', options); // Animation

      function afterAnimation() {
        // Set classes
        router.setPagePosition($newPage, 'current', false);
        router.setPagePosition($oldPage, 'next', true);

        if (dynamicNavbar) {
          router.setNavbarPosition($newNavbarEl, 'current', false);
          router.setNavbarPosition($oldNavbarEl, 'next', true);
        } // After animation event


        router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', 'next', options);
        router.pageCallback('afterIn', $newPage, $newNavbarEl, 'previous', 'current', options); // Remove Old Page

        if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
          $oldPage.addClass('stacked');
          $oldPage.trigger('page:stack');
          router.emit('pageStack', $oldPage[0]);

          if (dynamicNavbar) {
            $oldNavbarEl.addClass('stacked');
          }
        } else {
          router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'next', undefined, options);
          router.removePage($oldPage);

          if (dynamicNavbar && $oldNavbarEl.length) {
            router.removeNavbar($oldNavbarEl);
          }
        }

        router.allowPageChange = true;
        router.emit('routeChanged', router.currentRoute, router.previousRoute, router); // Preload previous page

        var preloadPreviousPage = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];

        if (preloadPreviousPage && router.history[router.history.length - 2] && !isMaster) {
          router.back(router.history[router.history.length - 2], {
            preload: true
          });
        }

        if (router.params.browserHistory) {
          History$1.clearRouterQueue();
        }
      }

      function setPositionClasses() {
        router.setPagePosition($oldPage, 'current');
        router.setPagePosition($newPage, 'previous', false);

        if (dynamicNavbar) {
          router.setNavbarPosition($oldNavbarEl, 'current');
          router.setNavbarPosition($newNavbarEl, 'previous', false);
        }
      }

      if (options.animate && !(currentIsMaster && app.width >= router.params.masterDetailBreakpoint)) {
        var transition = router.params.transition;

        if ($oldPage[0] && $oldPage[0].f7PageTransition) {
          transition = $oldPage[0].f7PageTransition;
          delete $oldPage[0].f7PageTransition;
        }

        if (options.transition) transition = options.transition;

        if (!transition && router.previousRoute && router.previousRoute.route) {
          transition = router.previousRoute.route.transition;
        }

        if (!transition && router.previousRoute && router.previousRoute.route && router.previousRoute.route.options) {
          transition = router.previousRoute.route.options.transition;
        }

        setPositionClasses();
        router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'backward', transition, function () {
          afterAnimation();
        });
      } else {
        afterAnimation();
      }

      return router;
    }

    function loadBack(router, backParams, backOptions, ignorePageChange) {
      if (!router.allowPageChange && !ignorePageChange) return router;
      var params = backParams;
      var options = backOptions;
      var url = params.url,
          content = params.content,
          el = params.el,
          pageName = params.pageName,
          component = params.component,
          componentUrl = params.componentUrl;

      if (options.route.url && router.url === options.route.url && !(options.reloadCurrent || options.reloadPrevious) && !router.params.allowDuplicateUrls) {
        return false;
      }

      if (!options.route && url) {
        options.route = router.parseRouteUrl(url);
      } // Component Callbacks


      function resolve(pageEl, newOptions) {
        return backward(router, pageEl, extend$1(options, newOptions));
      }

      function reject() {
        router.allowPageChange = true;
        return router;
      }

      if (url || componentUrl || component) {
        router.allowPageChange = false;
      } // Proceed


      if (content) {
        backward(router, router.getPageEl(content), options);
      } else if (el) {
        // Load page from specified HTMLElement or by page name in pages container
        backward(router, router.getPageEl(el), options);
      } else if (pageName) {
        // Load page by page name in pages container
        backward(router, router.$el.children(".page[data-name=\"" + pageName + "\"]").eq(0), options);
      } else if (component || componentUrl) {
        // Load from component (F7/Vue/React/...)
        try {
          router.pageComponentLoader({
            routerEl: router.el,
            component: component,
            componentUrl: componentUrl,
            options: options,
            resolve: resolve,
            reject: reject
          });
        } catch (err) {
          router.allowPageChange = true;
          throw err;
        }
      } else if (url) {
        // Load using XHR
        if (router.xhrAbortController) {
          router.xhrAbortController.abort();
          router.xhrAbortController = false;
        }

        router.xhrRequest(url, options).then(function (pageContent) {
          backward(router, router.getPageEl(pageContent), options);
        }).catch(function () {
          router.allowPageChange = true;
        });
      }

      return router;
    }

    function back() {
      var router = this;
      var device = getDevice();
      if (router.swipeBackActive) return router;
      var navigateUrl;
      var navigateOptions;
      var route;

      if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'object') {
        navigateOptions = (arguments.length <= 0 ? undefined : arguments[0]) || {};
      } else {
        navigateUrl = arguments.length <= 0 ? undefined : arguments[0];
        navigateOptions = (arguments.length <= 1 ? undefined : arguments[1]) || {};
      }

      var _navigateOptions = navigateOptions,
          name = _navigateOptions.name,
          params = _navigateOptions.params,
          query = _navigateOptions.query;

      if (name) {
        navigateUrl = router.generateUrl({
          name: name,
          params: params,
          query: query
        });

        if (navigateUrl) {
          return router.back(navigateUrl, extend$1({}, navigateOptions, {
            name: null,
            params: null,
            query: null
          }));
        }

        return router;
      }

      var app = router.app;
      appRouterCheck(router, 'back');
      var currentRouteIsModal = router.currentRoute.modal;
      var modalType;

      if (!currentRouteIsModal) {
        'popup popover sheet loginScreen actions customModal panel'.split(' ').forEach(function (modalLoadProp) {
          if (router.currentRoute.route[modalLoadProp]) {
            currentRouteIsModal = true;
            modalType = modalLoadProp;
          }
        });
      }

      if (currentRouteIsModal && !navigateOptions.preload) {
        var modalToClose = router.currentRoute.modal || router.currentRoute.route.modalInstance || app[modalType].get();
        var previousUrl = router.history[router.history.length - 2];
        var previousRoute; // check if previous route is modal too

        if (modalToClose && modalToClose.$el) {
          var prevOpenedModals = modalToClose.$el.prevAll('.modal-in');

          if (prevOpenedModals.length && prevOpenedModals[0].f7Modal) {
            var modalEl = prevOpenedModals[0]; // check if current router not inside of the modalEl

            if (!router.$el.parents(modalEl).length) {
              previousRoute = modalEl.f7Modal.route;
            }
          }
        }

        if (!previousRoute) {
          previousRoute = router.findMatchingRoute(previousUrl);
        }

        if (!previousRoute && previousUrl) {
          previousRoute = {
            url: previousUrl,
            path: previousUrl.split('?')[0],
            query: parseUrlQuery(previousUrl),
            route: {
              path: previousUrl.split('?')[0],
              url: previousUrl
            }
          };
        }

        if (!navigateUrl || navigateUrl.replace(/[# ]/g, '').trim().length === 0) {
          if (!previousRoute || !modalToClose) {
            return router;
          }
        }

        var forceOtherUrl = navigateOptions.force && previousRoute && navigateUrl;

        if (previousRoute && modalToClose) {
          var isBrokenBrowserHistory = device.ie || device.edge || device.firefox && !device.ios;
          var needHistoryBack = router.params.browserHistory && navigateOptions.browserHistory !== false;
          var currentRouteWithoutBrowserHistory = router.currentRoute && router.currentRoute.route && router.currentRoute.route.options && router.currentRoute.route.options.browserHistory === false;

          if (needHistoryBack && !isBrokenBrowserHistory && !currentRouteWithoutBrowserHistory) {
            History$1.back();
          }

          router.currentRoute = previousRoute;
          router.history.pop();
          router.saveHistory();

          if (needHistoryBack && isBrokenBrowserHistory && !currentRouteWithoutBrowserHistory) {
            History$1.back();
          }

          router.modalRemove(modalToClose);

          if (forceOtherUrl) {
            router.navigate(navigateUrl, {
              reloadCurrent: true
            });
          }
        } else if (modalToClose) {
          router.modalRemove(modalToClose);

          if (navigateUrl) {
            router.navigate(navigateUrl, {
              reloadCurrent: true
            });
          }
        }

        return router;
      }

      var $previousPage = router.$el.children('.page-current').prevAll('.page-previous:not(.page-master)').eq(0);
      var skipMaster;

      if (router.params.masterDetailBreakpoint > 0) {
        var classes = [];
        router.$el.children('.page').each(function (pageEl) {
          classes.push(pageEl.className);
        });
        var $previousMaster = router.$el.children('.page-current').prevAll('.page-master').eq(0);

        if ($previousMaster.length) {
          var expectedPreviousPageUrl = router.history[router.history.length - 2];
          var expectedPreviousPageRoute = router.findMatchingRoute(expectedPreviousPageUrl);

          if (expectedPreviousPageRoute && $previousMaster[0].f7Page && expectedPreviousPageRoute.route === $previousMaster[0].f7Page.route.route) {
            $previousPage = $previousMaster;

            if (!navigateOptions.preload) {
              skipMaster = app.width >= router.params.masterDetailBreakpoint;
            }
          }
        }
      }

      if (!navigateOptions.force && $previousPage.length && !skipMaster) {
        if (router.params.browserHistory && $previousPage[0].f7Page && router.history[router.history.length - 2] !== $previousPage[0].f7Page.route.url) {
          router.back(router.history[router.history.length - 2], extend$1(navigateOptions, {
            force: true
          }));
          return router;
        }

        var previousPageRoute = $previousPage[0].f7Page.route;
        processRouteQueue.call(router, previousPageRoute, router.currentRoute, function () {
          loadBack(router, {
            el: $previousPage
          }, extend$1(navigateOptions, {
            route: previousPageRoute
          }));
        }, function () {}, 'backward');
        return router;
      } // Navigate URL


      if (navigateUrl === '#') {
        navigateUrl = undefined;
      }

      if (navigateUrl && navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
        navigateUrl = ((router.path || '/') + navigateUrl).replace('//', '/');
      }

      if (!navigateUrl && router.history.length > 1) {
        navigateUrl = router.history[router.history.length - 2];
      }

      if (skipMaster && !navigateOptions.force && router.history[router.history.length - 3]) {
        return router.back(router.history[router.history.length - 3], extend$1({}, navigateOptions || {}, {
          force: true,
          animate: false
        }));
      }

      if (skipMaster && !navigateOptions.force) {
        return router;
      } // Find route to load


      route = router.findMatchingRoute(navigateUrl);

      if (!route) {
        if (navigateUrl) {
          route = {
            url: navigateUrl,
            path: navigateUrl.split('?')[0],
            query: parseUrlQuery(navigateUrl),
            route: {
              path: navigateUrl.split('?')[0],
              url: navigateUrl
            }
          };
        }
      }

      if (!route) {
        return router;
      }

      if (route.route.redirect) {
        return redirect.call(router, 'backward', route, navigateOptions);
      }

      var options = {};

      if (route.route.options) {
        extend$1(options, route.route.options, navigateOptions);
      } else {
        extend$1(options, navigateOptions);
      }

      options.route = route;
      var backForceLoaded;

      if (options.force && router.params.stackPages) {
        router.$el.children('.page-previous.stacked').each(function (pageEl) {
          if (pageEl.f7Page && pageEl.f7Page.route && pageEl.f7Page.route.url === route.url) {
            backForceLoaded = true;
            loadBack(router, {
              el: pageEl
            }, options);
          }
        });

        if (backForceLoaded) {
          return router;
        }
      }

      function resolve() {
        var routerLoaded = false;

        if (route.route.keepAlive && route.route.keepAliveData) {
          loadBack(router, {
            el: route.route.keepAliveData.pageEl
          }, options);
          routerLoaded = true;
        }

        'url content component pageName el componentUrl'.split(' ').forEach(function (pageLoadProp) {
          if (route.route[pageLoadProp] && !routerLoaded) {
            var _loadBack;

            routerLoaded = true;
            loadBack(router, (_loadBack = {}, _loadBack[pageLoadProp] = route.route[pageLoadProp], _loadBack), options);
          }
        });
        if (routerLoaded) return; // Async

        function asyncResolve(resolveParams, resolveOptions) {
          router.allowPageChange = false;
          loadBack(router, resolveParams, extend$1(options, resolveOptions), true);
        }

        function asyncReject() {
          router.allowPageChange = true;
        }

        if (route.route.async) {
          router.allowPageChange = false;
          route.route.async.call(router, {
            router: router,
            to: route,
            from: router.currentRoute,
            resolve: asyncResolve,
            reject: asyncReject,
            direction: 'backward',
            app: app
          });
        }

        if (route.route.asyncComponent) {
          asyncComponent(router, route.route.asyncComponent, asyncResolve, asyncReject);
        }
      }

      function reject() {
        router.allowPageChange = true;
      }

      if (options.preload) {
        resolve();
      } else {
        processRouteQueue.call(router, route, router.currentRoute, function () {
          if (route.route.modules) {
            app.loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules]).then(function () {
              resolve();
            }).catch(function () {
              reject();
            });
          } else {
            resolve();
          }
        }, function () {
          reject();
        }, 'backward');
      } // Return Router


      return router;
    }

    function clearPreviousPages(router) {
      appRouterCheck(router, 'clearPreviousPages');
      var app = router.app;
      var dynamicNavbar = router.dynamicNavbar;
      var $pagesToRemove = router.$el.children('.page').filter(function (pageInView) {
        if (router.currentRoute && (router.currentRoute.modal || router.currentRoute.panel)) return true;
        return pageInView !== router.currentPageEl;
      });
      $pagesToRemove.each(function (pageEl) {
        var $oldPageEl = $(pageEl);
        var $oldNavbarEl = $(app.navbar.getElByPage($oldPageEl));

        if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
          $oldPageEl.addClass('stacked');

          if (dynamicNavbar) {
            $oldNavbarEl.addClass('stacked');
          }
        } else {
          // Page remove event
          router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarEl, 'previous', undefined, {});
          router.removePage($oldPageEl);

          if (dynamicNavbar && $oldNavbarEl.length) {
            router.removeNavbar($oldNavbarEl);
          }
        }
      });
    }

    function clearPreviousHistory() {
      var router = this;
      appRouterCheck(router, 'clearPreviousHistory');
      var url = router.history[router.history.length - 1];
      clearPreviousPages(router);
      router.history = [url];
      router.view.history = [url];
      router.saveHistory();
    }
     // eslint-disable-line

    function _assertThisInitialized$3(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$3(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$4(subClass, superClass); }

    function _setPrototypeOf$4(o, p) { _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$4(o, p); }

    var Router = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$3(Router, _Framework7Class);

      function Router(app, view) {
        var _this;

        _this = _Framework7Class.call(this, {}, [typeof view === 'undefined' ? app : view]) || this;

        var router = _assertThisInitialized$3(_this); // Is App Router


        router.isAppRouter = typeof view === 'undefined';

        if (router.isAppRouter) {
          // App Router
          extend$1(false, router, {
            app: app,
            params: app.params.view,
            routes: app.routes || [],
            cache: app.cache
          });
        } else {
          // View Router
          extend$1(false, router, {
            app: app,
            view: view,
            viewId: view.id,
            id: view.params.routerId,
            params: view.params,
            routes: view.routes,
            history: view.history,
            scrollHistory: view.scrollHistory,
            cache: app.cache,
            dynamicNavbar: app.theme === 'ios' && view.params.iosDynamicNavbar,
            initialPages: [],
            initialNavbars: []
          });
        } // Install Modules


        router.useModules(); // AllowPageChage

        router.allowPageChange = true; // Current Route

        var currentRoute = {};
        var previousRoute = {};
        Object.defineProperty(router, 'currentRoute', {
          enumerable: true,
          configurable: true,
          set: function set(newRoute) {
            if (newRoute === void 0) {
              newRoute = {};
            }

            previousRoute = extend$1({}, currentRoute);
            currentRoute = newRoute;
            if (!currentRoute) return;
            router.url = currentRoute.url;
            router.emit('routeChange', newRoute, previousRoute, router);
          },
          get: function get() {
            return currentRoute;
          }
        });
        Object.defineProperty(router, 'previousRoute', {
          enumerable: true,
          configurable: true,
          get: function get() {
            return previousRoute;
          },
          set: function set(newRoute) {
            previousRoute = newRoute;
          }
        });
        return router || _assertThisInitialized$3(_this);
      }

      var _proto = Router.prototype;

      _proto.mount = function mount() {
        var router = this;
        var view = router.view;
        var document = getDocument();
        extend$1(false, router, {
          tempDom: document.createElement('div'),
          $el: view.$el,
          el: view.el,
          $navbarsEl: view.$navbarsEl,
          navbarsEl: view.navbarsEl
        });
        router.emit('local::mount routerMount', router);
      };

      _proto.animatableNavElements = function animatableNavElements($newNavbarEl, $oldNavbarEl, toLarge, fromLarge, direction) {
        var router = this;
        var dynamicNavbar = router.dynamicNavbar;
        var animateIcon = router.params.iosAnimateNavbarBackIcon;
        var newNavEls;
        var oldNavEls;

        function animatableNavEl($el, $navbarInner) {
          var isSliding = $el.hasClass('sliding') || $navbarInner.hasClass('sliding');
          var isSubnavbar = $el.hasClass('subnavbar');
          var needsOpacityTransition = isSliding ? !isSubnavbar : true;
          var $iconEl = $el.find('.back .icon');
          var isIconLabel;

          if (isSliding && animateIcon && $el.hasClass('left') && $iconEl.length > 0 && $iconEl.next('span').length) {
            $el = $iconEl.next('span'); // eslint-disable-line

            isIconLabel = true;
          }

          return {
            $el: $el,
            isIconLabel: isIconLabel,
            leftOffset: $el[0].f7NavbarLeftOffset,
            rightOffset: $el[0].f7NavbarRightOffset,
            isSliding: isSliding,
            isSubnavbar: isSubnavbar,
            needsOpacityTransition: needsOpacityTransition
          };
        }

        if (dynamicNavbar) {
          newNavEls = [];
          oldNavEls = [];
          $newNavbarEl.children('.navbar-inner').children('.left, .right, .title, .subnavbar').each(function (navEl) {
            var $navEl = $(navEl);
            if ($navEl.hasClass('left') && fromLarge && direction === 'forward') return;
            if ($navEl.hasClass('title') && toLarge) return;
            newNavEls.push(animatableNavEl($navEl, $newNavbarEl.children('.navbar-inner')));
          });

          if (!($oldNavbarEl.hasClass('navbar-master') && router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint)) {
            $oldNavbarEl.children('.navbar-inner').children('.left, .right, .title, .subnavbar').each(function (navEl) {
              var $navEl = $(navEl);
              if ($navEl.hasClass('left') && toLarge && !fromLarge && direction === 'forward') return;
              if ($navEl.hasClass('left') && toLarge && direction === 'backward') return;

              if ($navEl.hasClass('title') && fromLarge) {
                return;
              }

              oldNavEls.push(animatableNavEl($navEl, $oldNavbarEl.children('.navbar-inner')));
            });
          }

          [oldNavEls, newNavEls].forEach(function (navEls) {
            navEls.forEach(function (navEl) {
              var n = navEl;
              var isSliding = navEl.isSliding,
                  $el = navEl.$el;
              var otherEls = navEls === oldNavEls ? newNavEls : oldNavEls;
              if (!(isSliding && $el.hasClass('title') && otherEls)) return;
              otherEls.forEach(function (otherNavEl) {
                if (otherNavEl.isIconLabel) {
                  var iconTextEl = otherNavEl.$el[0];
                  n.leftOffset += iconTextEl ? iconTextEl.offsetLeft || 0 : 0;
                }
              });
            });
          });
        }

        return {
          newNavEls: newNavEls,
          oldNavEls: oldNavEls
        };
      };

      _proto.animate = function animate($oldPageEl, $newPageEl, $oldNavbarEl, $newNavbarEl, direction, transition, callback) {
        var router = this;

        if (router.params.animateCustom) {
          router.params.animateCustom.apply(router, [$oldPageEl, $newPageEl, $oldNavbarEl, $newNavbarEl, direction, callback]);
          return;
        }

        var dynamicNavbar = router.dynamicNavbar;
        var ios = router.app.theme === 'ios';

        if (transition) {
          var routerCustomTransitionClass = "router-transition-custom router-transition-" + transition + "-" + direction; // Animate

          var onCustomTransitionDone = function onCustomTransitionDone() {
            router.$el.removeClass(routerCustomTransitionClass);

            if (dynamicNavbar && router.$navbarsEl.length) {
              if ($newNavbarEl) {
                router.$navbarsEl.prepend($newNavbarEl);
              }

              if ($oldNavbarEl) {
                router.$navbarsEl.prepend($oldNavbarEl);
              }
            }

            if (callback) callback();
          };

          (direction === 'forward' ? $newPageEl : $oldPageEl).animationEnd(onCustomTransitionDone);

          if (dynamicNavbar) {
            if ($newNavbarEl && $newPageEl) {
              router.setNavbarPosition($newNavbarEl, '');
              $newNavbarEl.removeClass('navbar-next navbar-previous navbar-current');
              $newPageEl.prepend($newNavbarEl);
            }

            if ($oldNavbarEl && $oldPageEl) {
              router.setNavbarPosition($oldNavbarEl, '');
              $oldNavbarEl.removeClass('navbar-next navbar-previous navbar-current');
              $oldPageEl.prepend($oldNavbarEl);
            }
          }

          router.$el.addClass(routerCustomTransitionClass);
          return;
        } // Router Animation class


        var routerTransitionClass = "router-transition-" + direction + " router-transition";
        var newNavEls;
        var oldNavEls;
        var fromLarge;
        var toLarge;
        var toDifferent;
        var oldIsLarge;
        var newIsLarge;

        if (ios && dynamicNavbar) {
          var betweenMasterAndDetail = router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint && ($oldNavbarEl.hasClass('navbar-master') && $newNavbarEl.hasClass('navbar-master-detail') || $oldNavbarEl.hasClass('navbar-master-detail') && $newNavbarEl.hasClass('navbar-master'));

          if (!betweenMasterAndDetail) {
            oldIsLarge = $oldNavbarEl && $oldNavbarEl.hasClass('navbar-large');
            newIsLarge = $newNavbarEl && $newNavbarEl.hasClass('navbar-large');
            fromLarge = oldIsLarge && !$oldNavbarEl.hasClass('navbar-large-collapsed');
            toLarge = newIsLarge && !$newNavbarEl.hasClass('navbar-large-collapsed');
            toDifferent = fromLarge && !toLarge || toLarge && !fromLarge;
          }

          var navEls = router.animatableNavElements($newNavbarEl, $oldNavbarEl, toLarge, fromLarge, direction);
          newNavEls = navEls.newNavEls;
          oldNavEls = navEls.oldNavEls;
        }

        function animateNavbars(progress) {
          if (!(ios && dynamicNavbar)) return;

          if (progress === 1) {
            if (toLarge) {
              $newNavbarEl.addClass('router-navbar-transition-to-large');
              $oldNavbarEl.addClass('router-navbar-transition-to-large');
            }

            if (fromLarge) {
              $newNavbarEl.addClass('router-navbar-transition-from-large');
              $oldNavbarEl.addClass('router-navbar-transition-from-large');
            }
          }

          newNavEls.forEach(function (navEl) {
            var $el = navEl.$el;
            var offset = direction === 'forward' ? navEl.rightOffset : navEl.leftOffset;

            if (navEl.isSliding) {
              if (navEl.isSubnavbar && newIsLarge) {
                // prettier-ignore
                $el[0].style.setProperty('transform', "translate3d(" + offset * (1 - progress) + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)", 'important');
              } else {
                $el.transform("translate3d(" + offset * (1 - progress) + "px,0,0)");
              }
            }
          });
          oldNavEls.forEach(function (navEl) {
            var $el = navEl.$el;
            var offset = direction === 'forward' ? navEl.leftOffset : navEl.rightOffset;

            if (navEl.isSliding) {
              if (navEl.isSubnavbar && oldIsLarge) {
                $el.transform("translate3d(" + offset * progress + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)");
              } else {
                $el.transform("translate3d(" + offset * progress + "px,0,0)");
              }
            }
          });
        } // AnimationEnd Callback


        function onDone() {
          if (router.dynamicNavbar) {
            if ($newNavbarEl) {
              $newNavbarEl.removeClass('router-navbar-transition-to-large router-navbar-transition-from-large');
              $newNavbarEl.addClass('navbar-no-title-large-transition');
              nextFrame$1(function () {
                $newNavbarEl.removeClass('navbar-no-title-large-transition');
              });
            }

            if ($oldNavbarEl) {
              $oldNavbarEl.removeClass('router-navbar-transition-to-large router-navbar-transition-from-large');
            }

            if ($newNavbarEl.hasClass('sliding') || $newNavbarEl.children('.navbar-inner.sliding').length) {
              $newNavbarEl.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
            } else {
              $newNavbarEl.find('.sliding').transform('');
            }

            if ($oldNavbarEl.hasClass('sliding') || $oldNavbarEl.children('.navbar-inner.sliding').length) {
              $oldNavbarEl.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
            } else {
              $oldNavbarEl.find('.sliding').transform('');
            }
          }

          router.$el.removeClass(routerTransitionClass);
          if (callback) callback();
        }

        (direction === 'forward' ? $newPageEl : $oldPageEl).animationEnd(function () {
          onDone();
        }); // Animate

        if (dynamicNavbar) {
          // Prepare Navbars
          animateNavbars(0);
          nextFrame$1(function () {
            // Add class, start animation
            router.$el.addClass(routerTransitionClass);

            if (toDifferent) {
              // eslint-disable-next-line
              router.el._clientLeft = router.el.clientLeft;
            }

            animateNavbars(1);
          });
        } else {
          // Add class, start animation
          router.$el.addClass(routerTransitionClass);
        }
      };

      _proto.removeModal = function removeModal(modalEl) {
        var router = this;
        router.removeEl(modalEl);
      } // eslint-disable-next-line
      ;

      _proto.removeTabContent = function removeTabContent(tabEl) {
        var $tabEl = $(tabEl);
        $tabEl.html('');
      };

      _proto.removeNavbar = function removeNavbar(el) {
        var router = this;
        router.removeEl(el);
      };

      _proto.removePage = function removePage(el) {
        var $el = $(el);
        var f7Page = $el && $el[0] && $el[0].f7Page;
        var router = this;

        if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
          $el.remove();
          return;
        }

        router.removeEl(el);
      };

      _proto.removeEl = function removeEl(el) {
        if (!el) return;
        var router = this;
        var $el = $(el);
        if ($el.length === 0) return;
        $el.find('.tab').each(function (tabEl) {
          $(tabEl).children().each(function (tabChild) {
            if (tabChild.f7Component) {
              $(tabChild).trigger('tab:beforeremove');
              tabChild.f7Component.destroy();
            }
          });
        });

        if ($el[0].f7Component && $el[0].f7Component.destroy) {
          $el[0].f7Component.destroy();
        }

        if (!router.params.removeElements) {
          return;
        }

        if (router.params.removeElementsWithTimeout) {
          setTimeout(function () {
            $el.remove();
          }, router.params.removeElementsTimeout);
        } else {
          $el.remove();
        }
      };

      _proto.getPageEl = function getPageEl(content) {
        var router = this;

        if (typeof content === 'string') {
          router.tempDom.innerHTML = content;
        } else {
          if ($(content).hasClass('page')) {
            return content;
          }

          router.tempDom.innerHTML = '';
          $(router.tempDom).append(content);
        }

        return router.findElement('.page', router.tempDom);
      };

      _proto.findElement = function findElement(stringSelector, container, notStacked) {
        var router = this;
        var view = router.view;
        var app = router.app; // Modals Selector

        var modalsSelector = '.popup, .dialog, .popover, .actions-modal, .sheet-modal, .login-screen, .page';
        var $container = $(container);
        var selector = stringSelector;
        if (notStacked) selector += ':not(.stacked)';
        var found = $container.find(selector).filter(function (el) {
          return $(el).parents(modalsSelector).length === 0;
        });

        if (found.length > 1) {
          if (typeof view.selector === 'string') {
            // Search in related view
            found = $container.find(view.selector + " " + selector);
          }

          if (found.length > 1) {
            // Search in main view
            found = $container.find("." + app.params.viewMainClass + " " + selector);
          }
        }

        if (found.length === 1) return found; // Try to find not stacked

        if (!notStacked) found = router.findElement(selector, $container, true);
        if (found && found.length === 1) return found;
        if (found && found.length > 1) return $(found[0]);
        return undefined;
      };

      _proto.flattenRoutes = function flattenRoutes(routes) {
        if (routes === void 0) {
          routes = this.routes;
        }

        var router = this;
        var flattenedRoutes = [];
        routes.forEach(function (route) {
          var hasTabRoutes = false;

          if ('tabs' in route && route.tabs) {
            var mergedPathsRoutes = route.tabs.map(function (tabRoute) {
              var tRoute = extend$1({}, route, {
                path: (route.path + "/" + tabRoute.path).replace('///', '/').replace('//', '/'),
                parentPath: route.path,
                tab: tabRoute
              });
              delete tRoute.tabs;
              delete tRoute.routes;
              return tRoute;
            });
            hasTabRoutes = true;
            flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(mergedPathsRoutes));
          }

          if ('detailRoutes' in route) {
            var _mergedPathsRoutes = route.detailRoutes.map(function (detailRoute) {
              var dRoute = extend$1({}, detailRoute);
              dRoute.masterRoute = route;
              dRoute.masterRoutePath = route.path;
              return dRoute;
            });

            flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(_mergedPathsRoutes));
          }

          if ('routes' in route) {
            var _mergedPathsRoutes2 = route.routes.map(function (childRoute) {
              var cRoute = extend$1({}, childRoute);
              cRoute.path = (route.path + "/" + cRoute.path).replace('///', '/').replace('//', '/');
              return cRoute;
            });

            if (hasTabRoutes) {
              flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(_mergedPathsRoutes2));
            } else {
              flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(_mergedPathsRoutes2));
            }
          }

          if (!('routes' in route) && !('tabs' in route && route.tabs) && !('detailRoutes' in route)) {
            flattenedRoutes.push(route);
          }
        });
        return flattenedRoutes;
      } // eslint-disable-next-line
      ;

      _proto.parseRouteUrl = function parseRouteUrl(url) {
        if (!url) return {};
        var query = parseUrlQuery(url);
        var hash = url.split('#')[1];
        var params = {};
        var path = url.split('#')[0].split('?')[0];
        return {
          query: query,
          hash: hash,
          params: params,
          url: url,
          path: path
        };
      };

      _proto.generateUrl = function generateUrl(parameters) {
        if (parameters === void 0) {
          parameters = {};
        }

        if (typeof parameters === 'string') {
          return parameters;
        }

        var _parameters = parameters,
            name = _parameters.name,
            path = _parameters.path,
            params = _parameters.params,
            query = _parameters.query;

        if (!name && !path) {
          throw new Error('Framework7: "name" or "path" parameter is required');
        }

        var router = this;
        var route = name ? router.findRouteByKey('name', name) : router.findRouteByKey('path', path);

        if (!route) {
          if (name) {
            throw new Error("Framework7: route with name \"" + name + "\" not found");
          } else {
            throw new Error("Framework7: route with path \"" + path + "\" not found");
          }
        }

        var url = router.constructRouteUrl(route, {
          params: params,
          query: query
        });

        if (!url) {
          throw new Error("Framework7: can't construct URL for route with name \"" + name + "\"");
        }

        return url;
      } // eslint-disable-next-line
      ;

      _proto.constructRouteUrl = function constructRouteUrl(route, _temp) {
        var _ref = _temp === void 0 ? {} : _temp,
            params = _ref.params,
            query = _ref.query;

        var path = route.path;
        var toUrl = compile(path);
        var url;

        try {
          url = toUrl(params || {});
        } catch (error) {
          throw new Error("Framework7: error constructing route URL from passed params:\nRoute: " + path + "\n" + error.toString());
        }

        if (query) {
          if (typeof query === 'string') url += "?" + query;else if (Object.keys(query).length) url += "?" + serializeObject(query);
        }

        return url;
      };

      _proto.findTabRouteUrl = function findTabRouteUrl(tabEl) {
        var router = this;
        var $tabEl = $(tabEl);
        var parentPath = router.currentRoute.route.parentPath;
        var tabId = $tabEl.attr('id');
        var flattenedRoutes = router.flattenRoutes(router.routes);
        var foundTabRouteUrl;
        flattenedRoutes.forEach(function (route) {
          if (route.parentPath === parentPath && route.tab && route.tab.id === tabId) {
            if (router.currentRoute.params && Object.keys(router.currentRoute.params).length > 0) {
              foundTabRouteUrl = router.constructRouteUrl(route, {
                params: router.currentRoute.params,
                query: router.currentRoute.query
              });
            } else {
              foundTabRouteUrl = route.path;
            }
          }
        });
        return foundTabRouteUrl;
      };

      _proto.findRouteByKey = function findRouteByKey(key, value) {
        var router = this;
        var routes = router.routes;
        var flattenedRoutes = router.flattenRoutes(routes);
        var matchingRoute;
        flattenedRoutes.forEach(function (route) {
          if (matchingRoute) return;

          if (route[key] === value) {
            matchingRoute = route;
          }
        });
        return matchingRoute;
      };

      _proto.findMatchingRoute = function findMatchingRoute(url) {
        if (!url) return undefined;
        var router = this;
        var routes = router.routes;
        var flattenedRoutes = router.flattenRoutes(routes);

        var _router$parseRouteUrl = router.parseRouteUrl(url),
            path = _router$parseRouteUrl.path,
            query = _router$parseRouteUrl.query,
            hash = _router$parseRouteUrl.hash,
            params = _router$parseRouteUrl.params;

        var matchingRoute;
        flattenedRoutes.forEach(function (route) {
          if (matchingRoute) return;
          var keys = [];
          var pathsToMatch = [route.path];

          if (route.alias) {
            if (typeof route.alias === 'string') pathsToMatch.push(route.alias);else if (Array.isArray(route.alias)) {
              route.alias.forEach(function (aliasPath) {
                pathsToMatch.push(aliasPath);
              });
            }
          }

          var matched;
          pathsToMatch.forEach(function (pathToMatch) {
            if (matched) return;
            matched = pathToRegexp(pathToMatch, keys).exec(path);
          });

          if (matched) {
            keys.forEach(function (keyObj, index) {
              if (typeof keyObj.name === 'number') return;
              var paramValue = matched[index + 1];

              if (typeof paramValue === 'undefined' || paramValue === null) {
                params[keyObj.name] = paramValue;
              } else {
                params[keyObj.name] = decodeURIComponent(paramValue);
              }
            });
            var parentPath;

            if (route.parentPath) {
              parentPath = path.split('/').slice(0, route.parentPath.split('/').length - 1).join('/');
            }

            matchingRoute = {
              query: query,
              hash: hash,
              params: params,
              url: url,
              path: path,
              parentPath: parentPath,
              route: route,
              name: route.name
            };
          }
        });
        return matchingRoute;
      } // eslint-disable-next-line
      ;

      _proto.replaceRequestUrlParams = function replaceRequestUrlParams(url, options) {
        if (url === void 0) {
          url = '';
        }

        if (options === void 0) {
          options = {};
        }

        var compiledUrl = url;

        if (typeof compiledUrl === 'string' && compiledUrl.indexOf('{{') >= 0 && options && options.route && options.route.params && Object.keys(options.route.params).length) {
          Object.keys(options.route.params).forEach(function (paramName) {
            var regExp = new RegExp("{{" + paramName + "}}", 'g');
            compiledUrl = compiledUrl.replace(regExp, options.route.params[paramName] || '');
          });
        }

        return compiledUrl;
      };

      _proto.removeFromXhrCache = function removeFromXhrCache(url) {
        var router = this;
        var xhrCache = router.cache.xhr;
        var index = false;

        for (var i = 0; i < xhrCache.length; i += 1) {
          if (xhrCache[i].url === url) index = i;
        }

        if (index !== false) xhrCache.splice(index, 1);
      };

      _proto.xhrRequest = function xhrRequest(requestUrl, options) {
        var router = this;
        var params = router.params;
        var ignoreCache = options.ignoreCache;
        var url = requestUrl;
        var hasQuery = url.indexOf('?') >= 0;

        if (params.passRouteQueryToRequest && options && options.route && options.route.query && Object.keys(options.route.query).length) {
          url += "" + (hasQuery ? '&' : '?') + serializeObject(options.route.query);
          hasQuery = true;
        }

        if (params.passRouteParamsToRequest && options && options.route && options.route.params && Object.keys(options.route.params).length) {
          url += "" + (hasQuery ? '&' : '?') + serializeObject(options.route.params);
          hasQuery = true;
        }

        if (url.indexOf('{{') >= 0) {
          url = router.replaceRequestUrlParams(url, options);
        } // should we ignore get params or not


        if (params.xhrCacheIgnoreGetParameters && url.indexOf('?') >= 0) {
          url = url.split('?')[0];
        }

        return new Promise(function (resolve, reject) {
          if (params.xhrCache && !ignoreCache && url.indexOf('nocache') < 0 && params.xhrCacheIgnore.indexOf(url) < 0) {
            for (var i = 0; i < router.cache.xhr.length; i += 1) {
              var cachedUrl = router.cache.xhr[i];

              if (cachedUrl.url === url) {
                // Check expiration
                if (now$1() - cachedUrl.time < params.xhrCacheDuration) {
                  // Load from cache
                  resolve(cachedUrl.content);
                  return;
                }
              }
            }
          }

          router.xhrAbortController = router.app.request.abortController();
          router.app.request({
            abortController: router.xhrAbortController,
            url: url,
            method: 'GET',
            beforeSend: function beforeSend(xhr) {
              router.emit('routerAjaxStart', xhr, options);
            },
            complete: function complete(xhr, status) {
              router.emit('routerAjaxComplete', xhr);

              if (status !== 'error' && status !== 'timeout' && xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) {
                if (params.xhrCache && xhr.responseText !== '') {
                  router.removeFromXhrCache(url);
                  router.cache.xhr.push({
                    url: url,
                    time: now$1(),
                    content: xhr.responseText
                  });
                }

                router.emit('routerAjaxSuccess', xhr, options);
                resolve(xhr.responseText);
              } else {
                router.emit('routerAjaxError', xhr, options);
                reject(xhr);
              }
            },
            error: function error(xhr) {
              router.emit('routerAjaxError', xhr, options);
              reject(xhr);
            }
          });
        });
      };

      _proto.setNavbarPosition = function setNavbarPosition($el, position, ariaHidden) {
        var router = this;
        $el.removeClass('navbar-previous navbar-current navbar-next');

        if (position) {
          $el.addClass("navbar-" + position);
        }

        if (ariaHidden === false) {
          $el.removeAttr('aria-hidden');
        } else if (ariaHidden === true) {
          $el.attr('aria-hidden', 'true');
        }

        $el.trigger('navbar:position', {
          position: position
        });
        router.emit('navbarPosition', $el[0], position);
      };

      _proto.setPagePosition = function setPagePosition($el, position, ariaHidden) {
        var router = this;
        $el.removeClass('page-previous page-current page-next');
        $el.addClass("page-" + position);

        if (ariaHidden === false) {
          $el.removeAttr('aria-hidden');
        } else if (ariaHidden === true) {
          $el.attr('aria-hidden', 'true');
        }

        $el.trigger('page:position', {
          position: position
        });
        router.emit('pagePosition', $el[0], position);
      } // Remove theme elements
      ;

      _proto.removeThemeElements = function removeThemeElements(el) {
        var router = this;
        var theme = router.app.theme;
        var toRemove;

        if (theme === 'ios') {
          toRemove = '.md-only, .aurora-only, .if-md, .if-aurora, .if-not-ios, .not-ios';
        } else if (theme === 'md') {
          toRemove = '.ios-only, .aurora-only, .if-ios, .if-aurora, .if-not-md, .not-md';
        } else if (theme === 'aurora') {
          toRemove = '.ios-only, .md-only, .if-ios, .if-md, .if-not-aurora, .not-aurora';
        }

        $(el).find(toRemove).remove();
      };

      _proto.getPageData = function getPageData(pageEl, navbarEl, from, to, route, pageFromEl) {
        if (route === void 0) {
          route = {};
        }

        var router = this;
        var $pageEl = $(pageEl).eq(0);
        var $navbarEl = $(navbarEl).eq(0);
        var currentPage = $pageEl[0].f7Page || {};
        var direction;
        var pageFrom;
        if (from === 'next' && to === 'current' || from === 'current' && to === 'previous') direction = 'forward';
        if (from === 'current' && to === 'next' || from === 'previous' && to === 'current') direction = 'backward';

        if (currentPage && !currentPage.fromPage) {
          var $pageFromEl = $(pageFromEl);

          if ($pageFromEl.length) {
            pageFrom = $pageFromEl[0].f7Page;
          }
        }

        pageFrom = currentPage.pageFrom || pageFrom;

        if (pageFrom && pageFrom.pageFrom) {
          pageFrom.pageFrom = null;
        }

        var page = {
          app: router.app,
          view: router.view,
          router: router,
          $el: $pageEl,
          el: $pageEl[0],
          $pageEl: $pageEl,
          pageEl: $pageEl[0],
          $navbarEl: $navbarEl,
          navbarEl: $navbarEl[0],
          name: $pageEl.attr('data-name'),
          position: from,
          from: from,
          to: to,
          direction: direction,
          route: currentPage.route ? currentPage.route : route,
          pageFrom: pageFrom
        };
        $pageEl[0].f7Page = page;
        return page;
      } // Callbacks
      ;

      _proto.pageCallback = function pageCallback(callback, pageEl, navbarEl, from, to, options, pageFromEl) {
        if (options === void 0) {
          options = {};
        }

        if (!pageEl) return;
        var router = this;
        var $pageEl = $(pageEl);
        if (!$pageEl.length) return;
        var $navbarEl = $(navbarEl);
        var _options = options,
            route = _options.route;
        var restoreScrollTopOnBack = router.params.restoreScrollTopOnBack && !(router.params.masterDetailBreakpoint > 0 && $pageEl.hasClass('page-master') && router.app.width >= router.params.masterDetailBreakpoint);
        var keepAlive = $pageEl[0].f7Page && $pageEl[0].f7Page.route && $pageEl[0].f7Page.route.route && $pageEl[0].f7Page.route.route.keepAlive;

        if (callback === 'beforeRemove' && keepAlive) {
          callback = 'beforeUnmount'; // eslint-disable-line
        }

        var camelName = "page" + (callback[0].toUpperCase() + callback.slice(1, callback.length));
        var colonName = "page:" + callback.toLowerCase();
        var page = {};

        if (callback === 'beforeRemove' && $pageEl[0].f7Page) {
          page = extend$1($pageEl[0].f7Page, {
            from: from,
            to: to,
            position: from
          });
        } else {
          page = router.getPageData($pageEl[0], $navbarEl[0], from, to, route, pageFromEl);
        }

        page.swipeBack = !!options.swipeBack;

        var _ref2 = options.route ? options.route.route : {},
            _ref2$on = _ref2.on,
            on = _ref2$on === void 0 ? {} : _ref2$on,
            _ref2$once = _ref2.once,
            once = _ref2$once === void 0 ? {} : _ref2$once;

        if (options.on) {
          extend$1(on, options.on);
        }

        if (options.once) {
          extend$1(once, options.once);
        }

        function attachEvents() {
          if ($pageEl[0].f7RouteEventsAttached) return;
          $pageEl[0].f7RouteEventsAttached = true;

          if (on && Object.keys(on).length > 0) {
            $pageEl[0].f7RouteEventsOn = on;
            Object.keys(on).forEach(function (eventName) {
              on[eventName] = on[eventName].bind(router);
              $pageEl.on(eventNameToColonCase(eventName), on[eventName]);
            });
          }

          if (once && Object.keys(once).length > 0) {
            $pageEl[0].f7RouteEventsOnce = once;
            Object.keys(once).forEach(function (eventName) {
              once[eventName] = once[eventName].bind(router);
              $pageEl.once(eventNameToColonCase(eventName), once[eventName]);
            });
          }
        }

        function detachEvents() {
          if (!$pageEl[0].f7RouteEventsAttached) return;

          if ($pageEl[0].f7RouteEventsOn) {
            Object.keys($pageEl[0].f7RouteEventsOn).forEach(function (eventName) {
              $pageEl.off(eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOn[eventName]);
            });
          }

          if ($pageEl[0].f7RouteEventsOnce) {
            Object.keys($pageEl[0].f7RouteEventsOnce).forEach(function (eventName) {
              $pageEl.off(eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOnce[eventName]);
            });
          }

          $pageEl[0].f7RouteEventsAttached = null;
          $pageEl[0].f7RouteEventsOn = null;
          $pageEl[0].f7RouteEventsOnce = null;
          delete $pageEl[0].f7RouteEventsAttached;
          delete $pageEl[0].f7RouteEventsOn;
          delete $pageEl[0].f7RouteEventsOnce;
        }

        if (callback === 'mounted') {
          attachEvents();
        }

        if (callback === 'init') {
          if (restoreScrollTopOnBack && (from === 'previous' || !from) && to === 'current' && router.scrollHistory[page.route.url] && !$pageEl.hasClass('no-restore-scroll')) {
            var $pageContent = $pageEl.find('.page-content');

            if ($pageContent.length > 0) {
              // eslint-disable-next-line
              $pageContent = $pageContent.filter(function (pageContentEl) {
                return $(pageContentEl).parents('.tab:not(.tab-active)').length === 0 && !$(pageContentEl).is('.tab:not(.tab-active)');
              });
            }

            $pageContent.scrollTop(router.scrollHistory[page.route.url]);
          }

          attachEvents();

          if ($pageEl[0].f7PageInitialized) {
            $pageEl.trigger('page:reinit', page);
            router.emit('pageReinit', page);
            return;
          }

          $pageEl[0].f7PageInitialized = true;
        }

        if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'previous') {
          // Save scroll position
          var _$pageContent = $pageEl.find('.page-content');

          if (_$pageContent.length > 0) {
            // eslint-disable-next-line
            _$pageContent = _$pageContent.filter(function (pageContentEl) {
              return $(pageContentEl).parents('.tab:not(.tab-active)').length === 0 && !$(pageContentEl).is('.tab:not(.tab-active)');
            });
          }

          router.scrollHistory[page.route.url] = _$pageContent.scrollTop();
        }

        if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'next') {
          // Delete scroll position
          delete router.scrollHistory[page.route.url];
        }

        $pageEl.trigger(colonName, page);
        router.emit(camelName, page);

        if (callback === 'beforeRemove' || callback === 'beforeUnmount') {
          detachEvents();

          if (!keepAlive) {
            if ($pageEl[0].f7Page && $pageEl[0].f7Page.navbarEl) {
              delete $pageEl[0].f7Page.navbarEl.f7Page;
            }

            $pageEl[0].f7Page = null;
          }
        }
      };

      _proto.saveHistory = function saveHistory() {
        var router = this;
        var window = getWindow();
        router.view.history = router.history;

        if (router.params.browserHistory && router.params.browserHistoryStoreHistory && window.localStorage) {
          window.localStorage["f7router-" + router.view.id + "-history"] = JSON.stringify(router.history);
        }
      };

      _proto.restoreHistory = function restoreHistory() {
        var router = this;
        var window = getWindow();

        if (router.params.browserHistory && router.params.browserHistoryStoreHistory && window.localStorage && window.localStorage["f7router-" + router.view.id + "-history"]) {
          router.history = JSON.parse(window.localStorage["f7router-" + router.view.id + "-history"]);
          router.view.history = router.history;
        }
      };

      _proto.clearHistory = function clearHistory() {
        var router = this;
        router.history = [];
        if (router.view) router.view.history = [];
        router.saveHistory();
      };

      _proto.updateCurrentUrl = function updateCurrentUrl(newUrl) {
        var router = this;
        appRouterCheck(router, 'updateCurrentUrl'); // Update history

        if (router.history.length) {
          router.history[router.history.length - 1] = newUrl;
        } else {
          router.history.push(newUrl);
        } // Update current route params


        var _router$parseRouteUrl2 = router.parseRouteUrl(newUrl),
            query = _router$parseRouteUrl2.query,
            hash = _router$parseRouteUrl2.hash,
            params = _router$parseRouteUrl2.params,
            url = _router$parseRouteUrl2.url,
            path = _router$parseRouteUrl2.path;

        if (router.currentRoute) {
          extend$1(router.currentRoute, {
            query: query,
            hash: hash,
            params: params,
            url: url,
            path: path
          });
        }

        if (router.params.browserHistory) {
          var browserHistoryRoot = router.params.browserHistoryRoot || '';
          History$1.replace(router.view.id, {
            url: newUrl
          }, browserHistoryRoot + router.params.browserHistorySeparator + newUrl);
        } // Save History


        router.saveHistory();
        router.emit('routeUrlUpdate', router.currentRoute, router);
      };

      _proto.getInitialUrl = function getInitialUrl() {
        var router = this;

        if (router.initialUrl) {
          return {
            initialUrl: router.initialUrl,
            historyRestored: router.historyRestored
          };
        }

        var app = router.app,
            view = router.view;
        var document = getDocument();
        var window = getWindow();
        var location = app.params.url && typeof app.params.url === 'string' && typeof URL !== 'undefined' ? new URL(app.params.url) : document.location;
        var initialUrl = router.params.url;
        var documentUrl = location.href.split(location.origin)[1];
        var historyRestored;
        var _router$params = router.params,
            browserHistory = _router$params.browserHistory,
            browserHistoryOnLoad = _router$params.browserHistoryOnLoad,
            browserHistorySeparator = _router$params.browserHistorySeparator;
        var browserHistoryRoot = router.params.browserHistoryRoot;

        if ((window.cordova || window.Capacitor && window.Capacitor.isNative) && browserHistory && !browserHistorySeparator && !browserHistoryRoot && location.pathname.indexOf('index.html')) {
          // eslint-disable-next-line
          console.warn('Framework7: wrong or not complete browserHistory configuration, trying to guess browserHistoryRoot');
          browserHistoryRoot = location.pathname.split('index.html')[0];
        }

        if (!browserHistory || !browserHistoryOnLoad) {
          if (!initialUrl) {
            initialUrl = documentUrl;
          }

          if (location.search && initialUrl.indexOf('?') < 0) {
            initialUrl += location.search;
          }

          if (location.hash && initialUrl.indexOf('#') < 0) {
            initialUrl += location.hash;
          }
        } else {
          if (browserHistoryRoot && documentUrl.indexOf(browserHistoryRoot) >= 0) {
            documentUrl = documentUrl.split(browserHistoryRoot)[1];
            if (documentUrl === '') documentUrl = '/';
          }

          if (browserHistorySeparator.length > 0 && documentUrl.indexOf(browserHistorySeparator) >= 0) {
            initialUrl = documentUrl.split(browserHistorySeparator)[1];
          } else {
            initialUrl = documentUrl;
          }

          router.restoreHistory();

          if (router.history.indexOf(initialUrl) >= 0) {
            router.history = router.history.slice(0, router.history.indexOf(initialUrl) + 1);
          } else if (router.params.url === initialUrl) {
            router.history = [initialUrl];
          } else if (History$1.state && History$1.state[view.id] && History$1.state[view.id].url === router.history[router.history.length - 1]) {
            initialUrl = router.history[router.history.length - 1];
          } else {
            router.history = [documentUrl.split(browserHistorySeparator)[0] || '/', initialUrl];
          }

          if (router.history.length > 1) {
            historyRestored = true;
          } else {
            router.history = [];
          }

          router.saveHistory();
        }

        router.initialUrl = initialUrl;
        router.historyRestored = historyRestored;
        return {
          initialUrl: initialUrl,
          historyRestored: historyRestored
        };
      };

      _proto.init = function init() {
        var router = this;
        var app = router.app,
            view = router.view;
        var document = getDocument();
        router.mount();

        var _router$getInitialUrl = router.getInitialUrl(),
            initialUrl = _router$getInitialUrl.initialUrl,
            historyRestored = _router$getInitialUrl.historyRestored; // Init Swipeback


        if (view && router.params.iosSwipeBack && app.theme === 'ios' || view && router.params.mdSwipeBack && app.theme === 'md' || view && router.params.auroraSwipeBack && app.theme === 'aurora') {
          SwipeBack(router);
        }

        var _router$params2 = router.params,
            browserHistory = _router$params2.browserHistory,
            browserHistoryOnLoad = _router$params2.browserHistoryOnLoad,
            browserHistoryAnimateOnLoad = _router$params2.browserHistoryAnimateOnLoad,
            browserHistoryInitialMatch = _router$params2.browserHistoryInitialMatch;
        var currentRoute;

        if (router.history.length > 1) {
          // Will load page
          var initUrl = browserHistoryInitialMatch ? initialUrl : router.history[0];
          currentRoute = router.findMatchingRoute(initUrl);

          if (!currentRoute) {
            currentRoute = extend$1(router.parseRouteUrl(initUrl), {
              route: {
                url: initUrl,
                path: initUrl.split('?')[0]
              }
            });
          }
        } else {
          // Don't load page
          currentRoute = router.findMatchingRoute(initialUrl);

          if (!currentRoute) {
            currentRoute = extend$1(router.parseRouteUrl(initialUrl), {
              route: {
                url: initialUrl,
                path: initialUrl.split('?')[0]
              }
            });
          }
        }

        if (router.params.stackPages) {
          router.$el.children('.page').each(function (pageEl) {
            var $pageEl = $(pageEl);
            router.initialPages.push($pageEl[0]);

            if (router.dynamicNavbar && $pageEl.children('.navbar').length > 0) {
              router.initialNavbars.push($pageEl.children('.navbar')[0]);
            }
          });
        }

        if (router.$el.children('.page:not(.stacked)').length === 0 && initialUrl && router.params.loadInitialPage) {
          // No pages presented in DOM, reload new page
          router.navigate(initialUrl, {
            initial: true,
            reloadCurrent: true,
            browserHistory: false,
            animate: false,
            once: {
              modalOpen: function modalOpen() {
                if (!historyRestored) return;
                var preloadPreviousPage = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];

                if (preloadPreviousPage && router.history.length > 1) {
                  router.back({
                    preload: true
                  });
                }
              },
              pageAfterIn: function pageAfterIn() {
                if (!historyRestored) return;
                var preloadPreviousPage = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];

                if (preloadPreviousPage && router.history.length > 1) {
                  router.back({
                    preload: true
                  });
                }
              }
            }
          });
        } else if (router.$el.children('.page:not(.stacked)').length) {
          // Init current DOM page
          var hasTabRoute;
          router.currentRoute = currentRoute;
          router.$el.children('.page:not(.stacked)').each(function (pageEl) {
            var $pageEl = $(pageEl);
            var $navbarEl;
            router.setPagePosition($pageEl, 'current');

            if (router.dynamicNavbar) {
              $navbarEl = $pageEl.children('.navbar');

              if ($navbarEl.length > 0) {
                if (!router.$navbarsEl.parents(document).length) {
                  router.$el.prepend(router.$navbarsEl);
                }

                router.setNavbarPosition($navbarEl, 'current');
                router.$navbarsEl.append($navbarEl);

                if ($navbarEl.children('.title-large').length) {
                  $navbarEl.addClass('navbar-large');
                }

                $pageEl.children('.navbar').remove();
              } else {
                router.$navbarsEl.addClass('navbar-hidden');

                if ($navbarEl.children('.title-large').length) {
                  router.$navbarsEl.addClass('navbar-hidden navbar-large-hidden');
                }
              }
            }

            if (router.currentRoute && router.currentRoute.route && (router.currentRoute.route.master === true || typeof router.currentRoute.route.master === 'function' && router.currentRoute.route.master(app, router)) && router.params.masterDetailBreakpoint > 0) {
              $pageEl.addClass('page-master');
              $pageEl.trigger('page:role', {
                role: 'master'
              });

              if ($navbarEl && $navbarEl.length) {
                $navbarEl.addClass('navbar-master');
              }

              view.checkMasterDetailBreakpoint();
            }

            var initOptions = {
              route: router.currentRoute
            };

            if (router.currentRoute && router.currentRoute.route && router.currentRoute.route.options) {
              extend$1(initOptions, router.currentRoute.route.options);
            }

            router.currentPageEl = $pageEl[0];

            if (router.dynamicNavbar && $navbarEl.length) {
              router.currentNavbarEl = $navbarEl[0];
            }

            router.removeThemeElements($pageEl);

            if (router.dynamicNavbar && $navbarEl.length) {
              router.removeThemeElements($navbarEl);
            }

            if (initOptions.route.route.tab) {
              hasTabRoute = true;
              router.tabLoad(initOptions.route.route.tab, extend$1({}, initOptions));
            }

            router.pageCallback('init', $pageEl, $navbarEl, 'current', undefined, initOptions);
            router.pageCallback('beforeIn', $pageEl, $navbarEl, 'current', undefined, initOptions);
            router.pageCallback('afterIn', $pageEl, $navbarEl, 'current', undefined, initOptions);
          });

          if (historyRestored) {
            if (browserHistoryInitialMatch) {
              var preloadPreviousPage = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];

              if (preloadPreviousPage && router.history.length > 1) {
                router.back({
                  preload: true
                });
              }
            } else {
              router.navigate(initialUrl, {
                initial: true,
                browserHistory: false,
                history: false,
                animate: browserHistoryAnimateOnLoad,
                once: {
                  pageAfterIn: function pageAfterIn() {
                    var preloadPreviousPage = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];

                    if (preloadPreviousPage && router.history.length > 2) {
                      router.back({
                        preload: true
                      });
                    }
                  }
                }
              });
            }
          }

          if (!historyRestored && !hasTabRoute) {
            router.history.push(initialUrl);
            router.saveHistory();
          }
        }

        if (initialUrl && browserHistory && browserHistoryOnLoad && (!History$1.state || !History$1.state[view.id])) {
          History$1.initViewState(view.id, {
            url: initialUrl
          });
        }

        router.emit('local::init routerInit', router);
      };

      _proto.destroy = function destroy() {
        var router = this;
        router.emit('local::destroy routerDestroy', router); // Delete props & methods

        Object.keys(router).forEach(function (routerProp) {
          router[routerProp] = null;
          delete router[routerProp];
        });
        router = null;
      };

      return Router;
    }(Framework7Class$1); // Load


    Router.prototype.navigate = navigate;
    Router.prototype.refreshPage = refreshPage; // Tab

    Router.prototype.tabLoad = tabLoad;
    Router.prototype.tabRemove = tabRemove; // Modal

    Router.prototype.modalLoad = modalLoad;
    Router.prototype.modalRemove = modalRemove; // Back

    Router.prototype.back = back; // Clear history

    Router.prototype.clearPreviousHistory = clearPreviousHistory;
    var Router$1 = Router;

    var RouterModule = {
      name: 'router',
      static: {
        Router: Router$1
      },
      instance: {
        cache: {
          xhr: [],
          templates: [],
          components: []
        }
      },
      create: function create() {
        var instance = this;

        if (instance.app) {
          // View Router
          if (instance.params.router) {
            instance.router = new Router$1(instance.app, instance);
          }
        } else {
          // App Router
          instance.router = new Router$1(instance);
        }
      }
    };

    function resizableView(view) {
      var app = view.app;
      var support = getSupport();
      if (view.resizableInitialized) return;
      extend$1(view, {
        resizable: true,
        resizableWidth: null,
        resizableInitialized: true
      });
      var $htmlEl = $('html');
      var $el = view.$el;
      if (!$el) return;
      var $resizeHandlerEl;
      var isTouched;
      var isMoved;
      var touchesStart = {};
      var touchesDiff;
      var width;
      var minWidth;
      var maxWidth;

      function transformCSSWidth(v) {
        if (!v) return null;

        if (v.indexOf('%') >= 0 || v.indexOf('vw') >= 0) {
          return parseInt(v, 10) / 100 * app.width;
        }

        var newV = parseInt(v, 10);
        if (Number.isNaN(newV)) return null;
        return newV;
      }

      function isResizable() {
        return view.resizable && $el.hasClass('view-resizable') && $el.hasClass('view-master-detail');
      }

      function handleTouchStart(e) {
        if (!isResizable()) return;
        touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        isMoved = false;
        isTouched = true;
        var $pageMasterEl = $el.children('.page-master');
        minWidth = transformCSSWidth($pageMasterEl.css('min-width'));
        maxWidth = transformCSSWidth($pageMasterEl.css('max-width'));
      }

      function handleTouchMove(e) {
        if (!isTouched) return;
        e.f7PreventSwipePanel = true;
        var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;

        if (!isMoved) {
          width = $resizeHandlerEl[0].offsetLeft + $resizeHandlerEl[0].offsetWidth;
          $el.addClass('view-resizing');
          $htmlEl.css('cursor', 'col-resize');
        }

        isMoved = true;
        e.preventDefault();
        touchesDiff = pageX - touchesStart.x;
        var newWidth = width + touchesDiff;

        if (minWidth && !Number.isNaN(minWidth)) {
          newWidth = Math.max(newWidth, minWidth);
        }

        if (maxWidth && !Number.isNaN(maxWidth)) {
          newWidth = Math.min(newWidth, maxWidth);
        }

        newWidth = Math.min(Math.max(newWidth, 0), app.width);
        view.resizableWidth = newWidth;
        $htmlEl[0].style.setProperty('--f7-page-master-width', newWidth + "px");
        $el.trigger('view:resize', newWidth);
        view.emit('local::resize viewResize', view, newWidth);
      }

      function handleTouchEnd() {
        $('html').css('cursor', '');

        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }

        isTouched = false;
        isMoved = false;
        $htmlEl[0].style.setProperty('--f7-page-master-width', view.resizableWidth + "px");
        $el.removeClass('view-resizing');
      }

      function handleResize() {
        if (!view.resizableWidth) return;
        minWidth = transformCSSWidth($resizeHandlerEl.css('min-width'));
        maxWidth = transformCSSWidth($resizeHandlerEl.css('max-width'));

        if (minWidth && !Number.isNaN(minWidth) && view.resizableWidth < minWidth) {
          view.resizableWidth = Math.max(view.resizableWidth, minWidth);
        }

        if (maxWidth && !Number.isNaN(maxWidth) && view.resizableWidth > maxWidth) {
          view.resizableWidth = Math.min(view.resizableWidth, maxWidth);
        }

        view.resizableWidth = Math.min(Math.max(view.resizableWidth, 0), app.width);
        $htmlEl[0].style.setProperty('--f7-page-master-width', view.resizableWidth + "px");
      }

      $resizeHandlerEl = view.$el.children('.view-resize-handler');

      if (!$resizeHandlerEl.length) {
        view.$el.append('<div class="view-resize-handler"></div>');
        $resizeHandlerEl = view.$el.children('.view-resize-handler');
      }

      view.$resizeHandlerEl = $resizeHandlerEl;
      $el.addClass('view-resizable'); // Add Events

      var passive = support.passiveListener ? {
        passive: true
      } : false;
      view.$el.on(app.touchEvents.start, '.view-resize-handler', handleTouchStart, passive);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      app.on('resize', handleResize);
      view.on('beforeOpen', handleResize);
      view.once('viewDestroy', function () {
        $el.removeClass('view-resizable');
        view.$resizeHandlerEl.remove();
        view.$el.off(app.touchEvents.start, '.view-resize-handler', handleTouchStart, passive);
        app.off('touchmove:active', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
        app.off('resize', handleResize);
        view.off('beforeOpen', handleResize);
      });
    }

    function _assertThisInitialized$2(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$2(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$3(subClass, superClass); }

    function _setPrototypeOf$3(o, p) { _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$3(o, p); }

    var View$2 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$2(View, _Framework7Class);

      function View(app, el, viewParams) {
        var _this;

        if (viewParams === void 0) {
          viewParams = {};
        }

        _this = _Framework7Class.call(this, viewParams, [app]) || this;

        var view = _assertThisInitialized$2(_this);

        var ssr = view.params.routerId;
        var defaults = {
          routes: [],
          routesAdd: []
        };

        if (!ssr) {
          var $el = $(el);

          if (!$el.length) {
            var message = "Framework7: can't create a View instance because ";
            message += typeof el === 'string' ? "the selector \"" + el + "\" didn't match any element" : 'el must be an HTMLElement or Dom7 object';
            throw new Error(message);
          }
        } // Default View params


        view.params = extend$1({
          el: el
        }, defaults, app.params.view, viewParams); // Routes

        if (view.params.routes.length > 0) {
          view.routes = view.params.routes;
        } else {
          view.routes = [].concat(app.routes, view.params.routesAdd);
        } // View Props


        extend$1(false, view, {
          app: app,
          name: view.params.name,
          main: view.params.main,
          history: [],
          scrollHistory: {}
        }); // Install Modules

        view.useModules(); // Add to app

        app.views.push(view);

        if (view.main) {
          app.views.main = view;
        }

        if (view.name) {
          app.views[view.name] = view;
        } // Index


        view.index = app.views.indexOf(view); // View ID

        var viewId;

        if (view.name) {
          viewId = "view_" + view.name;
        } else if (view.main) {
          viewId = 'view_main';
        } else {
          viewId = "view_" + view.index;
        }

        view.id = viewId;

        if (!view.params.init) {
          return view || _assertThisInitialized$2(_this);
        } // Init View


        if (app.initialized) {
          view.init();
        } else {
          app.on('init', function () {
            view.init();
          });
        }

        return view || _assertThisInitialized$2(_this);
      }

      var _proto = View.prototype;

      _proto.destroy = function destroy() {
        var view = this;
        var app = view.app;
        view.$el.trigger('view:beforedestroy');
        view.emit('local::beforeDestroy viewBeforeDestroy', view);
        app.off('resize', view.checkMasterDetailBreakpoint);

        if (view.main) {
          app.views.main = null;
          delete app.views.main;
        } else if (view.name) {
          app.views[view.name] = null;
          delete app.views[view.name];
        }

        view.$el[0].f7View = null;
        delete view.$el[0].f7View;
        app.views.splice(app.views.indexOf(view), 1); // Destroy Router

        if (view.params.router && view.router) {
          view.router.destroy();
        }

        view.emit('local::destroy viewDestroy', view); // Delete props & methods

        Object.keys(view).forEach(function (viewProp) {
          view[viewProp] = null;
          delete view[viewProp];
        });
        view = null;
      };

      _proto.checkMasterDetailBreakpoint = function checkMasterDetailBreakpoint(force) {
        var view = this;
        var app = view.app;
        var wasMasterDetail = view.$el.hasClass('view-master-detail');
        var isMasterDetail = app.width >= view.params.masterDetailBreakpoint && view.$el.children('.page-master').length;

        if (typeof force === 'undefined' && isMasterDetail || force === true) {
          view.$el.addClass('view-master-detail');

          if (!wasMasterDetail) {
            view.emit('local::masterDetailBreakpoint viewMasterDetailBreakpoint', view);
            view.$el.trigger('view:masterDetailBreakpoint');
          }
        } else {
          view.$el.removeClass('view-master-detail');

          if (wasMasterDetail) {
            view.emit('local::masterDetailBreakpoint viewMasterDetailBreakpoint', view);
            view.$el.trigger('view:masterDetailBreakpoint');
          }
        }
      };

      _proto.initMasterDetail = function initMasterDetail() {
        var view = this;
        var app = view.app;
        view.checkMasterDetailBreakpoint = view.checkMasterDetailBreakpoint.bind(view);
        view.checkMasterDetailBreakpoint();

        if (view.params.masterDetailResizable) {
          resizableView(view);
        }

        app.on('resize', view.checkMasterDetailBreakpoint);
      };

      _proto.mount = function mount(viewEl) {
        var view = this;
        var app = view.app;
        var el = view.params.el || viewEl;
        var $el = $(el); // Selector

        var selector;
        if (typeof el === 'string') selector = el;else {
          // Supposed to be HTMLElement or Dom7
          selector = ($el.attr('id') ? "#" + $el.attr('id') : '') + ($el.attr('class') ? "." + $el.attr('class').replace(/ /g, '.').replace('.active', '') : '');
        } // DynamicNavbar

        var $navbarsEl;

        if (app.theme === 'ios' && view.params.iosDynamicNavbar) {
          $navbarsEl = $el.children('.navbars').eq(0);

          if ($navbarsEl.length === 0) {
            $navbarsEl = $('<div class="navbars"></div>');
          }
        }

        extend$1(view, {
          $el: $el,
          el: $el[0],
          main: view.main || $el.hasClass('view-main'),
          $navbarsEl: $navbarsEl,
          navbarsEl: $navbarsEl ? $navbarsEl[0] : undefined,
          selector: selector
        });

        if (view.main) {
          app.views.main = view;
        } // Save in DOM


        if ($el && $el[0]) {
          $el[0].f7View = view;
        }

        view.emit('local::mount viewMount', view);
      };

      _proto.init = function init(viewEl) {
        var view = this;
        view.mount(viewEl);

        if (view.params.router) {
          if (view.params.masterDetailBreakpoint > 0) {
            view.initMasterDetail();
          }

          view.router.init();
          view.$el.trigger('view:init');
          view.emit('local::init viewInit', view);
        }
      };

      return View;
    }(Framework7Class$1); // Use Router


    View$2.use(RouterModule);
    var View$3 = View$2;

    function initClicks(app) {
      function handleClicks(e) {
        var window = getWindow();
        var $clickedEl = $(e.target);
        var $clickedLinkEl = $clickedEl.closest('a');
        var isLink = $clickedLinkEl.length > 0;
        var url = isLink && $clickedLinkEl.attr('href'); // Check if link is external

        if (isLink) {
          if ($clickedLinkEl.is(app.params.clicks.externalLinks) || // eslint-disable-next-line
          url && url.indexOf('javascript:') >= 0) {
            var target = $clickedLinkEl.attr('target');

            if (url && window.cordova && window.cordova.InAppBrowser && (target === '_system' || target === '_blank')) {
              e.preventDefault();
              window.cordova.InAppBrowser.open(url, target);
            } else if (url && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Browser && (target === '_system' || target === '_blank')) {
              e.preventDefault();
              window.Capacitor.Plugins.Browser.open({
                url: url
              });
            }

            return;
          }
        } // Modules Clicks


        Object.keys(app.modules).forEach(function (moduleName) {
          var moduleClicks = app.modules[moduleName].clicks;
          if (!moduleClicks) return;
          if (e.preventF7Router) return;
          Object.keys(moduleClicks).forEach(function (clickSelector) {
            var matchingClickedElement = $clickedEl.closest(clickSelector).eq(0);

            if (matchingClickedElement.length > 0) {
              moduleClicks[clickSelector].call(app, matchingClickedElement, matchingClickedElement.dataset(), e);
            }
          });
        }); // Load Page

        var clickedLinkData = {};

        if (isLink) {
          e.preventDefault();
          clickedLinkData = $clickedLinkEl.dataset();
        }

        clickedLinkData.clickedEl = $clickedLinkEl[0]; // Prevent Router

        if (e.preventF7Router) return;
        if ($clickedLinkEl.hasClass('prevent-router') || $clickedLinkEl.hasClass('router-prevent')) return;
        var validUrl = url && url.length > 0 && url[0] !== '#';

        if (validUrl || $clickedLinkEl.hasClass('back')) {
          var view;

          if (clickedLinkData.view && clickedLinkData.view === 'current') {
            view = app.views.current;
          } else if (clickedLinkData.view) {
            view = $(clickedLinkData.view)[0].f7View;
          } else {
            view = $clickedEl.parents('.view')[0] && $clickedEl.parents('.view')[0].f7View;

            if (!$clickedLinkEl.hasClass('back') && view && view.params.linksView) {
              if (typeof view.params.linksView === 'string') view = $(view.params.linksView)[0].f7View;else if (view.params.linksView instanceof View$3) view = view.params.linksView;
            }
          }

          if (!view) {
            if (app.views.main) view = app.views.main;
          }

          if (!view || !view.router) return;

          if ($clickedLinkEl[0].f7RouteProps) {
            clickedLinkData.props = $clickedLinkEl[0].f7RouteProps;
          }

          if ($clickedLinkEl.hasClass('back')) view.router.back(url, clickedLinkData);else view.router.navigate(url, clickedLinkData);
        }
      }

      app.on('click', handleClicks);
    }

    var ClicksModule = {
      name: 'clicks',
      params: {
        clicks: {
          // External Links
          externalLinks: '.external'
        }
      },
      on: {
        init: function init() {
          var app = this;
          initClicks(app);
        }
      }
    };

    var RouterComponentLoaderModule = {
      name: 'routerComponentLoader',
      proto: {
        componentLoader: function componentLoader(component, componentUrl, options, resolve, reject) {
          if (options === void 0) {
            options = {};
          }

          var router = this;
          var app = router.app;
          var url = typeof component === 'string' ? component : componentUrl;
          var compiledUrl = router.replaceRequestUrlParams(url, options);

          function compile(componentFunction) {
            var context = options.context || {};
            if (typeof context === 'function') context = context.call(router);else if (typeof context === 'string') {
              try {
                context = JSON.parse(context);
              } catch (err) {
                reject(err);
                throw err;
              }
            }
            var componentContext = merge({}, context, {
              f7route: options.route,
              f7router: router
            });
            var componentProps = merge(options.route ? options.route.params || {} : {}, options.props || {}, options.routeProps || {});
            var componentEl;
            var componentRoot;

            if (options.componentOptions && options.componentOptions.el) {
              componentEl = options.componentOptions.el;
            }

            if (options.componentOptions && options.componentOptions.root) {
              componentRoot = options.componentOptions.root;
            }

            app.component.create(componentFunction, componentProps, {
              context: componentContext,
              el: componentEl,
              root: componentRoot
            }).then(function (createdComponent) {
              resolve(createdComponent.el);
            }).catch(function (err) {
              reject(err);
              throw new Error(err);
            });
          }

          var cachedComponent;

          if (compiledUrl && router.params.componentCache) {
            router.cache.components.forEach(function (cached) {
              if (cached.url === compiledUrl) cachedComponent = cached.component;
            });
          }

          if (compiledUrl && cachedComponent) {
            compile(cachedComponent);
          } else if (compiledUrl && !cachedComponent) {
            // Load via XHR
            if (router.xhrAbortController) {
              router.xhrAbortController.abort();
              router.xhrAbortController = false;
            }

            router.xhrRequest(url, options).then(function (loadedComponent) {
              var parsedComponent = app.component.parse(loadedComponent);

              if (router.params.componentCache) {
                router.cache.components.push({
                  url: compiledUrl,
                  component: parsedComponent
                });
              }

              compile(parsedComponent);
            }).catch(function (err) {
              reject();
              throw err;
            });
          } else {
            compile(component);
          }
        },
        modalComponentLoader: function modalComponentLoader(_temp) {
          var _ref = _temp === void 0 ? {} : _temp,
              component = _ref.component,
              componentUrl = _ref.componentUrl,
              options = _ref.options,
              resolve = _ref.resolve,
              reject = _ref.reject;

          var router = this;
          router.componentLoader(component, componentUrl, options, function (el) {
            resolve(el);
          }, reject);
        },
        tabComponentLoader: function tabComponentLoader(_temp2) {
          var _ref2 = _temp2 === void 0 ? {} : _temp2,
              component = _ref2.component,
              componentUrl = _ref2.componentUrl,
              options = _ref2.options,
              resolve = _ref2.resolve,
              reject = _ref2.reject;

          var router = this;
          router.componentLoader(component, componentUrl, options, function (el) {
            resolve(el);
          }, reject);
        },
        pageComponentLoader: function pageComponentLoader(_temp3) {
          var _ref3 = _temp3 === void 0 ? {} : _temp3,
              component = _ref3.component,
              componentUrl = _ref3.componentUrl,
              options = _ref3.options,
              resolve = _ref3.resolve,
              reject = _ref3.reject;

          var router = this;
          router.componentLoader(component, componentUrl, options, function (el, newOptions) {
            if (newOptions === void 0) {
              newOptions = {};
            }

            resolve(el, newOptions);
          }, reject);
        }
      }
    };

    var n=function(t,s,r,e){var u;s[0]=0;for(var h=1;h<s.length;h++){var p=s[h++],a=s[h]?(s[0]|=p?1:2,r[s[h++]]):s[++h];3===p?e[0]=a:4===p?e[1]=Object.assign(e[1]||{},a):5===p?(e[1]=e[1]||{})[s[++h]]=a:6===p?e[1][s[++h]]+=a+"":p?(u=t.apply(a,n(t,a,r,["",null])),e.push(u),a[0]?s[0]|=2:(s[h-2]=0,s[h]=u)):e.push(a);}return e},t=new Map;function htm(s){var r=t.get(this);return r||(r=new Map,t.set(this,r)),(r=n(this,r.get(s)||(r.set(s,r=function(n){for(var t,s,r=1,e="",u="",h=[0],p=function(n){1===r&&(n||(e=e.replace(/^\s*\n\s*|\s*\n\s*$/g,"")))?h.push(0,n,e):3===r&&(n||e)?(h.push(3,n,e),r=2):2===r&&"..."===e&&n?h.push(4,n,0):2===r&&e&&!n?h.push(5,0,!0,e):r>=5&&((e||!n&&5===r)&&(h.push(r,0,e,s),r=6),n&&(h.push(r,n,0,s),r=6)),e="";},a=0;a<n.length;a++){a&&(1===r&&p(),p(a));for(var l=0;l<n[a].length;l++)t=n[a][l],1===r?"<"===t?(p(),h=[h],r=3):e+=t:4===r?"--"===e&&">"===t?(r=1,e=""):e=t+e[0]:u?t===u?u="":e+=t:'"'===t||"'"===t?u=t:">"===t?(p(),r=1):r&&("="===t?(r=5,s=e,e=""):"/"===t&&(r<5||">"===n[a][l+1])?(p(),3===r&&(h=h[0]),r=h,(h=h[0]).push(2,0,r),r=0):" "===t||"\t"===t||"\n"===t||"\r"===t?(p(),r=2):e+=t),3===r&&"!--"===e&&(r=4,h=h[0]);}return p(),h}(s)),r),arguments,[])).length>1?r:r[0]}

    var ignoreChildren = [false, null, '', undefined];

    var h$1 = function h(type, props) {
      for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        children[_key - 2] = arguments[_key];
      }

      return {
        type: type,
        props: props || {},
        children: flattenArray(children.filter(function (child) {
          return ignoreChildren.indexOf(child) < 0;
        }))
      };
    };

    var $h = htm.bind(h$1);
    var $h$1 = $h;

    function vnode(sel, data, children, text, elm) {
      var key = data === undefined ? undefined : data.key;
      return {
        sel: sel,
        data: data,
        children: children,
        text: text,
        elm: elm,
        key: key
      };
    }

    var array = Array.isArray;
    function primitive(s) {
      return typeof s === 'string' || typeof s === 'number';
    }

    function addNS(data, children, sel) {
      data.ns = 'http://www.w3.org/2000/svg';

      if (sel !== 'foreignObject' && children !== undefined) {
        for (var i = 0; i < children.length; ++i) {
          var childData = children[i].data;

          if (childData !== undefined) {
            addNS(childData, children[i].children, children[i].sel);
          }
        }
      }
    }

    function h(sel, b, c) {
      var data = {},
          children,
          text,
          i;

      if (c !== undefined) {
        data = b;

        if (array(c)) {
          children = c;
        } else if (primitive(c)) {
          text = c;
        } else if (c && c.sel) {
          children = [c];
        }
      } else if (b !== undefined) {
        if (array(b)) {
          children = b;
        } else if (primitive(b)) {
          text = b;
        } else if (b && b.sel) {
          children = [b];
        } else {
          data = b;
        }
      }

      if (array(children)) {
        for (i = 0; i < children.length; ++i) {
          if (primitive(children[i])) children[i] = vnode(undefined, undefined, undefined, children[i], undefined);
        }
      }

      if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' && (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {
        addNS(data, children, sel);
      }

      return vnode(sel, data, children, text, undefined);
    }

    var customComponents = {};

    function _readOnlyError(name) { throw new TypeError("\"" + name + "\" is read-only"); }
    var SELF_CLOSING = 'area base br col command embed hr img input keygen link menuitem meta param source track wbr'.split(' ');
    var PROPS_ATTRS = 'hidden checked disabled readonly selected autofocus autoplay required multiple value indeterminate routeProps innerHTML'.split(' ');
    var BOOLEAN_PROPS = 'hidden checked disabled readonly selected autofocus autoplay required multiple readOnly indeterminate'.split(' ');

    var getTagName = function getTagName(treeNode) {
      return typeof treeNode.type === 'function' ? treeNode.type.name || 'CustomComponent' : treeNode.type;
    };

    var toCamelCase = function toCamelCase(name) {
      return name.split('-').map(function (word, index) {
        if (index === 0) return word.toLowerCase();
        return word[0].toUpperCase() + word.substr(1);
      }).join('');
    };

    var propsFromAttrs = function propsFromAttrs() {
      var context = {};

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      args.forEach(function (obj) {
        if (obj === void 0) {
          obj = {};
        }

        Object.keys(obj).forEach(function (key) {
          context[toCamelCase(key)] = obj[key];
        });
      });
      return context;
    };

    var createCustomComponent = function createCustomComponent(_ref) {
      var f7 = _ref.f7,
          treeNode = _ref.treeNode,
          vnode = _ref.vnode,
          data = _ref.data;
      var component = typeof treeNode.type === 'function' ? treeNode.type : customComponents[treeNode.type];
      f7.component.create(component, propsFromAttrs(data.attrs || {}, data.props || {}), {
        el: vnode.elm,
        children: treeNode.children
      }).then(function (c) {
        if (vnode.data && vnode.data.on && c && c.$el) {
          Object.keys(vnode.data.on).forEach(function (eventName) {
            c.$el.on(eventName, vnode.data.on[eventName]);
          });
        } // eslint-disable-next-line


        vnode.elm.__component__ = c;
      });
    };

    var updateCustomComponent = function updateCustomComponent(vnode) {
      // eslint-disable-next-line
      var component = vnode && vnode.elm && vnode.elm.__component__;
      if (!component) return;
      var newProps = propsFromAttrs(vnode.data.attrs || {}, vnode.data.props || {});
      component.children = vnode.data.treeNode.children;
      Object.assign(component.props, newProps);
      component.update();
    };

    var destroyCustomComponent = function destroyCustomComponent(vnode) {
      // eslint-disable-next-line
      var component = vnode && vnode.elm && vnode.elm.__component__;

      if (component) {
        var el = component.el,
            $el = component.$el;

        if (vnode.data && vnode.data.on && $el) {
          Object.keys(vnode.data.on).forEach(function (eventName) {
            $el.off(eventName, vnode.data.on[eventName]);
          });
        }

        if (component.destroy) component.destroy();
        if (el && el.parentNode) el.parentNode.removeChild(el);
        delete vnode.elm.__component__; // eslint-disable-line
      }
    };

    var isCustomComponent = function isCustomComponent(treeNodeType) {
      return typeof treeNodeType === 'function' || treeNodeType && treeNodeType.indexOf('-') > 0 && customComponents[treeNodeType];
    };

    function getHooks(treeNode, data, f7, initial, isRoot) {
      var hooks = {};
      var insert = [];
      var destroy = [];
      var update = [];
      var postpatch = [];
      var isFakeElement = false;
      var tagName = getTagName(treeNode);

      if (data && data.attrs && data.attrs.component) {
        // eslint-disable-next-line
        data.attrs.component, _readOnlyError("tagName");
        delete data.attrs.component;
        isFakeElement = true;
      }

      var isCustom = isCustomComponent(treeNode.type);

      if (isCustom) {
        insert.push(function (vnode) {
          if (vnode.sel !== tagName && !isFakeElement) return;
          createCustomComponent({
            f7: f7,
            treeNode: treeNode,
            vnode: vnode,
            data: data
          });
        });
        destroy.push(function (vnode) {
          destroyCustomComponent(vnode);
        });
        update.push(function (oldVnode, vnode) {
          updateCustomComponent(vnode);
        });
      }

      if (!isCustom) {
        if (!data || !data.attrs || !data.attrs.class) return hooks;
        var classNames = data.attrs.class;
        classNames.split(' ').forEach(function (className) {
          if (!initial) {
            insert.push.apply(insert, f7.getVnodeHooks('insert', className));
          }

          destroy.push.apply(destroy, f7.getVnodeHooks('destroy', className));
          update.push.apply(update, f7.getVnodeHooks('update', className));
          postpatch.push.apply(postpatch, f7.getVnodeHooks('postpatch', className));
        });
      }

      if (isRoot && !initial) {
        postpatch.push(function (oldVnode, vnode) {
          var vn = vnode || oldVnode;
          if (!vn) return;

          if (vn.data && vn.data.component) {
            vn.data.component.hook('onUpdated');
          }
        });
      }

      if (insert.length === 0 && destroy.length === 0 && update.length === 0 && postpatch.length === 0) {
        return hooks;
      }

      if (insert.length) {
        hooks.insert = function (vnode) {
          insert.forEach(function (f) {
            return f(vnode);
          });
        };
      }

      if (destroy.length) {
        hooks.destroy = function (vnode) {
          destroy.forEach(function (f) {
            return f(vnode);
          });
        };
      }

      if (update.length) {
        hooks.update = function (oldVnode, vnode) {
          update.forEach(function (f) {
            return f(oldVnode, vnode);
          });
        };
      }

      if (postpatch.length) {
        hooks.postpatch = function (oldVnode, vnode) {
          postpatch.forEach(function (f) {
            return f(oldVnode, vnode);
          });
        };
      }

      return hooks;
    }

    var getEventHandler = function getEventHandler(eventHandler, _temp) {
      var _ref2 = _temp === void 0 ? {} : _temp,
          stop = _ref2.stop,
          prevent = _ref2.prevent,
          once = _ref2.once;

      var fired = false;

      function handler() {
        var e = arguments.length <= 0 ? undefined : arguments[0];
        if (once && fired) return;
        if (stop) e.stopPropagation();
        if (prevent) e.preventDefault();
        fired = true;
        eventHandler.apply(void 0, arguments);
      }

      return handler;
    };

    var getData = function getData(treeNode, component, f7, initial, isRoot) {
      var data = {
        component: component,
        treeNode: treeNode
      };
      var tagName = getTagName(treeNode);
      Object.keys(treeNode.props).forEach(function (attrName) {
        var attrValue = treeNode.props[attrName];
        if (typeof attrValue === 'undefined') return;

        if (PROPS_ATTRS.indexOf(attrName) >= 0) {
          // Props
          if (!data.props) data.props = {};

          if (attrName === 'readonly') {
            // eslint-disable-next-line
            attrName = 'readOnly';
          }

          if (attrName === 'routeProps') {
            // eslint-disable-next-line
            attrName = 'f7RouteProps';
          }

          if (tagName === 'option' && attrName === 'value') {
            if (!data.attrs) data.attrs = {};
            data.attrs.value = attrValue;
          }

          if (BOOLEAN_PROPS.indexOf(attrName) >= 0) {
            // eslint-disable-next-line
            data.props[attrName] = attrValue === false ? false : true;
          } else {
            data.props[attrName] = attrValue;
          }
        } else if (attrName === 'key') {
          // Key
          data.key = attrValue;
        } else if (attrName.indexOf('@') === 0 || attrName.indexOf('on') === 0 && attrName.length > 2) {
          // Events
          if (!data.on) data.on = {};
          var eventName = attrName.indexOf('@') === 0 ? attrName.substr(1) : eventNameToColonCase(attrName.substr(2));
          var stop = false;
          var prevent = false;
          var once = false;

          if (eventName.indexOf('.') >= 0) {
            eventName.split('.').forEach(function (eventNamePart, eventNameIndex) {
              if (eventNameIndex === 0) eventName = eventNamePart;else {
                if (eventNamePart === 'stop') stop = true;
                if (eventNamePart === 'prevent') prevent = true;
                if (eventNamePart === 'once') once = true;
              }
            });
          }

          data.on[eventName] = getEventHandler(attrValue, {
            stop: stop,
            prevent: prevent,
            once: once
          });
        } else if (attrName === 'style') {
          // Style
          if (typeof attrValue !== 'string') {
            data.style = attrValue;
          } else {
            if (!data.attrs) data.attrs = {};
            data.attrs.style = attrValue;
          }
        } else {
          // Rest of attribures
          if (!data.attrs) data.attrs = {};
          data.attrs[attrName] = attrValue; // ID -> Key

          if (attrName === 'id' && !data.key && !isRoot) {
            data.key = attrValue;
          }
        }
      });
      var hooks = getHooks(treeNode, data, f7, initial, isRoot);

      hooks.prepatch = function (oldVnode, vnode) {
        if (!oldVnode || !vnode) return;

        if (oldVnode && oldVnode.data && oldVnode.data.props) {
          Object.keys(oldVnode.data.props).forEach(function (key) {
            if (BOOLEAN_PROPS.indexOf(key) < 0) return;
            if (!vnode.data) vnode.data = {};
            if (!vnode.data.props) vnode.data.props = {};

            if (oldVnode.data.props[key] === true && !(key in vnode.data.props)) {
              vnode.data.props[key] = false;
            }
          });
        }
      };

      data.hook = hooks;
      return data;
    };

    var getChildren = function getChildren(treeNode, component, f7, initial) {
      if (treeNode && treeNode.type && SELF_CLOSING.indexOf(treeNode.type) >= 0) {
        return [];
      }

      var children = [];
      var nodes = treeNode.children;

      for (var i = 0; i < nodes.length; i += 1) {
        var childNode = nodes[i];
        var child = treeNodeToVNode(childNode, component, f7, initial, false);

        if (Array.isArray(child)) {
          children.push.apply(children, child);
        } else if (child) {
          children.push(child);
        }
      }

      return children;
    };

    var getSlots = function getSlots(treeNode, component, f7, initial) {
      var slotName = treeNode.props.name || 'default';
      var slotNodes = (component.children || []).filter(function (childTreeNode) {
        var childSlotName = 'default';

        if (childTreeNode.props) {
          childSlotName = childTreeNode.props.slot || 'default';
        }

        return childSlotName === slotName;
      });

      if (slotNodes.length === 0) {
        return getChildren(treeNode, component, f7, initial);
      }

      return slotNodes.map(function (subTreeNode) {
        return treeNodeToVNode(subTreeNode, component, f7, initial);
      });
    };

    var isTreeNode = function isTreeNode(treeNode) {
      return isObject$1(treeNode) && 'props' in treeNode && 'type' in treeNode && 'children' in treeNode;
    };

    var treeNodeToVNode = function treeNodeToVNode(treeNode, component, f7, initial, isRoot) {
      if (!isTreeNode(treeNode)) {
        return String(treeNode);
      }

      if (treeNode.type === 'slot') {
        return getSlots(treeNode, component, f7, initial);
      }

      var data = getData(treeNode, component, f7, initial, isRoot);
      var children = isCustomComponent(treeNode.type) ? [] : getChildren(treeNode, component, f7, initial);
      return h(getTagName(treeNode), data, children);
    };

    function vdom(tree, component, initial) {
      if (tree === void 0) {
        tree = {};
      }

      return treeNodeToVNode(tree, component, component.f7, initial, true);
    }

    function createElement(tagName) {
      return document.createElement(tagName);
    }

    function createElementNS(namespaceURI, qualifiedName) {
      return document.createElementNS(namespaceURI, qualifiedName);
    }

    function createTextNode(text) {
      return document.createTextNode(text);
    }

    function createComment(text) {
      return document.createComment(text);
    }

    function insertBefore(parentNode, newNode, referenceNode) {
      if (referenceNode && referenceNode.parentNode !== parentNode) {
        if (referenceNode.__component__) referenceNode = referenceNode.__component__.el;
      }

      parentNode.insertBefore(newNode, referenceNode);
    }

    function removeChild(node, child) {
      if (!node) return;
      node.removeChild(child);
    }

    function appendChild(node, child) {
      node.appendChild(child);
    }

    function parentNode(node) {
      return node.parentNode;
    }

    function nextSibling(node) {
      return node.nextSibling;
    }

    function tagName(elm) {
      return elm.tagName;
    }

    function setTextContent(node, text) {
      node.textContent = text;
    }

    function getTextContent(node) {
      return node.textContent;
    }

    function isElement(node) {
      return node.nodeType === 1;
    }

    function isText(node) {
      return node.nodeType === 3;
    }

    function isComment(node) {
      return node.nodeType === 8;
    }

    var htmlDomApi = {
      createElement: createElement,
      createElementNS: createElementNS,
      createTextNode: createTextNode,
      createComment: createComment,
      insertBefore: insertBefore,
      removeChild: removeChild,
      appendChild: appendChild,
      parentNode: parentNode,
      nextSibling: nextSibling,
      tagName: tagName,
      setTextContent: setTextContent,
      getTextContent: getTextContent,
      isElement: isElement,
      isText: isText,
      isComment: isComment
    };
    var htmlDomApi$1 = htmlDomApi;

    function isUndef(s) {
      return s === undefined;
    }

    function isDef(s) {
      return s !== undefined;
    }

    var emptyNode = vnode('', {}, [], undefined, undefined);

    function sameVnode(vnode1, vnode2) {
      return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
    }

    function isVnode(vnode) {
      return vnode.sel !== undefined;
    }

    function createKeyToOldIdx(children, beginIdx, endIdx) {
      var i,
          map = {},
          key,
          ch;

      for (i = beginIdx; i <= endIdx; ++i) {
        ch = children[i];

        if (ch != null) {
          key = ch.key;
          if (key !== undefined) map[key] = i;
        }
      }

      return map;
    }

    var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];
    function init$1(modules, domApi) {
      var i,
          j,
          cbs = {};
      var api = domApi !== undefined ? domApi : htmlDomApi$1;

      for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];

        for (j = 0; j < modules.length; ++j) {
          var hook = modules[j][hooks[i]];

          if (hook !== undefined) {
            cbs[hooks[i]].push(hook);
          }
        }
      }

      function emptyNodeAt(elm) {
        var id = elm.id ? '#' + elm.id : '';
        var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';
        return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
      }

      function createRmCb(childElm, listeners) {
        return function rmCb() {
          if (--listeners === 0) {
            var parent_1 = api.parentNode(childElm);
            api.removeChild(parent_1, childElm);
          }
        };
      }

      function createElm(vnode, insertedVnodeQueue) {
        var i,
            data = vnode.data;

        if (data !== undefined) {
          if (isDef(i = data.hook) && isDef(i = i.init)) {
            i(vnode);
            data = vnode.data;
          }
        }

        var children = vnode.children,
            sel = vnode.sel;

        if (sel === '!') {
          if (isUndef(vnode.text)) {
            vnode.text = '';
          }

          vnode.elm = api.createComment(vnode.text);
        } else if (sel !== undefined) {
          // Parse selector
          var hashIdx = sel.indexOf('#');
          var dotIdx = sel.indexOf('.', hashIdx);
          var hash = hashIdx > 0 ? hashIdx : sel.length;
          var dot = dotIdx > 0 ? dotIdx : sel.length;
          var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
          var elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag) : api.createElement(tag);
          if (hash < dot) elm.setAttribute('id', sel.slice(hash + 1, dot));
          if (dotIdx > 0) elm.setAttribute('class', sel.slice(dot + 1).replace(/\./g, ' '));

          for (i = 0; i < cbs.create.length; ++i) {
            cbs.create[i](emptyNode, vnode);
          }

          if (array(children)) {
            for (i = 0; i < children.length; ++i) {
              var ch = children[i];

              if (ch != null) {
                api.appendChild(elm, createElm(ch, insertedVnodeQueue));
              }
            }
          } else if (primitive(vnode.text)) {
            api.appendChild(elm, api.createTextNode(vnode.text));
          }

          i = vnode.data.hook; // Reuse variable

          if (isDef(i)) {
            if (i.create) i.create(emptyNode, vnode);
            if (i.insert) insertedVnodeQueue.push(vnode);
          }
        } else {
          vnode.elm = api.createTextNode(vnode.text);
        }

        return vnode.elm;
      }

      function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
          var ch = vnodes[startIdx];

          if (ch != null) {
            api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
          }
        }
      }

      function invokeDestroyHook(vnode) {
        var i,
            j,
            data = vnode.data;

        if (data !== undefined) {
          if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode);

          for (i = 0; i < cbs.destroy.length; ++i) {
            cbs.destroy[i](vnode);
          }

          if (vnode.children !== undefined) {
            for (j = 0; j < vnode.children.length; ++j) {
              i = vnode.children[j];

              if (i != null && typeof i !== "string") {
                invokeDestroyHook(i);
              }
            }
          }
        }
      }

      function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
          var i_1 = void 0,
              listeners = void 0,
              rm = void 0,
              ch = vnodes[startIdx];

          if (ch != null) {
            if (isDef(ch.sel)) {
              invokeDestroyHook(ch);
              listeners = cbs.remove.length + 1;
              rm = createRmCb(ch.elm, listeners);

              for (i_1 = 0; i_1 < cbs.remove.length; ++i_1) {
                cbs.remove[i_1](ch, rm);
              }

              if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {
                i_1(ch, rm);
              } else {
                rm();
              }
            } else {
              api.removeChild(parentElm, ch.elm);
            }
          }
        }
      }

      function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
        var oldStartIdx = 0,
            newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx;
        var idxInOld;
        var elmToMove;
        var before;

        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
          if (oldStartVnode == null) {
            oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
          } else if (oldEndVnode == null) {
            oldEndVnode = oldCh[--oldEndIdx];
          } else if (newStartVnode == null) {
            newStartVnode = newCh[++newStartIdx];
          } else if (newEndVnode == null) {
            newEndVnode = newCh[--newEndIdx];
          } else if (sameVnode(oldStartVnode, newStartVnode)) {
            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
          } else if (sameVnode(oldEndVnode, newEndVnode)) {
            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
          } else if (sameVnode(oldStartVnode, newEndVnode)) {
            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
            api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
          } else if (sameVnode(oldEndVnode, newStartVnode)) {
            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
            api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
          } else {
            if (oldKeyToIdx === undefined) {
              oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
            }

            idxInOld = oldKeyToIdx[newStartVnode.key];

            if (isUndef(idxInOld)) {
              api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
              newStartVnode = newCh[++newStartIdx];
            } else {
              elmToMove = oldCh[idxInOld];

              if (elmToMove.sel !== newStartVnode.sel) {
                api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
              } else {
                patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                oldCh[idxInOld] = undefined;
                api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
              }

              newStartVnode = newCh[++newStartIdx];
            }
          }
        }

        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
          if (oldStartIdx > oldEndIdx) {
            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
          } else {
            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
          }
        }
      }

      function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
        var i, hook;

        if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
          i(oldVnode, vnode);
        }

        var elm = vnode.elm = oldVnode.elm;
        var oldCh = oldVnode.children;
        var ch = vnode.children;
        if (oldVnode === vnode) return;

        if (vnode.data !== undefined) {
          for (i = 0; i < cbs.update.length; ++i) {
            cbs.update[i](oldVnode, vnode);
          }

          i = vnode.data.hook;
          if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);
        }

        if (isUndef(vnode.text)) {
          if (isDef(oldCh) && isDef(ch)) {
            if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
          } else if (isDef(ch)) {
            if (isDef(oldVnode.text)) api.setTextContent(elm, '');
            addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
          } else if (isDef(oldCh)) {
            removeVnodes(elm, oldCh, 0, oldCh.length - 1);
          } else if (isDef(oldVnode.text)) {
            api.setTextContent(elm, '');
          }
        } else if (oldVnode.text !== vnode.text) {
          api.setTextContent(elm, vnode.text);
        }

        if (isDef(hook) && isDef(i = hook.postpatch)) {
          i(oldVnode, vnode);
        }
      }

      return function patch(oldVnode, vnode) {
        var i, elm, parent;
        var insertedVnodeQueue = [];

        for (i = 0; i < cbs.pre.length; ++i) {
          cbs.pre[i]();
        }

        if (!isVnode(oldVnode)) {
          oldVnode = emptyNodeAt(oldVnode);
        }

        if (sameVnode(oldVnode, vnode)) {
          patchVnode(oldVnode, vnode, insertedVnodeQueue);
        } else {
          elm = oldVnode.elm;
          parent = api.parentNode(elm);
          createElm(vnode, insertedVnodeQueue);

          if (parent !== null) {
            api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
            removeVnodes(parent, [oldVnode], 0, 0);
          }
        }

        for (i = 0; i < insertedVnodeQueue.length; ++i) {
          insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
        }

        for (i = 0; i < cbs.post.length; ++i) {
          cbs.post[i]();
        }

        return vnode;
      };
    }

    var xlinkNS = 'http://www.w3.org/1999/xlink';
    var xmlNS = 'http://www.w3.org/XML/1998/namespace';
    var colonChar = 58;
    var xChar = 120;

    function updateAttrs(oldVnode, vnode) {
      var key,
          elm = vnode.elm,
          oldAttrs = oldVnode.data.attrs,
          attrs = vnode.data.attrs;
      if (!oldAttrs && !attrs) return;
      if (oldAttrs === attrs) return;
      oldAttrs = oldAttrs || {};
      attrs = attrs || {}; // update modified attributes, add new attributes

      for (key in attrs) {
        var cur = attrs[key];
        var old = oldAttrs[key];

        if (old !== cur) {
          if (cur === true) {
            elm.setAttribute(key, "");
          } else if (cur === false) {
            elm.removeAttribute(key);
          } else {
            if (key.charCodeAt(0) !== xChar) {
              elm.setAttribute(key, cur);
            } else if (key.charCodeAt(3) === colonChar) {
              // Assume xml namespace
              elm.setAttributeNS(xmlNS, key, cur);
            } else if (key.charCodeAt(5) === colonChar) {
              // Assume xlink namespace
              elm.setAttributeNS(xlinkNS, key, cur);
            } else {
              elm.setAttribute(key, cur);
            }
          }
        }
      } // remove removed attributes
      // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
      // the other option is to remove all attributes with value == undefined


      for (key in oldAttrs) {
        if (!(key in attrs)) {
          elm.removeAttribute(key);
        }
      }
    }

    var attributesModule = {
      create: updateAttrs,
      update: updateAttrs
    };
    var attributesModule$1 = attributesModule;

    function updateProps(oldVnode, vnode) {
      var key,
          cur,
          old,
          elm = vnode.elm,
          oldProps = oldVnode.data.props,
          props = vnode.data.props;
      if (!oldProps && !props) return;
      if (oldProps === props) return;
      oldProps = oldProps || {};
      props = props || {};

      for (key in oldProps) {
        if (!props[key]) {
          delete elm[key];
        }
      }

      for (key in props) {
        cur = props[key];
        old = oldProps[key];

        if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
          elm[key] = cur;
        }
      }
    }

    var propsModule = {
      create: updateProps,
      update: updateProps
    };
    var propsModule$1 = propsModule;

    var raf = typeof window !== 'undefined' && window.requestAnimationFrame || setTimeout;

    var nextFrame = function nextFrame(fn) {
      raf(function () {
        raf(fn);
      });
    };

    function setNextFrame(obj, prop, val) {
      nextFrame(function () {
        obj[prop] = val;
      });
    }

    function updateStyle(oldVnode, vnode) {
      var cur,
          name,
          elm = vnode.elm,
          oldStyle = oldVnode.data.style,
          style = vnode.data.style;
      if (!oldStyle && !style) return;
      if (oldStyle === style) return;
      oldStyle = oldStyle || {};
      style = style || {};
      var oldHasDel = ('delayed' in oldStyle);

      for (name in oldStyle) {
        if (!style[name]) {
          if (name[0] === '-' && name[1] === '-') {
            elm.style.removeProperty(name);
          } else {
            elm.style[name] = '';
          }
        }
      }

      for (name in style) {
        cur = style[name];

        if (name === 'delayed' && style.delayed) {
          for (var name2 in style.delayed) {
            cur = style.delayed[name2];

            if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
              setNextFrame(elm.style, name2, cur);
            }
          }
        } else if (name !== 'remove' && cur !== oldStyle[name]) {
          if (name[0] === '-' && name[1] === '-') {
            elm.style.setProperty(name, cur);
          } else {
            elm.style[name] = cur;
          }
        }
      }
    }

    function applyDestroyStyle(vnode) {
      var style,
          name,
          elm = vnode.elm,
          s = vnode.data.style;
      if (!s || !(style = s.destroy)) return;

      for (name in style) {
        elm.style[name] = style[name];
      }
    }

    function applyRemoveStyle(vnode, rm) {
      var s = vnode.data.style;

      if (!s || !s.remove) {
        rm();
        return;
      }

      var name,
          elm = vnode.elm,
          i = 0,
          compStyle,
          style = s.remove,
          amount = 0,
          applied = [];

      for (name in style) {
        applied.push(name);
        elm.style[name] = style[name];
      }

      compStyle = getComputedStyle(elm);
      var props = compStyle['transition-property'].split(', ');

      for (; i < props.length; ++i) {
        if (applied.indexOf(props[i]) !== -1) amount++;
      }

      elm.addEventListener('transitionend', function (ev) {
        if (ev.target === elm) --amount;
        if (amount === 0) rm();
      });
    }

    var styleModule = {
      create: updateStyle,
      update: updateStyle,
      destroy: applyDestroyStyle,
      remove: applyRemoveStyle
    };
    var styleModule$1 = styleModule;

    function invokeHandler(handler, event, args) {
      if (typeof handler === 'function') {
        // call function handler
        handler.apply(void 0, [event].concat(args));
      }
    }

    function handleEvent(event, args, vnode) {
      var name = event.type;
      var on = vnode.data.on; // call event handler(s) if exists

      if (on && on[name]) {
        invokeHandler(on[name], event, args);
      }
    }

    function createListener() {
      return function handler(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        handleEvent(event, args, handler.vnode);
      };
    }

    function updateEvents(oldVnode, vnode) {
      var oldOn = oldVnode.data.on;
      var oldListener = oldVnode.listener;
      var oldElm = oldVnode.elm;
      var on = vnode && vnode.data.on;
      var elm = vnode && vnode.elm; // optimization for reused immutable handlers

      if (oldOn === on) {
        return;
      } // remove existing listeners which no longer used


      if (oldOn && oldListener) {
        // if element changed or deleted we remove all existing listeners unconditionally
        if (!on) {
          Object.keys(oldOn).forEach(function (name) {
            $(oldElm).off(name, oldListener);
          });
        } else {
          Object.keys(oldOn).forEach(function (name) {
            if (!on[name]) {
              $(oldElm).off(name, oldListener);
            }
          });
        }
      } // add new listeners which has not already attached


      if (on) {
        // reuse existing listener or create new
        var listener = oldVnode.listener || createListener();
        vnode.listener = listener; // update vnode for listener

        listener.vnode = vnode; // if element changed or added we add all needed listeners unconditionally

        if (!oldOn) {
          Object.keys(on).forEach(function (name) {
            $(elm).on(name, listener);
          });
        } else {
          Object.keys(on).forEach(function (name) {
            if (!oldOn[name]) {
              $(elm).on(name, listener);
            }
          });
        }
      }
    }

    var eventListenersModule = {
      create: updateEvents,
      update: updateEvents,
      destroy: updateEvents
    };

    /* eslint import/no-named-as-default: off */
    var patch = init$1([attributesModule$1, propsModule$1, styleModule$1, eventListenersModule]);
    var patch$1 = patch;

    /* eslint no-underscore-dangle: "off" */

    var Component = /*#__PURE__*/function () {
      function Component(app, component, props, _temp) {
        var _this = this;

        if (props === void 0) {
          props = {};
        }

        var _ref = _temp === void 0 ? {} : _temp,
            el = _ref.el,
            context = _ref.context,
            children = _ref.children;

        var document = getDocument();
        merge(this, {
          f7: app,
          props: props || {},
          context: context || {},
          id: component.id || id(),
          children: children || [],
          theme: {
            ios: app.theme === 'ios',
            md: app.theme === 'md',
            aurora: app.theme === 'aurora'
          },
          style: component.style,
          __updateQueue: [],
          __eventHandlers: [],
          __onceEventHandlers: [],
          __onBeforeMount: [],
          __onMounted: [],
          __onBeforeUpdate: [],
          __onUpdated: [],
          __onBeforeUnmount: [],
          __onUnmounted: []
        });

        var createComponent = function createComponent() {
          return component(_this.props, _this.getComponentContext(true));
        };

        var getRenderFuncion = function getRenderFuncion(componentResult) {
          return new Promise(function (resolve, reject) {
            if (typeof componentResult === 'function') {
              resolve(componentResult);
            } else if (componentResult instanceof Promise) {
              componentResult.then(function (render) {
                resolve(render);
              }).catch(function (err) {
                reject(err);
              });
            } else {
              reject(new Error('Framework7: Component render function is not a "function" type. Didn\'t you forget to "return $render"?'));
            }
          });
        };

        return new Promise(function (resolve, reject) {
          var componentResult = createComponent();
          getRenderFuncion(componentResult).then(function (render) {
            _this.renderFunction = render;

            var tree = _this.render();

            if (el) {
              _this.vnode = vdom(tree, _this, true);

              if (_this.style) {
                _this.styleEl = document.createElement('style');
                _this.styleEl.innerHTML = _this.style;
              }

              _this.el = el;
              patch$1(_this.el, _this.vnode);
              _this.el = _this.vnode.elm;
              _this.$el = $(_this.el);

              _this.attachEvents();

              _this.el.f7Component = _this;

              _this.mount();

              resolve(_this);
              return;
            } // Make Dom


            if (tree) {
              _this.vnode = vdom(tree, _this, true);
              _this.el = document.createElement(_this.vnode.sel || 'div');
              patch$1(_this.el, _this.vnode);
              _this.$el = $(_this.el);
            }

            if (_this.style) {
              _this.styleEl = document.createElement('style');
              _this.styleEl.innerHTML = _this.style;
            }

            _this.attachEvents();

            if (_this.el) {
              _this.el.f7Component = _this;
            }

            resolve(_this);
          }).catch(function (err) {
            reject(err);
          });
        });
      }

      var _proto = Component.prototype;

      _proto.on = function on(eventName, handler) {
        if (!this.__eventHandlers) return;

        this.__eventHandlers.push({
          eventName: eventName,
          handler: handler
        });
      };

      _proto.once = function once(eventName, handler) {
        if (!this.__eventHandlers) return;

        this.__onceEventHandlers.push({
          eventName: eventName,
          handler: handler
        });
      };

      _proto.getComponentRef = function getComponentRef() {
        var self = this;
        return function (initialValue) {
          var value = initialValue;
          var obj = {};
          Object.defineProperty(obj, 'value', {
            get: function get() {
              return value;
            },
            set: function set(v) {
              value = v;
              self.update();
            }
          });
          return obj;
        };
      };

      _proto.getComponentStore = function getComponentStore() {
        var _this2 = this;

        var _this$f7$store = this.f7.store,
            state = _this$f7$store.state,
            _gettersPlain = _this$f7$store._gettersPlain,
            dispatch = _this$f7$store.dispatch;
        var $store = {
          state: state,
          dispatch: dispatch
        };
        $store.getters = new Proxy(_gettersPlain, {
          get: function get(target, prop) {
            var obj = target[prop];

            var callback = function callback(v) {
              obj.value = v;

              _this2.update();
            };

            obj.onUpdated(callback);
            return obj;
          }
        });
        return $store;
      };

      _proto.getComponentContext = function getComponentContext(includeHooks) {
        var _this3 = this;

        var ctx = {
          $f7route: this.context.f7route,
          $f7router: this.context.f7router,
          $h: $h$1,
          $: $,
          $id: this.id,
          $f7: this.f7,
          $f7ready: this.f7ready.bind(this),
          $theme: this.theme,
          $tick: this.tick.bind(this),
          $update: this.update.bind(this),
          $emit: this.emit.bind(this),
          $store: this.getComponentStore(),
          $ref: this.getComponentRef(),
          $el: {}
        };
        Object.defineProperty(ctx.$el, 'value', {
          get: function get() {
            return _this3.$el;
          }
        });
        if (includeHooks) Object.assign(ctx, {
          $on: this.on.bind(this),
          $once: this.once.bind(this),
          $onBeforeMount: function $onBeforeMount(handler) {
            return _this3.__onBeforeMount.push(handler);
          },
          $onMounted: function $onMounted(handler) {
            return _this3.__onMounted.push(handler);
          },
          $onBeforeUpdate: function $onBeforeUpdate(handler) {
            return _this3.__onBeforeUpdate.push(handler);
          },
          $onUpdated: function $onUpdated(handler) {
            return _this3.__onUpdated.push(handler);
          },
          $onBeforeUnmount: function $onBeforeUnmount(handler) {
            return _this3.__onBeforeUnmount.push(handler);
          },
          $onUnmounted: function $onUnmounted(handler) {
            return _this3.__onUnmounted.push(handler);
          }
        });
        return ctx;
      };

      _proto.render = function render() {
        return this.renderFunction(this.getComponentContext());
      };

      _proto.emit = function emit(name, data) {
        if (!this.el) return;
        this.$el.trigger(name, data);
      };

      _proto.attachEvents = function attachEvents() {
        var $el = this.$el;
        if (!this.__eventHandlers) return;

        this.__eventHandlers.forEach(function (_ref2) {
          var eventName = _ref2.eventName,
              handler = _ref2.handler;
          $el.on(eventNameToColonCase(eventName), handler);
        });

        this.__onceEventHandlers.forEach(function (_ref3) {
          var eventName = _ref3.eventName,
              handler = _ref3.handler;
          $el.once(eventNameToColonCase(eventName), handler);
        });
      };

      _proto.detachEvents = function detachEvents() {
        var $el = this.$el;
        if (!this.__eventHandlers) return;

        this.__eventHandlers.forEach(function (_ref4) {
          var eventName = _ref4.eventName,
              handler = _ref4.handler;
          $el.on(eventNameToColonCase(eventName), handler);
        });

        this.__onceEventHandlers.forEach(function (_ref5) {
          var eventName = _ref5.eventName,
              handler = _ref5.handler;
          $el.once(eventNameToColonCase(eventName), handler);
        });
      };

      _proto.startUpdateQueue = function startUpdateQueue() {
        var _this4 = this;

        var window = getWindow();
        if (this.__requestAnimationFrameId) return;

        var update = function update() {
          _this4.hook('onBeforeUpdate');

          var tree = _this4.render(); // Make Dom


          if (tree) {
            var newVNode = vdom(tree, _this4, false);
            _this4.vnode = patch$1(_this4.vnode, newVNode);
          }
        };

        this.__requestAnimationFrameId = window.requestAnimationFrame(function () {
          if (_this4.__updateIsPending) update();
          var resolvers = [].concat(_this4.__updateQueue);
          _this4.__updateQueue = [];
          _this4.__updateIsPending = false;
          window.cancelAnimationFrame(_this4.__requestAnimationFrameId);
          delete _this4.__requestAnimationFrameId;
          delete _this4.__updateIsPending;
          resolvers.forEach(function (resolver) {
            return resolver();
          });
          resolvers = [];
        });
      };

      _proto.tick = function tick(callback) {
        var _this5 = this;

        return new Promise(function (resolve) {
          function resolver() {
            resolve();
            if (callback) callback();
          }

          _this5.__updateQueue.push(resolver);

          _this5.startUpdateQueue();
        });
      };

      _proto.update = function update(callback) {
        var _this6 = this;

        if (this.__destroyed) return new Promise(function () {});
        return new Promise(function (resolve) {
          var resolver = function resolver() {
            resolve();
            if (callback) callback();
          };

          _this6.__updateIsPending = true;

          _this6.__updateQueue.push(resolver);

          _this6.startUpdateQueue();
        });
      };

      _proto.setState = function setState(callback) {
        return this.update(callback);
      };

      _proto.f7ready = function f7ready(callback) {
        var _this7 = this;

        if (this.f7.initialized) {
          callback(this.f7);
          return;
        }

        this.f7.once('init', function () {
          callback(_this7.f7);
        });
      };

      _proto.mount = function mount(mountMethod) {
        this.hook('onBeforeMount', this.$el);
        if (this.styleEl) $('head').append(this.styleEl);
        if (mountMethod) mountMethod(this.el);
        this.hook('onMounted', this.$el);
      };

      _proto.destroy = function destroy() {
        if (this.__destroyed) return;
        var window = getWindow();
        this.hook('onBeforeUnmount');
        if (this.styleEl) $(this.styleEl).remove();
        this.detachEvents();
        this.hook('onUnmounted'); // Delete component instance

        if (this.el && this.el.f7Component) {
          this.el.f7Component = null;
          delete this.el.f7Component;
        } // Patch with empty node


        if (this.vnode) {
          this.vnode = patch$1(this.vnode, {
            sel: this.vnode.sel,
            data: {}
          });
        } // Clear update queue


        window.cancelAnimationFrame(this.__requestAnimationFrameId);
        this.__updateQueue = [];
        this.__eventHandlers = [];
        this.__onceEventHandlers = [];
        this.__onBeforeMount = [];
        this.__onMounted = [];
        this.__onBeforeUpdate = [];
        this.__onUpdated = [];
        this.__onBeforeUnmount = [];
        this.__onUnmounted = []; // Delete all props

        deleteProps(this);
        this.__destroyed = true;
      };

      _proto.hook = function hook(name) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        if (this.__destroyed) return;
        this["__" + name].forEach(function (handler) {
          handler.apply(void 0, args);
        });
      };

      return Component;
    }();

    var Component$1 = Component;

    function parseComponent(componentString) {
      var window = getWindow();
      var document = getDocument();
      var componentId = id();
      var callbackCreateName = "f7_component_create_callback_" + componentId; // Template

      var template;
      var hasTemplate = componentString.match(/<template([ ]?)([a-z0-9-]*)>/);

      if (hasTemplate) {
        template = componentString.split(/<template[ ]?[a-z0-9-]*>/).filter(function (item, index) {
          return index > 0;
        }).join('<template>').split('</template>').filter(function (item, index, arr) {
          return index < arr.length - 1;
        }).join('</template>').replace(/{{#raw}}([ \n]*)<template/g, '{{#raw}}<template').replace(/\/template>([ \n]*){{\/raw}}/g, '/template>{{/raw}}').replace(/([ \n])<template/g, '$1{{#raw}}<template').replace(/\/template>([ \n])/g, '/template>{{/raw}}$1');
      } // Parse Styles


      var style = null;

      if (componentString.indexOf('<style>') >= 0) {
        style = componentString.split('<style>')[1].split('</style>')[0];
      }

      if (componentString.indexOf('<style scoped>') >= 0) {
        style = componentString.split('<style scoped>')[1].split('</style>')[0];
      } // Parse Script


      var scriptContent;

      if (componentString.indexOf('<script>') >= 0) {
        var scripts = componentString.split('<script>');
        scriptContent = scripts[scripts.length - 1].split('</script>')[0].trim();
      } else {
        scriptContent = 'return () => {return $render}';
      }

      if (!scriptContent || !scriptContent.trim()) scriptContent = 'return () => {return $render}'; // Parse Template

      if (template) {
        scriptContent = scriptContent.replace('$render', "function ($$ctx) {\n          var $ = $$ctx.$$;\n          var $h = $$ctx.$h;\n          var $root = $$ctx.$root;\n          var $f7 = $$ctx.$f7;\n          var $f7route = $$ctx.$f7route;\n          var $f7router = $$ctx.$f7router;\n          var $theme = $$ctx.$theme;\n          var $update = $$ctx.$update;\n          var $store = $$ctx.$store;\n          var $ref = $$ctx.$ref;\n\n          return $h`" + template + "`\n        }\n        ").replace(/export default/g, 'return');
      } // Execute Script


      scriptContent = "window." + callbackCreateName + " = function () {" + scriptContent + "}"; // Insert Script El

      var scriptEl = document.createElement('script');
      scriptEl.innerHTML = scriptContent;
      $('head').append(scriptEl);
      var component = window[callbackCreateName](); // Remove Script El

      $(scriptEl).remove();
      window[callbackCreateName] = null;
      delete window[callbackCreateName]; // Assign Style

      if (style) {
        component.style = style;
      } // Component ID


      component.id = componentId;
      return component;
    }

    function registerComponent(tagName, component) {
      customComponents[tagName] = component;
    }

    function unregisterComponent(tagName) {
      delete customComponents[tagName];
    }
    var ComponentModule = {
      name: 'component',
      static: {
        Component: Component$1,
        registerComponent: registerComponent,
        unregisterComponent: unregisterComponent
      },
      create: function create() {
        var app = this;
        app.component = {
          registerComponent: registerComponent,
          unregisterComponent: unregisterComponent,
          parse: function parse(componentString) {
            return parseComponent(componentString);
          },
          create: function create(component, props, _ref) {
            var root = _ref.root,
                el = _ref.el,
                context = _ref.context,
                children = _ref.children;
            return new Component$1(app, component, props, {
              root: root,
              el: el,
              context: context,
              children: children
            });
          }
        };
      }
    };

    var HistoryModule = {
      name: 'history',
      static: {
        history: History$1
      },
      on: {
        init: function init() {
          History$1.init(this);
        }
      }
    };

    var SW = {
      registrations: [],
      register: function register(path, scope) {
        var app = this;
        var window = getWindow();

        if (!('serviceWorker' in window.navigator) || !app.serviceWorker.container) {
          return new Promise(function (resolve, reject) {
            reject(new Error('Service worker is not supported'));
          });
        }

        return new Promise(function (resolve, reject) {
          app.serviceWorker.container.register(path, scope ? {
            scope: scope
          } : {}).then(function (reg) {
            SW.registrations.push(reg);
            app.emit('serviceWorkerRegisterSuccess', reg);
            resolve(reg);
          }).catch(function (error) {
            app.emit('serviceWorkerRegisterError', error);
            reject(error);
          });
        });
      },
      unregister: function unregister(registration) {
        var app = this;
        var window = getWindow();

        if (!('serviceWorker' in window.navigator) || !app.serviceWorker.container) {
          return new Promise(function (resolve, reject) {
            reject(new Error('Service worker is not supported'));
          });
        }

        var registrations;
        if (!registration) registrations = SW.registrations;else if (Array.isArray(registration)) registrations = registration;else registrations = [registration];
        return Promise.all(registrations.map(function (reg) {
          return new Promise(function (resolve, reject) {
            reg.unregister().then(function () {
              if (SW.registrations.indexOf(reg) >= 0) {
                SW.registrations.splice(SW.registrations.indexOf(reg), 1);
              }

              app.emit('serviceWorkerUnregisterSuccess', reg);
              resolve();
            }).catch(function (error) {
              app.emit('serviceWorkerUnregisterError', reg, error);
              reject(error);
            });
          });
        }));
      }
    };
    var ServiceWorkerModule = {
      name: 'sw',
      params: {
        serviceWorker: {
          path: undefined,
          scope: undefined
        }
      },
      create: function create() {
        var app = this;
        var window = getWindow();
        extend$1(app, {
          serviceWorker: {
            container: 'serviceWorker' in window.navigator ? window.navigator.serviceWorker : undefined,
            registrations: SW.registrations,
            register: SW.register.bind(app),
            unregister: SW.unregister.bind(app)
          }
        });
      },
      on: {
        init: function init() {
          var window = getWindow();
          if (!('serviceWorker' in window.navigator)) return;
          var app = this;
          if (app.device.cordova || window.Capacitor && window.Capacitor.isNative) return;
          if (!app.serviceWorker.container) return;
          var paths = app.params.serviceWorker.path;
          var scope = app.params.serviceWorker.scope;
          if (!paths || Array.isArray(paths) && !paths.length) return;
          var toRegister = Array.isArray(paths) ? paths : [paths];
          toRegister.forEach(function (path) {
            app.serviceWorker.register(path, scope);
          });
        }
      }
    };

    function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }

    function createStore(storeParams) {
      if (storeParams === void 0) {
        storeParams = {};
      }

      var store = {
        __store: true
      };

      var originalState = _extends$1({}, storeParams.state || {});

      var actions = _extends$1({}, storeParams.actions || {});

      var getters = _extends$1({}, storeParams.getters || {});

      var state = extend$1({}, originalState);
      var propsQueue = [];
      var gettersDependencies = {};
      var gettersCallbacks = {};
      Object.keys(getters).forEach(function (getterKey) {
        gettersDependencies[getterKey] = [];
        gettersCallbacks[getterKey] = [];
      });

      var getGetterValue = function getGetterValue(getterKey) {
        return getters[getterKey]({
          state: store.state
        });
      };

      var addGetterDependencies = function addGetterDependencies(getterKey, deps) {
        if (!gettersDependencies[getterKey]) gettersDependencies[getterKey] = [];
        deps.forEach(function (dep) {
          if (gettersDependencies[getterKey].indexOf(dep) < 0) {
            gettersDependencies[getterKey].push(dep);
          }
        });
      };

      var addGetterCallback = function addGetterCallback(getterKey, callback) {
        if (!gettersCallbacks[getterKey]) gettersCallbacks[getterKey] = [];
        gettersCallbacks[getterKey].push(callback);
      };

      var runGetterCallbacks = function runGetterCallbacks(stateKey) {
        var keys = Object.keys(gettersDependencies).filter(function (getterKey) {
          return gettersDependencies[getterKey].indexOf(stateKey) >= 0;
        });
        keys.forEach(function (getterKey) {
          if (!gettersCallbacks[getterKey] || !gettersCallbacks[getterKey].length) return;
          gettersCallbacks[getterKey].forEach(function (callback) {
            callback(getGetterValue(getterKey));
          });
        });
      };

      var removeGetterCallback = function removeGetterCallback(callback) {
        Object.keys(gettersCallbacks).forEach(function (stateKey) {
          var callbacks = gettersCallbacks[stateKey];

          if (callbacks.indexOf(callback) >= 0) {
            callbacks.splice(callbacks.indexOf(callback), 1);
          }
        });
      }; // eslint-disable-next-line


      store.__removeCallback = function (callback) {
        removeGetterCallback(callback);
      };

      var getterValue = function getterValue(getterKey, addCallback) {
        if (addCallback === void 0) {
          addCallback = true;
        }

        if (getterKey === 'constructor') return undefined;
        propsQueue = [];
        var value = getGetterValue(getterKey);
        addGetterDependencies(getterKey, propsQueue);

        var onUpdated = function onUpdated(callback) {
          addGetterCallback(getterKey, callback);
        };

        var obj = {
          value: value,
          onUpdated: onUpdated
        };

        if (!addCallback) {
          return obj;
        }

        var callback = function callback(v) {
          obj.value = v;
        };

        obj.__callback = callback;
        addGetterCallback(getterKey, callback); // eslint-disable-next-line

        return obj;
      };

      store.state = new Proxy(state, {
        set: function set(target, prop, value) {
          target[prop] = value;
          runGetterCallbacks(prop);
          return true;
        },
        get: function get(target, prop) {
          propsQueue.push(prop);
          return target[prop];
        }
      });
      store.getters = new Proxy(getters, {
        set: function set() {
          return false;
        },
        get: function get(target, prop) {
          if (!target[prop]) {
            return undefined;
          }

          return getterValue(prop, true);
        }
      });
      store._gettersPlain = new Proxy(getters, {
        set: function set() {
          return false;
        },
        get: function get(target, prop) {
          if (!target[prop]) {
            return undefined;
          }

          return getterValue(prop, false);
        }
      });

      store.dispatch = function (actionName, data) {
        return new Promise(function (resolve, reject) {
          if (!actions[actionName]) {
            reject();
            throw new Error("Framework7: Store action \"" + actionName + "\" is not found");
          }

          var result = actions[actionName]({
            state: store.state,
            dispatch: store.dispatch
          }, data);
          resolve(result);
        });
      };

      return store;
    }

    var StoreModule = {
      name: 'store',
      static: {
        createStore: createStore
      },
      proto: {
        createStore: createStore
      }
    };

    var isCapacitor = function isCapacitor() {
      var window = getWindow();
      return window.Capacitor && window.Capacitor.isNative && window.Capacitor.Plugins && window.Capacitor.Plugins.StatusBar;
    };

    var Statusbar = {
      hide: function hide() {
        var window = getWindow();
        var device = getDevice();

        if (device.cordova && window.StatusBar) {
          window.StatusBar.hide();
        }

        if (isCapacitor()) {
          window.Capacitor.Plugins.StatusBar.hide();
        }
      },
      show: function show() {
        var window = getWindow();
        var device = getDevice();

        if (device.cordova && window.StatusBar) {
          window.StatusBar.show();
        }

        if (isCapacitor()) {
          window.Capacitor.Plugins.StatusBar.show();
        }
      },
      onClick: function onClick() {
        var app = this;
        var pageContent;

        if ($('.popup.modal-in').length > 0) {
          // Check for opened popup
          pageContent = $('.popup.modal-in').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
        } else if ($('.panel.panel-in').length > 0) {
          // Check for opened panel
          pageContent = $('.panel.panel-in').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
        } else if ($('.views > .view.tab-active').length > 0) {
          // View in tab bar app layout
          pageContent = $('.views > .view.tab-active').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
        } else if ($('.views').length > 0) {
          pageContent = $('.views').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
        } else {
          pageContent = app.$el.children('.view').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
        }

        if (pageContent && pageContent.length > 0) {
          // Check for tab
          if (pageContent.hasClass('tab')) {
            pageContent = pageContent.parent('.tabs').children('.page-content.tab-active');
          }

          if (pageContent.length > 0) pageContent.scrollTop(0, 300);
        }
      },
      setTextColor: function setTextColor(color) {
        var window = getWindow();
        var device = getDevice();

        if (device.cordova && window.StatusBar) {
          if (color === 'white') {
            window.StatusBar.styleLightContent();
          } else {
            window.StatusBar.styleDefault();
          }
        }

        if (isCapacitor()) {
          if (color === 'white') {
            window.Capacitor.Plugins.StatusBar.setStyle({
              style: 'DARK'
            });
          } else {
            window.Capacitor.Plugins.StatusBar.setStyle({
              style: 'LIGHT'
            });
          }
        }
      },
      setBackgroundColor: function setBackgroundColor(color) {
        var window = getWindow();
        var device = getDevice();

        if (device.cordova && window.StatusBar) {
          window.StatusBar.backgroundColorByHexString(color);
        }

        if (isCapacitor()) {
          window.Capacitor.Plugins.StatusBar.setBackgroundColor({
            color: color
          });
        }
      },
      isVisible: function isVisible() {
        var window = getWindow();
        var device = getDevice();
        return new Promise(function (resolve) {
          if (device.cordova && window.StatusBar) {
            resolve(window.StatusBar.isVisible);
          }

          if (isCapacitor()) {
            window.Capacitor.Plugins.StatusBar.getInfo().then(function (info) {
              resolve(info.visible);
            });
          }

          resolve(false);
        });
      },
      overlaysWebView: function overlaysWebView(overlays) {
        if (overlays === void 0) {
          overlays = true;
        }

        var window = getWindow();
        var device = getDevice();

        if (device.cordova && window.StatusBar) {
          window.StatusBar.overlaysWebView(overlays);
        }

        if (isCapacitor()) {
          window.Capacitor.Plugins.StatusBar.setOverlaysWebView({
            overlay: overlays
          });
        }
      },
      init: function init() {
        var app = this;
        var window = getWindow();
        var device = getDevice();
        var params = app.params.statusbar;
        if (!params.enabled) return;
        var isCordova = device.cordova && window.StatusBar;
        var isCap = isCapacitor();

        if (isCordova || isCap) {
          if (params.scrollTopOnClick) {
            $(window).on('statusTap', Statusbar.onClick.bind(app));
          }

          if (device.ios) {
            if (params.iosOverlaysWebView) {
              Statusbar.overlaysWebView(true);
            } else {
              Statusbar.overlaysWebView(false);
            }

            if (params.iosTextColor === 'white') {
              Statusbar.setTextColor('white');
            } else {
              Statusbar.setTextColor('black');
            }
          }

          if (device.android) {
            if (params.androidOverlaysWebView) {
              Statusbar.overlaysWebView(true);
            } else {
              Statusbar.overlaysWebView(false);
            }

            if (params.androidTextColor === 'white') {
              Statusbar.setTextColor('white');
            } else {
              Statusbar.setTextColor('black');
            }
          }
        }

        if (params.iosBackgroundColor && device.ios) {
          Statusbar.setBackgroundColor(params.iosBackgroundColor);
        }

        if (params.androidBackgroundColor && device.android) {
          Statusbar.setBackgroundColor(params.androidBackgroundColor);
        }
      }
    };
    var Statusbar$1 = {
      name: 'statusbar',
      params: {
        statusbar: {
          enabled: true,
          scrollTopOnClick: true,
          iosOverlaysWebView: true,
          iosTextColor: 'black',
          iosBackgroundColor: null,
          androidOverlaysWebView: false,
          androidTextColor: 'black',
          androidBackgroundColor: null
        }
      },
      create: function create() {
        var app = this;
        bindMethods(app, {
          statusbar: Statusbar
        });
      },
      on: {
        init: function init() {
          var app = this;
          Statusbar.init.call(app);
        }
      }
    };

    function getCurrentView(app) {
      var $popoverView = $('.popover.modal-in .view');
      var $popupView = $('.popup.modal-in .view');
      var $panelView = $('.panel.panel-in .view');
      var $viewsEl = $('.views');
      if ($viewsEl.length === 0) $viewsEl = app.$el; // Find active view as tab

      var $viewEl = $viewsEl.children('.view');

      if ($viewEl.length === 0) {
        $viewEl = $viewsEl.children('.tabs').children('.view');
      } // Propably in tabs or split view


      if ($viewEl.length > 1) {
        if ($viewEl.hasClass('tab')) {
          // Tabs
          $viewEl = $viewsEl.children('.view.tab-active');

          if ($viewEl.length === 0) {
            $viewEl = $viewsEl.children('.tabs').children('.view.tab-active');
          }
        }
      }

      if ($popoverView.length > 0 && $popoverView[0].f7View) return $popoverView[0].f7View;
      if ($popupView.length > 0 && $popupView[0].f7View) return $popupView[0].f7View;
      if ($panelView.length > 0 && $panelView[0].f7View) return $panelView[0].f7View;

      if ($viewEl.length > 0) {
        if ($viewEl.length === 1 && $viewEl[0].f7View) return $viewEl[0].f7View;

        if ($viewEl.length > 1) {
          return app.views.main;
        }
      }

      return undefined;
    }

    var View$1 = {
      name: 'view',
      params: {
        view: {
          init: true,
          name: undefined,
          main: false,
          router: true,
          linksView: null,
          stackPages: false,
          xhrCache: true,
          xhrCacheIgnore: [],
          xhrCacheIgnoreGetParameters: false,
          xhrCacheDuration: 1000 * 60 * 10,
          // Ten minutes
          componentCache: true,
          preloadPreviousPage: true,
          allowDuplicateUrls: false,
          reloadPages: false,
          reloadDetail: false,
          masterDetailBreakpoint: 0,
          masterDetailResizable: false,
          removeElements: true,
          removeElementsWithTimeout: false,
          removeElementsTimeout: 0,
          restoreScrollTopOnBack: true,
          unloadTabContent: true,
          passRouteQueryToRequest: true,
          passRouteParamsToRequest: false,
          loadInitialPage: true,
          // Swipe Back
          iosSwipeBack: true,
          iosSwipeBackAnimateShadow: true,
          iosSwipeBackAnimateOpacity: true,
          iosSwipeBackActiveArea: 30,
          iosSwipeBackThreshold: 0,
          mdSwipeBack: false,
          mdSwipeBackAnimateShadow: true,
          mdSwipeBackAnimateOpacity: false,
          mdSwipeBackActiveArea: 30,
          mdSwipeBackThreshold: 0,
          auroraSwipeBack: false,
          auroraSwipeBackAnimateShadow: false,
          auroraSwipeBackAnimateOpacity: true,
          auroraSwipeBackActiveArea: 30,
          auroraSwipeBackThreshold: 0,
          // Push State
          browserHistory: false,
          browserHistoryRoot: undefined,
          browserHistoryAnimate: true,
          browserHistoryAnimateOnLoad: false,
          browserHistorySeparator: '#!',
          browserHistoryOnLoad: true,
          browserHistoryInitialMatch: false,
          browserHistoryStoreHistory: true,
          // Animate Pages
          animate: true,
          // iOS Dynamic Navbar
          iosDynamicNavbar: true,
          // Animate iOS Navbar Back Icon
          iosAnimateNavbarBackIcon: true,
          // Delays
          iosPageLoadDelay: 0,
          mdPageLoadDelay: 0,
          auroraPageLoadDelay: 0,
          // Routes hooks
          routesBeforeEnter: null,
          routesBeforeLeave: null
        }
      },
      static: {
        View: View$3
      },
      create: function create() {
        var app = this;
        extend$1(app, {
          views: extend$1([], {
            create: function create(el, params) {
              return new View$3(app, el, params);
            },
            get: function get(viewEl) {
              var $viewEl = $(viewEl);
              if ($viewEl.length && $viewEl[0].f7View) return $viewEl[0].f7View;
              return undefined;
            }
          })
        });
        Object.defineProperty(app.views, 'current', {
          enumerable: true,
          configurable: true,
          get: function get() {
            return getCurrentView(app);
          }
        }); // Alias

        app.view = app.views;
      },
      on: {
        init: function init() {
          var app = this;
          $('.view-init').each(function (viewEl) {
            if (viewEl.f7View) return;
            var viewParams = $(viewEl).dataset();
            app.views.create(viewEl, viewParams);
          });
        },
        'modalOpen panelOpen': function onOpen(instance) {
          var app = this;
          instance.$el.find('.view-init').each(function (viewEl) {
            if (viewEl.f7View) return;
            var viewParams = $(viewEl).dataset();
            app.views.create(viewEl, viewParams);
          });
        },
        'modalBeforeDestroy panelBeforeDestroy': function onClose(instance) {
          if (!instance || !instance.$el) return;
          instance.$el.find('.view-init').each(function (viewEl) {
            var view = viewEl.f7View;
            if (!view) return;
            view.destroy();
          });
        }
      },
      vnode: {
        'view-init': {
          insert: function insert(vnode) {
            var app = this;
            var viewEl = vnode.elm;
            if (viewEl.f7View) return;
            var viewParams = $(viewEl).dataset();
            app.views.create(viewEl, viewParams);
          },
          destroy: function destroy(vnode) {
            var viewEl = vnode.elm;
            var view = viewEl.f7View;
            if (!view) return;
            view.destroy();
          }
        }
      }
    };

    var Navbar$1 = {
      size: function size(el) {
        var app = this;
        var $el = $(el);

        if ($el.hasClass('navbars')) {
          $el = $el.children('.navbar').each(function (navbarEl) {
            app.navbar.size(navbarEl);
          });
          return;
        }

        var $innerEl = $el.children('.navbar-inner');
        if (!$innerEl.length) return;
        var needCenterTitle = $innerEl.hasClass('navbar-inner-centered-title') || app.params.navbar[app.theme + "CenterTitle"];
        var needLeftTitle = app.theme === 'ios' && !app.params.navbar[app.theme + "CenterTitle"];
        if (!needCenterTitle && !needLeftTitle) return;

        if ($el.hasClass('stacked') || $el.parents('.stacked').length > 0 || $el.parents('.tab:not(.tab-active)').length > 0 || $el.parents('.popup:not(.modal-in)').length > 0) {
          return;
        }

        if (app.theme !== 'ios' && app.params.navbar[app.theme + "CenterTitle"]) {
          $innerEl.addClass('navbar-inner-centered-title');
        }

        if (app.theme === 'ios' && !app.params.navbar.iosCenterTitle) {
          $innerEl.addClass('navbar-inner-left-title');
        }

        var $viewEl = $el.parents('.view').eq(0);
        var left = app.rtl ? $innerEl.children('.right') : $innerEl.children('.left');
        var right = app.rtl ? $innerEl.children('.left') : $innerEl.children('.right');
        var title = $innerEl.children('.title');
        var subnavbar = $innerEl.children('.subnavbar');
        var noLeft = left.length === 0;
        var noRight = right.length === 0;
        var leftWidth = noLeft ? 0 : left.outerWidth(true);
        var rightWidth = noRight ? 0 : right.outerWidth(true);
        var titleWidth = title.outerWidth(true);
        var navbarStyles = $innerEl.styles();
        var navbarWidth = $innerEl[0].offsetWidth;
        var navbarInnerWidth = navbarWidth - parseInt(navbarStyles.paddingLeft, 10) - parseInt(navbarStyles.paddingRight, 10);
        var isPrevious = $el.hasClass('navbar-previous');
        var sliding = $innerEl.hasClass('sliding');
        var router;
        var dynamicNavbar;

        if ($viewEl.length > 0 && $viewEl[0].f7View) {
          router = $viewEl[0].f7View.router;
          dynamicNavbar = router && router.dynamicNavbar;
        }

        var currLeft;
        var diff;

        if (noRight) {
          currLeft = navbarInnerWidth - titleWidth;
        }

        if (noLeft) {
          currLeft = 0;
        }

        if (!noLeft && !noRight) {
          currLeft = (navbarInnerWidth - rightWidth - titleWidth + leftWidth) / 2;
        }

        var requiredLeft = (navbarInnerWidth - titleWidth) / 2;

        if (navbarInnerWidth - leftWidth - rightWidth > titleWidth) {
          if (requiredLeft < leftWidth) {
            requiredLeft = leftWidth;
          }

          if (requiredLeft + titleWidth > navbarInnerWidth - rightWidth) {
            requiredLeft = navbarInnerWidth - rightWidth - titleWidth;
          }

          diff = requiredLeft - currLeft;
        } else {
          diff = 0;
        } // RTL inverter


        var inverter = app.rtl ? -1 : 1;

        if (dynamicNavbar && app.theme === 'ios') {
          if (title.hasClass('sliding') || title.length > 0 && sliding) {
            var titleLeftOffset = -(currLeft + diff) * inverter;
            var titleRightOffset = (navbarInnerWidth - currLeft - diff - titleWidth) * inverter;

            if (isPrevious) {
              if (router && router.params.iosAnimateNavbarBackIcon) {
                var activeNavbarBackLink = $el.parent().find('.navbar-current').children('.left.sliding').find('.back .icon ~ span');

                if (activeNavbarBackLink.length > 0) {
                  titleLeftOffset += activeNavbarBackLink[0].offsetLeft;
                }
              }
            }

            title[0].f7NavbarLeftOffset = titleLeftOffset;
            title[0].f7NavbarRightOffset = titleRightOffset;
          }

          if (!noLeft && (left.hasClass('sliding') || sliding)) {
            if (app.rtl) {
              left[0].f7NavbarLeftOffset = -(navbarInnerWidth - left[0].offsetWidth) / 2 * inverter;
              left[0].f7NavbarRightOffset = leftWidth * inverter;
            } else {
              left[0].f7NavbarLeftOffset = -leftWidth;
              left[0].f7NavbarRightOffset = (navbarInnerWidth - left[0].offsetWidth) / 2;

              if (router && router.params.iosAnimateNavbarBackIcon && left.find('.back .icon').length > 0) {
                if (left.find('.back .icon ~ span').length) {
                  var leftOffset = left[0].f7NavbarLeftOffset;
                  var rightOffset = left[0].f7NavbarRightOffset;
                  left[0].f7NavbarLeftOffset = 0;
                  left[0].f7NavbarRightOffset = 0;
                  left.find('.back .icon ~ span')[0].f7NavbarLeftOffset = leftOffset;
                  left.find('.back .icon ~ span')[0].f7NavbarRightOffset = rightOffset - left.find('.back .icon')[0].offsetWidth;
                }
              }
            }
          }

          if (!noRight && (right.hasClass('sliding') || sliding)) {
            if (app.rtl) {
              right[0].f7NavbarLeftOffset = -rightWidth * inverter;
              right[0].f7NavbarRightOffset = (navbarInnerWidth - right[0].offsetWidth) / 2 * inverter;
            } else {
              right[0].f7NavbarLeftOffset = -(navbarInnerWidth - right[0].offsetWidth) / 2;
              right[0].f7NavbarRightOffset = rightWidth;
            }
          }

          if (subnavbar.length && (subnavbar.hasClass('sliding') || sliding)) {
            subnavbar[0].f7NavbarLeftOffset = app.rtl ? subnavbar[0].offsetWidth : -subnavbar[0].offsetWidth;
            subnavbar[0].f7NavbarRightOffset = -subnavbar[0].f7NavbarLeftOffset;
          }
        } // Center title


        if (needCenterTitle) {
          var titleLeft = diff;
          if (app.rtl && noLeft && noRight && title.length > 0) titleLeft = -titleLeft;
          title.css({
            left: titleLeft + "px"
          });
        }
      },
      hide: function hide(el, animate, hideStatusbar, hideOnlyCurrent) {
        if (animate === void 0) {
          animate = true;
        }

        if (hideStatusbar === void 0) {
          hideStatusbar = false;
        }

        if (hideOnlyCurrent === void 0) {
          hideOnlyCurrent = false;
        }

        var app = this;
        var $el = $(el);
        var isDynamic = $el.hasClass('navbar') && $el.parent('.navbars').length && !hideOnlyCurrent;
        if (isDynamic) $el = $el.parents('.navbars');
        if (!$el.length) return;
        if ($el.hasClass('navbar-hidden')) return;
        var className = "navbar-hidden" + (animate ? ' navbar-transitioning' : '');
        var currentIsLarge = isDynamic ? $el.find('.navbar-current .title-large').length : $el.find('.title-large').length;

        if (currentIsLarge) {
          className += ' navbar-large-hidden';
        }

        if (hideStatusbar) {
          className += ' navbar-hidden-statusbar';
        }

        $el.transitionEnd(function () {
          $el.removeClass('navbar-transitioning');
        });
        $el.addClass(className);

        if (isDynamic) {
          $el.children('.navbar').each(function (subEl) {
            $(subEl).trigger('navbar:hide');
            app.emit('navbarHide', subEl);
          });
        } else {
          $el.trigger('navbar:hide');
          app.emit('navbarHide', $el[0]);
        }
      },
      show: function show(el, animate, hideOnlyCurrent) {
        if (el === void 0) {
          el = '.navbar-hidden';
        }

        if (animate === void 0) {
          animate = true;
        }

        if (hideOnlyCurrent === void 0) {
          hideOnlyCurrent = false;
        }

        var app = this;
        var $el = $(el);
        var isDynamic = $el.hasClass('navbar') && $el.parent('.navbars').length && !hideOnlyCurrent;
        if (isDynamic) $el = $el.parents('.navbars');
        if (!$el.length) return;
        if (!$el.hasClass('navbar-hidden')) return;

        if (animate) {
          $el.addClass('navbar-transitioning');
          $el.transitionEnd(function () {
            $el.removeClass('navbar-transitioning');
          });
        }

        $el.removeClass('navbar-hidden navbar-large-hidden navbar-hidden-statusbar');

        if (isDynamic) {
          $el.children('.navbar').each(function (subEl) {
            $(subEl).trigger('navbar:show');
            app.emit('navbarShow', subEl);
          });
        } else {
          $el.trigger('navbar:show');
          app.emit('navbarShow', $el[0]);
        }
      },
      getElByPage: function getElByPage(page) {
        var $pageEl;
        var $navbarEl;
        var pageData;

        if (page.$navbarEl || page.$el) {
          pageData = page;
          $pageEl = page.$el;
        } else {
          $pageEl = $(page);
          if ($pageEl.length > 0) pageData = $pageEl[0].f7Page;
        }

        if (pageData && pageData.$navbarEl && pageData.$navbarEl.length > 0) {
          $navbarEl = pageData.$navbarEl;
        } else if ($pageEl) {
          $navbarEl = $pageEl.children('.navbar');
        }

        if (!$navbarEl || $navbarEl && $navbarEl.length === 0) return undefined;
        return $navbarEl[0];
      },
      getPageByEl: function getPageByEl(navbarEl) {
        var $navbarEl = $(navbarEl);

        if ($navbarEl.parents('.page').length) {
          return $navbarEl.parents('.page')[0];
        }

        var pageEl;
        $navbarEl.parents('.view').find('.page').each(function (el) {
          if (el && el.f7Page && el.f7Page.navbarEl && $navbarEl[0] === el.f7Page.navbarEl) {
            pageEl = el;
          }
        });
        return pageEl;
      },
      collapseLargeTitle: function collapseLargeTitle(navbarEl) {
        var app = this;
        var $navbarEl = $(navbarEl);

        if ($navbarEl.hasClass('navbars')) {
          $navbarEl = $navbarEl.find('.navbar');

          if ($navbarEl.length > 1) {
            $navbarEl = $(navbarEl).find('.navbar-large.navbar-current');
          }

          if ($navbarEl.length > 1 || !$navbarEl.length) {
            return;
          }
        }

        var $pageEl = $(app.navbar.getPageByEl($navbarEl));
        $navbarEl.addClass('navbar-large-collapsed');
        $pageEl.eq(0).addClass('page-with-navbar-large-collapsed').trigger('page:navbarlargecollapsed');
        app.emit('pageNavbarLargeCollapsed', $pageEl[0]);
        $navbarEl.trigger('navbar:collapse');
        app.emit('navbarCollapse', $navbarEl[0]);
      },
      expandLargeTitle: function expandLargeTitle(navbarEl) {
        var app = this;
        var $navbarEl = $(navbarEl);

        if ($navbarEl.hasClass('navbars')) {
          $navbarEl = $navbarEl.find('.navbar-large');

          if ($navbarEl.length > 1) {
            $navbarEl = $(navbarEl).find('.navbar-large.navbar-current');
          }

          if ($navbarEl.length > 1 || !$navbarEl.length) {
            return;
          }
        }

        var $pageEl = $(app.navbar.getPageByEl($navbarEl));
        $navbarEl.removeClass('navbar-large-collapsed');
        $pageEl.eq(0).removeClass('page-with-navbar-large-collapsed').trigger('page:navbarlargeexpanded');
        app.emit('pageNavbarLargeExpanded', $pageEl[0]);
        $navbarEl.trigger('navbar:expand');
        app.emit('navbarExpand', $navbarEl[0]);
      },
      toggleLargeTitle: function toggleLargeTitle(navbarEl) {
        var app = this;
        var $navbarEl = $(navbarEl);

        if ($navbarEl.hasClass('navbars')) {
          $navbarEl = $navbarEl.find('.navbar-large');

          if ($navbarEl.length > 1) {
            $navbarEl = $(navbarEl).find('.navbar-large.navbar-current');
          }

          if ($navbarEl.length > 1 || !$navbarEl.length) {
            return;
          }
        }

        if ($navbarEl.hasClass('navbar-large-collapsed')) {
          app.navbar.expandLargeTitle($navbarEl);
        } else {
          app.navbar.collapseLargeTitle($navbarEl);
        }
      },
      initNavbarOnScroll: function initNavbarOnScroll(pageEl, navbarEl, needHide, needCollapse, needTransparent) {
        var app = this;
        var support = getSupport();
        var $pageEl = $(pageEl);
        var $navbarEl = $(navbarEl);
        var $titleLargeEl = $navbarEl.find('.title-large');
        var isLarge = $titleLargeEl.length || $navbarEl.hasClass('.navbar-large');
        var navbarHideHeight = 44;
        var snapPageScrollToLargeTitle = app.params.navbar.snapPageScrollToLargeTitle;
        var snapPageScrollToTransparentNavbar = app.params.navbar.snapPageScrollToTransparentNavbar;
        var previousScrollTop;
        var currentScrollTop;
        var scrollHeight;
        var offsetHeight;
        var reachEnd;
        var action;
        var navbarHidden;
        var navbarCollapsed;
        var navbarTitleLargeHeight;
        var navbarOffsetHeight;

        if (needCollapse || needHide && isLarge) {
          navbarTitleLargeHeight = $navbarEl.css('--f7-navbar-large-title-height');

          if (navbarTitleLargeHeight && navbarTitleLargeHeight.indexOf('px') >= 0) {
            navbarTitleLargeHeight = parseInt(navbarTitleLargeHeight, 10);

            if (Number.isNaN(navbarTitleLargeHeight) && $titleLargeEl.length) {
              navbarTitleLargeHeight = $titleLargeEl[0].offsetHeight;
            } else if (Number.isNaN(navbarTitleLargeHeight)) {
              if (app.theme === 'ios') navbarTitleLargeHeight = 52;else if (app.theme === 'md') navbarTitleLargeHeight = 48;else if (app.theme === 'aurora') navbarTitleLargeHeight = 38;
            }
          } else if ($titleLargeEl.length) {
            navbarTitleLargeHeight = $titleLargeEl[0].offsetHeight;
          } else {
            // eslint-disable-next-line
            if (app.theme === 'ios') navbarTitleLargeHeight = 52;else if (app.theme === 'md') navbarTitleLargeHeight = 48;else if (app.theme === 'aurora') navbarTitleLargeHeight = 38;
          }
        }

        if (needHide && isLarge) {
          navbarHideHeight += navbarTitleLargeHeight;
        }

        var scrollChanged;
        var scrollContent;
        var scrollTimeoutId;
        var touchEndTimeoutId;
        var touchSnapTimeout = 70;
        var desktopSnapTimeout = 300;

        function calcScrollableDistance() {
          $pageEl.find('.page-content').each(function (pageContentEl) {
            pageContentEl.f7ScrollableDistance = pageContentEl.scrollHeight - pageContentEl.offsetHeight;
          });
        }

        function snapLargeNavbar() {
          var inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
          if (inSearchbarExpanded) return;
          if (!scrollContent || currentScrollTop < 0) return;

          if (currentScrollTop >= navbarTitleLargeHeight / 2 && currentScrollTop < navbarTitleLargeHeight) {
            $(scrollContent).scrollTop(navbarTitleLargeHeight, 100);
          } else if (currentScrollTop < navbarTitleLargeHeight) {
            $(scrollContent).scrollTop(0, 200);
          }
        }

        function snapTransparentNavbar() {
          var inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
          if (inSearchbarExpanded) return;
          if (!scrollContent || currentScrollTop < 0) return;

          if (currentScrollTop >= navbarOffsetHeight / 2 && currentScrollTop < navbarOffsetHeight) {
            $(scrollContent).scrollTop(navbarOffsetHeight, 100);
          } else if (currentScrollTop < navbarOffsetHeight) {
            $(scrollContent).scrollTop(0, 200);
          }
        }

        function handleNavbarTransparent() {
          var isHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');
          var inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
          if (inSearchbarExpanded || isHidden) return;

          if (!navbarOffsetHeight) {
            navbarOffsetHeight = navbarEl.offsetHeight;
          }

          var opacity = currentScrollTop / navbarOffsetHeight;
          var notTransparent = $navbarEl.hasClass('navbar-transparent-visible');
          opacity = Math.max(Math.min(opacity, 1), 0);

          if (notTransparent && opacity === 1 || !notTransparent && opacity === 0) {
            $navbarEl.find('.navbar-bg, .title').css('opacity', '');
            return;
          }

          if (notTransparent && opacity === 0) {
            $navbarEl.trigger('navbar:transparenthide');
            app.emit('navbarTransparentHide', $navbarEl[0]);
            $navbarEl.removeClass('navbar-transparent-visible');
            $navbarEl.find('.navbar-bg, .title').css('opacity', '');
            return;
          }

          if (!notTransparent && opacity === 1) {
            $navbarEl.trigger('navbar:transparentshow');
            app.emit('navbarTransparentShow', $navbarEl[0]);
            $navbarEl.addClass('navbar-transparent-visible');
            $navbarEl.find('.navbar-bg, .title').css('opacity', '');
            return;
          }

          $navbarEl.find('.navbar-bg, .title').css('opacity', opacity);

          if (snapPageScrollToTransparentNavbar) {
            if (!support.touch) {
              clearTimeout(scrollTimeoutId);
              scrollTimeoutId = setTimeout(function () {
                snapTransparentNavbar();
              }, desktopSnapTimeout);
            } else if (touchEndTimeoutId) {
              clearTimeout(touchEndTimeoutId);
              touchEndTimeoutId = null;
              touchEndTimeoutId = setTimeout(function () {
                snapTransparentNavbar();
                clearTimeout(touchEndTimeoutId);
                touchEndTimeoutId = null;
              }, touchSnapTimeout);
            }
          }
        }

        var previousCollapseProgress = null;
        var collapseProgress = null;

        function handleLargeNavbarCollapse(pageContentEl) {
          var isHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');
          if (isHidden) return;
          var isLargeTransparent = $navbarEl.hasClass('navbar-large-transparent') || $navbarEl.hasClass('navbar-large') && $navbarEl.hasClass('navbar-transparent');
          previousCollapseProgress = collapseProgress;
          var scrollableDistance = Math.min(navbarTitleLargeHeight, pageContentEl.f7ScrollableDistance || navbarTitleLargeHeight);
          collapseProgress = Math.min(Math.max(currentScrollTop / scrollableDistance, 0), 1);
          var previousCollapseWasInMiddle = previousCollapseProgress > 0 && previousCollapseProgress < 1;
          var inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
          if (inSearchbarExpanded) return;
          navbarCollapsed = $navbarEl.hasClass('navbar-large-collapsed');

          if (collapseProgress === 0 && navbarCollapsed) {
            app.navbar.expandLargeTitle($navbarEl[0]);
          } else if (collapseProgress === 1 && !navbarCollapsed) {
            app.navbar.collapseLargeTitle($navbarEl[0]);
          }

          if (collapseProgress === 0 && navbarCollapsed || collapseProgress === 0 && previousCollapseWasInMiddle || collapseProgress === 1 && !navbarCollapsed || collapseProgress === 1 && previousCollapseWasInMiddle) {
            if (app.theme === 'md') {
              $navbarEl.find('.navbar-inner').css('overflow', '');
            }

            $navbarEl.find('.title').css('opacity', '');
            $navbarEl.find('.title-large-text, .subnavbar').css('transform', '');

            if (isLargeTransparent) {
              $navbarEl.find('.navbar-bg').css('opacity', '');
            } else {
              $navbarEl.find('.navbar-bg').css('transform', '');
            }
          } else if (collapseProgress > 0 && collapseProgress < 1) {
            if (app.theme === 'md') {
              $navbarEl.find('.navbar-inner').css('overflow', 'visible');
            }

            $navbarEl.find('.title').css('opacity', collapseProgress);
            $navbarEl.find('.title-large-text, .subnavbar').css('transform', "translate3d(0px, " + -1 * collapseProgress * navbarTitleLargeHeight + "px, 0)");

            if (isLargeTransparent) {
              $navbarEl.find('.navbar-bg').css('opacity', collapseProgress);
            } else {
              $navbarEl.find('.navbar-bg').css('transform', "translate3d(0px, " + -1 * collapseProgress * navbarTitleLargeHeight + "px, 0)");
            }
          }

          if (snapPageScrollToLargeTitle) {
            if (!support.touch) {
              clearTimeout(scrollTimeoutId);
              scrollTimeoutId = setTimeout(function () {
                snapLargeNavbar();
              }, desktopSnapTimeout);
            } else if (touchEndTimeoutId) {
              clearTimeout(touchEndTimeoutId);
              touchEndTimeoutId = null;
              touchEndTimeoutId = setTimeout(function () {
                snapLargeNavbar();
                clearTimeout(touchEndTimeoutId);
                touchEndTimeoutId = null;
              }, touchSnapTimeout);
            }
          }
        }

        function handleTitleHideShow() {
          if ($pageEl.hasClass('page-with-card-opened')) return;
          scrollHeight = scrollContent.scrollHeight;
          offsetHeight = scrollContent.offsetHeight;
          reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
          navbarHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');

          if (reachEnd) {
            if (app.params.navbar.showOnPageScrollEnd) {
              action = 'show';
            }
          } else if (previousScrollTop > currentScrollTop) {
            if (app.params.navbar.showOnPageScrollTop || currentScrollTop <= navbarHideHeight) {
              action = 'show';
            } else {
              action = 'hide';
            }
          } else if (currentScrollTop > navbarHideHeight) {
            action = 'hide';
          } else {
            action = 'show';
          }

          if (action === 'show' && navbarHidden) {
            app.navbar.show($navbarEl, true, true);
            navbarHidden = false;
          } else if (action === 'hide' && !navbarHidden) {
            app.navbar.hide($navbarEl, true, false, true);
            navbarHidden = true;
          }

          previousScrollTop = currentScrollTop;
        }

        function handleScroll(e) {
          scrollContent = this;

          if (e && e.target && e.target !== scrollContent) {
            return;
          }

          currentScrollTop = scrollContent.scrollTop;
          scrollChanged = currentScrollTop;

          if (needCollapse) {
            handleLargeNavbarCollapse(scrollContent);
          } else if (needTransparent) {
            handleNavbarTransparent();
          }

          if ($pageEl.hasClass('page-previous')) return;

          if (needHide) {
            handleTitleHideShow();
          }
        }

        function handeTouchStart() {
          scrollChanged = false;
        }

        function handleTouchEnd() {
          clearTimeout(touchEndTimeoutId);
          touchEndTimeoutId = null;
          touchEndTimeoutId = setTimeout(function () {
            if (scrollChanged !== false) {
              if (needTransparent && !needCollapse) {
                snapTransparentNavbar();
              } else {
                snapLargeNavbar();
              }

              clearTimeout(touchEndTimeoutId);
              touchEndTimeoutId = null;
            }
          }, touchSnapTimeout);
        }

        $pageEl.on('scroll', '.page-content', handleScroll, true);

        if (support.touch && (needCollapse && snapPageScrollToLargeTitle || needTransparent && snapPageScrollToTransparentNavbar)) {
          app.on('touchstart:passive', handeTouchStart);
          app.on('touchend:passive', handleTouchEnd);
        }

        calcScrollableDistance();

        if (needCollapse || needTransparent) {
          $pageEl.find('.page-content').each(function (pageContentEl) {
            if (pageContentEl.scrollTop > 0) handleScroll.call(pageContentEl);
          });
        }

        app.on('resize', calcScrollableDistance);

        $pageEl[0].f7DetachNavbarScrollHandlers = function f7DetachNavbarScrollHandlers() {
          app.off('resize', calcScrollableDistance);
          delete $pageEl[0].f7DetachNavbarScrollHandlers;
          $pageEl.off('scroll', '.page-content', handleScroll, true);

          if (support.touch && (needCollapse && snapPageScrollToLargeTitle || needTransparent && snapPageScrollToTransparentNavbar)) {
            app.off('touchstart:passive', handeTouchStart);
            app.off('touchend:passive', handleTouchEnd);
          }
        };
      }
    };
    var Navbar$2 = {
      name: 'navbar',
      create: function create() {
        var app = this;
        bindMethods(app, {
          navbar: Navbar$1
        });
      },
      params: {
        navbar: {
          scrollTopOnTitleClick: true,
          iosCenterTitle: true,
          mdCenterTitle: false,
          auroraCenterTitle: true,
          hideOnPageScroll: false,
          showOnPageScrollEnd: true,
          showOnPageScrollTop: true,
          collapseLargeTitleOnScroll: true,
          snapPageScrollToLargeTitle: true,
          snapPageScrollToTransparentNavbar: true
        }
      },
      on: {
        'panelBreakpoint panelCollapsedBreakpoint panelResize viewResize resize viewMasterDetailBreakpoint': function onPanelResize() {
          var app = this;
          $('.navbar').each(function (navbarEl) {
            app.navbar.size(navbarEl);
          });
        },
        pageBeforeRemove: function pageBeforeRemove(page) {
          if (page.$el[0].f7DetachNavbarScrollHandlers) {
            page.$el[0].f7DetachNavbarScrollHandlers();
          }
        },
        pageBeforeIn: function pageBeforeIn(page) {
          var app = this;
          if (app.theme !== 'ios') return;
          var $navbarsEl;
          var view = page.$el.parents('.view')[0].f7View;
          var navbarEl = app.navbar.getElByPage(page);

          if (!navbarEl) {
            $navbarsEl = page.$el.parents('.view').children('.navbars');
          } else {
            $navbarsEl = $(navbarEl).parents('.navbars');
          }

          if (page.$el.hasClass('no-navbar') || view.router.dynamicNavbar && !navbarEl) {
            var animate = !!(page.pageFrom && page.router.history.length > 0);
            app.navbar.hide($navbarsEl, animate);
          } else {
            app.navbar.show($navbarsEl);
          }
        },
        pageReinit: function pageReinit(page) {
          var app = this;
          var $navbarEl = $(app.navbar.getElByPage(page));
          if (!$navbarEl || $navbarEl.length === 0) return;
          app.navbar.size($navbarEl);
        },
        pageInit: function pageInit(page) {
          var app = this;
          var $navbarEl = $(app.navbar.getElByPage(page));
          if (!$navbarEl || $navbarEl.length === 0) return; // Size

          app.navbar.size($navbarEl); // Need Collapse On Scroll

          var needCollapseOnScrollHandler;

          if ($navbarEl.find('.title-large').length > 0) {
            $navbarEl.addClass('navbar-large');
          }

          if ($navbarEl.hasClass('navbar-large')) {
            if (app.params.navbar.collapseLargeTitleOnScroll) needCollapseOnScrollHandler = true;
            page.$el.addClass('page-with-navbar-large');
          } // Need transparent on scroll


          var needTransparentOnScroll;

          if (!needCollapseOnScrollHandler && $navbarEl.hasClass('navbar-transparent')) {
            needTransparentOnScroll = true;
          } // Need Hide On Scroll


          var needHideOnScrollHandler;

          if (app.params.navbar.hideOnPageScroll || page.$el.find('.hide-navbar-on-scroll').length || page.$el.hasClass('hide-navbar-on-scroll') || page.$el.find('.hide-bars-on-scroll').length || page.$el.hasClass('hide-bars-on-scroll')) {
            if (page.$el.find('.keep-navbar-on-scroll').length || page.$el.hasClass('keep-navbar-on-scroll') || page.$el.find('.keep-bars-on-scroll').length || page.$el.hasClass('keep-bars-on-scroll')) {
              needHideOnScrollHandler = false;
            } else {
              needHideOnScrollHandler = true;
            }
          }

          if (needCollapseOnScrollHandler || needHideOnScrollHandler || needTransparentOnScroll) {
            app.navbar.initNavbarOnScroll(page.el, $navbarEl[0], needHideOnScrollHandler, needCollapseOnScrollHandler, needTransparentOnScroll);
          }
        },
        'panelOpen panelSwipeOpen modalOpen': function onPanelModalOpen(instance) {
          var app = this;
          instance.$el.find('.navbar:not(.navbar-previous):not(.stacked)').each(function (navbarEl) {
            app.navbar.size(navbarEl);
          });
        },
        tabShow: function tabShow(tabEl) {
          var app = this;
          $(tabEl).find('.navbar:not(.navbar-previous):not(.stacked)').each(function (navbarEl) {
            app.navbar.size(navbarEl);
          });
        }
      },
      clicks: {
        '.navbar .title': function onTitleClick($clickedEl, clickedData, e) {
          var app = this;
          if (!app.params.navbar.scrollTopOnTitleClick) return;

          if ($(e.target).closest('a, button').length > 0) {
            return;
          }

          var $pageContentEl; // Find active page

          var $navbarEl = $clickedEl.parents('.navbar');
          var $navbarsEl = $navbarEl.parents('.navbars'); // Static Layout

          $pageContentEl = $navbarEl.parents('.page-content');

          if ($pageContentEl.length === 0) {
            // Fixed Layout
            if ($navbarEl.parents('.page').length > 0) {
              $pageContentEl = $navbarEl.parents('.page').find('.page-content');
            } // Through Layout iOS


            if ($pageContentEl.length === 0 && $navbarsEl.length) {
              if ($navbarsEl.nextAll('.page-current:not(.stacked)').length > 0) {
                $pageContentEl = $navbarsEl.nextAll('.page-current:not(.stacked)').find('.page-content');
              }
            } // Through Layout


            if ($pageContentEl.length === 0) {
              if ($navbarEl.nextAll('.page-current:not(.stacked)').length > 0) {
                $pageContentEl = $navbarEl.nextAll('.page-current:not(.stacked)').find('.page-content');
              }
            }
          }

          if ($pageContentEl && $pageContentEl.length > 0) {
            // Check for tab
            if ($pageContentEl.hasClass('tab')) {
              $pageContentEl = $pageContentEl.parent('.tabs').children('.page-content.tab-active');
            }

            if ($pageContentEl.length > 0) $pageContentEl.scrollTop(0, 300);
          }
        }
      },
      vnode: {
        navbar: {
          postpatch: function postpatch(vnode) {
            var app = this;
            app.navbar.size(vnode.elm);
          }
        }
      }
    };

    var Toolbar$1 = {
      setHighlight: function setHighlight(tabbarEl) {
        var app = this;
        if (app.theme === 'ios') return;
        var $tabbarEl = $(tabbarEl);
        if ($tabbarEl.length === 0 || !($tabbarEl.hasClass('tabbar') || $tabbarEl.hasClass('tabbar-labels'))) return;
        var $highlightEl = $tabbarEl.find('.tab-link-highlight');
        var tabLinksCount = $tabbarEl.find('.tab-link').length;

        if (tabLinksCount === 0) {
          $highlightEl.remove();
          return;
        }

        if ($highlightEl.length === 0) {
          $tabbarEl.children('.toolbar-inner').append('<span class="tab-link-highlight"></span>');
          $highlightEl = $tabbarEl.find('.tab-link-highlight');
        } else if ($highlightEl.next().length) {
          $tabbarEl.children('.toolbar-inner').append($highlightEl);
        }

        var $activeLink = $tabbarEl.find('.tab-link-active');
        var highlightWidth;
        var highlightTranslate;

        if ($tabbarEl.hasClass('tabbar-scrollable') && $activeLink && $activeLink[0]) {
          highlightWidth = $activeLink[0].offsetWidth + "px";
          highlightTranslate = $activeLink[0].offsetLeft + "px";
        } else {
          var activeIndex = $activeLink.index();
          highlightWidth = 100 / tabLinksCount + "%";
          highlightTranslate = (app.rtl ? -activeIndex : activeIndex) * 100 + "%";
        }

        nextFrame$1(function () {
          $highlightEl.css('width', highlightWidth).transform("translate3d(" + highlightTranslate + ",0,0)");
        });
      },
      init: function init(tabbarEl) {
        var app = this;
        app.toolbar.setHighlight(tabbarEl);
      },
      hide: function hide(el, animate) {
        if (animate === void 0) {
          animate = true;
        }

        var app = this;
        var $el = $(el);
        if ($el.hasClass('toolbar-hidden')) return;
        var className = "toolbar-hidden" + (animate ? ' toolbar-transitioning' : '');
        $el.transitionEnd(function () {
          $el.removeClass('toolbar-transitioning');
        });
        $el.addClass(className);
        $el.trigger('toolbar:hide');
        app.emit('toolbarHide', $el[0]);
      },
      show: function show(el, animate) {
        if (animate === void 0) {
          animate = true;
        }

        var app = this;
        var $el = $(el);
        if (!$el.hasClass('toolbar-hidden')) return;

        if (animate) {
          $el.addClass('toolbar-transitioning');
          $el.transitionEnd(function () {
            $el.removeClass('toolbar-transitioning');
          });
        }

        $el.removeClass('toolbar-hidden');
        $el.trigger('toolbar:show');
        app.emit('toolbarShow', $el[0]);
      },
      initToolbarOnScroll: function initToolbarOnScroll(pageEl) {
        var app = this;
        var $pageEl = $(pageEl);
        var $toolbarEl = $pageEl.parents('.view').children('.toolbar');

        if ($toolbarEl.length === 0) {
          $toolbarEl = $pageEl.find('.toolbar');
        }

        if ($toolbarEl.length === 0) {
          $toolbarEl = $pageEl.parents('.views').children('.tabbar, .tabbar-labels');
        }

        if ($toolbarEl.length === 0) {
          return;
        }

        var previousScrollTop;
        var currentScrollTop;
        var scrollHeight;
        var offsetHeight;
        var reachEnd;
        var action;
        var toolbarHidden;

        function handleScroll(e) {
          if ($pageEl.hasClass('page-with-card-opened')) return;
          if ($pageEl.hasClass('page-previous')) return;
          var scrollContent = this;

          if (e && e.target && e.target !== scrollContent) {
            return;
          }

          currentScrollTop = scrollContent.scrollTop;
          scrollHeight = scrollContent.scrollHeight;
          offsetHeight = scrollContent.offsetHeight;
          reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
          toolbarHidden = $toolbarEl.hasClass('toolbar-hidden');

          if (reachEnd) {
            if (app.params.toolbar.showOnPageScrollEnd) {
              action = 'show';
            }
          } else if (previousScrollTop > currentScrollTop) {
            if (app.params.toolbar.showOnPageScrollTop || currentScrollTop <= 44) {
              action = 'show';
            } else {
              action = 'hide';
            }
          } else if (currentScrollTop > 44) {
            action = 'hide';
          } else {
            action = 'show';
          }

          if (action === 'show' && toolbarHidden) {
            app.toolbar.show($toolbarEl);
            toolbarHidden = false;
          } else if (action === 'hide' && !toolbarHidden) {
            app.toolbar.hide($toolbarEl);
            toolbarHidden = true;
          }

          previousScrollTop = currentScrollTop;
        }

        $pageEl.on('scroll', '.page-content', handleScroll, true);
        $pageEl[0].f7ScrollToolbarHandler = handleScroll;
      }
    };
    var Toolbar$2 = {
      name: 'toolbar',
      create: function create() {
        var app = this;
        bindMethods(app, {
          toolbar: Toolbar$1
        });
      },
      params: {
        toolbar: {
          hideOnPageScroll: false,
          showOnPageScrollEnd: true,
          showOnPageScrollTop: true
        }
      },
      on: {
        pageBeforeRemove: function pageBeforeRemove(page) {
          if (page.$el[0].f7ScrollToolbarHandler) {
            page.$el.off('scroll', '.page-content', page.$el[0].f7ScrollToolbarHandler, true);
          }
        },
        pageBeforeIn: function pageBeforeIn(page) {
          var app = this;
          var $toolbarEl = page.$el.parents('.view').children('.toolbar');

          if ($toolbarEl.length === 0) {
            $toolbarEl = page.$el.parents('.views').children('.tabbar, .tabbar-labels');
          }

          if ($toolbarEl.length === 0) {
            $toolbarEl = page.$el.find('.toolbar');
          }

          if ($toolbarEl.length === 0) {
            return;
          }

          if (page.$el.hasClass('no-toolbar')) {
            app.toolbar.hide($toolbarEl);
          } else {
            app.toolbar.show($toolbarEl);
          }
        },
        pageInit: function pageInit(page) {
          var app = this;
          page.$el.find('.tabbar, .tabbar-labels').each(function (tabbarEl) {
            app.toolbar.init(tabbarEl);
          });

          if (app.params.toolbar.hideOnPageScroll || page.$el.find('.hide-toolbar-on-scroll').length || page.$el.hasClass('hide-toolbar-on-scroll') || page.$el.find('.hide-bars-on-scroll').length || page.$el.hasClass('hide-bars-on-scroll')) {
            if (page.$el.find('.keep-toolbar-on-scroll').length || page.$el.hasClass('keep-toolbar-on-scroll') || page.$el.find('.keep-bars-on-scroll').length || page.$el.hasClass('keep-bars-on-scroll')) {
              return;
            }

            app.toolbar.initToolbarOnScroll(page.el);
          }
        },
        init: function init() {
          var app = this;
          app.$el.find('.tabbar, .tabbar-labels').each(function (tabbarEl) {
            app.toolbar.init(tabbarEl);
          });
        }
      },
      vnode: {
        tabbar: {
          insert: function insert(vnode) {
            var app = this;
            app.toolbar.init(vnode.elm);
          }
        }
      }
    };

    var Subnavbar = {
      name: 'subnavbar',
      on: {
        pageInit: function pageInit(page) {
          if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find('.subnavbar').length) {
            page.$el.addClass('page-with-subnavbar');
          }

          var $innerSubnavbars = page.$el.find('.subnavbar').filter(function (subnavbarEl) {
            return $(subnavbarEl).parents('.page')[0] === page.$el[0];
          });

          if ($innerSubnavbars.length) {
            page.$el.addClass('page-with-subnavbar');
          }
        }
      }
    };

    var TouchRipple$1 = /*#__PURE__*/function () {
      function TouchRipple(app, $el, x, y) {
        var ripple = this;
        if (!$el) return undefined;

        var _$el$0$getBoundingCli = $el[0].getBoundingClientRect(),
            left = _$el$0$getBoundingCli.left,
            top = _$el$0$getBoundingCli.top,
            width = _$el$0$getBoundingCli.width,
            height = _$el$0$getBoundingCli.height;

        var center = {
          x: x - left,
          y: y - top
        };
        var diameter = Math.max(Math.pow(Math.pow(height, 2) + Math.pow(width, 2), 0.5), 48);
        var isInset = false;
        var insetElements = app.params.touch.touchRippleInsetElements || '';

        if (insetElements && $el.is(insetElements)) {
          isInset = true;
        }

        if (isInset) {
          diameter = Math.max(Math.min(width, height), 48);
        }

        if (!isInset && $el.css('overflow') === 'hidden') {
          var distanceFromCenter = Math.pow(Math.pow(center.x - width / 2, 2) + Math.pow(center.y - height / 2, 2), 0.5);
          var scale = (diameter / 2 + distanceFromCenter) / (diameter / 2);
          ripple.rippleTransform = "translate3d(0px, 0px, 0) scale(" + scale + ")";
        } else {
          // prettier-ignore
          ripple.rippleTransform = "translate3d(" + (-center.x + width / 2) + "px, " + (-center.y + height / 2) + "px, 0) scale(1)";
        }

        if (isInset) {
          $el.addClass('ripple-inset');
        }

        ripple.$rippleWaveEl = $("<div class=\"ripple-wave\" style=\"width: " + diameter + "px; height: " + diameter + "px; margin-top:-" + diameter / 2 + "px; margin-left:-" + diameter / 2 + "px; left:" + center.x + "px; top:" + center.y + "px; --f7-ripple-transform: " + ripple.rippleTransform + "\"></div>");
        $el.prepend(ripple.$rippleWaveEl);
        ripple.$rippleWaveEl.animationEnd(function () {
          if (!ripple.$rippleWaveEl) return;
          if (ripple.$rippleWaveEl.hasClass('ripple-wave-out')) return;
          ripple.$rippleWaveEl.addClass('ripple-wave-in');

          if (ripple.shouldBeRemoved) {
            ripple.out();
          }
        });
        return ripple;
      }

      var _proto = TouchRipple.prototype;

      _proto.destroy = function destroy() {
        var ripple = this;

        if (ripple.$rippleWaveEl) {
          ripple.$rippleWaveEl.remove();
        }

        Object.keys(ripple).forEach(function (key) {
          ripple[key] = null;
          delete ripple[key];
        });
        ripple = null;
      };

      _proto.out = function out() {
        var ripple = this;
        var $rippleWaveEl = this.$rippleWaveEl;
        clearTimeout(ripple.removeTimeout);
        $rippleWaveEl.addClass('ripple-wave-out');
        ripple.removeTimeout = setTimeout(function () {
          ripple.destroy();
        }, 300);
        $rippleWaveEl.animationEnd(function () {
          clearTimeout(ripple.removeTimeout);
          ripple.destroy();
        });
      };

      _proto.remove = function remove() {
        var ripple = this;
        if (ripple.shouldBeRemoved) return;
        ripple.removeTimeout = setTimeout(function () {
          ripple.destroy();
        }, 400);
        ripple.shouldBeRemoved = true;

        if (ripple.$rippleWaveEl.hasClass('ripple-wave-in')) {
          ripple.out();
        }
      };

      return TouchRipple;
    }();

    function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf$2(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

    function _setPrototypeOf$2(o, p) { _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$2(o, p); }
    var TouchRipple = {
      name: 'touch-ripple',
      static: {
        TouchRipple: TouchRipple$1
      },
      create: function create() {
        var app = this;
        app.touchRipple = {
          create: function create() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            return _construct(TouchRipple$1, args);
          }
        };
      }
    };

    function _assertThisInitialized$1(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$1(subClass, superClass); }

    function _setPrototypeOf$1(o, p) { _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$1(o, p); }
    var openedModals = [];
    var dialogsQueue = [];

    function clearDialogsQueue() {
      if (dialogsQueue.length === 0) return;
      var dialog = dialogsQueue.shift();
      dialog.open();
    }

    var Modal$1 = /*#__PURE__*/function (_Framework7Class) {
      _inheritsLoose$1(Modal, _Framework7Class);

      function Modal(app, params) {
        var _this;

        _this = _Framework7Class.call(this, params, [app]) || this;

        var modal = _assertThisInitialized$1(_this);

        var defaults = {}; // Extend defaults with modules params

        modal.useModulesParams(defaults);
        modal.params = extend$1(defaults, params);
        modal.opened = false;
        var $containerEl = modal.params.containerEl ? $(modal.params.containerEl).eq(0) : app.$el;
        if (!$containerEl.length) $containerEl = app.$el;
        modal.$containerEl = $containerEl;
        modal.containerEl = $containerEl[0]; // Install Modules

        modal.useModules();
        return _assertThisInitialized$1(_this) || _assertThisInitialized$1(_this);
      }

      var _proto = Modal.prototype;

      _proto.onOpen = function onOpen() {
        var modal = this;
        modal.opened = true;
        openedModals.push(modal);
        $('html').addClass("with-modal-" + modal.type.toLowerCase());
        modal.$el.trigger("modal:open " + modal.type.toLowerCase() + ":open");
        modal.emit("local::open modalOpen " + modal.type + "Open", modal);
      };

      _proto.onOpened = function onOpened() {
        var modal = this;
        modal.$el.trigger("modal:opened " + modal.type.toLowerCase() + ":opened");
        modal.emit("local::opened modalOpened " + modal.type + "Opened", modal);
      };

      _proto.onClose = function onClose() {
        var modal = this;
        modal.opened = false;
        if (!modal.type || !modal.$el) return;
        openedModals.splice(openedModals.indexOf(modal), 1);
        $('html').removeClass("with-modal-" + modal.type.toLowerCase());
        modal.$el.trigger("modal:close " + modal.type.toLowerCase() + ":close");
        modal.emit("local::close modalClose " + modal.type + "Close", modal);
      };

      _proto.onClosed = function onClosed() {
        var modal = this;
        if (!modal.type || !modal.$el) return;
        modal.$el.removeClass('modal-out');
        modal.$el.hide();
        modal.$el.trigger("modal:closed " + modal.type.toLowerCase() + ":closed");
        modal.emit("local::closed modalClosed " + modal.type + "Closed", modal);
      };

      _proto.open = function open(animateModal) {
        var modal = this;
        var document = getDocument();
        var app = modal.app;
        var $el = modal.$el;
        var $backdropEl = modal.$backdropEl;
        var type = modal.type;
        var animate = true;
        if (typeof animateModal !== 'undefined') animate = animateModal;else if (typeof modal.params.animate !== 'undefined') {
          animate = modal.params.animate;
        }

        if (!$el || $el.hasClass('modal-in')) {
          if (animateModal === false && $el[0] && type !== 'dialog') {
            $el[0].style.display = 'block';
          }

          return modal;
        }

        if (type === 'dialog' && app.params.modal.queueDialogs) {
          var pushToQueue;

          if ($('.dialog.modal-in').length > 0) {
            pushToQueue = true;
          } else if (openedModals.length > 0) {
            openedModals.forEach(function (openedModal) {
              if (openedModal.type === 'dialog') pushToQueue = true;
            });
          }

          if (pushToQueue) {
            dialogsQueue.push(modal);
            return modal;
          }
        }

        var $modalParentEl = $el.parent();
        var wasInDom = $el.parents(document).length > 0;

        if (!$modalParentEl.is(modal.$containerEl)) {
          modal.$containerEl.append($el);
          modal.once(type + "Closed", function () {
            if (wasInDom) {
              $modalParentEl.append($el);
            } else {
              $el.remove();
            }
          });
        } // Show Modal


        $el.show();
        /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */

        modal._clientLeft = $el[0].clientLeft; // Modal

        function transitionEnd() {
          if ($el.hasClass('modal-out')) {
            modal.onClosed();
          } else if ($el.hasClass('modal-in')) {
            modal.onOpened();
          }
        }

        if (animate) {
          if ($backdropEl) {
            $backdropEl.removeClass('not-animated');
            $backdropEl.addClass('backdrop-in');
          }

          $el.animationEnd(function () {
            transitionEnd();
          });
          $el.transitionEnd(function () {
            transitionEnd();
          });
          $el.removeClass('modal-out not-animated').addClass('modal-in');
          modal.onOpen();
        } else {
          if ($backdropEl) {
            $backdropEl.addClass('backdrop-in not-animated');
          }

          $el.removeClass('modal-out').addClass('modal-in not-animated');
          modal.onOpen();
          modal.onOpened();
        }

        return modal;
      };

      _proto.close = function close(animateModal) {
        var modal = this;
        var $el = modal.$el;
        var $backdropEl = modal.$backdropEl;
        var animate = true;
        if (typeof animateModal !== 'undefined') animate = animateModal;else if (typeof modal.params.animate !== 'undefined') {
          animate = modal.params.animate;
        }

        if (!$el || !$el.hasClass('modal-in')) {
          if (dialogsQueue.indexOf(modal) >= 0) {
            dialogsQueue.splice(dialogsQueue.indexOf(modal), 1);
          }

          return modal;
        } // backdrop


        if ($backdropEl) {
          var needToHideBackdrop = true;

          if (modal.type === 'popup') {
            modal.$el.prevAll('.popup.modal-in').add(modal.$el.nextAll('.popup.modal-in')).each(function (popupEl) {
              var popupInstance = popupEl.f7Modal;
              if (!popupInstance) return;

              if (popupInstance.params.closeByBackdropClick && popupInstance.params.backdrop && popupInstance.backdropEl === modal.backdropEl) {
                needToHideBackdrop = false;
              }
            });
          }

          if (needToHideBackdrop) {
            $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
            $backdropEl.removeClass('backdrop-in');
          }
        } // Modal


        $el[animate ? 'removeClass' : 'addClass']('not-animated');

        function transitionEnd() {
          if ($el.hasClass('modal-out')) {
            modal.onClosed();
          } else if ($el.hasClass('modal-in')) {
            modal.onOpened();
          }
        }

        if (animate) {
          $el.animationEnd(function () {
            transitionEnd();
          });
          $el.transitionEnd(function () {
            transitionEnd();
          });
          $el.removeClass('modal-in').addClass('modal-out'); // Emit close

          modal.onClose();
        } else {
          $el.addClass('not-animated').removeClass('modal-in').addClass('modal-out'); // Emit close

          modal.onClose();
          modal.onClosed();
        }

        if (modal.type === 'dialog') {
          clearDialogsQueue();
        }

        return modal;
      };

      _proto.destroy = function destroy() {
        var modal = this;
        if (modal.destroyed) return;
        modal.emit("local::beforeDestroy modalBeforeDestroy " + modal.type + "BeforeDestroy", modal);

        if (modal.$el) {
          modal.$el.trigger("modal:beforedestroy " + modal.type.toLowerCase() + ":beforedestroy");

          if (modal.$el.length && modal.$el[0].f7Modal) {
            delete modal.$el[0].f7Modal;
          }
        }

        deleteProps(modal);
        modal.destroyed = true;
      };

      return Modal;
    }(Framework7Class$1);

    var Modal$2 = Modal$1;

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

    var CustomModal = /*#__PURE__*/function (_Modal) {
      _inheritsLoose(CustomModal, _Modal);

      function CustomModal(app, params) {
        var _this;

        var extendedParams = extend$1({
          backdrop: true,
          closeByBackdropClick: true,
          on: {}
        }, params); // Extends with open/close Modal methods;

        _this = _Modal.call(this, app, extendedParams) || this;

        var customModal = _assertThisInitialized(_this);

        customModal.params = extendedParams; // Find Element

        var $el;

        if (!customModal.params.el) {
          $el = $(customModal.params.content);
        } else {
          $el = $(customModal.params.el);
        }

        if ($el && $el.length > 0 && $el[0].f7Modal) {
          return $el[0].f7Modal || _assertThisInitialized(_this);
        }

        if ($el.length === 0) {
          return customModal.destroy() || _assertThisInitialized(_this);
        }

        var $backdropEl;

        if (customModal.params.backdrop) {
          $backdropEl = app.$el.children('.custom-modal-backdrop');

          if ($backdropEl.length === 0) {
            $backdropEl = $('<div class="custom-modal-backdrop"></div>');
            app.$el.append($backdropEl);
          }
        }

        function handleClick(e) {
          if (!customModal || customModal.destroyed) return;

          if ($backdropEl && e.target === $backdropEl[0]) {
            customModal.close();
          }
        }

        customModal.on('customModalOpened', function () {
          if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
            app.on('click', handleClick);
          }
        });
        customModal.on('customModalClose', function () {
          if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
            app.off('click', handleClick);
          }
        });
        extend$1(customModal, {
          app: app,
          $el: $el,
          el: $el[0],
          $backdropEl: $backdropEl,
          backdropEl: $backdropEl && $backdropEl[0],
          type: 'customModal'
        });
        $el[0].f7Modal = customModal;
        return customModal || _assertThisInitialized(_this);
      }

      return CustomModal;
    }(Modal$2);

    var CustomModal$1 = CustomModal;

    var Modal = {
      name: 'modal',
      static: {
        Modal: Modal$2,
        CustomModal: CustomModal$1
      },
      create: function create() {
        var app = this;
        app.customModal = {
          create: function create(params) {
            return new CustomModal$1(app, params);
          }
        };
      },
      params: {
        modal: {
          queueDialogs: true
        }
      }
    };

    /**
     * Framework7 6.3.5
     * Full featured mobile HTML framework for building iOS & Android apps
     * https://framework7.io/
     *
     * Copyright 2014-2021 Vladimir Kharlampidi
     *
     * Released under the MIT License
     *
     * Released on: September 30, 2021
     */
    Router$1.use([RouterComponentLoaderModule]);
    Framework7$1.use([DeviceModule, SupportModule, UtilsModule, ResizeModule, RequestModule, TouchModule, ClicksModule, RouterModule, HistoryModule, ComponentModule, ServiceWorkerModule, StoreModule, Statusbar$1, View$1, Navbar$2, Toolbar$2, Subnavbar, TouchRipple, Modal]);

    /**
     * Framework7 6.3.5
     * Full featured mobile HTML framework for building iOS & Android apps
     * https://framework7.io/
     *
     * Copyright 2014-2021 Vladimir Kharlampidi
     *
     * Released under the MIT License
     *
     * Released on: September 30, 2021
     */
    Framework7$1.use([DeviceModule, SupportModule, UtilsModule, ResizeModule, RequestModule, TouchModule, ClicksModule, RouterModule, HistoryModule, ServiceWorkerModule, StoreModule, Statusbar$1, View$1, Navbar$2, Toolbar$2, Subnavbar, TouchRipple, Modal]);

    function noUndefinedProps(obj) {
      var o = {};
      Object.keys(obj).forEach(function (key) {
        if (typeof obj[key] !== 'undefined') o[key] = obj[key];
      });
      return o;
    }
    function isStringProp(val) {
      return typeof val === 'string' && val !== '';
    }
    function isObject(o) {
      return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
    }
    function now() {
      return Date.now();
    }
    function extend() {
      var deep = true;
      var to;
      var from;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (typeof args[0] === 'boolean') {
        deep = args[0];
        to = args[1];
        args.splice(0, 2);
        from = args;
      } else {
        to = args[0];
        args.splice(0, 1);
        from = args;
      }

      for (var i = 0; i < from.length; i += 1) {
        var nextSource = args[i];

        if (nextSource !== undefined && nextSource !== null) {
          var keysArray = Object.keys(Object(nextSource));

          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              if (!deep) {
                to[nextKey] = nextSource[nextKey];
              } else if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                extend(to[nextKey], nextSource[nextKey]);
              } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                to[nextKey] = {};
                extend(to[nextKey], nextSource[nextKey]);
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }

      return to;
    }
    function classNames() {
      var classes = [];

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      args.forEach(function (arg) {
        if (typeof arg === 'object' && arg.constructor === Object) {
          Object.keys(arg).forEach(function (key) {
            if (arg[key]) classes.push(key);
          });
        } else if (arg) classes.push(arg);
      });
      var uniqueClasses = [];
      classes.forEach(function (c) {
        if (uniqueClasses.indexOf(c) < 0) uniqueClasses.push(c);
      });
      return uniqueClasses.join(' ');
    }
    function createEmitter(createEventDispatcher, props) {
      var dispatch = createEventDispatcher();

      var emit = function emit(events, argsArray) {
        if (!events || !events.trim().length || typeof events !== 'string') return;
        events.trim().split(' ').forEach(function (event) {
          var eventName = (event || '').trim();
          if (!eventName) return;
          var propName = "on" + (eventName.charAt(0).toUpperCase() + eventName.slice(1));
          dispatch(eventName, argsArray);
          if (typeof props[propName] === 'function') props[propName].apply(props, argsArray);
        });
      };

      return emit;
    }
    var routerIdCounter = 0;
    var routerComponentIdCounter = 0;
    function unsetRouterIds() {
      routerIdCounter = 0;
      routerComponentIdCounter = 0;
    }
    function getRouterId() {
      routerIdCounter += 1;
      return now() + "_" + routerIdCounter;
    }
    function getComponentId() {
      routerComponentIdCounter += 1;
      return now() + "_" + routerComponentIdCounter;
    }
    function plainText(text) {
      if (typeof text === 'undefined' || text === null) return '';
      return text;
    }

    /* eslint-disable import/no-mutable-exports */
    var f7;

    if (!Framework7$1.__app__) {
      // eslint-disable-next-line
      Framework7$1.__app__ = {
        f7: undefined,
        f7events: undefined,
        theme: {},
        f7routers: {
          views: [],
          tabs: [],
          modals: null
        }
      };
    }

    var app$1 = Framework7$1.__app__;

    app$1.setInstance = function (instance) {
      f7 = instance;
    };

    var setTheme = function setTheme() {
      if (!app$1.f7) return;
      app$1.theme.ios = app$1.f7.theme === 'ios';
      app$1.f7.theme === 'ios';
      app$1.theme.md = app$1.f7.theme === 'md';
      app$1.f7.theme === 'md';
      app$1.theme.aurora = app$1.f7.theme === 'aurora';
      app$1.f7.theme === 'aurora';
    };

    var cleanup = function cleanup() {
      unsetRouterIds();
      delete app$1.theme.ios;
      delete app$1.theme.md;
      delete app$1.theme.aurora;
      app$1.f7routers.views = [];
      app$1.f7routers.tabs = [];
      app$1.f7routers.modals = null;
    };

    var f7initEvents = function f7initEvents() {
      app$1.f7events = new Framework7$1.Events();
    };

    var f7init = function f7init(rootEl, params, init) {
      if (params === void 0) {
        params = {};
      }

      if (init === void 0) {
        init = true;
      }

      var f7Params = extend({}, params, {
        el: rootEl,
        init: init
      });
      if (typeof params.store !== 'undefined') f7Params.store = params.store;
      if (!f7Params.routes) f7Params.routes = [];

      if (f7Params.userAgent && (f7Params.theme === 'auto' || !f7Params.theme)) {
        var device = Framework7$1.getDevice({
          userAgent: f7Params.userAgent
        }, true);
        app$1.theme.ios = !!device.ios;
        app$1.theme.aurora = device.desktop && device.electron;
        app$1.theme.md = !app$1.theme.ios && !app$1.theme.aurora;
      } // eslint-disable-next-line


      if (app$1.f7 && typeof window !== 'undefined') return; // eslint-disable-next-line

      if (typeof window === 'undefined') cleanup();
      var instance = new Framework7$1(f7Params);
      app$1.f7 = instance;
      f7 = instance;
      app$1.setInstance(instance);
      setTheme();

      if (instance.initialized) {
        app$1.f7 = instance;
        f7 = instance;
        app$1.setInstance(instance);
        app$1.f7events.emit('ready', app$1.f7);
      } else {
        instance.on('init', function () {
          app$1.f7 = instance;
          f7 = instance;
          app$1.setInstance(instance);
          app$1.f7events.emit('ready', app$1.f7);
        });
      }
    };

    var f7ready = function f7ready(callback) {
      if (!callback) return;
      if (app$1.f7 && app$1.f7.initialized) callback(app$1.f7);else {
        app$1.f7events.once('ready', callback);
      }
    };

    /* eslint no-underscore-dangle: "off" */

    var getChildrenArray = function getChildrenArray(el) {
      var arr = [];

      for (var i = 0; i < el.children.length; i += 1) {
        arr.push(el.children[i]);
      }

      return arr;
    };

    var hasSameChildren = function hasSameChildren(childrenBefore, childrenAfter) {
      if (childrenBefore.length !== childrenAfter.length) return false;
      var set = new Set([].concat(childrenBefore, childrenAfter));
      if (set.size === childrenBefore.length) return true;
      return false;
    };

    var componentsRouter = {
      proto: {
        pageComponentLoader: function pageComponentLoader(_ref) {
          var routerEl = _ref.routerEl,
              component = _ref.component,
              options = _ref.options,
              resolve = _ref.resolve,
              reject = _ref.reject;
          var router = this;
          var routerId = router.id;
          var el = routerEl;
          var viewRouter;
          app$1.f7routers.views.forEach(function (data) {
            if (data.el && data.el === routerEl || data.routerId && data.routerId === routerId) {
              viewRouter = data;
            }
          });

          if (!viewRouter) {
            reject();
            return;
          }

          var pageData = {
            component: component,
            id: getComponentId(),
            props: extend({
              f7route: options.route,
              f7router: router
            }, options.route.params, options.props || {})
          };
          var resolved;
          var childrenBefore = getChildrenArray(el);

          function onDidUpdate(componentRouterData) {
            if (componentRouterData !== viewRouter || resolved) return;
            var childrenAfter = getChildrenArray(el);
            if (hasSameChildren(childrenBefore, childrenAfter)) return;
            app$1.f7events.off('viewRouterDidUpdate', onDidUpdate);
            var pageEl = el.children[el.children.length - 1];
            pageData.el = pageEl;
            resolve(pageEl);
            resolved = true;
          }

          app$1.f7events.on('viewRouterDidUpdate', onDidUpdate);
          viewRouter.pages.push(pageData);
          viewRouter.setPages(viewRouter.pages);
        },
        removePage: function removePage($pageEl) {
          if (!$pageEl) return;
          var router = this;
          var f7Page;
          if ('length' in $pageEl && $pageEl[0]) f7Page = $pageEl[0].f7Page;else f7Page = $pageEl.f7Page;

          if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
            router.app.$($pageEl).remove();
            return;
          }

          var viewRouter;
          app$1.f7routers.views.forEach(function (data) {
            if (data.el && data.el === router.el) {
              viewRouter = data;
            }
          });
          var pageEl;

          if ('length' in $pageEl) {
            // Dom7
            if ($pageEl.length === 0) return;
            pageEl = $pageEl[0];
          } else {
            pageEl = $pageEl;
          }

          if (!pageEl) return;
          var pageComponentFound;
          viewRouter.pages.forEach(function (page, index) {
            if (page.el === pageEl) {
              pageComponentFound = true;
              viewRouter.pages.splice(index, 1);
              viewRouter.setPages(viewRouter.pages);
            }
          });

          if (!pageComponentFound) {
            pageEl.parentNode.removeChild(pageEl);
          }
        },
        tabComponentLoader: function tabComponentLoader(_temp) {
          var _ref2 = _temp === void 0 ? {} : _temp,
              tabEl = _ref2.tabEl,
              component = _ref2.component,
              options = _ref2.options,
              resolve = _ref2.resolve,
              reject = _ref2.reject;

          var router = this;
          if (!tabEl) reject();
          var tabRouter;
          app$1.f7routers.tabs.forEach(function (tabData) {
            if (tabData.el && tabData.el === tabEl) {
              tabRouter = tabData;
            }
          });

          if (!tabRouter) {
            reject();
            return;
          }

          var id = getComponentId();
          var tabContent = {
            id: id,
            component: component,
            props: extend({
              f7route: options.route,
              f7router: router
            }, options.route.route && options.route.route.tab && options.route.route.tab.options && options.route.route.tab.options.props || {}, options.route.params, options.props || {})
          };
          var resolved;

          function onDidUpdate(componentRouterData) {
            if (componentRouterData !== tabRouter || resolved) return;
            app$1.f7events.off('tabRouterDidUpdate', onDidUpdate);
            var tabContentEl = tabEl.children[0];
            resolve(tabContentEl);
            resolved = true;
          }

          app$1.f7events.on('tabRouterDidUpdate', onDidUpdate);
          tabRouter.setTabContent(tabContent);
        },
        removeTabContent: function removeTabContent(tabEl) {
          if (!tabEl) return;
          var tabRouter;
          app$1.f7routers.tabs.forEach(function (tabData) {
            if (tabData.el && tabData.el === tabEl) {
              tabRouter = tabData;
            }
          });

          if (!tabRouter) {
            tabEl.innerHTML = ''; // eslint-disable-line

            return;
          }

          tabRouter.setTabContent(null);
        },
        modalComponentLoader: function modalComponentLoader(_temp2) {
          var _ref3 = _temp2 === void 0 ? {} : _temp2,
              component = _ref3.component,
              options = _ref3.options,
              resolve = _ref3.resolve,
              reject = _ref3.reject;

          var router = this;
          var modalsRouter = app$1.f7routers.modals;

          if (!modalsRouter) {
            reject();
            return;
          }

          var modalData = {
            component: component,
            id: getComponentId(),
            props: extend({
              f7route: options.route,
              f7router: router
            }, options.route.params, options.props || {})
          };
          var resolved;

          function onDidUpdate() {
            if (resolved) return;
            app$1.f7events.off('modalsRouterDidUpdate', onDidUpdate);
            var modalEl = modalsRouter.el.children[modalsRouter.el.children.length - 1];
            modalData.el = modalEl;
            resolve(modalEl);
            resolved = true;
          }

          app$1.f7events.on('modalsRouterDidUpdate', onDidUpdate);
          modalsRouter.modals.push(modalData);
          modalsRouter.setModals(modalsRouter.modals);
        },
        removeModal: function removeModal(modalEl) {
          var modalsRouter = app$1.f7routers.modals;
          if (!modalsRouter) return;
          var modalDataToRemove;
          modalsRouter.modals.forEach(function (modalData) {
            if (modalData.el === modalEl) modalDataToRemove = modalData;
          });
          modalsRouter.modals.splice(modalsRouter.modals.indexOf(modalDataToRemove), 1);
          modalsRouter.setModals(modalsRouter.modals);
        }
      }
    };

    // eslint-disable-next-line
    var Framework7Svelte = {
      name: 'sveltePlugin',
      installed: false,
      install: function install(params) {
        if (params === void 0) {
          params = {};
        }

        if (Framework7Svelte.installed) return;
        Framework7Svelte.installed = true;
        f7initEvents();
        var _params = params,
            paramsTheme = _params.theme,
            userAgent = _params.userAgent;

        if (paramsTheme === 'md') {
          app$1.theme.md = true;
        }

        if (paramsTheme === 'ios') {
          app$1.theme.md = true;
        }

        if (paramsTheme === 'aurora') {
          app$1.theme.md = true;
        } // eslint-disable-next-line


        var needThemeCalc = typeof window === 'undefined' ? !!userAgent : true;

        if (needThemeCalc && (!paramsTheme || paramsTheme === 'auto')) {
          var device = Framework7$1.getDevice({
            userAgent: userAgent
          }, true);
          app$1.theme.ios = !!device.ios;
          app$1.theme.ios;
          app$1.theme.aurora = device.desktop && device.electron;
          app$1.theme.aurora;
          app$1.theme.md = !app$1.theme.ios && !app$1.theme.aurora;
          app$1.theme.md;
        }

        f7ready(function () {
          setTheme();
        });
        Framework7$1.Router.use(componentsRouter);
      }
    };

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function compute_slots(slots) {
        const result = {};
        for (const key in slots) {
            result[key] = true;
        }
        return result;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
        select.selectedIndex = -1; // no option should be selected
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.0' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    function colorClasses(props) {
      var _ref;

      var color = props.color,
          colorTheme = props.colorTheme,
          textColor = props.textColor,
          bgColor = props.bgColor,
          borderColor = props.borderColor,
          rippleColor = props.rippleColor,
          themeDark = props.themeDark;
      return _ref = {
        'theme-dark': themeDark
      }, _ref["color-" + color] = color, _ref["color-theme-" + colorTheme] = colorTheme, _ref["text-color-" + textColor] = textColor, _ref["bg-color-" + bgColor] = bgColor, _ref["border-color-" + borderColor] = borderColor, _ref["ripple-color-" + rippleColor] = rippleColor, _ref;
    }
    function routerAttrs(props) {
      var force = props.force,
          reloadCurrent = props.reloadCurrent,
          reloadPrevious = props.reloadPrevious,
          reloadAll = props.reloadAll,
          reloadDetail = props.reloadDetail,
          animate = props.animate,
          ignoreCache = props.ignoreCache,
          routeTabId = props.routeTabId,
          view = props.view,
          transition = props.transition,
          openIn = props.openIn;
      var dataAnimate;

      if ('animate' in props && typeof animate !== 'undefined') {
        dataAnimate = animate.toString();
      }

      var dataReloadDetail;

      if ('reloadDetail' in props && typeof reloadDetail !== 'undefined') {
        dataReloadDetail = reloadDetail.toString();
      }

      return {
        'data-force': force || undefined,
        'data-reload-current': reloadCurrent || undefined,
        'data-reload-all': reloadAll || undefined,
        'data-reload-previous': reloadPrevious || undefined,
        'data-reload-detail': dataReloadDetail,
        'data-animate': dataAnimate,
        'data-ignore-cache': ignoreCache || undefined,
        'data-route-tab-id': routeTabId || undefined,
        'data-view': isStringProp(view) ? view : undefined,
        'data-transition': isStringProp(transition) ? transition : undefined,
        'data-open-in': isStringProp(openIn) ? openIn : undefined
      };
    }
    function routerClasses(props) {
      var back = props.back,
          linkBack = props.linkBack,
          external = props.external,
          preventRouter = props.preventRouter;
      return {
        back: back || linkBack,
        external: external,
        'prevent-router': preventRouter
      };
    }
    function actionsAttrs(props) {
      var searchbarEnable = props.searchbarEnable,
          searchbarDisable = props.searchbarDisable,
          searchbarClear = props.searchbarClear,
          searchbarToggle = props.searchbarToggle,
          panelOpen = props.panelOpen,
          panelClose = props.panelClose,
          panelToggle = props.panelToggle,
          popupOpen = props.popupOpen,
          popupClose = props.popupClose,
          actionsOpen = props.actionsOpen,
          actionsClose = props.actionsClose,
          popoverOpen = props.popoverOpen,
          popoverClose = props.popoverClose,
          loginScreenOpen = props.loginScreenOpen,
          loginScreenClose = props.loginScreenClose,
          sheetOpen = props.sheetOpen,
          sheetClose = props.sheetClose,
          sortableEnable = props.sortableEnable,
          sortableDisable = props.sortableDisable,
          sortableToggle = props.sortableToggle,
          cardOpen = props.cardOpen,
          cardClose = props.cardClose;
      return {
        'data-searchbar': isStringProp(searchbarEnable) && searchbarEnable || isStringProp(searchbarDisable) && searchbarDisable || isStringProp(searchbarClear) && searchbarClear || isStringProp(searchbarToggle) && searchbarToggle || undefined,
        'data-panel': isStringProp(panelOpen) && panelOpen || isStringProp(panelClose) && panelClose || isStringProp(panelToggle) && panelToggle || undefined,
        'data-popup': isStringProp(popupOpen) && popupOpen || isStringProp(popupClose) && popupClose || undefined,
        'data-actions': isStringProp(actionsOpen) && actionsOpen || isStringProp(actionsClose) && actionsClose || undefined,
        'data-popover': isStringProp(popoverOpen) && popoverOpen || isStringProp(popoverClose) && popoverClose || undefined,
        'data-sheet': isStringProp(sheetOpen) && sheetOpen || isStringProp(sheetClose) && sheetClose || undefined,
        'data-login-screen': isStringProp(loginScreenOpen) && loginScreenOpen || isStringProp(loginScreenClose) && loginScreenClose || undefined,
        'data-sortable': isStringProp(sortableEnable) && sortableEnable || isStringProp(sortableDisable) && sortableDisable || isStringProp(sortableToggle) && sortableToggle || undefined,
        'data-card': isStringProp(cardOpen) && cardOpen || isStringProp(cardClose) && cardClose || undefined
      };
    }
    function actionsClasses(props) {
      var searchbarEnable = props.searchbarEnable,
          searchbarDisable = props.searchbarDisable,
          searchbarClear = props.searchbarClear,
          searchbarToggle = props.searchbarToggle,
          panelOpen = props.panelOpen,
          panelClose = props.panelClose,
          panelToggle = props.panelToggle,
          popupOpen = props.popupOpen,
          popupClose = props.popupClose,
          actionsClose = props.actionsClose,
          actionsOpen = props.actionsOpen,
          popoverOpen = props.popoverOpen,
          popoverClose = props.popoverClose,
          loginScreenOpen = props.loginScreenOpen,
          loginScreenClose = props.loginScreenClose,
          sheetOpen = props.sheetOpen,
          sheetClose = props.sheetClose,
          sortableEnable = props.sortableEnable,
          sortableDisable = props.sortableDisable,
          sortableToggle = props.sortableToggle,
          cardOpen = props.cardOpen,
          cardPreventOpen = props.cardPreventOpen,
          cardClose = props.cardClose,
          menuClose = props.menuClose;
      return {
        'searchbar-enable': searchbarEnable || searchbarEnable === '',
        'searchbar-disable': searchbarDisable || searchbarDisable === '',
        'searchbar-clear': searchbarClear || searchbarClear === '',
        'searchbar-toggle': searchbarToggle || searchbarToggle === '',
        'panel-close': panelClose || panelClose === '',
        'panel-open': panelOpen || panelOpen === '',
        'panel-toggle': panelToggle || panelToggle === '',
        'popup-close': popupClose || popupClose === '',
        'popup-open': popupOpen || popupOpen === '',
        'actions-close': actionsClose || actionsClose === '',
        'actions-open': actionsOpen || actionsOpen === '',
        'popover-close': popoverClose || popoverClose === '',
        'popover-open': popoverOpen || popoverOpen === '',
        'sheet-close': sheetClose || sheetClose === '',
        'sheet-open': sheetOpen || sheetOpen === '',
        'login-screen-close': loginScreenClose || loginScreenClose === '',
        'login-screen-open': loginScreenOpen || loginScreenOpen === '',
        'sortable-enable': sortableEnable || sortableEnable === '',
        'sortable-disable': sortableDisable || sortableDisable === '',
        'sortable-toggle': sortableToggle || sortableToggle === '',
        'card-close': cardClose || cardClose === '',
        'card-open': cardOpen || cardOpen === '',
        'card-prevent-open': cardPreventOpen || cardPreventOpen === '',
        'menu-close': menuClose || menuClose === ''
      };
    }

    var ignoreProps = ['color', 'colorTheme', 'textColor', 'bgColor', 'borderColor', 'rippleColor', 'themeDark', 'force', 'reloadCurrent', 'reloadPrevious', 'reloadAll', 'reloadDetail', 'animate', 'ignoreCache', 'routeTabId', 'view', 'transition', 'openIn', 'back', 'linkBack', 'external', 'preventRouter', 'searchbarEnable', 'searchbarDisable', 'searchbarClear', 'searchbarToggle', 'panelOpen', 'panelClose', 'panelToggle', 'popupOpen', 'popupClose', 'actionsOpen', 'actionsClose', 'popoverOpen', 'popoverClose', 'loginScreenOpen', 'loginScreenClose', 'sheetOpen', 'sheetClose', 'sortableEnable', 'sortableDisable', 'sortableToggle', 'cardOpen', 'cardClose'];
    function restProps(rest) {
      if (rest === void 0) {
        rest = {};
      }

      var props = {};
      Object.keys(rest).filter(function (prop) {
        return !ignoreProps.includes(prop);
      }).forEach(function (key) {
        if (key.indexOf('on') !== 0) {
          props[key] = rest[key];
        }
      });
      return props;
    }

    /* node_modules/framework7-svelte/esm/svelte/routable-modals.svelte generated by Svelte v3.44.0 */
    const file$v = "node_modules/framework7-svelte/esm/svelte/routable-modals.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (33:2) {#each modals as modal (modal.id)}
    function create_each_block$1(key_1, ctx) {
    	let first;
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*modal*/ ctx[5].props];
    	var switch_value = /*modal*/ ctx[5].component;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			const switch_instance_changes = (dirty & /*modals*/ 1)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*modal*/ ctx[5].props)])
    			: {};

    			if (switch_value !== (switch_value = /*modal*/ ctx[5].component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(33:2) {#each modals as modal (modal.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value = /*modals*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*modal*/ ctx[5].id;
    	validate_each_keys(ctx, each_value, get_each_context$1, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$1(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "framework7-modals");
    			add_location(div, file$v, 31, 0, 629);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			/*div_binding*/ ctx[2](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*modals*/ 1) {
    				each_value = /*modals*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$1, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$1, null, get_each_context$1);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*div_binding*/ ctx[2](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Routable_modals', slots, []);
    	let modals = [];
    	let el;
    	let routerData;

    	onMount(() => {
    		routerData = {
    			el,
    			modals,
    			setModals(m) {
    				tick().then(() => {
    					$$invalidate(0, modals = m);
    				});
    			}
    		};

    		app$1.f7routers.modals = routerData;
    	});

    	afterUpdate(() => {
    		if (!routerData) return;
    		app$1.f7events.emit('modalsRouterDidUpdate', routerData);
    	});

    	onDestroy(() => {
    		if (!routerData) return;
    		app$1.f7routers.modals = null;
    		routerData = null;
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Routable_modals> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(1, el);
    		});
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		afterUpdate,
    		tick,
    		app: app$1,
    		modals,
    		el,
    		routerData
    	});

    	$$self.$inject_state = $$props => {
    		if ('modals' in $$props) $$invalidate(0, modals = $$props.modals);
    		if ('el' in $$props) $$invalidate(1, el = $$props.el);
    		if ('routerData' in $$props) routerData = $$props.routerData;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [modals, el, div_binding];
    }

    class Routable_modals extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Routable_modals",
    			options,
    			id: create_fragment$z.name
    		});
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/app.svelte generated by Svelte v3.44.0 */
    const file$u = "node_modules/framework7-svelte/esm/svelte/app.svelte";

    function create_fragment$y(ctx) {
    	let div;
    	let t;
    	let routablemodals;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	routablemodals = new Routable_modals({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			t = space();
    			create_component(routablemodals.$$.fragment);
    			attr_dev(div, "class", /*classes*/ ctx[1]);
    			add_location(div, file$u, 32, 0, 843);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t);
    			mount_component(routablemodals, div, null);
    			/*div_binding*/ ctx[5](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*classes*/ 2) {
    				attr_dev(div, "class", /*classes*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(routablemodals.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(routablemodals.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			destroy_component(routablemodals);
    			/*div_binding*/ ctx[5](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let classes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let el;

    	if (!app$1.f7 || typeof window === 'undefined') {
    		f7init(el, noUndefinedProps($$props), false);
    	}

    	onMount(() => {
    		const parentEl = el.parentNode;

    		if (parentEl && parentEl !== document.body && parentEl.parentNode === document.body) {
    			parentEl.style.height = '100%';
    		}

    		if (app$1.f7) {
    			app$1.f7.init(el);
    			return;
    		}

    		f7init(el, noUndefinedProps($$props), true);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(0, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		app: app$1,
    		f7init,
    		colorClasses,
    		classNames,
    		noUndefinedProps,
    		RoutableModals: Routable_modals,
    		className,
    		el,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(1, classes = classNames(className, 'framework7-root', colorClasses($$props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [el, classes, className, $$scope, slots, div_binding];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$y, safe_not_equal, { class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get class() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var useTooltip = function useTooltip(el, props) {
      var f7Tooltip = null;
      var tooltip = props.tooltip,
          tooltipTrigger = props.tooltipTrigger;

      if (el && tooltip) {
        f7ready(function () {
          f7Tooltip = app$1.f7.tooltip.create({
            targetEl: el,
            text: tooltip,
            trigger: tooltipTrigger
          });
        });
      }

      return {
        update: function update(_temp) {
          var _ref = _temp === void 0 ? {} : _temp,
              value = _ref.tooltip;

          if (!value && f7Tooltip) {
            f7Tooltip.destroy();
            f7Tooltip = null;
            return;
          }

          if (value && !f7Tooltip && app$1.f7) {
            f7Tooltip = app$1.f7.tooltip.create({
              targetEl: el,
              text: value,
              trigger: tooltipTrigger
            });
            return;
          }

          if (!value || !f7Tooltip) return;
          f7Tooltip.setText(value);
        },
        destroy: function destroy() {
          if (f7Tooltip && f7Tooltip.destroy) {
            f7Tooltip.destroy();
            f7Tooltip = null;
          }
        }
      };
    };

    /* node_modules/framework7-svelte/esm/svelte/badge.svelte generated by Svelte v3.44.0 */
    const file$t = "node_modules/framework7-svelte/esm/svelte/badge.svelte";

    function create_fragment$x(ctx) {
    	let span;
    	let useTooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	let span_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			set_attributes(span, span_data);
    			add_location(span, file$t, 15, 0, 435);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(useTooltip_action = useTooltip.call(null, span, {
    					tooltip: /*tooltip*/ ctx[0],
    					tooltipTrigger: /*tooltipTrigger*/ ctx[1]
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
    				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
    			]));

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 3) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[0],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[1]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","tooltip","tooltipTrigger"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Badge', slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { tooltipTrigger = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ('tooltip' in $$new_props) $$invalidate(0, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$new_props) $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		colorClasses,
    		classNames,
    		restProps,
    		useTooltip,
    		className,
    		tooltip,
    		tooltipTrigger,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(4, className = $$new_props.className);
    		if ('tooltip' in $$props) $$invalidate(0, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$props) $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('classes' in $$props) $$invalidate(2, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(2, classes = classNames(className, 'badge', colorClasses($$props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [tooltip, tooltipTrigger, classes, $$restProps, className, $$scope, slots];
    }

    class Badge extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$x, safe_not_equal, { class: 4, tooltip: 0, tooltipTrigger: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Badge",
    			options,
    			id: create_fragment$x.name
    		});
    	}

    	get class() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipTrigger() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipTrigger(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/block-title.svelte generated by Svelte v3.44.0 */
    const file$s = "node_modules/framework7-svelte/esm/svelte/block-title.svelte";

    function create_fragment$w(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$s, 22, 0, 469);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
    				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["large","medium","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Block_title', slots, ['default']);
    	let { large = false } = $$props;
    	let { medium = false } = $$props;
    	let { class: className = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('large' in $$new_props) $$invalidate(2, large = $$new_props.large);
    		if ('medium' in $$new_props) $$invalidate(3, medium = $$new_props.medium);
    		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		colorClasses,
    		classNames,
    		restProps,
    		large,
    		medium,
    		className,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    		if ('large' in $$props) $$invalidate(2, large = $$new_props.large);
    		if ('medium' in $$props) $$invalidate(3, medium = $$new_props.medium);
    		if ('className' in $$props) $$invalidate(4, className = $$new_props.className);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(0, classes = classNames(
    			className,
    			'block-title',
    			{
    				'block-title-large': large,
    				'block-title-medium': medium
    			},
    			colorClasses($$props)
    		));
    	};

    	$$props = exclude_internal_props($$props);
    	return [classes, $$restProps, large, medium, className, $$scope, slots];
    }

    class Block_title extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$w, safe_not_equal, { large: 2, medium: 3, class: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Block_title",
    			options,
    			id: create_fragment$w.name
    		});
    	}

    	get large() {
    		throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set large(value) {
    		throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get medium() {
    		throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set medium(value) {
    		throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // eslint-disable-next-line
    var useTab = function useTab(getEl, emit) {
      var onTabShow = function onTabShow(el) {
        if (getEl() !== el) return;
        emit('tabShow', [el]);
      };

      var onTabHide = function onTabHide(el) {
        if (getEl() !== el) return;
        emit('tabHide', [el]);
      };

      var attachEvents = function attachEvents() {
        if (!getEl()) return;
        f7ready(function () {
          f7.on('tabShow', onTabShow);
          f7.on('tabHide', onTabHide);
        });
      };

      var detachEvents = function detachEvents() {
        if (!f7) return;
        f7.off('tabShow', onTabShow);
        f7.off('tabHide', onTabHide);
      };

      onMount(function () {
        attachEvents();
      });
      onDestroy(function () {
        detachEvents();
      });
    };

    /* node_modules/framework7-svelte/esm/svelte/block.svelte generated by Svelte v3.44.0 */
    const file$r = "node_modules/framework7-svelte/esm/svelte/block.svelte";

    function create_fragment$v(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[21].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
    	let div_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$r, 58, 0, 1600);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[22](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[20],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
    				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[22](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"inset","xsmallInset","smallInset","mediumInset","largeInset","xlargeInset","strong","tabs","tab","tabActive","accordionList","accordionOpposite","noHairlines","noHairlinesMd","noHairlinesIos","noHairlinesAurora","class"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Block', slots, ['default']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { inset = false } = $$props;
    	let { xsmallInset = false } = $$props;
    	let { smallInset = false } = $$props;
    	let { mediumInset = false } = $$props;
    	let { largeInset = false } = $$props;
    	let { xlargeInset = false } = $$props;
    	let { strong = false } = $$props;
    	let { tabs = false } = $$props;
    	let { tab = false } = $$props;
    	let { tabActive = false } = $$props;
    	let { accordionList = false } = $$props;
    	let { accordionOpposite = false } = $$props;
    	let { noHairlines = false } = $$props;
    	let { noHairlinesMd = false } = $$props;
    	let { noHairlinesIos = false } = $$props;
    	let { noHairlinesAurora = false } = $$props;
    	let { class: className = undefined } = $$props;
    	let el;
    	useTab(() => el, emit);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(0, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('inset' in $$new_props) $$invalidate(3, inset = $$new_props.inset);
    		if ('xsmallInset' in $$new_props) $$invalidate(4, xsmallInset = $$new_props.xsmallInset);
    		if ('smallInset' in $$new_props) $$invalidate(5, smallInset = $$new_props.smallInset);
    		if ('mediumInset' in $$new_props) $$invalidate(6, mediumInset = $$new_props.mediumInset);
    		if ('largeInset' in $$new_props) $$invalidate(7, largeInset = $$new_props.largeInset);
    		if ('xlargeInset' in $$new_props) $$invalidate(8, xlargeInset = $$new_props.xlargeInset);
    		if ('strong' in $$new_props) $$invalidate(9, strong = $$new_props.strong);
    		if ('tabs' in $$new_props) $$invalidate(10, tabs = $$new_props.tabs);
    		if ('tab' in $$new_props) $$invalidate(11, tab = $$new_props.tab);
    		if ('tabActive' in $$new_props) $$invalidate(12, tabActive = $$new_props.tabActive);
    		if ('accordionList' in $$new_props) $$invalidate(13, accordionList = $$new_props.accordionList);
    		if ('accordionOpposite' in $$new_props) $$invalidate(14, accordionOpposite = $$new_props.accordionOpposite);
    		if ('noHairlines' in $$new_props) $$invalidate(15, noHairlines = $$new_props.noHairlines);
    		if ('noHairlinesMd' in $$new_props) $$invalidate(16, noHairlinesMd = $$new_props.noHairlinesMd);
    		if ('noHairlinesIos' in $$new_props) $$invalidate(17, noHairlinesIos = $$new_props.noHairlinesIos);
    		if ('noHairlinesAurora' in $$new_props) $$invalidate(18, noHairlinesAurora = $$new_props.noHairlinesAurora);
    		if ('class' in $$new_props) $$invalidate(19, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		colorClasses,
    		classNames,
    		createEmitter,
    		restProps,
    		useTab,
    		emit,
    		inset,
    		xsmallInset,
    		smallInset,
    		mediumInset,
    		largeInset,
    		xlargeInset,
    		strong,
    		tabs,
    		tab,
    		tabActive,
    		accordionList,
    		accordionOpposite,
    		noHairlines,
    		noHairlinesMd,
    		noHairlinesIos,
    		noHairlinesAurora,
    		className,
    		el,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    		if ('inset' in $$props) $$invalidate(3, inset = $$new_props.inset);
    		if ('xsmallInset' in $$props) $$invalidate(4, xsmallInset = $$new_props.xsmallInset);
    		if ('smallInset' in $$props) $$invalidate(5, smallInset = $$new_props.smallInset);
    		if ('mediumInset' in $$props) $$invalidate(6, mediumInset = $$new_props.mediumInset);
    		if ('largeInset' in $$props) $$invalidate(7, largeInset = $$new_props.largeInset);
    		if ('xlargeInset' in $$props) $$invalidate(8, xlargeInset = $$new_props.xlargeInset);
    		if ('strong' in $$props) $$invalidate(9, strong = $$new_props.strong);
    		if ('tabs' in $$props) $$invalidate(10, tabs = $$new_props.tabs);
    		if ('tab' in $$props) $$invalidate(11, tab = $$new_props.tab);
    		if ('tabActive' in $$props) $$invalidate(12, tabActive = $$new_props.tabActive);
    		if ('accordionList' in $$props) $$invalidate(13, accordionList = $$new_props.accordionList);
    		if ('accordionOpposite' in $$props) $$invalidate(14, accordionOpposite = $$new_props.accordionOpposite);
    		if ('noHairlines' in $$props) $$invalidate(15, noHairlines = $$new_props.noHairlines);
    		if ('noHairlinesMd' in $$props) $$invalidate(16, noHairlinesMd = $$new_props.noHairlinesMd);
    		if ('noHairlinesIos' in $$props) $$invalidate(17, noHairlinesIos = $$new_props.noHairlinesIos);
    		if ('noHairlinesAurora' in $$props) $$invalidate(18, noHairlinesAurora = $$new_props.noHairlinesAurora);
    		if ('className' in $$props) $$invalidate(19, className = $$new_props.className);
    		if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(1, classes = classNames(
    			className,
    			'block',
    			{
    				inset,
    				'xsmall-inset': xsmallInset,
    				'small-inset': smallInset,
    				'medium-inset': mediumInset,
    				'large-inset': largeInset,
    				'xlarge-inset': xlargeInset,
    				'block-strong': strong,
    				'accordion-list': accordionList,
    				'accordion-opposite': accordionOpposite,
    				tabs,
    				tab,
    				'tab-active': tabActive,
    				'no-hairlines': noHairlines,
    				'no-hairlines-md': noHairlinesMd,
    				'no-hairlines-ios': noHairlinesIos,
    				'no-hairlines-aurora': noHairlinesAurora
    			},
    			colorClasses($$props)
    		));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		el,
    		classes,
    		$$restProps,
    		inset,
    		xsmallInset,
    		smallInset,
    		mediumInset,
    		largeInset,
    		xlargeInset,
    		strong,
    		tabs,
    		tab,
    		tabActive,
    		accordionList,
    		accordionOpposite,
    		noHairlines,
    		noHairlinesMd,
    		noHairlinesIos,
    		noHairlinesAurora,
    		className,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class Block extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$s, create_fragment$v, safe_not_equal, {
    			inset: 3,
    			xsmallInset: 4,
    			smallInset: 5,
    			mediumInset: 6,
    			largeInset: 7,
    			xlargeInset: 8,
    			strong: 9,
    			tabs: 10,
    			tab: 11,
    			tabActive: 12,
    			accordionList: 13,
    			accordionOpposite: 14,
    			noHairlines: 15,
    			noHairlinesMd: 16,
    			noHairlinesIos: 17,
    			noHairlinesAurora: 18,
    			class: 19
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Block",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get inset() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inset(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xsmallInset() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xsmallInset(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smallInset() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smallInset(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mediumInset() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mediumInset(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get largeInset() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set largeInset(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xlargeInset() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xlargeInset(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get strong() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set strong(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabs() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabs(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tab() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tab(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabActive() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabActive(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accordionList() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accordionList(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accordionOpposite() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accordionOpposite(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlines() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlines(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesMd() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesMd(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesIos() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesIos(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesAurora() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesAurora(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var useRouteProps = function useRouteProps(el, routeProps) {
      if (el && routeProps) {
        el.f7RouteProps = routeProps;
      }

      return {
        update: function update(newValue) {
          if (el && el.f7RouteProps && !newValue) delete el.f7RouteProps;else if (el && newValue) el.f7RouteProps = newValue;
        },
        destroy: function destroy() {
          if (el && routeProps) {
            delete el.f7RouteProps;
          }
        }
      };
    };

    var useIcon = function useIcon(props) {
      if (props === void 0) {
        props = {};
      }

      var _props = props,
          icon = _props.icon,
          iconMaterial = _props.iconMaterial,
          iconF7 = _props.iconF7,
          iconMd = _props.iconMd,
          iconIos = _props.iconIos,
          iconAurora = _props.iconAurora,
          iconColor = _props.iconColor,
          iconSize = _props.iconSize,
          iconBadge = _props.iconBadge,
          badgeColor = _props.badgeColor,
          iconBadgeColor = _props.iconBadgeColor;

      if (icon || iconMaterial || iconF7 || iconMd || iconIos || iconAurora) {
        return {
          props: {
            material: iconMaterial,
            f7: iconF7,
            icon: icon,
            md: iconMd,
            ios: iconIos,
            aurora: iconAurora,
            color: iconColor,
            size: iconSize
          },
          badge: iconBadge || iconBadge === 0 ? {
            props: {
              color: badgeColor || iconBadgeColor
            },
            content: iconBadge
          } : null
        };
      }

      return null;
    };

    var useTheme = function useTheme(set) {
      var t = app$1.f7 ? app$1.theme : null;

      if (!app$1.f7) {
        f7ready(function () {
          set(app$1.theme);
        });
      }

      return t;
    };

    /* node_modules/framework7-svelte/esm/svelte/icon.svelte generated by Svelte v3.44.0 */
    const file$q = "node_modules/framework7-svelte/esm/svelte/icon.svelte";

    function create_fragment$u(ctx) {
    	let i;
    	let t0_value = (/*iconText*/ ctx[4] || '') + "";
    	let t0;
    	let t1;
    	let useTooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[21].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

    	let i_levels = [
    		{ style: /*iconStyle*/ ctx[3] },
    		{ class: /*iconClasses*/ ctx[5] },
    		restProps(/*$$restProps*/ ctx[6])
    	];

    	let i_data = {};

    	for (let i = 0; i < i_levels.length; i += 1) {
    		i_data = assign(i_data, i_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			i = element("i");
    			t0 = text(t0_value);
    			t1 = space();
    			if (default_slot) default_slot.c();
    			set_attributes(i, i_data);
    			add_location(i, file$q, 89, 0, 2329);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    			append_dev(i, t0);
    			append_dev(i, t1);

    			if (default_slot) {
    				default_slot.m(i, null);
    			}

    			/*i_binding*/ ctx[22](i);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(useTooltip_action = useTooltip.call(null, i, {
    					tooltip: /*tooltip*/ ctx[0],
    					tooltipTrigger: /*tooltipTrigger*/ ctx[1]
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*iconText*/ 16) && t0_value !== (t0_value = (/*iconText*/ ctx[4] || '') + "")) set_data_dev(t0, t0_value);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[20],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(i, i_data = get_spread_update(i_levels, [
    				(!current || dirty & /*iconStyle*/ 8) && { style: /*iconStyle*/ ctx[3] },
    				(!current || dirty & /*iconClasses*/ 32) && { class: /*iconClasses*/ ctx[5] },
    				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
    			]));

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 3) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[0],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[1]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			if (default_slot) default_slot.d(detaching);
    			/*i_binding*/ ctx[22](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let iconClasses;
    	let iconText;
    	let iconSize;
    	let iconStyle;

    	const omit_props_names = [
    		"style","class","material","f7","icon","ios","aurora","md","tooltip","tooltipTrigger","size"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Icon', slots, ['default']);
    	let { style = undefined } = $$props;
    	let { class: className = undefined } = $$props;
    	let { material = undefined } = $$props;
    	let { f7 = undefined } = $$props;
    	let { icon = undefined } = $$props;
    	let { ios = undefined } = $$props;
    	let { aurora = undefined } = $$props;
    	let { md = undefined } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { tooltipTrigger = undefined } = $$props;
    	let { size = undefined } = $$props;
    	let el;

    	let theme = useTheme(t => {
    		$$invalidate(16, theme = t);
    	});

    	let classes = { icon: true };
    	let themeIcon;

    	function iconTextComputed(t) {
    		let textComputed = material || f7;

    		if (md && t && t.md && (md.indexOf('material:') >= 0 || md.indexOf('f7:') >= 0)) {
    			textComputed = md.split(':')[1];
    		} else if (ios && t && t.ios && (ios.indexOf('material:') >= 0 || ios.indexOf('f7:') >= 0)) {
    			textComputed = ios.split(':')[1];
    		} else if (aurora && t && t.aurora && (aurora.indexOf('material:') >= 0 || aurora.indexOf('f7:') >= 0)) {
    			textComputed = aurora.split(':')[1];
    		}

    		return textComputed;
    	}

    	function i_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(2, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('style' in $$new_props) $$invalidate(7, style = $$new_props.style);
    		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
    		if ('material' in $$new_props) $$invalidate(9, material = $$new_props.material);
    		if ('f7' in $$new_props) $$invalidate(10, f7 = $$new_props.f7);
    		if ('icon' in $$new_props) $$invalidate(11, icon = $$new_props.icon);
    		if ('ios' in $$new_props) $$invalidate(12, ios = $$new_props.ios);
    		if ('aurora' in $$new_props) $$invalidate(13, aurora = $$new_props.aurora);
    		if ('md' in $$new_props) $$invalidate(14, md = $$new_props.md);
    		if ('tooltip' in $$new_props) $$invalidate(0, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$new_props) $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('size' in $$new_props) $$invalidate(15, size = $$new_props.size);
    		if ('$$scope' in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		colorClasses,
    		classNames,
    		restProps,
    		useTooltip,
    		useTheme,
    		style,
    		className,
    		material,
    		f7,
    		icon,
    		ios,
    		aurora,
    		md,
    		tooltip,
    		tooltipTrigger,
    		size,
    		el,
    		theme,
    		classes,
    		themeIcon,
    		iconTextComputed,
    		iconSize,
    		iconStyle,
    		iconText,
    		iconClasses
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    		if ('style' in $$props) $$invalidate(7, style = $$new_props.style);
    		if ('className' in $$props) $$invalidate(8, className = $$new_props.className);
    		if ('material' in $$props) $$invalidate(9, material = $$new_props.material);
    		if ('f7' in $$props) $$invalidate(10, f7 = $$new_props.f7);
    		if ('icon' in $$props) $$invalidate(11, icon = $$new_props.icon);
    		if ('ios' in $$props) $$invalidate(12, ios = $$new_props.ios);
    		if ('aurora' in $$props) $$invalidate(13, aurora = $$new_props.aurora);
    		if ('md' in $$props) $$invalidate(14, md = $$new_props.md);
    		if ('tooltip' in $$props) $$invalidate(0, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$props) $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('size' in $$props) $$invalidate(15, size = $$new_props.size);
    		if ('el' in $$props) $$invalidate(2, el = $$new_props.el);
    		if ('theme' in $$props) $$invalidate(16, theme = $$new_props.theme);
    		if ('classes' in $$props) $$invalidate(17, classes = $$new_props.classes);
    		if ('themeIcon' in $$props) $$invalidate(18, themeIcon = $$new_props.themeIcon);
    		if ('iconSize' in $$props) $$invalidate(19, iconSize = $$new_props.iconSize);
    		if ('iconStyle' in $$props) $$invalidate(3, iconStyle = $$new_props.iconStyle);
    		if ('iconText' in $$props) $$invalidate(4, iconText = $$new_props.iconText);
    		if ('iconClasses' in $$props) $$invalidate(5, iconClasses = $$new_props.iconClasses);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*theme, ios, md, aurora*/ 94208) {
    			if (theme) {
    				if (theme.ios) $$invalidate(18, themeIcon = ios);
    				if (theme.md) $$invalidate(18, themeIcon = md);
    				if (theme.aurora) $$invalidate(18, themeIcon = aurora);
    			}
    		}

    		if ($$self.$$.dirty & /*themeIcon, material, f7, icon*/ 265728) {
    			if (themeIcon) {
    				const parts = themeIcon.split(':');
    				const prop = parts[0];
    				const value = parts[1];

    				if (prop === 'material' || prop === 'f7') {
    					$$invalidate(17, classes['material-icons'] = prop === 'material', classes);
    					$$invalidate(17, classes['f7-icons'] = prop === 'f7', classes);
    				}

    				if (prop === 'icon') {
    					$$invalidate(17, classes[value] = true, classes);
    				}
    			} else {
    				$$invalidate(17, classes = {
    					icon: true,
    					'material-icons': material,
    					'f7-icons': f7
    				});

    				if (icon) $$invalidate(17, classes[icon] = true, classes);
    			}
    		}

    		$$invalidate(5, iconClasses = classNames(className, classes, colorClasses($$props)));

    		if ($$self.$$.dirty & /*theme*/ 65536) {
    			$$invalidate(4, iconText = iconTextComputed(theme));
    		}

    		if ($$self.$$.dirty & /*size*/ 32768) {
    			$$invalidate(19, iconSize = typeof size === 'number' || parseFloat(size) === size * 1
    			? `${size}px`
    			: size);
    		}

    		if ($$self.$$.dirty & /*style, iconSize*/ 524416) {
    			$$invalidate(3, iconStyle = (style || '') + (iconSize
    			? `;font-size: ${iconSize}; width: ${iconSize}; height: ${iconSize}`.replace(';;', '')
    			: ''));
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		tooltip,
    		tooltipTrigger,
    		el,
    		iconStyle,
    		iconText,
    		iconClasses,
    		$$restProps,
    		style,
    		className,
    		material,
    		f7,
    		icon,
    		ios,
    		aurora,
    		md,
    		size,
    		theme,
    		classes,
    		themeIcon,
    		iconSize,
    		$$scope,
    		slots,
    		i_binding
    	];
    }

    class Icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$r, create_fragment$u, safe_not_equal, {
    			style: 7,
    			class: 8,
    			material: 9,
    			f7: 10,
    			icon: 11,
    			ios: 12,
    			aurora: 13,
    			md: 14,
    			tooltip: 0,
    			tooltipTrigger: 1,
    			size: 15
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get style() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get material() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set material(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get f7() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set f7(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ios() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ios(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get aurora() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set aurora(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get md() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set md(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipTrigger() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipTrigger(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/use-icon.svelte generated by Svelte v3.44.0 */

    // (9:2) {#if icon.badge}
    function create_if_block$g(ctx) {
    	let badge;
    	let current;
    	const badge_spread_levels = [/*icon*/ ctx[0].badge.props];

    	let badge_props = {
    		$$slots: { default: [create_default_slot_1$7] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < badge_spread_levels.length; i += 1) {
    		badge_props = assign(badge_props, badge_spread_levels[i]);
    	}

    	badge = new Badge({ props: badge_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(badge.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_changes = (dirty & /*icon*/ 1)
    			? get_spread_update(badge_spread_levels, [get_spread_object(/*icon*/ ctx[0].badge.props)])
    			: {};

    			if (dirty & /*$$scope, icon*/ 3) {
    				badge_changes.$$scope = { dirty, ctx };
    			}

    			badge.$set(badge_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(9:2) {#if icon.badge}",
    		ctx
    	});

    	return block;
    }

    // (10:4) <Badge {...icon.badge.props}>
    function create_default_slot_1$7(ctx) {
    	let t_value = /*icon*/ ctx[0].badge.content + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*icon*/ 1 && t_value !== (t_value = /*icon*/ ctx[0].badge.content + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(10:4) <Badge {...icon.badge.props}>",
    		ctx
    	});

    	return block;
    }

    // (8:0) <Icon {...icon.props}>
    function create_default_slot$b(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*icon*/ ctx[0].badge && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[0].badge) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*icon*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$g(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(8:0) <Icon {...icon.props}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let icon_1;
    	let current;
    	const icon_1_spread_levels = [/*icon*/ ctx[0].props];

    	let icon_1_props = {
    		$$slots: { default: [create_default_slot$b] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < icon_1_spread_levels.length; i += 1) {
    		icon_1_props = assign(icon_1_props, icon_1_spread_levels[i]);
    	}

    	icon_1 = new Icon({ props: icon_1_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(icon_1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const icon_1_changes = (dirty & /*icon*/ 1)
    			? get_spread_update(icon_1_spread_levels, [get_spread_object(/*icon*/ ctx[0].props)])
    			: {};

    			if (dirty & /*$$scope, icon*/ 3) {
    				icon_1_changes.$$scope = { dirty, ctx };
    			}

    			icon_1.$set(icon_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use_icon', slots, []);
    	let { icon = undefined } = $$props;
    	const writable_props = ['icon'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use_icon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('icon' in $$props) $$invalidate(0, icon = $$props.icon);
    	};

    	$$self.$capture_state = () => ({ Icon, Badge, icon });

    	$$self.$inject_state = $$props => {
    		if ('icon' in $$props) $$invalidate(0, icon = $$props.icon);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [icon];
    }

    class Use_icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$t, safe_not_equal, { icon: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use_icon",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get icon() {
    		throw new Error("<Use_icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Use_icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/preloader.svelte generated by Svelte v3.44.0 */
    const file$p = "node_modules/framework7-svelte/esm/svelte/preloader.svelte";

    // (50:2) {:else}
    function create_else_block$6(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "preloader-inner");
    			add_location(span, file$p, 49, 9, 1589);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(50:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (48:34) 
    function create_if_block_2$a(ctx) {
    	let span1;
    	let span0;

    	const block = {
    		c: function create() {
    			span1 = element("span");
    			span0 = element("span");
    			attr_dev(span0, "class", "preloader-inner-circle");
    			add_location(span0, file$p, 48, 35, 1532);
    			attr_dev(span1, "class", "preloader-inner");
    			add_location(span1, file$p, 48, 4, 1501);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span1, anchor);
    			append_dev(span1, span0);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(48:34) ",
    		ctx
    	});

    	return block;
    }

    // (37:31) 
    function create_if_block_1$b(ctx) {
    	let span8;
    	let span0;
    	let t0;
    	let span1;
    	let t1;
    	let span2;
    	let t2;
    	let span3;
    	let t3;
    	let span4;
    	let t4;
    	let span5;
    	let t5;
    	let span6;
    	let t6;
    	let span7;

    	const block = {
    		c: function create() {
    			span8 = element("span");
    			span0 = element("span");
    			t0 = space();
    			span1 = element("span");
    			t1 = space();
    			span2 = element("span");
    			t2 = space();
    			span3 = element("span");
    			t3 = space();
    			span4 = element("span");
    			t4 = space();
    			span5 = element("span");
    			t5 = space();
    			span6 = element("span");
    			t6 = space();
    			span7 = element("span");
    			attr_dev(span0, "class", "preloader-inner-line");
    			add_location(span0, file$p, 38, 6, 1104);
    			attr_dev(span1, "class", "preloader-inner-line");
    			add_location(span1, file$p, 39, 6, 1148);
    			attr_dev(span2, "class", "preloader-inner-line");
    			add_location(span2, file$p, 40, 6, 1192);
    			attr_dev(span3, "class", "preloader-inner-line");
    			add_location(span3, file$p, 41, 6, 1236);
    			attr_dev(span4, "class", "preloader-inner-line");
    			add_location(span4, file$p, 42, 6, 1280);
    			attr_dev(span5, "class", "preloader-inner-line");
    			add_location(span5, file$p, 43, 6, 1324);
    			attr_dev(span6, "class", "preloader-inner-line");
    			add_location(span6, file$p, 44, 6, 1368);
    			attr_dev(span7, "class", "preloader-inner-line");
    			add_location(span7, file$p, 45, 6, 1412);
    			attr_dev(span8, "class", "preloader-inner");
    			add_location(span8, file$p, 37, 4, 1067);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span8, anchor);
    			append_dev(span8, span0);
    			append_dev(span8, t0);
    			append_dev(span8, span1);
    			append_dev(span8, t1);
    			append_dev(span8, span2);
    			append_dev(span8, t2);
    			append_dev(span8, span3);
    			append_dev(span8, t3);
    			append_dev(span8, span4);
    			append_dev(span8, t4);
    			append_dev(span8, span5);
    			append_dev(span8, t5);
    			append_dev(span8, span6);
    			append_dev(span8, t6);
    			append_dev(span8, span7);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span8);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(37:31) ",
    		ctx
    	});

    	return block;
    }

    // (31:2) {#if theme && theme.md}
    function create_if_block$f(ctx) {
    	let span;
    	let svg;
    	let circle;

    	const block = {
    		c: function create() {
    			span = element("span");
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			attr_dev(circle, "cx", "18");
    			attr_dev(circle, "cy", "18");
    			attr_dev(circle, "r", "16");
    			add_location(circle, file$p, 33, 8, 972);
    			attr_dev(svg, "viewBox", "0 0 36 36");
    			add_location(svg, file$p, 32, 6, 938);
    			attr_dev(span, "class", "preloader-inner");
    			add_location(span, file$p, 31, 4, 901);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, svg);
    			append_dev(svg, circle);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(31:2) {#if theme && theme.md}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let span;

    	function select_block_type(ctx, dirty) {
    		if (/*theme*/ ctx[0] && /*theme*/ ctx[0].md) return create_if_block$f;
    		if (/*theme*/ ctx[0] && /*theme*/ ctx[0].ios) return create_if_block_1$b;
    		if (/*theme*/ ctx[0] && /*theme*/ ctx[0].aurora) return create_if_block_2$a;
    		return create_else_block$6;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	let span_levels = [
    		{ style: /*preloaderStyle*/ ctx[2] },
    		{ class: /*classes*/ ctx[1] },
    		restProps(/*$$restProps*/ ctx[3])
    	];

    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block.c();
    			set_attributes(span, span_data);
    			add_location(span, file$p, 29, 0, 797);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if_block.m(span, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span, null);
    				}
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				dirty & /*preloaderStyle*/ 4 && { style: /*preloaderStyle*/ ctx[2] },
    				dirty & /*classes*/ 2 && { class: /*classes*/ ctx[1] },
    				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let sizeComputed;
    	let preloaderStyle;
    	let classes;
    	const omit_props_names = ["style","class","size"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Preloader', slots, []);
    	let { style = undefined } = $$props;
    	let { class: className = undefined } = $$props;
    	let { size = undefined } = $$props;

    	let theme = useTheme(t => {
    		$$invalidate(0, theme = t);
    	});

    	$$self.$$set = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('style' in $$new_props) $$invalidate(4, style = $$new_props.style);
    		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
    		if ('size' in $$new_props) $$invalidate(6, size = $$new_props.size);
    	};

    	$$self.$capture_state = () => ({
    		restProps,
    		colorClasses,
    		classNames,
    		useTheme,
    		style,
    		className,
    		size,
    		theme,
    		classes,
    		sizeComputed,
    		preloaderStyle
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    		if ('style' in $$props) $$invalidate(4, style = $$new_props.style);
    		if ('className' in $$props) $$invalidate(5, className = $$new_props.className);
    		if ('size' in $$props) $$invalidate(6, size = $$new_props.size);
    		if ('theme' in $$props) $$invalidate(0, theme = $$new_props.theme);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    		if ('sizeComputed' in $$props) $$invalidate(7, sizeComputed = $$new_props.sizeComputed);
    		if ('preloaderStyle' in $$props) $$invalidate(2, preloaderStyle = $$new_props.preloaderStyle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*size*/ 64) {
    			$$invalidate(7, sizeComputed = size && typeof size === 'string' && size.indexOf('px') >= 0
    			? size.replace('px', '')
    			: size);
    		}

    		if ($$self.$$.dirty & /*style, sizeComputed*/ 144) {
    			$$invalidate(2, preloaderStyle = ((style || '') + (sizeComputed
    			? `;width: ${sizeComputed}px; height: ${sizeComputed}px; --f7-preloader-size: ${sizeComputed}px`
    			: '')).replace(';;', ';'));
    		}

    		$$invalidate(1, classes = classNames(className, 'preloader', colorClasses($$props)));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		theme,
    		classes,
    		preloaderStyle,
    		$$restProps,
    		style,
    		className,
    		size,
    		sizeComputed
    	];
    }

    class Preloader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$s, safe_not_equal, { style: 4, class: 5, size: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Preloader",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get style() {
    		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/button.svelte generated by Svelte v3.44.0 */
    const file$o = "node_modules/framework7-svelte/esm/svelte/button.svelte";

    // (163:0) {:else}
    function create_else_block_1$3(ctx) {
    	let a;
    	let current_block_type_index;
    	let if_block;
    	let useRouteProps_action;
    	let useTooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_6$2, create_else_block_2$3];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*preloader*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let a_levels = [{ class: /*classes*/ ctx[10] }, /*attrs*/ ctx[11]];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if_block.c();
    			set_attributes(a, a_data);
    			add_location(a, file$o, 163, 2, 4437);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if_blocks[current_block_type_index].m(a, null);
    			/*a_binding*/ ctx[50](a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[3])),
    					listen_dev(a, "click", /*onClick*/ ctx[12], false, false, false),
    					action_destroyer(useTooltip_action = useTooltip.call(null, a, {
    						tooltip: /*tooltip*/ ctx[1],
    						tooltipTrigger: /*tooltipTrigger*/ ctx[2]
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(a, null);
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty[0] & /*classes*/ 1024) && { class: /*classes*/ ctx[10] },
    				dirty[0] & /*attrs*/ 2048 && /*attrs*/ ctx[11]
    			]));

    			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 8) useRouteProps_action.update.call(null, /*routeProps*/ ctx[3]);

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 6) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[1],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[2]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if_blocks[current_block_type_index].d();
    			/*a_binding*/ ctx[50](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(163:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (132:0) {#if tagName === 'button'}
    function create_if_block$e(ctx) {
    	let button;
    	let current_block_type_index;
    	let if_block;
    	let useRouteProps_action;
    	let useTooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$a, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*preloader*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let button_levels = [{ class: /*classes*/ ctx[10] }, /*attrs*/ ctx[11]];
    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			if_block.c();
    			set_attributes(button, button_data);
    			add_location(button, file$o, 132, 2, 3770);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			if_blocks[current_block_type_index].m(button, null);
    			if (button.autofocus) button.focus();
    			/*button_binding*/ ctx[49](button);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useRouteProps_action = useRouteProps.call(null, button, /*routeProps*/ ctx[3])),
    					listen_dev(button, "click", /*onClick*/ ctx[12], false, false, false),
    					action_destroyer(useTooltip_action = useTooltip.call(null, button, {
    						tooltip: /*tooltip*/ ctx[1],
    						tooltipTrigger: /*tooltipTrigger*/ ctx[2]
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(button, null);
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				(!current || dirty[0] & /*classes*/ 1024) && { class: /*classes*/ ctx[10] },
    				dirty[0] & /*attrs*/ 2048 && /*attrs*/ ctx[11]
    			]));

    			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 8) useRouteProps_action.update.call(null, /*routeProps*/ ctx[3]);

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 6) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[1],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[2]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if_blocks[current_block_type_index].d();
    			/*button_binding*/ ctx[49](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(132:0) {#if tagName === 'button'}",
    		ctx
    	});

    	return block;
    }

    // (183:4) {:else}
    function create_else_block_2$3(ctx) {
    	let t0;
    	let t1;
    	let current;
    	let if_block0 = /*icon*/ ctx[8] && create_if_block_10$2(ctx);
    	let if_block1 = typeof /*text*/ ctx[0] !== 'undefined' && create_if_block_9$2(ctx);
    	const default_slot_template = /*#slots*/ ctx[48].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[47], null);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[8]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 256) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_10$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (typeof /*text*/ ctx[0] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_9$2(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[47],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[47])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[47], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$3.name,
    		type: "else",
    		source: "(183:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (172:4) {#if preloader}
    function create_if_block_6$2(ctx) {
    	let preloader_1;
    	let t0;
    	let span;
    	let t1;
    	let t2;
    	let current;

    	preloader_1 = new Preloader({
    			props: {
    				size: /*preloaderSize*/ ctx[5],
    				color: /*preloaderColor*/ ctx[6]
    			},
    			$$inline: true
    		});

    	let if_block0 = /*icon*/ ctx[8] && create_if_block_8$2(ctx);
    	let if_block1 = typeof /*text*/ ctx[0] !== 'undefined' && create_if_block_7$2(ctx);
    	const default_slot_template = /*#slots*/ ctx[48].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[47], null);

    	const block = {
    		c: function create() {
    			create_component(preloader_1.$$.fragment);
    			t0 = space();
    			span = element("span");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (default_slot) default_slot.c();
    			add_location(span, file$o, 173, 6, 4695);
    		},
    		m: function mount(target, anchor) {
    			mount_component(preloader_1, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			if (if_block0) if_block0.m(span, null);
    			append_dev(span, t1);
    			if (if_block1) if_block1.m(span, null);
    			append_dev(span, t2);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const preloader_1_changes = {};
    			if (dirty[0] & /*preloaderSize*/ 32) preloader_1_changes.size = /*preloaderSize*/ ctx[5];
    			if (dirty[0] & /*preloaderColor*/ 64) preloader_1_changes.color = /*preloaderColor*/ ctx[6];
    			preloader_1.$set(preloader_1_changes);

    			if (/*icon*/ ctx[8]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 256) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_8$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(span, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (typeof /*text*/ ctx[0] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_7$2(ctx);
    					if_block1.c();
    					if_block1.m(span, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[47],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[47])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[47], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(preloader_1.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(preloader_1.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(preloader_1, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(172:4) {#if preloader}",
    		ctx
    	});

    	return block;
    }

    // (184:6) {#if icon}
    function create_if_block_10$2(ctx) {
    	let useicon;
    	let current;

    	useicon = new Use_icon({
    			props: { icon: /*icon*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(useicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(useicon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const useicon_changes = {};
    			if (dirty[0] & /*icon*/ 256) useicon_changes.icon = /*icon*/ ctx[8];
    			useicon.$set(useicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(useicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(useicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(useicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$2.name,
    		type: "if",
    		source: "(184:6) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (187:6) {#if typeof text !== 'undefined'}
    function create_if_block_9$2(ctx) {
    	let span;
    	let t_value = plainText(/*text*/ ctx[0]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$o, 187, 8, 5008);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*text*/ 1 && t_value !== (t_value = plainText(/*text*/ ctx[0]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$2.name,
    		type: "if",
    		source: "(187:6) {#if typeof text !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (175:8) {#if icon}
    function create_if_block_8$2(ctx) {
    	let useicon;
    	let current;

    	useicon = new Use_icon({
    			props: { icon: /*icon*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(useicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(useicon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const useicon_changes = {};
    			if (dirty[0] & /*icon*/ 256) useicon_changes.icon = /*icon*/ ctx[8];
    			useicon.$set(useicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(useicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(useicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(useicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$2.name,
    		type: "if",
    		source: "(175:8) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (178:8) {#if typeof text !== 'undefined'}
    function create_if_block_7$2(ctx) {
    	let span;
    	let t_value = plainText(/*text*/ ctx[0]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$o, 178, 10, 4816);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*text*/ 1 && t_value !== (t_value = plainText(/*text*/ ctx[0]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$2.name,
    		type: "if",
    		source: "(178:8) {#if typeof text !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (152:4) {:else}
    function create_else_block$5(ctx) {
    	let t0;
    	let t1;
    	let current;
    	let if_block0 = /*icon*/ ctx[8] && create_if_block_5$2(ctx);
    	let if_block1 = typeof /*text*/ ctx[0] !== 'undefined' && create_if_block_4$2(ctx);
    	const default_slot_template = /*#slots*/ ctx[48].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[47], null);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[8]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 256) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (typeof /*text*/ ctx[0] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4$2(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[47],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[47])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[47], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(152:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (141:4) {#if preloader}
    function create_if_block_1$a(ctx) {
    	let preloader_1;
    	let t0;
    	let span;
    	let t1;
    	let t2;
    	let current;

    	preloader_1 = new Preloader({
    			props: {
    				size: /*preloaderSize*/ ctx[5],
    				color: /*preloaderColor*/ ctx[6]
    			},
    			$$inline: true
    		});

    	let if_block0 = /*icon*/ ctx[8] && create_if_block_3$6(ctx);
    	let if_block1 = typeof /*text*/ ctx[0] !== 'undefined' && create_if_block_2$9(ctx);
    	const default_slot_template = /*#slots*/ ctx[48].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[47], null);

    	const block = {
    		c: function create() {
    			create_component(preloader_1.$$.fragment);
    			t0 = space();
    			span = element("span");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (default_slot) default_slot.c();
    			add_location(span, file$o, 142, 6, 4033);
    		},
    		m: function mount(target, anchor) {
    			mount_component(preloader_1, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			if (if_block0) if_block0.m(span, null);
    			append_dev(span, t1);
    			if (if_block1) if_block1.m(span, null);
    			append_dev(span, t2);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const preloader_1_changes = {};
    			if (dirty[0] & /*preloaderSize*/ 32) preloader_1_changes.size = /*preloaderSize*/ ctx[5];
    			if (dirty[0] & /*preloaderColor*/ 64) preloader_1_changes.color = /*preloaderColor*/ ctx[6];
    			preloader_1.$set(preloader_1_changes);

    			if (/*icon*/ ctx[8]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 256) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(span, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (typeof /*text*/ ctx[0] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$9(ctx);
    					if_block1.c();
    					if_block1.m(span, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[47],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[47])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[47], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(preloader_1.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(preloader_1.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(preloader_1, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(141:4) {#if preloader}",
    		ctx
    	});

    	return block;
    }

    // (153:6) {#if icon}
    function create_if_block_5$2(ctx) {
    	let useicon;
    	let current;

    	useicon = new Use_icon({
    			props: { icon: /*icon*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(useicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(useicon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const useicon_changes = {};
    			if (dirty[0] & /*icon*/ 256) useicon_changes.icon = /*icon*/ ctx[8];
    			useicon.$set(useicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(useicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(useicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(useicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(153:6) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (156:6) {#if typeof text !== 'undefined'}
    function create_if_block_4$2(ctx) {
    	let span;
    	let t_value = plainText(/*text*/ ctx[0]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$o, 156, 8, 4346);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*text*/ 1 && t_value !== (t_value = plainText(/*text*/ ctx[0]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(156:6) {#if typeof text !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (144:8) {#if icon}
    function create_if_block_3$6(ctx) {
    	let useicon;
    	let current;

    	useicon = new Use_icon({
    			props: { icon: /*icon*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(useicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(useicon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const useicon_changes = {};
    			if (dirty[0] & /*icon*/ 256) useicon_changes.icon = /*icon*/ ctx[8];
    			useicon.$set(useicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(useicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(useicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(useicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(144:8) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (147:8) {#if typeof text !== 'undefined'}
    function create_if_block_2$9(ctx) {
    	let span;
    	let t_value = plainText(/*text*/ ctx[0]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$o, 147, 10, 4154);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*text*/ 1 && t_value !== (t_value = plainText(/*text*/ ctx[0]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(147:8) {#if typeof text !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$e, create_else_block_1$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*tagName*/ ctx[9] === 'button') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let hrefComputed;
    	let attrs;
    	let classes;
    	let tagName;
    	let icon;

    	const omit_props_names = [
    		"class","text","tabLink","tabLinkActive","type","href","target","round","roundMd","roundIos","roundAurora","fill","fillMd","fillIos","fillAurora","large","largeMd","largeIos","largeAurora","small","smallMd","smallIos","smallAurora","raised","raisedMd","raisedIos","raisedAurora","outline","outlineMd","outlineIos","outlineAurora","active","disabled","tooltip","tooltipTrigger","routeProps","preloader","preloaderSize","preloaderColor","loading"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { text = undefined } = $$props;
    	let { tabLink = undefined } = $$props;
    	let { tabLinkActive = false } = $$props;
    	let { type = undefined } = $$props;
    	let { href = '#' } = $$props;
    	let { target = undefined } = $$props;
    	let { round = false } = $$props;
    	let { roundMd = false } = $$props;
    	let { roundIos = false } = $$props;
    	let { roundAurora = false } = $$props;
    	let { fill = false } = $$props;
    	let { fillMd = false } = $$props;
    	let { fillIos = false } = $$props;
    	let { fillAurora = false } = $$props;
    	let { large = false } = $$props;
    	let { largeMd = false } = $$props;
    	let { largeIos = false } = $$props;
    	let { largeAurora = false } = $$props;
    	let { small = false } = $$props;
    	let { smallMd = false } = $$props;
    	let { smallIos = false } = $$props;
    	let { smallAurora = false } = $$props;
    	let { raised = false } = $$props;
    	let { raisedMd = false } = $$props;
    	let { raisedIos = false } = $$props;
    	let { raisedAurora = false } = $$props;
    	let { outline = false } = $$props;
    	let { outlineMd = false } = $$props;
    	let { outlineIos = false } = $$props;
    	let { outlineAurora = false } = $$props;
    	let { active = false } = $$props;
    	let { disabled = false } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { tooltipTrigger = undefined } = $$props;
    	let { routeProps = undefined } = $$props;
    	let { preloader = false } = $$props;
    	let { preloaderSize = undefined } = $$props;
    	let { preloaderColor = undefined } = $$props;
    	let { loading = false } = $$props;
    	let el;

    	function onClick() {
    		emit('click');
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(7, el);
    		});
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(7, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(52, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(53, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(13, className = $$new_props.class);
    		if ('text' in $$new_props) $$invalidate(0, text = $$new_props.text);
    		if ('tabLink' in $$new_props) $$invalidate(14, tabLink = $$new_props.tabLink);
    		if ('tabLinkActive' in $$new_props) $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
    		if ('type' in $$new_props) $$invalidate(16, type = $$new_props.type);
    		if ('href' in $$new_props) $$invalidate(17, href = $$new_props.href);
    		if ('target' in $$new_props) $$invalidate(18, target = $$new_props.target);
    		if ('round' in $$new_props) $$invalidate(19, round = $$new_props.round);
    		if ('roundMd' in $$new_props) $$invalidate(20, roundMd = $$new_props.roundMd);
    		if ('roundIos' in $$new_props) $$invalidate(21, roundIos = $$new_props.roundIos);
    		if ('roundAurora' in $$new_props) $$invalidate(22, roundAurora = $$new_props.roundAurora);
    		if ('fill' in $$new_props) $$invalidate(23, fill = $$new_props.fill);
    		if ('fillMd' in $$new_props) $$invalidate(24, fillMd = $$new_props.fillMd);
    		if ('fillIos' in $$new_props) $$invalidate(25, fillIos = $$new_props.fillIos);
    		if ('fillAurora' in $$new_props) $$invalidate(26, fillAurora = $$new_props.fillAurora);
    		if ('large' in $$new_props) $$invalidate(27, large = $$new_props.large);
    		if ('largeMd' in $$new_props) $$invalidate(28, largeMd = $$new_props.largeMd);
    		if ('largeIos' in $$new_props) $$invalidate(29, largeIos = $$new_props.largeIos);
    		if ('largeAurora' in $$new_props) $$invalidate(30, largeAurora = $$new_props.largeAurora);
    		if ('small' in $$new_props) $$invalidate(31, small = $$new_props.small);
    		if ('smallMd' in $$new_props) $$invalidate(32, smallMd = $$new_props.smallMd);
    		if ('smallIos' in $$new_props) $$invalidate(33, smallIos = $$new_props.smallIos);
    		if ('smallAurora' in $$new_props) $$invalidate(34, smallAurora = $$new_props.smallAurora);
    		if ('raised' in $$new_props) $$invalidate(35, raised = $$new_props.raised);
    		if ('raisedMd' in $$new_props) $$invalidate(36, raisedMd = $$new_props.raisedMd);
    		if ('raisedIos' in $$new_props) $$invalidate(37, raisedIos = $$new_props.raisedIos);
    		if ('raisedAurora' in $$new_props) $$invalidate(38, raisedAurora = $$new_props.raisedAurora);
    		if ('outline' in $$new_props) $$invalidate(39, outline = $$new_props.outline);
    		if ('outlineMd' in $$new_props) $$invalidate(40, outlineMd = $$new_props.outlineMd);
    		if ('outlineIos' in $$new_props) $$invalidate(41, outlineIos = $$new_props.outlineIos);
    		if ('outlineAurora' in $$new_props) $$invalidate(42, outlineAurora = $$new_props.outlineAurora);
    		if ('active' in $$new_props) $$invalidate(43, active = $$new_props.active);
    		if ('disabled' in $$new_props) $$invalidate(44, disabled = $$new_props.disabled);
    		if ('tooltip' in $$new_props) $$invalidate(1, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$new_props) $$invalidate(2, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('routeProps' in $$new_props) $$invalidate(3, routeProps = $$new_props.routeProps);
    		if ('preloader' in $$new_props) $$invalidate(4, preloader = $$new_props.preloader);
    		if ('preloaderSize' in $$new_props) $$invalidate(5, preloaderSize = $$new_props.preloaderSize);
    		if ('preloaderColor' in $$new_props) $$invalidate(6, preloaderColor = $$new_props.preloaderColor);
    		if ('loading' in $$new_props) $$invalidate(45, loading = $$new_props.loading);
    		if ('$$scope' in $$new_props) $$invalidate(47, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		colorClasses,
    		routerAttrs,
    		routerClasses,
    		actionsAttrs,
    		actionsClasses,
    		classNames,
    		extend,
    		isStringProp,
    		plainText,
    		createEmitter,
    		restProps,
    		useTooltip,
    		useRouteProps,
    		useIcon,
    		UseIcon: Use_icon,
    		Preloader,
    		emit,
    		className,
    		text,
    		tabLink,
    		tabLinkActive,
    		type,
    		href,
    		target,
    		round,
    		roundMd,
    		roundIos,
    		roundAurora,
    		fill,
    		fillMd,
    		fillIos,
    		fillAurora,
    		large,
    		largeMd,
    		largeIos,
    		largeAurora,
    		small,
    		smallMd,
    		smallIos,
    		smallAurora,
    		raised,
    		raisedMd,
    		raisedIos,
    		raisedAurora,
    		outline,
    		outlineMd,
    		outlineIos,
    		outlineAurora,
    		active,
    		disabled,
    		tooltip,
    		tooltipTrigger,
    		routeProps,
    		preloader,
    		preloaderSize,
    		preloaderColor,
    		loading,
    		el,
    		onClick,
    		icon,
    		tagName,
    		classes,
    		hrefComputed,
    		attrs
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(52, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(13, className = $$new_props.className);
    		if ('text' in $$props) $$invalidate(0, text = $$new_props.text);
    		if ('tabLink' in $$props) $$invalidate(14, tabLink = $$new_props.tabLink);
    		if ('tabLinkActive' in $$props) $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
    		if ('type' in $$props) $$invalidate(16, type = $$new_props.type);
    		if ('href' in $$props) $$invalidate(17, href = $$new_props.href);
    		if ('target' in $$props) $$invalidate(18, target = $$new_props.target);
    		if ('round' in $$props) $$invalidate(19, round = $$new_props.round);
    		if ('roundMd' in $$props) $$invalidate(20, roundMd = $$new_props.roundMd);
    		if ('roundIos' in $$props) $$invalidate(21, roundIos = $$new_props.roundIos);
    		if ('roundAurora' in $$props) $$invalidate(22, roundAurora = $$new_props.roundAurora);
    		if ('fill' in $$props) $$invalidate(23, fill = $$new_props.fill);
    		if ('fillMd' in $$props) $$invalidate(24, fillMd = $$new_props.fillMd);
    		if ('fillIos' in $$props) $$invalidate(25, fillIos = $$new_props.fillIos);
    		if ('fillAurora' in $$props) $$invalidate(26, fillAurora = $$new_props.fillAurora);
    		if ('large' in $$props) $$invalidate(27, large = $$new_props.large);
    		if ('largeMd' in $$props) $$invalidate(28, largeMd = $$new_props.largeMd);
    		if ('largeIos' in $$props) $$invalidate(29, largeIos = $$new_props.largeIos);
    		if ('largeAurora' in $$props) $$invalidate(30, largeAurora = $$new_props.largeAurora);
    		if ('small' in $$props) $$invalidate(31, small = $$new_props.small);
    		if ('smallMd' in $$props) $$invalidate(32, smallMd = $$new_props.smallMd);
    		if ('smallIos' in $$props) $$invalidate(33, smallIos = $$new_props.smallIos);
    		if ('smallAurora' in $$props) $$invalidate(34, smallAurora = $$new_props.smallAurora);
    		if ('raised' in $$props) $$invalidate(35, raised = $$new_props.raised);
    		if ('raisedMd' in $$props) $$invalidate(36, raisedMd = $$new_props.raisedMd);
    		if ('raisedIos' in $$props) $$invalidate(37, raisedIos = $$new_props.raisedIos);
    		if ('raisedAurora' in $$props) $$invalidate(38, raisedAurora = $$new_props.raisedAurora);
    		if ('outline' in $$props) $$invalidate(39, outline = $$new_props.outline);
    		if ('outlineMd' in $$props) $$invalidate(40, outlineMd = $$new_props.outlineMd);
    		if ('outlineIos' in $$props) $$invalidate(41, outlineIos = $$new_props.outlineIos);
    		if ('outlineAurora' in $$props) $$invalidate(42, outlineAurora = $$new_props.outlineAurora);
    		if ('active' in $$props) $$invalidate(43, active = $$new_props.active);
    		if ('disabled' in $$props) $$invalidate(44, disabled = $$new_props.disabled);
    		if ('tooltip' in $$props) $$invalidate(1, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$props) $$invalidate(2, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('routeProps' in $$props) $$invalidate(3, routeProps = $$new_props.routeProps);
    		if ('preloader' in $$props) $$invalidate(4, preloader = $$new_props.preloader);
    		if ('preloaderSize' in $$props) $$invalidate(5, preloaderSize = $$new_props.preloaderSize);
    		if ('preloaderColor' in $$props) $$invalidate(6, preloaderColor = $$new_props.preloaderColor);
    		if ('loading' in $$props) $$invalidate(45, loading = $$new_props.loading);
    		if ('el' in $$props) $$invalidate(7, el = $$new_props.el);
    		if ('icon' in $$props) $$invalidate(8, icon = $$new_props.icon);
    		if ('tagName' in $$props) $$invalidate(9, tagName = $$new_props.tagName);
    		if ('classes' in $$props) $$invalidate(10, classes = $$new_props.classes);
    		if ('hrefComputed' in $$props) $$invalidate(46, hrefComputed = $$new_props.hrefComputed);
    		if ('attrs' in $$props) $$invalidate(11, attrs = $$new_props.attrs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*href*/ 131072) {
    			$$invalidate(46, hrefComputed = href === true ? '#' : href || undefined);
    		}

    		$$invalidate(11, attrs = extend(
    			{
    				href: hrefComputed,
    				target,
    				type,
    				'data-tab': isStringProp(tabLink) && tabLink || undefined,
    				...restProps($$restProps)
    			},
    			routerAttrs($$props),
    			actionsAttrs($$props)
    		));

    		$$invalidate(10, classes = classNames(
    			className,
    			'button',
    			{
    				'tab-link': tabLink || tabLink === '',
    				'tab-link-active': tabLinkActive,
    				'button-round': round,
    				'button-round-ios': roundIos,
    				'button-round-aurora': roundAurora,
    				'button-round-md': roundMd,
    				'button-fill': fill,
    				'button-fill-ios': fillIos,
    				'button-fill-aurora': fillAurora,
    				'button-fill-md': fillMd,
    				'button-large': large,
    				'button-large-ios': largeIos,
    				'button-large-aurora': largeAurora,
    				'button-large-md': largeMd,
    				'button-small': small,
    				'button-small-ios': smallIos,
    				'button-small-aurora': smallAurora,
    				'button-small-md': smallMd,
    				'button-raised': raised,
    				'button-raised-ios': raisedIos,
    				'button-raised-aurora': raisedAurora,
    				'button-raised-md': raisedMd,
    				'button-active': active,
    				'button-outline': outline,
    				'button-outline-ios': outlineIos,
    				'button-outline-aurora': outlineAurora,
    				'button-outline-md': outlineMd,
    				'button-preloader': preloader,
    				'button-loading': loading,
    				disabled
    			},
    			colorClasses($$props),
    			routerClasses($$props),
    			actionsClasses($$props)
    		));

    		if ($$self.$$.dirty[0] & /*type*/ 65536) {
    			$$invalidate(9, tagName = type === 'submit' || type === 'reset' || type === 'button'
    			? 'button'
    			: 'a');
    		}

    		$$invalidate(8, icon = useIcon($$props));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		text,
    		tooltip,
    		tooltipTrigger,
    		routeProps,
    		preloader,
    		preloaderSize,
    		preloaderColor,
    		el,
    		icon,
    		tagName,
    		classes,
    		attrs,
    		onClick,
    		className,
    		tabLink,
    		tabLinkActive,
    		type,
    		href,
    		target,
    		round,
    		roundMd,
    		roundIos,
    		roundAurora,
    		fill,
    		fillMd,
    		fillIos,
    		fillAurora,
    		large,
    		largeMd,
    		largeIos,
    		largeAurora,
    		small,
    		smallMd,
    		smallIos,
    		smallAurora,
    		raised,
    		raisedMd,
    		raisedIos,
    		raisedAurora,
    		outline,
    		outlineMd,
    		outlineIos,
    		outlineAurora,
    		active,
    		disabled,
    		loading,
    		hrefComputed,
    		$$scope,
    		slots,
    		button_binding,
    		a_binding
    	];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$o,
    			create_fragment$r,
    			safe_not_equal,
    			{
    				class: 13,
    				text: 0,
    				tabLink: 14,
    				tabLinkActive: 15,
    				type: 16,
    				href: 17,
    				target: 18,
    				round: 19,
    				roundMd: 20,
    				roundIos: 21,
    				roundAurora: 22,
    				fill: 23,
    				fillMd: 24,
    				fillIos: 25,
    				fillAurora: 26,
    				large: 27,
    				largeMd: 28,
    				largeIos: 29,
    				largeAurora: 30,
    				small: 31,
    				smallMd: 32,
    				smallIos: 33,
    				smallAurora: 34,
    				raised: 35,
    				raisedMd: 36,
    				raisedIos: 37,
    				raisedAurora: 38,
    				outline: 39,
    				outlineMd: 40,
    				outlineIos: 41,
    				outlineAurora: 42,
    				active: 43,
    				disabled: 44,
    				tooltip: 1,
    				tooltipTrigger: 2,
    				routeProps: 3,
    				preloader: 4,
    				preloaderSize: 5,
    				preloaderColor: 6,
    				loading: 45
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get class() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabLink() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabLink(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabLinkActive() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabLinkActive(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get target() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set target(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get round() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set round(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get roundMd() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set roundMd(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get roundIos() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set roundIos(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get roundAurora() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set roundAurora(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillMd() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillMd(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillIos() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillIos(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillAurora() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillAurora(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get large() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set large(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get largeMd() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set largeMd(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get largeIos() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set largeIos(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get largeAurora() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set largeAurora(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get small() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set small(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smallMd() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smallMd(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smallIos() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smallIos(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smallAurora() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smallAurora(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get raised() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set raised(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get raisedMd() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set raisedMd(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get raisedIos() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set raisedIos(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get raisedAurora() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set raisedAurora(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outline() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outline(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outlineMd() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outlineMd(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outlineIos() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outlineIos(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outlineAurora() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outlineAurora(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipTrigger() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipTrigger(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get routeProps() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routeProps(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get preloader() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set preloader(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get preloaderSize() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set preloaderSize(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get preloaderColor() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set preloaderColor(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/card-content.svelte generated by Svelte v3.44.0 */
    const file$n = "node_modules/framework7-svelte/esm/svelte/card-content.svelte";

    function create_fragment$q(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
    	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$n, 20, 0, 411);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
    				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","padding"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Card_content', slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { padding = true } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('padding' in $$new_props) $$invalidate(3, padding = $$new_props.padding);
    		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		colorClasses,
    		classNames,
    		restProps,
    		className,
    		padding,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('padding' in $$props) $$invalidate(3, padding = $$new_props.padding);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(0, classes = classNames(className, 'card-content', { 'card-content-padding': padding }, colorClasses($$props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [classes, $$restProps, className, padding, $$scope, slots];
    }

    class Card_content extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$q, safe_not_equal, { class: 2, padding: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Card_content",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get class() {
    		throw new Error("<Card_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Card_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<Card_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<Card_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/card-footer.svelte generated by Svelte v3.44.0 */
    const file$m = "node_modules/framework7-svelte/esm/svelte/card-footer.svelte";

    function create_fragment$p(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$m, 11, 0, 311);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
    				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Card_footer', slots, ['default']);
    	let { class: className = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		colorClasses,
    		classNames,
    		restProps,
    		className,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(0, classes = classNames(className, 'card-footer', colorClasses($$props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [classes, $$restProps, className, $$scope, slots];
    }

    class Card_footer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$p, safe_not_equal, { class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Card_footer",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get class() {
    		throw new Error("<Card_footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Card_footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/card-header.svelte generated by Svelte v3.44.0 */
    const file$l = "node_modules/framework7-svelte/esm/svelte/card-header.svelte";

    function create_fragment$o(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$l, 11, 0, 311);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
    				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Card_header', slots, ['default']);
    	let { class: className = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		colorClasses,
    		classNames,
    		restProps,
    		className,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(0, classes = classNames(className, 'card-header', colorClasses($$props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [classes, $$restProps, className, $$scope, slots];
    }

    class Card_header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$o, safe_not_equal, { class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Card_header",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get class() {
    		throw new Error("<Card_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Card_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/card.svelte generated by Svelte v3.44.0 */
    const file$k = "node_modules/framework7-svelte/esm/svelte/card.svelte";
    const get_footer_slot_changes$1 = dirty => ({});
    const get_footer_slot_context$1 = ctx => ({});
    const get_content_slot_changes$2 = dirty => ({});
    const get_content_slot_context$2 = ctx => ({});
    const get_header_slot_changes$1 = dirty => ({});
    const get_header_slot_context$1 = ctx => ({});

    // (151:2) {#if typeof title !== 'undefined' || hasHeaderSlots}
    function create_if_block_2$8(ctx) {
    	let cardheader;
    	let current;

    	cardheader = new Card_header({
    			props: {
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cardheader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cardheader, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cardheader_changes = {};

    			if (dirty[0] & /*$$scope, title*/ 268435457) {
    				cardheader_changes.$$scope = { dirty, ctx };
    			}

    			cardheader.$set(cardheader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardheader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardheader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cardheader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(151:2) {#if typeof title !== 'undefined' || hasHeaderSlots}",
    		ctx
    	});

    	return block;
    }

    // (152:4) <CardHeader>
    function create_default_slot_2$5(ctx) {
    	let t0_value = plainText(/*title*/ ctx[0]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[26].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[28], get_header_slot_context$1);

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);

    			if (header_slot) {
    				header_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = plainText(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[0] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[28],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[28])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[28], dirty, get_header_slot_changes$1),
    						get_header_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(152:4) <CardHeader>",
    		ctx
    	});

    	return block;
    }

    // (157:2) {#if typeof content !== 'undefined' || hasContentSlots}
    function create_if_block_1$9(ctx) {
    	let cardcontent;
    	let current;

    	cardcontent = new Card_content({
    			props: {
    				padding: /*padding*/ ctx[12],
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cardcontent.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cardcontent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cardcontent_changes = {};
    			if (dirty[0] & /*padding*/ 4096) cardcontent_changes.padding = /*padding*/ ctx[12];

    			if (dirty[0] & /*$$scope, content*/ 268435458) {
    				cardcontent_changes.$$scope = { dirty, ctx };
    			}

    			cardcontent.$set(cardcontent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardcontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardcontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cardcontent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(157:2) {#if typeof content !== 'undefined' || hasContentSlots}",
    		ctx
    	});

    	return block;
    }

    // (158:4) <CardContent {padding}>
    function create_default_slot_1$6(ctx) {
    	let t0_value = plainText(/*content*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let current;
    	const content_slot_template = /*#slots*/ ctx[26].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[28], get_content_slot_context$2);

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    			if (content_slot) content_slot.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);

    			if (content_slot) {
    				content_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*content*/ 2) && t0_value !== (t0_value = plainText(/*content*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[0] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[28],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[28])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[28], dirty, get_content_slot_changes$2),
    						get_content_slot_context$2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (content_slot) content_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(158:4) <CardContent {padding}>",
    		ctx
    	});

    	return block;
    }

    // (163:2) {#if typeof footer !== 'undefined' || hasFooterSlots}
    function create_if_block$d(ctx) {
    	let cardfooter;
    	let current;

    	cardfooter = new Card_footer({
    			props: {
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cardfooter.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cardfooter, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cardfooter_changes = {};

    			if (dirty[0] & /*$$scope, footer*/ 268435460) {
    				cardfooter_changes.$$scope = { dirty, ctx };
    			}

    			cardfooter.$set(cardfooter_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardfooter.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardfooter.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cardfooter, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(163:2) {#if typeof footer !== 'undefined' || hasFooterSlots}",
    		ctx
    	});

    	return block;
    }

    // (164:4) <CardFooter>
    function create_default_slot$a(ctx) {
    	let t0_value = plainText(/*footer*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[26].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[28], get_footer_slot_context$1);

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);

    			if (footer_slot) {
    				footer_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 4) && t0_value !== (t0_value = plainText(/*footer*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[0] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[28],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[28])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[28], dirty, get_footer_slot_changes$1),
    						get_footer_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(164:4) <CardFooter>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let div_data_animate_value;
    	let div_data_hide_navbar_on_open_value;
    	let div_data_hide_toolbar_on_open_value;
    	let div_data_hide_statusbar_on_open_value;
    	let div_data_swipe_to_close_value;
    	let div_data_close_by_backdrop_click_value;
    	let div_data_backdrop_value;
    	let current;
    	let if_block0 = (typeof /*title*/ ctx[0] !== 'undefined' || /*hasHeaderSlots*/ ctx[16]) && create_if_block_2$8(ctx);
    	let if_block1 = (typeof /*content*/ ctx[1] !== 'undefined' || /*hasContentSlots*/ ctx[15]) && create_if_block_1$9(ctx);
    	let if_block2 = (typeof /*footer*/ ctx[2] !== 'undefined' || /*hasFooterSlots*/ ctx[14]) && create_if_block$d(ctx);
    	const default_slot_template = /*#slots*/ ctx[26].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);

    	let div_levels = [
    		{ class: /*classes*/ ctx[17] },
    		{
    			"data-animate": div_data_animate_value = typeof /*animate*/ ctx[3] === 'undefined'
    			? /*animate*/ ctx[3]
    			: /*animate*/ ctx[3].toString()
    		},
    		{
    			"data-hide-navbar-on-open": div_data_hide_navbar_on_open_value = typeof /*hideNavbarOnOpen*/ ctx[4] === 'undefined'
    			? /*hideNavbarOnOpen*/ ctx[4]
    			: /*hideNavbarOnOpen*/ ctx[4].toString()
    		},
    		{
    			"data-hide-toolbar-on-open": div_data_hide_toolbar_on_open_value = typeof /*hideToolbarOnOpen*/ ctx[5] === 'undefined'
    			? /*hideToolbarOnOpen*/ ctx[5]
    			: /*hideToolbarOnOpen*/ ctx[5].toString()
    		},
    		{
    			"data-hide-statusbar-on-open": div_data_hide_statusbar_on_open_value = typeof /*hideStatusbarOnOpen*/ ctx[6] === 'undefined'
    			? /*hideStatusbarOnOpen*/ ctx[6]
    			: /*hideStatusbarOnOpen*/ ctx[6].toString()
    		},
    		{
    			"data-scrollable-el": /*scrollableEl*/ ctx[7]
    		},
    		{
    			"data-swipe-to-close": div_data_swipe_to_close_value = typeof /*swipeToClose*/ ctx[8] === 'undefined'
    			? /*swipeToClose*/ ctx[8]
    			: /*swipeToClose*/ ctx[8].toString()
    		},
    		{
    			"data-close-by-backdrop-click": div_data_close_by_backdrop_click_value = typeof /*closeByBackdropClick*/ ctx[9] === 'undefined'
    			? /*closeByBackdropClick*/ ctx[9]
    			: /*closeByBackdropClick*/ ctx[9].toString()
    		},
    		{
    			"data-backdrop": div_data_backdrop_value = typeof /*backdrop*/ ctx[10] === 'undefined'
    			? /*backdrop*/ ctx[10]
    			: /*backdrop*/ ctx[10].toString()
    		},
    		{
    			"data-backdrop-el": /*backdropEl*/ ctx[11]
    		},
    		restProps(/*$$restProps*/ ctx[18])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$k, 128, 0, 3396);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[27](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*title*/ ctx[0] !== 'undefined' || /*hasHeaderSlots*/ ctx[16]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*title, hasHeaderSlots*/ 65537) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$8(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (typeof /*content*/ ctx[1] !== 'undefined' || /*hasContentSlots*/ ctx[15]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*content, hasContentSlots*/ 32770) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$9(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (typeof /*footer*/ ctx[2] !== 'undefined' || /*hasFooterSlots*/ ctx[14]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*footer, hasFooterSlots*/ 16388) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$d(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[28],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[28])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[28], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty[0] & /*classes*/ 131072) && { class: /*classes*/ ctx[17] },
    				(!current || dirty[0] & /*animate*/ 8 && div_data_animate_value !== (div_data_animate_value = typeof /*animate*/ ctx[3] === 'undefined'
    				? /*animate*/ ctx[3]
    				: /*animate*/ ctx[3].toString())) && { "data-animate": div_data_animate_value },
    				(!current || dirty[0] & /*hideNavbarOnOpen*/ 16 && div_data_hide_navbar_on_open_value !== (div_data_hide_navbar_on_open_value = typeof /*hideNavbarOnOpen*/ ctx[4] === 'undefined'
    				? /*hideNavbarOnOpen*/ ctx[4]
    				: /*hideNavbarOnOpen*/ ctx[4].toString())) && {
    					"data-hide-navbar-on-open": div_data_hide_navbar_on_open_value
    				},
    				(!current || dirty[0] & /*hideToolbarOnOpen*/ 32 && div_data_hide_toolbar_on_open_value !== (div_data_hide_toolbar_on_open_value = typeof /*hideToolbarOnOpen*/ ctx[5] === 'undefined'
    				? /*hideToolbarOnOpen*/ ctx[5]
    				: /*hideToolbarOnOpen*/ ctx[5].toString())) && {
    					"data-hide-toolbar-on-open": div_data_hide_toolbar_on_open_value
    				},
    				(!current || dirty[0] & /*hideStatusbarOnOpen*/ 64 && div_data_hide_statusbar_on_open_value !== (div_data_hide_statusbar_on_open_value = typeof /*hideStatusbarOnOpen*/ ctx[6] === 'undefined'
    				? /*hideStatusbarOnOpen*/ ctx[6]
    				: /*hideStatusbarOnOpen*/ ctx[6].toString())) && {
    					"data-hide-statusbar-on-open": div_data_hide_statusbar_on_open_value
    				},
    				(!current || dirty[0] & /*scrollableEl*/ 128) && {
    					"data-scrollable-el": /*scrollableEl*/ ctx[7]
    				},
    				(!current || dirty[0] & /*swipeToClose*/ 256 && div_data_swipe_to_close_value !== (div_data_swipe_to_close_value = typeof /*swipeToClose*/ ctx[8] === 'undefined'
    				? /*swipeToClose*/ ctx[8]
    				: /*swipeToClose*/ ctx[8].toString())) && {
    					"data-swipe-to-close": div_data_swipe_to_close_value
    				},
    				(!current || dirty[0] & /*closeByBackdropClick*/ 512 && div_data_close_by_backdrop_click_value !== (div_data_close_by_backdrop_click_value = typeof /*closeByBackdropClick*/ ctx[9] === 'undefined'
    				? /*closeByBackdropClick*/ ctx[9]
    				: /*closeByBackdropClick*/ ctx[9].toString())) && {
    					"data-close-by-backdrop-click": div_data_close_by_backdrop_click_value
    				},
    				(!current || dirty[0] & /*backdrop*/ 1024 && div_data_backdrop_value !== (div_data_backdrop_value = typeof /*backdrop*/ ctx[10] === 'undefined'
    				? /*backdrop*/ ctx[10]
    				: /*backdrop*/ ctx[10].toString())) && { "data-backdrop": div_data_backdrop_value },
    				(!current || dirty[0] & /*backdropEl*/ 2048) && {
    					"data-backdrop-el": /*backdropEl*/ ctx[11]
    				},
    				dirty[0] & /*$$restProps*/ 262144 && restProps(/*$$restProps*/ ctx[18])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[27](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let classes;
    	let hasHeaderSlots;
    	let hasContentSlots;
    	let hasFooterSlots;

    	const omit_props_names = [
    		"class","title","content","footer","outline","expandable","expandableAnimateWidth","expandableOpened","animate","hideNavbarOnOpen","hideToolbarOnOpen","hideStatusbarOnOpen","scrollableEl","swipeToClose","closeByBackdropClick","backdrop","backdropEl","noShadow","noBorder","padding"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Card', slots, ['header','content','footer','default']);
    	const $$slots = compute_slots(slots);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { title = undefined } = $$props;
    	let { content = undefined } = $$props;
    	let { footer = undefined } = $$props;
    	let { outline = false } = $$props;
    	let { expandable = false } = $$props;
    	let { expandableAnimateWidth = false } = $$props;
    	let { expandableOpened = false } = $$props;
    	let { animate = undefined } = $$props;
    	let { hideNavbarOnOpen = undefined } = $$props;
    	let { hideToolbarOnOpen = undefined } = $$props;
    	let { hideStatusbarOnOpen = undefined } = $$props;
    	let { scrollableEl = undefined } = $$props;
    	let { swipeToClose = undefined } = $$props;
    	let { closeByBackdropClick = undefined } = $$props;
    	let { backdrop = undefined } = $$props;
    	let { backdropEl = undefined } = $$props;
    	let { noShadow = false } = $$props;
    	let { noBorder = false } = $$props;
    	let { padding = true } = $$props;
    	let el;

    	/* eslint-enable no-undef */
    	function open() {
    		app$1.f7.card.open(el);
    	}

    	function close() {
    		app$1.f7.card.close(el);
    	}

    	let initialWatched = false;

    	function watchOpened(openedPassed) {
    		if (!initialWatched) {
    			initialWatched = true;
    			return;
    		}

    		if (openedPassed) {
    			open();
    		} else {
    			close();
    		}
    	}

    	function onBeforeOpen(cardEl, prevent) {
    		if (cardEl !== el) return;
    		emit('cardBeforeOpen', [el, prevent]);
    	}

    	function onOpen(cardEl) {
    		if (cardEl !== el) return;
    		emit('cardOpen', [el]);
    		$$invalidate(19, expandableOpened = true);
    	}

    	function onOpened(cardEl, pageEl) {
    		if (cardEl !== el) return;
    		emit('cardOpened', [el, pageEl]);
    	}

    	function onClose(cardEl) {
    		if (cardEl !== el) return;
    		emit('cardClose', [el]);
    	}

    	function onClosed(cardEl, pageEl) {
    		if (cardEl !== el) return;
    		emit('cardClosed', [el, pageEl]);
    		$$invalidate(19, expandableOpened = false);
    	}

    	onMount(() => {
    		if (!expandable) return;

    		f7ready(() => {
    			app$1.f7.on('cardBeforeOpen', onBeforeOpen);
    			app$1.f7.on('cardOpen', onOpen);
    			app$1.f7.on('cardOpened', onOpened);
    			app$1.f7.on('cardClose', onClose);
    			app$1.f7.on('cardClosed', onClosed);

    			if (expandable && expandableOpened && el) {
    				app$1.f7.card.open(el, false);
    			}
    		});
    	});

    	onDestroy(() => {
    		if (!expandable) return;
    		if (!app$1.f7 || !el) return;
    		app$1.f7.off('cardBeforeOpen', onBeforeOpen);
    		app$1.f7.off('cardOpen', onOpen);
    		app$1.f7.off('cardOpened', onOpened);
    		app$1.f7.off('cardClose', onClose);
    		app$1.f7.off('cardClosed', onClosed);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(13, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(40, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(20, className = $$new_props.class);
    		if ('title' in $$new_props) $$invalidate(0, title = $$new_props.title);
    		if ('content' in $$new_props) $$invalidate(1, content = $$new_props.content);
    		if ('footer' in $$new_props) $$invalidate(2, footer = $$new_props.footer);
    		if ('outline' in $$new_props) $$invalidate(21, outline = $$new_props.outline);
    		if ('expandable' in $$new_props) $$invalidate(22, expandable = $$new_props.expandable);
    		if ('expandableAnimateWidth' in $$new_props) $$invalidate(23, expandableAnimateWidth = $$new_props.expandableAnimateWidth);
    		if ('expandableOpened' in $$new_props) $$invalidate(19, expandableOpened = $$new_props.expandableOpened);
    		if ('animate' in $$new_props) $$invalidate(3, animate = $$new_props.animate);
    		if ('hideNavbarOnOpen' in $$new_props) $$invalidate(4, hideNavbarOnOpen = $$new_props.hideNavbarOnOpen);
    		if ('hideToolbarOnOpen' in $$new_props) $$invalidate(5, hideToolbarOnOpen = $$new_props.hideToolbarOnOpen);
    		if ('hideStatusbarOnOpen' in $$new_props) $$invalidate(6, hideStatusbarOnOpen = $$new_props.hideStatusbarOnOpen);
    		if ('scrollableEl' in $$new_props) $$invalidate(7, scrollableEl = $$new_props.scrollableEl);
    		if ('swipeToClose' in $$new_props) $$invalidate(8, swipeToClose = $$new_props.swipeToClose);
    		if ('closeByBackdropClick' in $$new_props) $$invalidate(9, closeByBackdropClick = $$new_props.closeByBackdropClick);
    		if ('backdrop' in $$new_props) $$invalidate(10, backdrop = $$new_props.backdrop);
    		if ('backdropEl' in $$new_props) $$invalidate(11, backdropEl = $$new_props.backdropEl);
    		if ('noShadow' in $$new_props) $$invalidate(24, noShadow = $$new_props.noShadow);
    		if ('noBorder' in $$new_props) $$invalidate(25, noBorder = $$new_props.noBorder);
    		if ('padding' in $$new_props) $$invalidate(12, padding = $$new_props.padding);
    		if ('$$scope' in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		colorClasses,
    		classNames,
    		plainText,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		CardHeader: Card_header,
    		CardContent: Card_content,
    		CardFooter: Card_footer,
    		emit,
    		className,
    		title,
    		content,
    		footer,
    		outline,
    		expandable,
    		expandableAnimateWidth,
    		expandableOpened,
    		animate,
    		hideNavbarOnOpen,
    		hideToolbarOnOpen,
    		hideStatusbarOnOpen,
    		scrollableEl,
    		swipeToClose,
    		closeByBackdropClick,
    		backdrop,
    		backdropEl,
    		noShadow,
    		noBorder,
    		padding,
    		el,
    		open,
    		close,
    		initialWatched,
    		watchOpened,
    		onBeforeOpen,
    		onOpen,
    		onOpened,
    		onClose,
    		onClosed,
    		hasFooterSlots,
    		hasContentSlots,
    		hasHeaderSlots,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(40, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(20, className = $$new_props.className);
    		if ('title' in $$props) $$invalidate(0, title = $$new_props.title);
    		if ('content' in $$props) $$invalidate(1, content = $$new_props.content);
    		if ('footer' in $$props) $$invalidate(2, footer = $$new_props.footer);
    		if ('outline' in $$props) $$invalidate(21, outline = $$new_props.outline);
    		if ('expandable' in $$props) $$invalidate(22, expandable = $$new_props.expandable);
    		if ('expandableAnimateWidth' in $$props) $$invalidate(23, expandableAnimateWidth = $$new_props.expandableAnimateWidth);
    		if ('expandableOpened' in $$props) $$invalidate(19, expandableOpened = $$new_props.expandableOpened);
    		if ('animate' in $$props) $$invalidate(3, animate = $$new_props.animate);
    		if ('hideNavbarOnOpen' in $$props) $$invalidate(4, hideNavbarOnOpen = $$new_props.hideNavbarOnOpen);
    		if ('hideToolbarOnOpen' in $$props) $$invalidate(5, hideToolbarOnOpen = $$new_props.hideToolbarOnOpen);
    		if ('hideStatusbarOnOpen' in $$props) $$invalidate(6, hideStatusbarOnOpen = $$new_props.hideStatusbarOnOpen);
    		if ('scrollableEl' in $$props) $$invalidate(7, scrollableEl = $$new_props.scrollableEl);
    		if ('swipeToClose' in $$props) $$invalidate(8, swipeToClose = $$new_props.swipeToClose);
    		if ('closeByBackdropClick' in $$props) $$invalidate(9, closeByBackdropClick = $$new_props.closeByBackdropClick);
    		if ('backdrop' in $$props) $$invalidate(10, backdrop = $$new_props.backdrop);
    		if ('backdropEl' in $$props) $$invalidate(11, backdropEl = $$new_props.backdropEl);
    		if ('noShadow' in $$props) $$invalidate(24, noShadow = $$new_props.noShadow);
    		if ('noBorder' in $$props) $$invalidate(25, noBorder = $$new_props.noBorder);
    		if ('padding' in $$props) $$invalidate(12, padding = $$new_props.padding);
    		if ('el' in $$props) $$invalidate(13, el = $$new_props.el);
    		if ('initialWatched' in $$props) initialWatched = $$new_props.initialWatched;
    		if ('hasFooterSlots' in $$props) $$invalidate(14, hasFooterSlots = $$new_props.hasFooterSlots);
    		if ('hasContentSlots' in $$props) $$invalidate(15, hasContentSlots = $$new_props.hasContentSlots);
    		if ('hasHeaderSlots' in $$props) $$invalidate(16, hasHeaderSlots = $$new_props.hasHeaderSlots);
    		if ('classes' in $$props) $$invalidate(17, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(17, classes = classNames(
    			className,
    			'card',
    			{
    				'card-outline': outline,
    				'card-expandable': expandable,
    				'card-expandable-animate-width': expandableAnimateWidth,
    				'no-shadow': noShadow,
    				'no-border': noBorder
    			},
    			colorClasses($$props)
    		));

    		if ($$self.$$.dirty[0] & /*expandableOpened*/ 524288) {
    			watchOpened(expandableOpened);
    		}
    	};

    	$$invalidate(16, hasHeaderSlots = $$slots.header);
    	$$invalidate(15, hasContentSlots = $$slots.content);
    	$$invalidate(14, hasFooterSlots = $$slots.footer);
    	$$props = exclude_internal_props($$props);

    	return [
    		title,
    		content,
    		footer,
    		animate,
    		hideNavbarOnOpen,
    		hideToolbarOnOpen,
    		hideStatusbarOnOpen,
    		scrollableEl,
    		swipeToClose,
    		closeByBackdropClick,
    		backdrop,
    		backdropEl,
    		padding,
    		el,
    		hasFooterSlots,
    		hasContentSlots,
    		hasHeaderSlots,
    		classes,
    		$$restProps,
    		expandableOpened,
    		className,
    		outline,
    		expandable,
    		expandableAnimateWidth,
    		noShadow,
    		noBorder,
    		slots,
    		div_binding,
    		$$scope
    	];
    }

    class Card extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$k,
    			create_fragment$n,
    			safe_not_equal,
    			{
    				class: 20,
    				title: 0,
    				content: 1,
    				footer: 2,
    				outline: 21,
    				expandable: 22,
    				expandableAnimateWidth: 23,
    				expandableOpened: 19,
    				animate: 3,
    				hideNavbarOnOpen: 4,
    				hideToolbarOnOpen: 5,
    				hideStatusbarOnOpen: 6,
    				scrollableEl: 7,
    				swipeToClose: 8,
    				closeByBackdropClick: 9,
    				backdrop: 10,
    				backdropEl: 11,
    				noShadow: 24,
    				noBorder: 25,
    				padding: 12
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Card",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get class() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get footer() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set footer(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outline() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outline(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expandable() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expandable(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expandableAnimateWidth() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expandableAnimateWidth(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expandableOpened() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expandableOpened(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get animate() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set animate(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideNavbarOnOpen() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideNavbarOnOpen(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideToolbarOnOpen() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideToolbarOnOpen(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideStatusbarOnOpen() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideStatusbarOnOpen(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollableEl() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollableEl(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get swipeToClose() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set swipeToClose(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeByBackdropClick() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeByBackdropClick(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backdrop() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backdrop(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backdropEl() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backdropEl(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noShadow() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noShadow(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noBorder() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noBorder(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/col.svelte generated by Svelte v3.44.0 */
    const file$j = "node_modules/framework7-svelte/esm/svelte/col.svelte";

    // (68:25) 
    function create_if_block_2$7(ctx) {
    	let span;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
    	let if_block = /*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2] && create_if_block_3$5(ctx);
    	let span_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			t = space();
    			if (if_block) if_block.c();
    			set_attributes(span, span_data);
    			add_location(span, file$j, 68, 2, 1801);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			append_dev(span, t);
    			if (if_block) if_block.m(span, null);
    			/*span_binding*/ ctx[19](span);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*onClick*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2]) {
    				if (if_block) ; else {
    					if_block = create_if_block_3$5(ctx);
    					if_block.c();
    					if_block.m(span, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
    				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			if (if_block) if_block.d();
    			/*span_binding*/ ctx[19](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(68:25) ",
    		ctx
    	});

    	return block;
    }

    // (63:0) {#if tag === 'div'}
    function create_if_block$c(ctx) {
    	let div;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
    	let if_block = /*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2] && create_if_block_1$8(ctx);
    	let div_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			t = space();
    			if (if_block) if_block.c();
    			set_attributes(div, div_data);
    			add_location(div, file$j, 63, 2, 1591);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			/*div_binding*/ ctx[18](div);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*onClick*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2]) {
    				if (if_block) ; else {
    					if_block = create_if_block_1$8(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
    				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			if (if_block) if_block.d();
    			/*div_binding*/ ctx[18](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(63:0) {#if tag === 'div'}",
    		ctx
    	});

    	return block;
    }

    // (71:4) {#if resizable && resizableHandler}
    function create_if_block_3$5(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "resize-handler");
    			add_location(span, file$j, 70, 39, 1938);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(71:4) {#if resizable && resizableHandler}",
    		ctx
    	});

    	return block;
    }

    // (66:4) {#if resizable && resizableHandler}
    function create_if_block_1$8(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "resize-handler");
    			add_location(span, file$j, 65, 39, 1727);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(66:4) {#if resizable && resizableHandler}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$c, create_if_block_2$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*tag*/ ctx[0] === 'div') return 0;
    		if (/*tag*/ ctx[0] === 'span') return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","tag","width","xsmall","small","medium","large","xlarge","resizable","resizableFixed","resizableAbsolute","resizableHandler"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Col', slots, ['default']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { tag = 'div' } = $$props;
    	let { width = 'auto' } = $$props;
    	let { xsmall = undefined } = $$props;
    	let { small = undefined } = $$props;
    	let { medium = undefined } = $$props;
    	let { large = undefined } = $$props;
    	let { xlarge = undefined } = $$props;
    	let { resizable = false } = $$props;
    	let { resizableFixed = false } = $$props;
    	let { resizableAbsolute = false } = $$props;
    	let { resizableHandler = true } = $$props;
    	let el;

    	function onClick() {
    		emit('click');
    	}

    	function onResize(targetEl) {
    		if (el !== targetEl) return;
    		emit('gridResize');
    	}

    	onMount(() => {
    		f7ready(() => {
    			app$1.f7.on('gridResize', onResize);
    		});
    	});

    	onDestroy(() => {
    		if (!app$1.f7) return;
    		app$1.f7.off('gridResize', onResize);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(3, el);
    		});
    	}

    	function span_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(3, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(7, className = $$new_props.class);
    		if ('tag' in $$new_props) $$invalidate(0, tag = $$new_props.tag);
    		if ('width' in $$new_props) $$invalidate(8, width = $$new_props.width);
    		if ('xsmall' in $$new_props) $$invalidate(9, xsmall = $$new_props.xsmall);
    		if ('small' in $$new_props) $$invalidate(10, small = $$new_props.small);
    		if ('medium' in $$new_props) $$invalidate(11, medium = $$new_props.medium);
    		if ('large' in $$new_props) $$invalidate(12, large = $$new_props.large);
    		if ('xlarge' in $$new_props) $$invalidate(13, xlarge = $$new_props.xlarge);
    		if ('resizable' in $$new_props) $$invalidate(1, resizable = $$new_props.resizable);
    		if ('resizableFixed' in $$new_props) $$invalidate(14, resizableFixed = $$new_props.resizableFixed);
    		if ('resizableAbsolute' in $$new_props) $$invalidate(15, resizableAbsolute = $$new_props.resizableAbsolute);
    		if ('resizableHandler' in $$new_props) $$invalidate(2, resizableHandler = $$new_props.resizableHandler);
    		if ('$$scope' in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		colorClasses,
    		classNames,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		emit,
    		className,
    		tag,
    		width,
    		xsmall,
    		small,
    		medium,
    		large,
    		xlarge,
    		resizable,
    		resizableFixed,
    		resizableAbsolute,
    		resizableHandler,
    		el,
    		onClick,
    		onResize,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(7, className = $$new_props.className);
    		if ('tag' in $$props) $$invalidate(0, tag = $$new_props.tag);
    		if ('width' in $$props) $$invalidate(8, width = $$new_props.width);
    		if ('xsmall' in $$props) $$invalidate(9, xsmall = $$new_props.xsmall);
    		if ('small' in $$props) $$invalidate(10, small = $$new_props.small);
    		if ('medium' in $$props) $$invalidate(11, medium = $$new_props.medium);
    		if ('large' in $$props) $$invalidate(12, large = $$new_props.large);
    		if ('xlarge' in $$props) $$invalidate(13, xlarge = $$new_props.xlarge);
    		if ('resizable' in $$props) $$invalidate(1, resizable = $$new_props.resizable);
    		if ('resizableFixed' in $$props) $$invalidate(14, resizableFixed = $$new_props.resizableFixed);
    		if ('resizableAbsolute' in $$props) $$invalidate(15, resizableAbsolute = $$new_props.resizableAbsolute);
    		if ('resizableHandler' in $$props) $$invalidate(2, resizableHandler = $$new_props.resizableHandler);
    		if ('el' in $$props) $$invalidate(3, el = $$new_props.el);
    		if ('classes' in $$props) $$invalidate(4, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(4, classes = classNames(
    			className,
    			{
    				col: width === 'auto',
    				[`col-${width}`]: width !== 'auto',
    				[`xsmall-${xsmall}`]: xsmall,
    				[`small-${small}`]: small,
    				[`medium-${medium}`]: medium,
    				[`large-${large}`]: large,
    				[`xlarge-${xlarge}`]: xlarge,
    				resizable,
    				'resizable-fixed': resizableFixed,
    				'resizable-absolute': resizableAbsolute
    			},
    			colorClasses($$props)
    		));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		tag,
    		resizable,
    		resizableHandler,
    		el,
    		classes,
    		onClick,
    		$$restProps,
    		className,
    		width,
    		xsmall,
    		small,
    		medium,
    		large,
    		xlarge,
    		resizableFixed,
    		resizableAbsolute,
    		$$scope,
    		slots,
    		div_binding,
    		span_binding
    	];
    }

    class Col extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$j, create_fragment$m, safe_not_equal, {
    			class: 7,
    			tag: 0,
    			width: 8,
    			xsmall: 9,
    			small: 10,
    			medium: 11,
    			large: 12,
    			xlarge: 13,
    			resizable: 1,
    			resizableFixed: 14,
    			resizableAbsolute: 15,
    			resizableHandler: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Col",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get class() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tag() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tag(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xsmall() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xsmall(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get small() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set small(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get medium() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set medium(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get large() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set large(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xlarge() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xlarge(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resizable() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resizable(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resizableFixed() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resizableFixed(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resizableAbsolute() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resizableAbsolute(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resizableHandler() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resizableHandler(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/fab.svelte generated by Svelte v3.44.0 */
    const file$i = "node_modules/framework7-svelte/esm/svelte/fab.svelte";
    const get_root_slot_changes$3 = dirty => ({});
    const get_root_slot_context$3 = ctx => ({});
    const get_link_slot_changes = dirty => ({});
    const get_link_slot_context = ctx => ({});
    const get_text_slot_changes$1 = dirty => ({});
    const get_text_slot_context$1 = ctx => ({});

    // (81:4) {#if typeof text !== 'undefined' || hasTextSlots}
    function create_if_block$b(ctx) {
    	let div;
    	let t0_value = plainText(/*text*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const text_slot_template = /*#slots*/ ctx[18].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[17], get_text_slot_context$1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (text_slot) text_slot.c();
    			attr_dev(div, "class", "fab-text");
    			add_location(div, file$i, 81, 6, 1964);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[19](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[17], dirty, get_text_slot_changes$1),
    						get_text_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (text_slot) text_slot.d(detaching);
    			/*div_binding*/ ctx[19](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(81:4) {#if typeof text !== 'undefined' || hasTextSlots}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let div;
    	let a;
    	let t0;
    	let t1;
    	let useTooltip_action;
    	let t2;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[18].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
    	let if_block = (typeof /*text*/ ctx[2] !== 'undefined' || /*hasTextSlots*/ ctx[7]) && create_if_block$b(ctx);
    	const link_slot_template = /*#slots*/ ctx[18].link;
    	const link_slot = create_slot(link_slot_template, ctx, /*$$scope*/ ctx[17], get_link_slot_context);
    	const root_slot_template = /*#slots*/ ctx[18].root;
    	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[17], get_root_slot_context$3);

    	let div_levels = [
    		{ class: /*classes*/ ctx[10] },
    		{ "data-morph-to": /*morphTo*/ ctx[0] },
    		{ "data-f7-slot": /*f7Slot*/ ctx[5] },
    		restProps(/*$$restProps*/ ctx[13])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			a = element("a");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			if (link_slot) link_slot.c();
    			t2 = space();
    			if (root_slot) root_slot.c();
    			attr_dev(a, "target", /*target*/ ctx[1]);
    			attr_dev(a, "href", /*hrefComputed*/ ctx[11]);
    			add_location(a, file$i, 72, 2, 1752);
    			set_attributes(div, div_data);
    			add_location(div, file$i, 65, 0, 1628);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, a);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			append_dev(a, t0);
    			if (if_block) if_block.m(a, null);
    			append_dev(a, t1);

    			if (link_slot) {
    				link_slot.m(a, null);
    			}

    			/*a_binding*/ ctx[20](a);
    			append_dev(div, t2);

    			if (root_slot) {
    				root_slot.m(div, null);
    			}

    			/*div_binding_1*/ ctx[21](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*onClick*/ ctx[12], false, false, false),
    					action_destroyer(useTooltip_action = useTooltip.call(null, a, {
    						tooltip: /*tooltip*/ ctx[3],
    						tooltipTrigger: /*tooltipTrigger*/ ctx[4]
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
    						null
    					);
    				}
    			}

    			if (typeof /*text*/ ctx[2] !== 'undefined' || /*hasTextSlots*/ ctx[7]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*text, hasTextSlots*/ 132) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(a, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (link_slot) {
    				if (link_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						link_slot,
    						link_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(link_slot_template, /*$$scope*/ ctx[17], dirty, get_link_slot_changes),
    						get_link_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*target*/ 2) {
    				attr_dev(a, "target", /*target*/ ctx[1]);
    			}

    			if (!current || dirty & /*hrefComputed*/ 2048) {
    				attr_dev(a, "href", /*hrefComputed*/ ctx[11]);
    			}

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 24) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[3],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[4]
    			});

    			if (root_slot) {
    				if (root_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						root_slot,
    						root_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(root_slot_template, /*$$scope*/ ctx[17], dirty, get_root_slot_changes$3),
    						get_root_slot_context$3
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 1024) && { class: /*classes*/ ctx[10] },
    				(!current || dirty & /*morphTo*/ 1) && { "data-morph-to": /*morphTo*/ ctx[0] },
    				(!current || dirty & /*f7Slot*/ 32) && { "data-f7-slot": /*f7Slot*/ ctx[5] },
    				dirty & /*$$restProps*/ 8192 && restProps(/*$$restProps*/ ctx[13])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(if_block);
    			transition_in(link_slot, local);
    			transition_in(root_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(if_block);
    			transition_out(link_slot, local);
    			transition_out(root_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			if (if_block) if_block.d();
    			if (link_slot) link_slot.d(detaching);
    			/*a_binding*/ ctx[20](null);
    			if (root_slot) root_slot.d(detaching);
    			/*div_binding_1*/ ctx[21](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let hrefComputed;
    	let hasTextSlots;
    	let classes;

    	const omit_props_names = [
    		"class","morphTo","href","target","text","position","tooltip","tooltipTrigger","f7Slot"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Fab', slots, ['default','text','link','root']);
    	const $$slots = compute_slots(slots);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { morphTo = undefined } = $$props;
    	let { href = undefined } = $$props;
    	let { target = undefined } = $$props;
    	let { text = undefined } = $$props;
    	let { position = 'right-bottom' } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { tooltipTrigger = undefined } = $$props;
    	let { f7Slot = 'fixed' } = $$props;
    	let el;
    	let linkEl;
    	let textEl;

    	function onClick() {
    		emit('click');
    	}

    	onMount(() => {
    		f7ready(() => {
    			const dom7 = app$1.f7.$;
    			const rootEls = dom7(linkEl).children('.fab-buttons');

    			if (rootEls.length) {
    				dom7(el).append(rootEls);
    			}
    		});
    	});

    	afterUpdate(() => {
    		if (!app$1.f7) return;
    		const dom7 = app$1.f7.$;
    		const rootEls = dom7(linkEl).children('.fab-buttons');

    		if (rootEls.length) {
    			dom7(el).append(rootEls);
    		}
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			textEl = $$value;
    			$$invalidate(6, textEl);
    		});
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			linkEl = $$value;
    			$$invalidate(9, linkEl);
    		});
    	}

    	function div_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(8, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(14, className = $$new_props.class);
    		if ('morphTo' in $$new_props) $$invalidate(0, morphTo = $$new_props.morphTo);
    		if ('href' in $$new_props) $$invalidate(15, href = $$new_props.href);
    		if ('target' in $$new_props) $$invalidate(1, target = $$new_props.target);
    		if ('text' in $$new_props) $$invalidate(2, text = $$new_props.text);
    		if ('position' in $$new_props) $$invalidate(16, position = $$new_props.position);
    		if ('tooltip' in $$new_props) $$invalidate(3, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$new_props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('f7Slot' in $$new_props) $$invalidate(5, f7Slot = $$new_props.f7Slot);
    		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		afterUpdate,
    		colorClasses,
    		classNames,
    		plainText,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		useTooltip,
    		emit,
    		className,
    		morphTo,
    		href,
    		target,
    		text,
    		position,
    		tooltip,
    		tooltipTrigger,
    		f7Slot,
    		el,
    		linkEl,
    		textEl,
    		onClick,
    		hasTextSlots,
    		classes,
    		hrefComputed
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(14, className = $$new_props.className);
    		if ('morphTo' in $$props) $$invalidate(0, morphTo = $$new_props.morphTo);
    		if ('href' in $$props) $$invalidate(15, href = $$new_props.href);
    		if ('target' in $$props) $$invalidate(1, target = $$new_props.target);
    		if ('text' in $$props) $$invalidate(2, text = $$new_props.text);
    		if ('position' in $$props) $$invalidate(16, position = $$new_props.position);
    		if ('tooltip' in $$props) $$invalidate(3, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('f7Slot' in $$props) $$invalidate(5, f7Slot = $$new_props.f7Slot);
    		if ('el' in $$props) $$invalidate(8, el = $$new_props.el);
    		if ('linkEl' in $$props) $$invalidate(9, linkEl = $$new_props.linkEl);
    		if ('textEl' in $$props) $$invalidate(6, textEl = $$new_props.textEl);
    		if ('hasTextSlots' in $$props) $$invalidate(7, hasTextSlots = $$new_props.hasTextSlots);
    		if ('classes' in $$props) $$invalidate(10, classes = $$new_props.classes);
    		if ('hrefComputed' in $$props) $$invalidate(11, hrefComputed = $$new_props.hrefComputed);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*href*/ 32768) {
    			$$invalidate(11, hrefComputed = href === true ? '#' : href || undefined);
    		}

    		$$invalidate(10, classes = classNames(
    			className,
    			'fab',
    			`fab-${position}`,
    			{
    				'fab-morph': morphTo,
    				'fab-extended': text || hasTextSlots || typeof textEl !== 'undefined'
    			},
    			colorClasses($$props)
    		));
    	};

    	$$invalidate(7, hasTextSlots = $$slots.text);
    	$$props = exclude_internal_props($$props);

    	return [
    		morphTo,
    		target,
    		text,
    		tooltip,
    		tooltipTrigger,
    		f7Slot,
    		textEl,
    		hasTextSlots,
    		el,
    		linkEl,
    		classes,
    		hrefComputed,
    		onClick,
    		$$restProps,
    		className,
    		href,
    		position,
    		$$scope,
    		slots,
    		div_binding,
    		a_binding,
    		div_binding_1
    	];
    }

    class Fab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$i, create_fragment$l, safe_not_equal, {
    			class: 14,
    			morphTo: 0,
    			href: 15,
    			target: 1,
    			text: 2,
    			position: 16,
    			tooltip: 3,
    			tooltipTrigger: 4,
    			f7Slot: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Fab",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get class() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get morphTo() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set morphTo(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get target() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set target(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get position() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipTrigger() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipTrigger(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get f7Slot() {
    		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set f7Slot(value) {
    		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/toggle.svelte generated by Svelte v3.44.0 */
    const file$h = "node_modules/framework7-svelte/esm/svelte/toggle.svelte";

    function create_fragment$k(ctx) {
    	let label;
    	let input;
    	let input_value_value;
    	let t;
    	let span;
    	let useTooltip_action;
    	let mounted;
    	let dispose;
    	let label_levels = [{ class: /*classes*/ ctx[9] }, restProps(/*$$restProps*/ ctx[11])];
    	let label_data = {};

    	for (let i = 0; i < label_levels.length; i += 1) {
    		label_data = assign(label_data, label_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			label = element("label");
    			input = element("input");
    			t = space();
    			span = element("span");
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "name", /*name*/ ctx[3]);
    			input.disabled = /*disabled*/ ctx[1];
    			input.readOnly = /*readonly*/ ctx[2];
    			input.checked = /*checked*/ ctx[0];

    			input.value = input_value_value = typeof /*value*/ ctx[4] === 'undefined'
    			? ''
    			: /*value*/ ctx[4];

    			add_location(input, file$h, 85, 2, 1825);
    			attr_dev(span, "class", "toggle-icon");
    			add_location(span, file$h, 95, 2, 2017);
    			set_attributes(label, label_data);
    			add_location(label, file$h, 79, 0, 1702);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, input);
    			/*input_binding*/ ctx[15](input);
    			append_dev(label, t);
    			append_dev(label, span);
    			/*label_binding*/ ctx[16](label);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*onChange*/ ctx[10], false, false, false),
    					action_destroyer(useTooltip_action = useTooltip.call(null, label, {
    						tooltip: /*tooltip*/ ctx[5],
    						tooltipTrigger: /*tooltipTrigger*/ ctx[6]
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*name*/ 8) {
    				attr_dev(input, "name", /*name*/ ctx[3]);
    			}

    			if (dirty & /*disabled*/ 2) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[1]);
    			}

    			if (dirty & /*readonly*/ 4) {
    				prop_dev(input, "readOnly", /*readonly*/ ctx[2]);
    			}

    			if (dirty & /*checked*/ 1) {
    				prop_dev(input, "checked", /*checked*/ ctx[0]);
    			}

    			if (dirty & /*value*/ 16 && input_value_value !== (input_value_value = typeof /*value*/ ctx[4] === 'undefined'
    			? ''
    			: /*value*/ ctx[4])) {
    				prop_dev(input, "value", input_value_value);
    			}

    			set_attributes(label, label_data = get_spread_update(label_levels, [
    				dirty & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
    				dirty & /*$$restProps*/ 2048 && restProps(/*$$restProps*/ ctx[11])
    			]));

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 96) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[5],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[6]
    			});
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			/*input_binding*/ ctx[15](null);
    			/*label_binding*/ ctx[16](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance_1$2($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","init","checked","disabled","readonly","name","value","tooltip","tooltipTrigger","instance"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Toggle', slots, []);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { init = true } = $$props;
    	let { checked = undefined } = $$props;
    	let { disabled = undefined } = $$props;
    	let { readonly = undefined } = $$props;
    	let { name = undefined } = $$props;
    	let { value = undefined } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { tooltipTrigger = undefined } = $$props;
    	let el;
    	let inputEl;
    	let f7Toggle;

    	function instance() {
    		return f7Toggle;
    	}

    	let initialWatched = false;

    	function watchChecked(isChecked) {
    		if (!initialWatched) {
    			initialWatched = true;
    			return;
    		}

    		if (!f7Toggle) return;
    		f7Toggle.checked = isChecked;
    	}

    	function onChange(event) {
    		emit('change', [event]);
    	}

    	onMount(() => {
    		if (!init) return;

    		f7ready(() => {
    			f7Toggle = app$1.f7.toggle.create({
    				el,
    				on: {
    					change(toggle) {
    						emit('toggleChange', [toggle.checked]);
    						$$invalidate(0, checked = toggle.checked);
    					}
    				}
    			});
    		});
    	});

    	onDestroy(() => {
    		if (f7Toggle && f7Toggle.destroy && f7Toggle.$el) {
    			f7Toggle.destroy();
    			f7Toggle = null;
    		}
    	});

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(8, inputEl);
    		});
    	}

    	function label_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(7, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(12, className = $$new_props.class);
    		if ('init' in $$new_props) $$invalidate(13, init = $$new_props.init);
    		if ('checked' in $$new_props) $$invalidate(0, checked = $$new_props.checked);
    		if ('disabled' in $$new_props) $$invalidate(1, disabled = $$new_props.disabled);
    		if ('readonly' in $$new_props) $$invalidate(2, readonly = $$new_props.readonly);
    		if ('name' in $$new_props) $$invalidate(3, name = $$new_props.name);
    		if ('value' in $$new_props) $$invalidate(4, value = $$new_props.value);
    		if ('tooltip' in $$new_props) $$invalidate(5, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$new_props) $$invalidate(6, tooltipTrigger = $$new_props.tooltipTrigger);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		colorClasses,
    		classNames,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		useTooltip,
    		emit,
    		className,
    		init,
    		checked,
    		disabled,
    		readonly,
    		name,
    		value,
    		tooltip,
    		tooltipTrigger,
    		el,
    		inputEl,
    		f7Toggle,
    		instance,
    		initialWatched,
    		watchChecked,
    		onChange,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(12, className = $$new_props.className);
    		if ('init' in $$props) $$invalidate(13, init = $$new_props.init);
    		if ('checked' in $$props) $$invalidate(0, checked = $$new_props.checked);
    		if ('disabled' in $$props) $$invalidate(1, disabled = $$new_props.disabled);
    		if ('readonly' in $$props) $$invalidate(2, readonly = $$new_props.readonly);
    		if ('name' in $$props) $$invalidate(3, name = $$new_props.name);
    		if ('value' in $$props) $$invalidate(4, value = $$new_props.value);
    		if ('tooltip' in $$props) $$invalidate(5, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$props) $$invalidate(6, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('el' in $$props) $$invalidate(7, el = $$new_props.el);
    		if ('inputEl' in $$props) $$invalidate(8, inputEl = $$new_props.inputEl);
    		if ('f7Toggle' in $$props) f7Toggle = $$new_props.f7Toggle;
    		if ('initialWatched' in $$props) initialWatched = $$new_props.initialWatched;
    		if ('classes' in $$props) $$invalidate(9, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(9, classes = classNames('toggle', className, { disabled }, colorClasses($$props)));

    		if ($$self.$$.dirty & /*checked*/ 1) {
    			watchChecked(checked);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		checked,
    		disabled,
    		readonly,
    		name,
    		value,
    		tooltip,
    		tooltipTrigger,
    		el,
    		inputEl,
    		classes,
    		onChange,
    		$$restProps,
    		className,
    		init,
    		instance,
    		input_binding,
    		label_binding
    	];
    }

    class Toggle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance_1$2, create_fragment$k, safe_not_equal, {
    			class: 12,
    			init: 13,
    			checked: 0,
    			disabled: 1,
    			readonly: 2,
    			name: 3,
    			value: 4,
    			tooltip: 5,
    			tooltipTrigger: 6,
    			instance: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Toggle",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get class() {
    		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get init() {
    		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set init(value) {
    		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checked() {
    		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checked(value) {
    		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readonly() {
    		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readonly(value) {
    		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipTrigger() {
    		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipTrigger(value) {
    		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get instance() {
    		return this.$$.ctx[14];
    	}

    	set instance(value) {
    		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/text-editor.svelte generated by Svelte v3.44.0 */
    const file$g = "node_modules/framework7-svelte/esm/svelte/text-editor.svelte";

    const get_root_slot_changes$2 = dirty => ({
    	textEditor: dirty[0] & /*f7TextEditor*/ 2
    });

    const get_root_slot_context$2 = ctx => ({ textEditor: /*f7TextEditor*/ ctx[1] });

    const get_root_end_slot_changes$2 = dirty => ({
    	textEditor: dirty[0] & /*f7TextEditor*/ 2
    });

    const get_root_end_slot_context$2 = ctx => ({ textEditor: /*f7TextEditor*/ ctx[1] });

    const get_default_slot_changes$1 = dirty => ({
    	textEditor: dirty[0] & /*f7TextEditor*/ 2
    });

    const get_default_slot_context$1 = ctx => ({ textEditor: /*f7TextEditor*/ ctx[1] });

    const get_root_start_slot_changes$2 = dirty => ({
    	textEditor: dirty[0] & /*f7TextEditor*/ 2
    });

    const get_root_start_slot_context$2 = ctx => ({ textEditor: /*f7TextEditor*/ ctx[1] });

    function create_fragment$j(ctx) {
    	let div1;
    	let t0;
    	let div0;
    	let t1;
    	let t2;
    	let current;
    	const root_start_slot_template = /*#slots*/ ctx[17]["root-start"];
    	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[16], get_root_start_slot_context$2);
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], get_default_slot_context$1);
    	const root_end_slot_template = /*#slots*/ ctx[17]["root-end"];
    	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[16], get_root_end_slot_context$2);
    	const root_slot_template = /*#slots*/ ctx[17].root;
    	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[16], get_root_slot_context$2);
    	let div1_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
    	let div1_data = {};

    	for (let i = 0; i < div1_levels.length; i += 1) {
    		div1_data = assign(div1_data, div1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (root_start_slot) root_start_slot.c();
    			t0 = space();
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			t1 = space();
    			if (root_end_slot) root_end_slot.c();
    			t2 = space();
    			if (root_slot) root_slot.c();
    			attr_dev(div0, "class", "text-editor-content");
    			attr_dev(div0, "contenteditable", "");
    			add_location(div0, file$g, 120, 2, 2984);
    			set_attributes(div1, div1_data);
    			add_location(div1, file$g, 118, 0, 2862);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);

    			if (root_start_slot) {
    				root_start_slot.m(div1, null);
    			}

    			append_dev(div1, t0);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			append_dev(div1, t1);

    			if (root_end_slot) {
    				root_end_slot.m(div1, null);
    			}

    			append_dev(div1, t2);

    			if (root_slot) {
    				root_slot.m(div1, null);
    			}

    			/*div1_binding*/ ctx[18](div1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (root_start_slot) {
    				if (root_start_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/ 65538)) {
    					update_slot_base(
    						root_start_slot,
    						root_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(root_start_slot_template, /*$$scope*/ ctx[16], dirty, get_root_start_slot_changes$2),
    						get_root_start_slot_context$2
    					);
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/ 65538)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, get_default_slot_changes$1),
    						get_default_slot_context$1
    					);
    				}
    			}

    			if (root_end_slot) {
    				if (root_end_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/ 65538)) {
    					update_slot_base(
    						root_end_slot,
    						root_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(root_end_slot_template, /*$$scope*/ ctx[16], dirty, get_root_end_slot_changes$2),
    						get_root_end_slot_context$2
    					);
    				}
    			}

    			if (root_slot) {
    				if (root_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/ 65538)) {
    					update_slot_base(
    						root_slot,
    						root_slot_template,
    						ctx,
    						/*$$scope*/ ctx[16],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
    						: get_slot_changes(root_slot_template, /*$$scope*/ ctx[16], dirty, get_root_slot_changes$2),
    						get_root_slot_context$2
    					);
    				}
    			}

    			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
    				(!current || dirty[0] & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
    				dirty[0] & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(root_start_slot, local);
    			transition_in(default_slot, local);
    			transition_in(root_end_slot, local);
    			transition_in(root_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(root_start_slot, local);
    			transition_out(default_slot, local);
    			transition_out(root_end_slot, local);
    			transition_out(root_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (root_start_slot) root_start_slot.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    			if (root_end_slot) root_end_slot.d(detaching);
    			if (root_slot) root_slot.d(detaching);
    			/*div1_binding*/ ctx[18](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance_1$1($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","mode","value","buttons","customButtons","dividers","imageUrlText","linkUrlText","placeholder","clearFormattingOnPaste","resizable","instance"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text_editor', slots, ['root-start','default','root-end','root']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { mode = undefined } = $$props;
    	let { value = undefined } = $$props;
    	let { buttons = undefined } = $$props;
    	let { customButtons = undefined } = $$props;
    	let { dividers = undefined } = $$props;
    	let { imageUrlText = undefined } = $$props;
    	let { linkUrlText = undefined } = $$props;
    	let { placeholder = undefined } = $$props;
    	let { clearFormattingOnPaste = undefined } = $$props;
    	let { resizable = false } = $$props;
    	let el;
    	let f7TextEditor;

    	function instance() {
    		return f7TextEditor;
    	}

    	function watchValue(newValue) {
    		if (f7TextEditor) {
    			f7TextEditor.setValue(newValue);
    		}
    	}

    	function onChange(editor, editorValue) {
    		emit('textEditorChange', [editorValue]);
    	}

    	function onInput(editor, editorValue) {
    		emit('textEditorInput', [editorValue]);
    	}

    	function onFocus() {
    		emit('textEditorFocus');
    	}

    	function onBlur() {
    		emit('textEditorBlur');
    	}

    	function onButtonClick(editor, button) {
    		emit('textEditorButtonClick', [button]);
    	}

    	function onKeyboardOpen() {
    		emit('textEditorKeyboardOpen');
    	}

    	function onKeyboardClose() {
    		emit('textEditorKeyboardClose');
    	}

    	function onPopoverOpen() {
    		emit('textEditorPopoverOpen');
    	}

    	function onPopoverClose() {
    		emit('textEditorPopoverClose');
    	}

    	const onInsertLink = (editor, url) => {
    		emit('textEditorInsertLink', [url]);
    	};

    	const onInsertImage = (editor, url) => {
    		emit('textEditorInsertImage', [url]);
    	};

    	onMount(() => {
    		const params = noUndefinedProps({
    			el,
    			mode,
    			value,
    			buttons,
    			customButtons,
    			dividers,
    			imageUrlText,
    			linkUrlText,
    			placeholder,
    			clearFormattingOnPaste,
    			on: {
    				change: onChange,
    				input: onInput,
    				focus: onFocus,
    				blur: onBlur,
    				buttonClick: onButtonClick,
    				keyboardOpen: onKeyboardOpen,
    				keyboardClose: onKeyboardClose,
    				popoverOpen: onPopoverOpen,
    				popoverClose: onPopoverClose,
    				insertLink: onInsertLink,
    				insertImage: onInsertImage
    			}
    		});

    		f7ready(() => {
    			$$invalidate(1, f7TextEditor = app$1.f7.textEditor.create(params));
    		});
    	});

    	onDestroy(() => {
    		if (f7TextEditor && f7TextEditor.destroy) {
    			f7TextEditor.destroy();
    			$$invalidate(1, f7TextEditor = null);
    		}
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(0, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ('mode' in $$new_props) $$invalidate(5, mode = $$new_props.mode);
    		if ('value' in $$new_props) $$invalidate(6, value = $$new_props.value);
    		if ('buttons' in $$new_props) $$invalidate(7, buttons = $$new_props.buttons);
    		if ('customButtons' in $$new_props) $$invalidate(8, customButtons = $$new_props.customButtons);
    		if ('dividers' in $$new_props) $$invalidate(9, dividers = $$new_props.dividers);
    		if ('imageUrlText' in $$new_props) $$invalidate(10, imageUrlText = $$new_props.imageUrlText);
    		if ('linkUrlText' in $$new_props) $$invalidate(11, linkUrlText = $$new_props.linkUrlText);
    		if ('placeholder' in $$new_props) $$invalidate(12, placeholder = $$new_props.placeholder);
    		if ('clearFormattingOnPaste' in $$new_props) $$invalidate(13, clearFormattingOnPaste = $$new_props.clearFormattingOnPaste);
    		if ('resizable' in $$new_props) $$invalidate(14, resizable = $$new_props.resizable);
    		if ('$$scope' in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		colorClasses,
    		classNames,
    		noUndefinedProps,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		emit,
    		className,
    		mode,
    		value,
    		buttons,
    		customButtons,
    		dividers,
    		imageUrlText,
    		linkUrlText,
    		placeholder,
    		clearFormattingOnPaste,
    		resizable,
    		el,
    		f7TextEditor,
    		instance,
    		watchValue,
    		onChange,
    		onInput,
    		onFocus,
    		onBlur,
    		onButtonClick,
    		onKeyboardOpen,
    		onKeyboardClose,
    		onPopoverOpen,
    		onPopoverClose,
    		onInsertLink,
    		onInsertImage,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(4, className = $$new_props.className);
    		if ('mode' in $$props) $$invalidate(5, mode = $$new_props.mode);
    		if ('value' in $$props) $$invalidate(6, value = $$new_props.value);
    		if ('buttons' in $$props) $$invalidate(7, buttons = $$new_props.buttons);
    		if ('customButtons' in $$props) $$invalidate(8, customButtons = $$new_props.customButtons);
    		if ('dividers' in $$props) $$invalidate(9, dividers = $$new_props.dividers);
    		if ('imageUrlText' in $$props) $$invalidate(10, imageUrlText = $$new_props.imageUrlText);
    		if ('linkUrlText' in $$props) $$invalidate(11, linkUrlText = $$new_props.linkUrlText);
    		if ('placeholder' in $$props) $$invalidate(12, placeholder = $$new_props.placeholder);
    		if ('clearFormattingOnPaste' in $$props) $$invalidate(13, clearFormattingOnPaste = $$new_props.clearFormattingOnPaste);
    		if ('resizable' in $$props) $$invalidate(14, resizable = $$new_props.resizable);
    		if ('el' in $$props) $$invalidate(0, el = $$new_props.el);
    		if ('f7TextEditor' in $$props) $$invalidate(1, f7TextEditor = $$new_props.f7TextEditor);
    		if ('classes' in $$props) $$invalidate(2, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(2, classes = classNames(className, 'text-editor', resizable && 'text-editor-resizable', colorClasses($$props)));

    		if ($$self.$$.dirty[0] & /*value*/ 64) {
    			watchValue(value);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		el,
    		f7TextEditor,
    		classes,
    		$$restProps,
    		className,
    		mode,
    		value,
    		buttons,
    		customButtons,
    		dividers,
    		imageUrlText,
    		linkUrlText,
    		placeholder,
    		clearFormattingOnPaste,
    		resizable,
    		instance,
    		$$scope,
    		slots,
    		div1_binding
    	];
    }

    class Text_editor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance_1$1,
    			create_fragment$j,
    			safe_not_equal,
    			{
    				class: 4,
    				mode: 5,
    				value: 6,
    				buttons: 7,
    				customButtons: 8,
    				dividers: 9,
    				imageUrlText: 10,
    				linkUrlText: 11,
    				placeholder: 12,
    				clearFormattingOnPaste: 13,
    				resizable: 14,
    				instance: 15
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text_editor",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get class() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mode() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mode(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get buttons() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set buttons(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get customButtons() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set customButtons(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dividers() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dividers(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get imageUrlText() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageUrlText(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get linkUrlText() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set linkUrlText(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get clearFormattingOnPaste() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set clearFormattingOnPaste(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resizable() {
    		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resizable(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get instance() {
    		return this.$$.ctx[15];
    	}

    	set instance(value) {
    		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // eslint-disable-next-line
    var useSmartSelect = function useSmartSelect(props, setInstance, getEl) {
      var f7SmartSelect;
      onMount(function () {
        f7ready(function () {
          if (props.smartSelect) {
            var ssParams = extend({
              el: getEl()
            }, props.smartSelectParams || {});
            f7SmartSelect = app$1.f7.smartSelect.create(ssParams);
            setInstance(f7SmartSelect);
          }
        });
      });
      onDestroy(function () {
        if (f7SmartSelect && f7SmartSelect.destroy) {
          f7SmartSelect.destroy();
        }

        f7SmartSelect = null;
        setInstance(f7SmartSelect);
      });
    };

    // eslint-disable-next-line
    var getReactiveContext = function getReactiveContext(name, setValue) {
      var ctx = getContext(name);
      if (!ctx) return undefined;
      var value = ctx.value,
          subscribe = ctx.subscribe,
          unsubscribe = ctx.unsubscribe;
      subscribe(setValue);
      onDestroy(function () {
        unsubscribe(setValue);
      });
      return value;
    };

    /* node_modules/framework7-svelte/esm/svelte/link.svelte generated by Svelte v3.44.0 */
    const file$f = "node_modules/framework7-svelte/esm/svelte/link.svelte";

    // (110:2) {#if icon}
    function create_if_block_2$6(ctx) {
    	let useicon;
    	let current;

    	useicon = new Use_icon({
    			props: { icon: /*icon*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(useicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(useicon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const useicon_changes = {};
    			if (dirty[0] & /*icon*/ 256) useicon_changes.icon = /*icon*/ ctx[8];
    			useicon.$set(useicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(useicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(useicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(useicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(110:2) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (114:2) {#if typeof text !== 'undefined' || typeof badge !== 'undefined'}
    function create_if_block$a(ctx) {
    	let span;
    	let t0_value = plainText(/*text*/ ctx[0]) + "";
    	let t0;
    	let t1;
    	let current;
    	let if_block = typeof /*badge*/ ctx[1] !== 'undefined' && create_if_block_1$7(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			toggle_class(span, "tabbar-label", /*isTabbarLabel*/ ctx[6]);
    			add_location(span, file$f, 114, 4, 2938);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			if (if_block) if_block.m(span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*text*/ 1) && t0_value !== (t0_value = plainText(/*text*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

    			if (typeof /*badge*/ ctx[1] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(span, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*isTabbarLabel*/ 64) {
    				toggle_class(span, "tabbar-label", /*isTabbarLabel*/ ctx[6]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(114:2) {#if typeof text !== 'undefined' || typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (117:6) {#if typeof badge !== 'undefined'}
    function create_if_block_1$7(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[2],
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 4) badge_1_changes.color = /*badgeColor*/ ctx[2];

    			if (dirty[0] & /*$$scope, badge*/ 268435458) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(117:6) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (117:40) <Badge color={badgeColor}>
    function create_default_slot$9(ctx) {
    	let t_value = plainText(/*badge*/ ctx[1]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 2 && t_value !== (t_value = plainText(/*badge*/ ctx[1]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(117:40) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let a;
    	let t0;
    	let t1;
    	let useTooltip_action;
    	let useRouteProps_action;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*icon*/ ctx[8] && create_if_block_2$6(ctx);
    	const default_slot_template = /*#slots*/ ctx[26].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);
    	let if_block1 = (typeof /*text*/ ctx[0] !== 'undefined' || typeof /*badge*/ ctx[1] !== 'undefined') && create_if_block$a(ctx);
    	let a_levels = [{ class: /*classes*/ ctx[9] }, /*attrs*/ ctx[10]];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (default_slot) default_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			set_attributes(a, a_data);
    			add_location(a, file$f, 101, 0, 2657);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if (if_block0) if_block0.m(a, null);
    			append_dev(a, t0);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			append_dev(a, t1);
    			if (if_block1) if_block1.m(a, null);
    			/*a_binding*/ ctx[27](a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*onClick*/ ctx[11], false, false, false),
    					action_destroyer(useTooltip_action = useTooltip.call(null, a, {
    						tooltip: /*tooltip*/ ctx[3],
    						tooltipTrigger: /*tooltipTrigger*/ ctx[4]
    					})),
    					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[5]))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*icon*/ ctx[8]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 256) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(a, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[28],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[28])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[28], dirty, null),
    						null
    					);
    				}
    			}

    			if (typeof /*text*/ ctx[0] !== 'undefined' || typeof /*badge*/ ctx[1] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*text, badge*/ 3) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$a(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(a, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty[0] & /*classes*/ 512) && { class: /*classes*/ ctx[9] },
    				dirty[0] & /*attrs*/ 1024 && /*attrs*/ ctx[10]
    			]));

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 24) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[3],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[4]
    			});

    			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 32) useRouteProps_action.update.call(null, /*routeProps*/ ctx[5]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block0) if_block0.d();
    			if (default_slot) default_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			/*a_binding*/ ctx[27](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let isTabbarLabel;
    	let hrefComputed;
    	let attrs;
    	let hasDefaultSlots;
    	let iconOnlyComputed;
    	let classes;
    	let icon;

    	const omit_props_names = [
    		"class","noLinkClass","text","tabLink","tabLinkActive","tabbarLabel","iconOnly","badge","badgeColor","href","target","tooltip","tooltipTrigger","routeProps","smartSelect","smartSelectParams"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Link', slots, ['default']);
    	const $$slots = compute_slots(slots);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { noLinkClass = false } = $$props;
    	let { text = undefined } = $$props;
    	let { tabLink = undefined } = $$props;
    	let { tabLinkActive = false } = $$props;
    	let { tabbarLabel = false } = $$props;
    	let { iconOnly = false } = $$props;
    	let { badge = undefined } = $$props;
    	let { badgeColor = undefined } = $$props;
    	let { href = '#' } = $$props;
    	let { target = undefined } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { tooltipTrigger = undefined } = $$props;
    	let { routeProps = undefined } = $$props;
    	let { smartSelect = false } = $$props;
    	let { smartSelectParams = undefined } = $$props;
    	let el;
    	let f7SmartSelect;

    	let TabbarContext = getReactiveContext('TabbarContext', newValue => {
    		$$invalidate(22, TabbarContext = newValue);
    	}) || {};

    	function onClick() {
    		emit('click');
    	}

    	useSmartSelect(
    		{ smartSelect, smartSelectParams },
    		instance => {
    			f7SmartSelect = instance;
    		},
    		() => el
    	);

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(7, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(31, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(33, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(12, className = $$new_props.class);
    		if ('noLinkClass' in $$new_props) $$invalidate(13, noLinkClass = $$new_props.noLinkClass);
    		if ('text' in $$new_props) $$invalidate(0, text = $$new_props.text);
    		if ('tabLink' in $$new_props) $$invalidate(14, tabLink = $$new_props.tabLink);
    		if ('tabLinkActive' in $$new_props) $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
    		if ('tabbarLabel' in $$new_props) $$invalidate(16, tabbarLabel = $$new_props.tabbarLabel);
    		if ('iconOnly' in $$new_props) $$invalidate(17, iconOnly = $$new_props.iconOnly);
    		if ('badge' in $$new_props) $$invalidate(1, badge = $$new_props.badge);
    		if ('badgeColor' in $$new_props) $$invalidate(2, badgeColor = $$new_props.badgeColor);
    		if ('href' in $$new_props) $$invalidate(18, href = $$new_props.href);
    		if ('target' in $$new_props) $$invalidate(19, target = $$new_props.target);
    		if ('tooltip' in $$new_props) $$invalidate(3, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$new_props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('routeProps' in $$new_props) $$invalidate(5, routeProps = $$new_props.routeProps);
    		if ('smartSelect' in $$new_props) $$invalidate(20, smartSelect = $$new_props.smartSelect);
    		if ('smartSelectParams' in $$new_props) $$invalidate(21, smartSelectParams = $$new_props.smartSelectParams);
    		if ('$$scope' in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		colorClasses,
    		routerAttrs,
    		routerClasses,
    		actionsAttrs,
    		actionsClasses,
    		classNames,
    		extend,
    		isStringProp,
    		plainText,
    		createEmitter,
    		restProps,
    		useTooltip,
    		useSmartSelect,
    		useRouteProps,
    		useIcon,
    		getReactiveContext,
    		UseIcon: Use_icon,
    		Badge,
    		emit,
    		className,
    		noLinkClass,
    		text,
    		tabLink,
    		tabLinkActive,
    		tabbarLabel,
    		iconOnly,
    		badge,
    		badgeColor,
    		href,
    		target,
    		tooltip,
    		tooltipTrigger,
    		routeProps,
    		smartSelect,
    		smartSelectParams,
    		el,
    		f7SmartSelect,
    		TabbarContext,
    		onClick,
    		icon,
    		iconOnlyComputed,
    		isTabbarLabel,
    		classes,
    		hasDefaultSlots,
    		hrefComputed,
    		attrs
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(31, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(12, className = $$new_props.className);
    		if ('noLinkClass' in $$props) $$invalidate(13, noLinkClass = $$new_props.noLinkClass);
    		if ('text' in $$props) $$invalidate(0, text = $$new_props.text);
    		if ('tabLink' in $$props) $$invalidate(14, tabLink = $$new_props.tabLink);
    		if ('tabLinkActive' in $$props) $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
    		if ('tabbarLabel' in $$props) $$invalidate(16, tabbarLabel = $$new_props.tabbarLabel);
    		if ('iconOnly' in $$props) $$invalidate(17, iconOnly = $$new_props.iconOnly);
    		if ('badge' in $$props) $$invalidate(1, badge = $$new_props.badge);
    		if ('badgeColor' in $$props) $$invalidate(2, badgeColor = $$new_props.badgeColor);
    		if ('href' in $$props) $$invalidate(18, href = $$new_props.href);
    		if ('target' in $$props) $$invalidate(19, target = $$new_props.target);
    		if ('tooltip' in $$props) $$invalidate(3, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('routeProps' in $$props) $$invalidate(5, routeProps = $$new_props.routeProps);
    		if ('smartSelect' in $$props) $$invalidate(20, smartSelect = $$new_props.smartSelect);
    		if ('smartSelectParams' in $$props) $$invalidate(21, smartSelectParams = $$new_props.smartSelectParams);
    		if ('el' in $$props) $$invalidate(7, el = $$new_props.el);
    		if ('f7SmartSelect' in $$props) f7SmartSelect = $$new_props.f7SmartSelect;
    		if ('TabbarContext' in $$props) $$invalidate(22, TabbarContext = $$new_props.TabbarContext);
    		if ('icon' in $$props) $$invalidate(8, icon = $$new_props.icon);
    		if ('iconOnlyComputed' in $$props) $$invalidate(23, iconOnlyComputed = $$new_props.iconOnlyComputed);
    		if ('isTabbarLabel' in $$props) $$invalidate(6, isTabbarLabel = $$new_props.isTabbarLabel);
    		if ('classes' in $$props) $$invalidate(9, classes = $$new_props.classes);
    		if ('hasDefaultSlots' in $$props) $$invalidate(24, hasDefaultSlots = $$new_props.hasDefaultSlots);
    		if ('hrefComputed' in $$props) $$invalidate(25, hrefComputed = $$new_props.hrefComputed);
    		if ('attrs' in $$props) $$invalidate(10, attrs = $$new_props.attrs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*tabbarLabel, TabbarContext*/ 4259840) {
    			$$invalidate(6, isTabbarLabel = tabbarLabel || TabbarContext.tabbarHasLabels);
    		}

    		if ($$self.$$.dirty[0] & /*href*/ 262144) {
    			$$invalidate(25, hrefComputed = href === true ? '#' : href || undefined);
    		}

    		$$invalidate(10, attrs = extend(
    			{
    				href: hrefComputed,
    				target,
    				'data-tab': isStringProp(tabLink) && tabLink || undefined,
    				...restProps($$restProps)
    			},
    			routerAttrs($$props),
    			actionsAttrs($$props)
    		));

    		if ($$self.$$.dirty[0] & /*iconOnly, text, hasDefaultSlots*/ 16908289) {
    			$$invalidate(23, iconOnlyComputed = iconOnly || !text && !hasDefaultSlots);
    		}

    		$$invalidate(9, classes = classNames(
    			className,
    			{
    				link: !(noLinkClass || isTabbarLabel),
    				'icon-only': iconOnlyComputed,
    				'tab-link': tabLink || tabLink === '',
    				'tab-link-active': tabLinkActive,
    				'smart-select': smartSelect
    			},
    			colorClasses($$props),
    			routerClasses($$props),
    			actionsClasses($$props)
    		));

    		$$invalidate(8, icon = useIcon($$props));
    	};

    	$$invalidate(24, hasDefaultSlots = $$slots.default);
    	$$props = exclude_internal_props($$props);

    	return [
    		text,
    		badge,
    		badgeColor,
    		tooltip,
    		tooltipTrigger,
    		routeProps,
    		isTabbarLabel,
    		el,
    		icon,
    		classes,
    		attrs,
    		onClick,
    		className,
    		noLinkClass,
    		tabLink,
    		tabLinkActive,
    		tabbarLabel,
    		iconOnly,
    		href,
    		target,
    		smartSelect,
    		smartSelectParams,
    		TabbarContext,
    		iconOnlyComputed,
    		hasDefaultSlots,
    		hrefComputed,
    		slots,
    		a_binding,
    		$$scope
    	];
    }

    class Link extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$h,
    			create_fragment$i,
    			safe_not_equal,
    			{
    				class: 12,
    				noLinkClass: 13,
    				text: 0,
    				tabLink: 14,
    				tabLinkActive: 15,
    				tabbarLabel: 16,
    				iconOnly: 17,
    				badge: 1,
    				badgeColor: 2,
    				href: 18,
    				target: 19,
    				tooltip: 3,
    				tooltipTrigger: 4,
    				routeProps: 5,
    				smartSelect: 20,
    				smartSelectParams: 21
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Link",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get class() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noLinkClass() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noLinkClass(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabLink() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabLink(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabLinkActive() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabLinkActive(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabbarLabel() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabbarLabel(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconOnly() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconOnly(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get badge() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set badge(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get badgeColor() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set badgeColor(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get target() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set target(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipTrigger() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipTrigger(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get routeProps() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routeProps(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smartSelect() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smartSelect(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smartSelectParams() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smartSelectParams(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // eslint-disable-next-line
    var setReactiveContext = function setReactiveContext(name, getValue) {
      var contextCallbacks = [];

      var contextSubscribe = function contextSubscribe(callback) {
        contextCallbacks.push(callback);
      };

      var contextUnsubscribe = function contextUnsubscribe(callback) {
        if (contextCallbacks.indexOf(callback) >= 0) {
          contextCallbacks.splice(contextCallbacks.indexOf, callback);
        }
      };

      var contextRunCallbacks = function contextRunCallbacks() {
        contextCallbacks.forEach(function (callback) {
          callback(getValue());
        });
      };

      setContext(name, {
        value: getValue(),
        subscribe: contextSubscribe,
        unsubscribe: contextUnsubscribe
      });
      beforeUpdate(function () {
        contextRunCallbacks();
      });
    };

    /* node_modules/framework7-svelte/esm/svelte/list-input.svelte generated by Svelte v3.44.0 */
    const file$e = "node_modules/framework7-svelte/esm/svelte/list-input.svelte";
    const get_content_end_slot_changes_1$1 = dirty => ({});
    const get_content_end_slot_context_1$1 = ctx => ({});
    const get_content_slot_changes_1$1 = dirty => ({});
    const get_content_slot_context_1$1 = ctx => ({});
    const get_inner_end_slot_changes_1$1 = dirty => ({});
    const get_inner_end_slot_context_1$1 = ctx => ({});
    const get_inner_slot_changes_1$1 = dirty => ({});
    const get_inner_slot_context_1$1 = ctx => ({});
    const get_info_slot_changes_1 = dirty => ({});
    const get_info_slot_context_1 = ctx => ({});
    const get_error_message_slot_changes_1 = dirty => ({});
    const get_error_message_slot_context_1 = ctx => ({});
    const get_input_slot_changes_1 = dirty => ({});
    const get_input_slot_context_1 = ctx => ({});
    const get_label_slot_changes_1 = dirty => ({});
    const get_label_slot_context_1 = ctx => ({});
    const get_inner_start_slot_changes_1$1 = dirty => ({});
    const get_inner_start_slot_context_1$1 = ctx => ({});
    const get_media_slot_changes_1$1 = dirty => ({});
    const get_media_slot_context_1$1 = ctx => ({});
    const get_content_start_slot_changes_1$1 = dirty => ({});
    const get_content_start_slot_context_1$1 = ctx => ({});
    const get_root_end_slot_changes$1 = dirty => ({});
    const get_root_end_slot_context$1 = ctx => ({});
    const get_root_slot_changes$1 = dirty => ({});
    const get_root_slot_context$1 = ctx => ({});
    const get_content_end_slot_changes$1 = dirty => ({});
    const get_content_end_slot_context$1 = ctx => ({});
    const get_content_slot_changes$1 = dirty => ({});
    const get_content_slot_context$1 = ctx => ({});
    const get_inner_end_slot_changes$1 = dirty => ({});
    const get_inner_end_slot_context$1 = ctx => ({});
    const get_inner_slot_changes$1 = dirty => ({});
    const get_inner_slot_context$1 = ctx => ({});
    const get_info_slot_changes = dirty => ({});
    const get_info_slot_context = ctx => ({});
    const get_error_message_slot_changes = dirty => ({});
    const get_error_message_slot_context = ctx => ({});
    const get_input_slot_changes = dirty => ({});
    const get_input_slot_context = ctx => ({});
    const get_label_slot_changes = dirty => ({});
    const get_label_slot_context = ctx => ({});
    const get_inner_start_slot_changes$1 = dirty => ({});
    const get_inner_start_slot_context$1 = ctx => ({});
    const get_media_slot_changes$1 = dirty => ({});
    const get_media_slot_context$1 = ctx => ({});
    const get_content_start_slot_changes$1 = dirty => ({});
    const get_content_start_slot_context$1 = ctx => ({});
    const get_root_start_slot_changes$1 = dirty => ({});
    const get_root_start_slot_context$1 = ctx => ({});

    // (577:0) {:else}
    function create_else_block_1$2(ctx) {
    	let div2;
    	let t0;
    	let t1;
    	let t2;
    	let div1;
    	let t3;
    	let t4;
    	let div0;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let t10;
    	let t11;
    	let t12;
    	let current;
    	const content_start_slot_template = /*#slots*/ ctx[77]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[76], get_content_start_slot_context_1$1);
    	let if_block0 = /*isSortable*/ ctx[51] && /*isSortableOpposite*/ ctx[50] && create_if_block_23$1(ctx);
    	let if_block1 = (/*media*/ ctx[1] || /*hasMediaSlots*/ ctx[48]) && create_if_block_21$1(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[77]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[76], get_inner_start_slot_context_1$1);
    	let if_block2 = (typeof /*label*/ ctx[36] !== 'undefined' || /*hasLabelSlots*/ ctx[47]) && create_if_block_20$1(ctx);
    	let if_block3 = /*input*/ ctx[3] && create_if_block_16$1(ctx);
    	const input_slot_template = /*#slots*/ ctx[77].input;
    	const input_slot = create_slot(input_slot_template, ctx, /*$$scope*/ ctx[76], get_input_slot_context_1);
    	let if_block4 = /*hasErrorMessage*/ ctx[38] && /*errorMessageForce*/ ctx[34] && create_if_block_15$1(ctx);
    	let if_block5 = /*clearButton*/ ctx[32] && create_if_block_14$1(ctx);
    	let if_block6 = (typeof /*info*/ ctx[35] !== 'undefined' || /*hasInfoSlots*/ ctx[39]) && create_if_block_13$1(ctx);
    	const inner_slot_template = /*#slots*/ ctx[77].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[76], get_inner_slot_context_1$1);
    	const inner_end_slot_template = /*#slots*/ ctx[77]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[76], get_inner_end_slot_context_1$1);
    	const content_slot_template = /*#slots*/ ctx[77].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[76], get_content_slot_context_1$1);
    	const content_end_slot_template = /*#slots*/ ctx[77]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[76], get_content_end_slot_context_1$1);
    	let div2_levels = [{ class: /*itemContentClasses*/ ctx[45] }, restProps(/*$$restProps*/ ctx[56])];
    	let div2_data = {};

    	for (let i = 0; i < div2_levels.length; i += 1) {
    		div2_data = assign(div2_data, div2_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			if (content_start_slot) content_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div1 = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			div0 = element("div");
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (input_slot) input_slot.c();
    			t6 = space();
    			if (if_block4) if_block4.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			t9 = space();
    			if (inner_slot) inner_slot.c();
    			t10 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t11 = space();
    			if (content_slot) content_slot.c();
    			t12 = space();
    			if (content_end_slot) content_end_slot.c();
    			attr_dev(div0, "class", /*inputWrapClasses*/ ctx[43]);
    			add_location(div0, file$e, 597, 6, 17800);
    			attr_dev(div1, "class", "item-inner");
    			add_location(div1, file$e, 589, 4, 17554);
    			set_attributes(div2, div2_data);
    			add_location(div2, file$e, 577, 2, 17178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);

    			if (content_start_slot) {
    				content_start_slot.m(div2, null);
    			}

    			append_dev(div2, t0);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t1);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);

    			if (inner_start_slot) {
    				inner_start_slot.m(div1, null);
    			}

    			append_dev(div1, t3);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div1, t4);
    			append_dev(div1, div0);
    			if (if_block3) if_block3.m(div0, null);
    			append_dev(div0, t5);

    			if (input_slot) {
    				input_slot.m(div0, null);
    			}

    			append_dev(div0, t6);
    			if (if_block4) if_block4.m(div0, null);
    			append_dev(div0, t7);
    			if (if_block5) if_block5.m(div0, null);
    			append_dev(div0, t8);
    			if (if_block6) if_block6.m(div0, null);
    			append_dev(div1, t9);

    			if (inner_slot) {
    				inner_slot.m(div1, null);
    			}

    			append_dev(div1, t10);

    			if (inner_end_slot) {
    				inner_end_slot.m(div1, null);
    			}

    			append_dev(div2, t11);

    			if (content_slot) {
    				content_slot.m(div2, null);
    			}

    			append_dev(div2, t12);

    			if (content_end_slot) {
    				content_end_slot.m(div2, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[76], dirty, get_content_start_slot_changes_1$1),
    						get_content_start_slot_context_1$1
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[51] && /*isSortableOpposite*/ ctx[50]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_23$1(ctx);
    					if_block0.c();
    					if_block0.m(div2, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*media*/ ctx[1] || /*hasMediaSlots*/ ctx[48]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*media*/ 2 | dirty[1] & /*hasMediaSlots*/ 131072) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_21$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div2, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[76], dirty, get_inner_start_slot_changes_1$1),
    						get_inner_start_slot_context_1$1
    					);
    				}
    			}

    			if (typeof /*label*/ ctx[36] !== 'undefined' || /*hasLabelSlots*/ ctx[47]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*label, hasLabelSlots*/ 65568) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_20$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div1, t4);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*input*/ ctx[3]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*input*/ 8) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_16$1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div0, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (input_slot) {
    				if (input_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						input_slot,
    						input_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(input_slot_template, /*$$scope*/ ctx[76], dirty, get_input_slot_changes_1),
    						get_input_slot_context_1
    					);
    				}
    			}

    			if (/*hasErrorMessage*/ ctx[38] && /*errorMessageForce*/ ctx[34]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasErrorMessage, errorMessageForce*/ 136) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_15$1(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div0, t7);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*clearButton*/ ctx[32]) {
    				if (if_block5) ; else {
    					if_block5 = create_if_block_14$1(ctx);
    					if_block5.c();
    					if_block5.m(div0, t8);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (typeof /*info*/ ctx[35] !== 'undefined' || /*hasInfoSlots*/ ctx[39]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*info, hasInfoSlots*/ 272) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_13$1(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(div0, null);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[1] & /*inputWrapClasses*/ 4096) {
    				attr_dev(div0, "class", /*inputWrapClasses*/ ctx[43]);
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[76], dirty, get_inner_slot_changes_1$1),
    						get_inner_slot_context_1$1
    					);
    				}
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[76], dirty, get_inner_end_slot_changes_1$1),
    						get_inner_end_slot_context_1$1
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[76], dirty, get_content_slot_changes_1$1),
    						get_content_slot_context_1$1
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[76], dirty, get_content_end_slot_changes_1$1),
    						get_content_end_slot_context_1$1
    					);
    				}
    			}

    			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
    				(!current || dirty[1] & /*itemContentClasses*/ 16384) && { class: /*itemContentClasses*/ ctx[45] },
    				dirty[1] & /*$$restProps*/ 33554432 && restProps(/*$$restProps*/ ctx[56])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(input_slot, local);
    			transition_in(if_block4);
    			transition_in(if_block6);
    			transition_in(inner_slot, local);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(input_slot, local);
    			transition_out(if_block4);
    			transition_out(if_block6);
    			transition_out(inner_slot, local);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (input_slot) input_slot.d(detaching);
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (inner_slot) inner_slot.d(detaching);
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(577:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (373:0) {#if wrap}
    function create_if_block$9(ctx) {
    	let li;
    	let t0;
    	let div2;
    	let t1;
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let t5;
    	let div0;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let t10;
    	let t11;
    	let t12;
    	let t13;
    	let t14;
    	let t15;
    	let t16;
    	let current;
    	const root_start_slot_template = /*#slots*/ ctx[77]["root-start"];
    	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[76], get_root_start_slot_context$1);
    	const content_start_slot_template = /*#slots*/ ctx[77]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[76], get_content_start_slot_context$1);
    	let if_block0 = /*isSortable*/ ctx[51] && /*isSortableOpposite*/ ctx[50] && create_if_block_12$1(ctx);
    	let if_block1 = (/*media*/ ctx[1] || /*hasMediaSlots*/ ctx[48]) && create_if_block_10$1(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[77]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[76], get_inner_start_slot_context$1);
    	let if_block2 = (typeof /*label*/ ctx[36] !== 'undefined' || /*hasLabelSlots*/ ctx[47]) && create_if_block_9$1(ctx);
    	let if_block3 = /*input*/ ctx[3] && create_if_block_5$1(ctx);
    	const input_slot_template = /*#slots*/ ctx[77].input;
    	const input_slot = create_slot(input_slot_template, ctx, /*$$scope*/ ctx[76], get_input_slot_context);
    	let if_block4 = /*hasErrorMessage*/ ctx[38] && /*errorMessageForce*/ ctx[34] && create_if_block_4$1(ctx);
    	let if_block5 = /*clearButton*/ ctx[32] && create_if_block_3$4(ctx);
    	let if_block6 = (typeof /*info*/ ctx[35] !== 'undefined' || /*hasInfoSlots*/ ctx[39]) && create_if_block_2$5(ctx);
    	const inner_slot_template = /*#slots*/ ctx[77].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[76], get_inner_slot_context$1);
    	const inner_end_slot_template = /*#slots*/ ctx[77]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[76], get_inner_end_slot_context$1);
    	const content_slot_template = /*#slots*/ ctx[77].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[76], get_content_slot_context$1);
    	const content_end_slot_template = /*#slots*/ ctx[77]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[76], get_content_end_slot_context$1);
    	let if_block7 = /*isSortable*/ ctx[51] && !/*isSortableOpposite*/ ctx[50] && create_if_block_1$6(ctx);
    	const root_slot_template = /*#slots*/ ctx[77].root;
    	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[76], get_root_slot_context$1);
    	const root_end_slot_template = /*#slots*/ ctx[77]["root-end"];
    	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[76], get_root_end_slot_context$1);
    	let li_levels = [{ class: /*classes*/ ctx[42] }, restProps(/*$$restProps*/ ctx[56])];
    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (root_start_slot) root_start_slot.c();
    			t0 = space();
    			div2 = element("div");
    			if (content_start_slot) content_start_slot.c();
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			div1 = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			t5 = space();
    			div0 = element("div");
    			if (if_block3) if_block3.c();
    			t6 = space();
    			if (input_slot) input_slot.c();
    			t7 = space();
    			if (if_block4) if_block4.c();
    			t8 = space();
    			if (if_block5) if_block5.c();
    			t9 = space();
    			if (if_block6) if_block6.c();
    			t10 = space();
    			if (inner_slot) inner_slot.c();
    			t11 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t12 = space();
    			if (content_slot) content_slot.c();
    			t13 = space();
    			if (content_end_slot) content_end_slot.c();
    			t14 = space();
    			if (if_block7) if_block7.c();
    			t15 = space();
    			if (root_slot) root_slot.c();
    			t16 = space();
    			if (root_end_slot) root_end_slot.c();
    			attr_dev(div0, "class", /*inputWrapClasses*/ ctx[43]);
    			add_location(div0, file$e, 395, 8, 11064);
    			attr_dev(div1, "class", "item-inner");
    			add_location(div1, file$e, 387, 6, 10802);
    			attr_dev(div2, "class", /*itemContentClasses*/ ctx[45]);
    			add_location(div2, file$e, 375, 4, 10432);
    			set_attributes(li, li_data);
    			add_location(li, file$e, 373, 2, 10348);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (root_start_slot) {
    				root_start_slot.m(li, null);
    			}

    			append_dev(li, t0);
    			append_dev(li, div2);

    			if (content_start_slot) {
    				content_start_slot.m(div2, null);
    			}

    			append_dev(div2, t1);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t2);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			if (inner_start_slot) {
    				inner_start_slot.m(div1, null);
    			}

    			append_dev(div1, t4);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div1, t5);
    			append_dev(div1, div0);
    			if (if_block3) if_block3.m(div0, null);
    			append_dev(div0, t6);

    			if (input_slot) {
    				input_slot.m(div0, null);
    			}

    			append_dev(div0, t7);
    			if (if_block4) if_block4.m(div0, null);
    			append_dev(div0, t8);
    			if (if_block5) if_block5.m(div0, null);
    			append_dev(div0, t9);
    			if (if_block6) if_block6.m(div0, null);
    			append_dev(div1, t10);

    			if (inner_slot) {
    				inner_slot.m(div1, null);
    			}

    			append_dev(div1, t11);

    			if (inner_end_slot) {
    				inner_end_slot.m(div1, null);
    			}

    			append_dev(div2, t12);

    			if (content_slot) {
    				content_slot.m(div2, null);
    			}

    			append_dev(div2, t13);

    			if (content_end_slot) {
    				content_end_slot.m(div2, null);
    			}

    			append_dev(li, t14);
    			if (if_block7) if_block7.m(li, null);
    			append_dev(li, t15);

    			if (root_slot) {
    				root_slot.m(li, null);
    			}

    			append_dev(li, t16);

    			if (root_end_slot) {
    				root_end_slot.m(li, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (root_start_slot) {
    				if (root_start_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						root_start_slot,
    						root_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(root_start_slot_template, /*$$scope*/ ctx[76], dirty, get_root_start_slot_changes$1),
    						get_root_start_slot_context$1
    					);
    				}
    			}

    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[76], dirty, get_content_start_slot_changes$1),
    						get_content_start_slot_context$1
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[51] && /*isSortableOpposite*/ ctx[50]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_12$1(ctx);
    					if_block0.c();
    					if_block0.m(div2, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*media*/ ctx[1] || /*hasMediaSlots*/ ctx[48]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*media*/ 2 | dirty[1] & /*hasMediaSlots*/ 131072) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_10$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div2, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[76], dirty, get_inner_start_slot_changes$1),
    						get_inner_start_slot_context$1
    					);
    				}
    			}

    			if (typeof /*label*/ ctx[36] !== 'undefined' || /*hasLabelSlots*/ ctx[47]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*label, hasLabelSlots*/ 65568) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_9$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div1, t5);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*input*/ ctx[3]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*input*/ 8) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_5$1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div0, t6);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (input_slot) {
    				if (input_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						input_slot,
    						input_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(input_slot_template, /*$$scope*/ ctx[76], dirty, get_input_slot_changes),
    						get_input_slot_context
    					);
    				}
    			}

    			if (/*hasErrorMessage*/ ctx[38] && /*errorMessageForce*/ ctx[34]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasErrorMessage, errorMessageForce*/ 136) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_4$1(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div0, t8);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*clearButton*/ ctx[32]) {
    				if (if_block5) ; else {
    					if_block5 = create_if_block_3$4(ctx);
    					if_block5.c();
    					if_block5.m(div0, t9);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (typeof /*info*/ ctx[35] !== 'undefined' || /*hasInfoSlots*/ ctx[39]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*info, hasInfoSlots*/ 272) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_2$5(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(div0, null);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[1] & /*inputWrapClasses*/ 4096) {
    				attr_dev(div0, "class", /*inputWrapClasses*/ ctx[43]);
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[76], dirty, get_inner_slot_changes$1),
    						get_inner_slot_context$1
    					);
    				}
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[76], dirty, get_inner_end_slot_changes$1),
    						get_inner_end_slot_context$1
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[76], dirty, get_content_slot_changes$1),
    						get_content_slot_context$1
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[76], dirty, get_content_end_slot_changes$1),
    						get_content_end_slot_context$1
    					);
    				}
    			}

    			if (!current || dirty[1] & /*itemContentClasses*/ 16384) {
    				attr_dev(div2, "class", /*itemContentClasses*/ ctx[45]);
    			}

    			if (/*isSortable*/ ctx[51] && !/*isSortableOpposite*/ ctx[50]) {
    				if (if_block7) ; else {
    					if_block7 = create_if_block_1$6(ctx);
    					if_block7.c();
    					if_block7.m(li, t15);
    				}
    			} else if (if_block7) {
    				if_block7.d(1);
    				if_block7 = null;
    			}

    			if (root_slot) {
    				if (root_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						root_slot,
    						root_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(root_slot_template, /*$$scope*/ ctx[76], dirty, get_root_slot_changes$1),
    						get_root_slot_context$1
    					);
    				}
    			}

    			if (root_end_slot) {
    				if (root_end_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						root_end_slot,
    						root_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(root_end_slot_template, /*$$scope*/ ctx[76], dirty, get_root_end_slot_changes$1),
    						get_root_end_slot_context$1
    					);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				(!current || dirty[1] & /*classes*/ 2048) && { class: /*classes*/ ctx[42] },
    				dirty[1] & /*$$restProps*/ 33554432 && restProps(/*$$restProps*/ ctx[56])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(root_start_slot, local);
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(input_slot, local);
    			transition_in(if_block4);
    			transition_in(if_block6);
    			transition_in(inner_slot, local);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			transition_in(root_slot, local);
    			transition_in(root_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(root_start_slot, local);
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(input_slot, local);
    			transition_out(if_block4);
    			transition_out(if_block6);
    			transition_out(inner_slot, local);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			transition_out(root_slot, local);
    			transition_out(root_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (root_start_slot) root_start_slot.d(detaching);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (input_slot) input_slot.d(detaching);
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (inner_slot) inner_slot.d(detaching);
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    			if (if_block7) if_block7.d();
    			if (root_slot) root_slot.d(detaching);
    			if (root_end_slot) root_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(373:0) {#if wrap}",
    		ctx
    	});

    	return block;
    }

    // (580:4) {#if isSortable && isSortableOpposite}
    function create_if_block_23$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$e, 580, 6, 17322);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_23$1.name,
    		type: "if",
    		source: "(580:4) {#if isSortable && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (584:4) {#if media || hasMediaSlots}
    function create_if_block_21$1(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[1] !== 'undefined' && create_if_block_22$1(ctx);
    	const media_slot_template = /*#slots*/ ctx[77].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[76], get_media_slot_context_1$1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$e, 584, 6, 17405);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[1] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_22$1(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[76], dirty, get_media_slot_changes_1$1),
    						get_media_slot_context_1$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_21$1.name,
    		type: "if",
    		source: "(584:4) {#if media || hasMediaSlots}",
    		ctx
    	});

    	return block;
    }

    // (586:8) {#if typeof media !== 'undefined'}
    function create_if_block_22$1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[1])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$e, 585, 42, 17472);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 2 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[1])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_22$1.name,
    		type: "if",
    		source: "(586:8) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (592:6) {#if typeof label !== 'undefined' || hasLabelSlots}
    function create_if_block_20$1(ctx) {
    	let div;
    	let t0_value = plainText(/*label*/ ctx[36]) + "";
    	let t0;
    	let t1;
    	let current;
    	const label_slot_template = /*#slots*/ ctx[77].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[76], get_label_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (label_slot) label_slot.c();
    			attr_dev(div, "class", /*labelClasses*/ ctx[44]);
    			add_location(div, file$e, 592, 8, 17679);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (label_slot) {
    				label_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[1] & /*label*/ 32) && t0_value !== (t0_value = plainText(/*label*/ ctx[36]) + "")) set_data_dev(t0, t0_value);

    			if (label_slot) {
    				if (label_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[76], dirty, get_label_slot_changes_1),
    						get_label_slot_context_1
    					);
    				}
    			}

    			if (!current || dirty[1] & /*labelClasses*/ 8192) {
    				attr_dev(div, "class", /*labelClasses*/ ctx[44]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (label_slot) label_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_20$1.name,
    		type: "if",
    		source: "(592:6) {#if typeof label !== 'undefined' || hasLabelSlots}",
    		ctx
    	});

    	return block;
    }

    // (599:8) {#if input}
    function create_if_block_16$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	const if_block_creators = [
    		create_if_block_17$1,
    		create_if_block_18$1,
    		create_if_block_19$1,
    		create_else_block_2$2
    	];

    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*type*/ ctx[4] === 'select') return 0;
    		if (/*type*/ ctx[4] === 'textarea') return 1;
    		if (/*type*/ ctx[4] === 'texteditor') return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16$1.name,
    		type: "if",
    		source: "(599:8) {#if input}",
    		ctx
    	});

    	return block;
    }

    // (702:10) {:else}
    function create_else_block_2$2(ctx) {
    	let input_1;
    	let input_1_validate_value;
    	let input_1_data_validate_value;
    	let input_1_data_validate_on_blur_value;
    	let input_1_data_error_message_value;
    	let input_1_value_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
    			attr_dev(input_1, "name", /*name*/ ctx[5]);
    			attr_dev(input_1, "type", /*inputType*/ ctx[40]);
    			attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
    			attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
    			attr_dev(input_1, "id", /*inputId*/ ctx[11]);
    			attr_dev(input_1, "size", /*size*/ ctx[12]);
    			attr_dev(input_1, "accept", /*accept*/ ctx[13]);
    			attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
    			attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
    			attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
    			input_1.autofocus = /*autofocus*/ ctx[18];
    			attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
    			input_1.disabled = /*disabled*/ ctx[9];
    			attr_dev(input_1, "max", /*max*/ ctx[20]);
    			attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
    			attr_dev(input_1, "min", /*min*/ ctx[21]);
    			attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
    			attr_dev(input_1, "step", /*step*/ ctx[22]);
    			input_1.multiple = /*multiple*/ ctx[25];
    			input_1.readOnly = /*readonly*/ ctx[7];
    			input_1.required = /*required*/ ctx[8];
    			attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);

    			attr_dev(input_1, "validate", input_1_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined);

    			attr_dev(input_1, "data-validate", input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);

    			attr_dev(input_1, "data-error-message", input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33]);

    			attr_dev(input_1, "class", /*inputClasses*/ ctx[46]);

    			input_1.value = input_1_value_value = /*type*/ ctx[4] === 'datepicker' || /*type*/ ctx[4] === 'colorpicker' || /*type*/ ctx[4] === 'file'
    			? ''
    			: /*inputValue*/ ctx[49];

    			add_location(input_1, file$e, 702, 12, 21184);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    			/*input_1_binding_1*/ ctx[83](input_1);
    			if (/*autofocus*/ ctx[18]) input_1.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(input_1, "focus", /*onFocus*/ ctx[53], false, false, false),
    					listen_dev(input_1, "blur", /*onBlur*/ ctx[54], false, false, false),
    					listen_dev(input_1, "input", /*onInput*/ ctx[52], false, false, false),
    					listen_dev(input_1, "change", /*onChange*/ ctx[55], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*inputStyle*/ 67108864) {
    				attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
    			}

    			if (dirty[0] & /*name*/ 32) {
    				attr_dev(input_1, "name", /*name*/ ctx[5]);
    			}

    			if (dirty[1] & /*inputType*/ 512) {
    				attr_dev(input_1, "type", /*inputType*/ ctx[40]);
    			}

    			if (dirty[0] & /*inputmode*/ 64) {
    				attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
    			}

    			if (dirty[0] & /*placeholder*/ 1024) {
    				attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
    			}

    			if (dirty[0] & /*inputId*/ 2048) {
    				attr_dev(input_1, "id", /*inputId*/ ctx[11]);
    			}

    			if (dirty[0] & /*size*/ 4096) {
    				attr_dev(input_1, "size", /*size*/ ctx[12]);
    			}

    			if (dirty[0] & /*accept*/ 8192) {
    				attr_dev(input_1, "accept", /*accept*/ ctx[13]);
    			}

    			if (dirty[0] & /*autocomplete*/ 16384) {
    				attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
    			}

    			if (dirty[0] & /*autocorrect*/ 32768) {
    				attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
    			}

    			if (dirty[0] & /*autocapitalize*/ 65536) {
    				attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			}

    			if (dirty[0] & /*spellcheck*/ 131072) {
    				attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
    			}

    			if (dirty[0] & /*autofocus*/ 262144) {
    				prop_dev(input_1, "autofocus", /*autofocus*/ ctx[18]);
    			}

    			if (dirty[0] & /*autosave*/ 524288) {
    				attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
    			}

    			if (dirty[0] & /*disabled*/ 512) {
    				prop_dev(input_1, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*max*/ 1048576) {
    				attr_dev(input_1, "max", /*max*/ ctx[20]);
    			}

    			if (dirty[0] & /*maxlength*/ 8388608) {
    				attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
    			}

    			if (dirty[0] & /*min*/ 2097152) {
    				attr_dev(input_1, "min", /*min*/ ctx[21]);
    			}

    			if (dirty[0] & /*minlength*/ 16777216) {
    				attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
    			}

    			if (dirty[0] & /*step*/ 4194304) {
    				attr_dev(input_1, "step", /*step*/ ctx[22]);
    			}

    			if (dirty[0] & /*multiple*/ 33554432) {
    				prop_dev(input_1, "multiple", /*multiple*/ ctx[25]);
    			}

    			if (dirty[0] & /*readonly*/ 128) {
    				prop_dev(input_1, "readOnly", /*readonly*/ ctx[7]);
    			}

    			if (dirty[0] & /*required*/ 256) {
    				prop_dev(input_1, "required", /*required*/ ctx[8]);
    			}

    			if (dirty[0] & /*pattern*/ 134217728) {
    				attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);
    			}

    			if (dirty[0] & /*validate*/ 268435456 && input_1_validate_value !== (input_1_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined)) {
    				attr_dev(input_1, "validate", input_1_validate_value);
    			}

    			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && input_1_data_validate_value !== (input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(input_1, "data-validate", input_1_data_validate_value);
    			}

    			if (dirty[0] & /*validateOnBlur*/ 536870912 && input_1_data_validate_on_blur_value !== (input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value);
    			}

    			if (dirty[0] & /*tabindex*/ 1073741824) {
    				attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);
    			}

    			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && input_1_data_error_message_value !== (input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33])) {
    				attr_dev(input_1, "data-error-message", input_1_data_error_message_value);
    			}

    			if (dirty[1] & /*inputClasses*/ 32768) {
    				attr_dev(input_1, "class", /*inputClasses*/ ctx[46]);
    			}

    			if (dirty[0] & /*type*/ 16 | dirty[1] & /*inputValue*/ 262144 && input_1_value_value !== (input_1_value_value = /*type*/ ctx[4] === 'datepicker' || /*type*/ ctx[4] === 'colorpicker' || /*type*/ ctx[4] === 'file'
    			? ''
    			: /*inputValue*/ ctx[49]) && input_1.value !== input_1_value_value) {
    				prop_dev(input_1, "value", input_1_value_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    			/*input_1_binding_1*/ ctx[83](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$2.name,
    		type: "else",
    		source: "(702:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (691:42) 
    function create_if_block_19$1(ctx) {
    	let texteditor;
    	let current;

    	const texteditor_spread_levels = [
    		{
    			value: typeof /*value*/ ctx[0] === 'undefined'
    			? ''
    			: /*value*/ ctx[0]
    		},
    		{ resizable: /*resizable*/ ctx[31] },
    		{ placeholder: /*placeholder*/ ctx[10] },
    		{ onTextEditorFocus: /*onFocus*/ ctx[53] },
    		{ onTextEditorBlur: /*onBlur*/ ctx[54] },
    		{ onTextEditorInput: /*onInput*/ ctx[52] },
    		{ onTextEditorChange: /*onChange*/ ctx[55] },
    		/*textEditorParams*/ ctx[37]
    	];

    	let texteditor_props = {};

    	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
    		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
    	}

    	texteditor = new Text_editor({ props: texteditor_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(texteditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(texteditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const texteditor_changes = (dirty[0] & /*value, placeholder*/ 1025 | dirty[1] & /*resizable, onFocus, onBlur, onInput, onChange, textEditorParams*/ 31457345)
    			? get_spread_update(texteditor_spread_levels, [
    					dirty[0] & /*value*/ 1 && {
    						value: typeof /*value*/ ctx[0] === 'undefined'
    						? ''
    						: /*value*/ ctx[0]
    					},
    					dirty[1] & /*resizable*/ 1 && { resizable: /*resizable*/ ctx[31] },
    					dirty[0] & /*placeholder*/ 1024 && { placeholder: /*placeholder*/ ctx[10] },
    					dirty[1] & /*onFocus*/ 4194304 && { onTextEditorFocus: /*onFocus*/ ctx[53] },
    					dirty[1] & /*onBlur*/ 8388608 && { onTextEditorBlur: /*onBlur*/ ctx[54] },
    					dirty[1] & /*onInput*/ 2097152 && { onTextEditorInput: /*onInput*/ ctx[52] },
    					dirty[1] & /*onChange*/ 16777216 && { onTextEditorChange: /*onChange*/ ctx[55] },
    					dirty[1] & /*textEditorParams*/ 64 && get_spread_object(/*textEditorParams*/ ctx[37])
    				])
    			: {};

    			texteditor.$set(texteditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(texteditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(texteditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(texteditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19$1.name,
    		type: "if",
    		source: "(691:42) ",
    		ctx
    	});

    	return block;
    }

    // (646:40) 
    function create_if_block_18$1(ctx) {
    	let textarea;
    	let textarea_validate_value;
    	let textarea_data_validate_value;
    	let textarea_data_validate_on_blur_value;
    	let textarea_data_error_message_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			textarea = element("textarea");
    			attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
    			attr_dev(textarea, "name", /*name*/ ctx[5]);
    			attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
    			attr_dev(textarea, "id", /*inputId*/ ctx[11]);
    			attr_dev(textarea, "size", /*size*/ ctx[12]);
    			attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
    			attr_dev(textarea, "accept", /*accept*/ ctx[13]);
    			attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
    			attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
    			attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
    			textarea.autofocus = /*autofocus*/ ctx[18];
    			attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
    			textarea.disabled = /*disabled*/ ctx[9];
    			attr_dev(textarea, "max", /*max*/ ctx[20]);
    			attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
    			attr_dev(textarea, "min", /*min*/ ctx[21]);
    			attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
    			attr_dev(textarea, "step", /*step*/ ctx[22]);
    			attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
    			textarea.readOnly = /*readonly*/ ctx[7];
    			textarea.required = /*required*/ ctx[8];
    			attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);

    			attr_dev(textarea, "validate", textarea_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined);

    			attr_dev(textarea, "data-validate", textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);

    			attr_dev(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33]);

    			attr_dev(textarea, "class", /*inputClasses*/ ctx[46]);
    			textarea.value = /*inputValue*/ ctx[49];
    			add_location(textarea, file$e, 646, 12, 19358);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, textarea, anchor);
    			/*textarea_binding_1*/ ctx[82](textarea);
    			if (/*autofocus*/ ctx[18]) textarea.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "focus", /*onFocus*/ ctx[53], false, false, false),
    					listen_dev(textarea, "blur", /*onBlur*/ ctx[54], false, false, false),
    					listen_dev(textarea, "input", /*onInput*/ ctx[52], false, false, false),
    					listen_dev(textarea, "change", /*onChange*/ ctx[55], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*inputStyle*/ 67108864) {
    				attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
    			}

    			if (dirty[0] & /*name*/ 32) {
    				attr_dev(textarea, "name", /*name*/ ctx[5]);
    			}

    			if (dirty[0] & /*placeholder*/ 1024) {
    				attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
    			}

    			if (dirty[0] & /*inputId*/ 2048) {
    				attr_dev(textarea, "id", /*inputId*/ ctx[11]);
    			}

    			if (dirty[0] & /*size*/ 4096) {
    				attr_dev(textarea, "size", /*size*/ ctx[12]);
    			}

    			if (dirty[0] & /*inputmode*/ 64) {
    				attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
    			}

    			if (dirty[0] & /*accept*/ 8192) {
    				attr_dev(textarea, "accept", /*accept*/ ctx[13]);
    			}

    			if (dirty[0] & /*autocomplete*/ 16384) {
    				attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
    			}

    			if (dirty[0] & /*autocorrect*/ 32768) {
    				attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
    			}

    			if (dirty[0] & /*autocapitalize*/ 65536) {
    				attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			}

    			if (dirty[0] & /*spellcheck*/ 131072) {
    				attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
    			}

    			if (dirty[0] & /*autofocus*/ 262144) {
    				prop_dev(textarea, "autofocus", /*autofocus*/ ctx[18]);
    			}

    			if (dirty[0] & /*autosave*/ 524288) {
    				attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
    			}

    			if (dirty[0] & /*disabled*/ 512) {
    				prop_dev(textarea, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*max*/ 1048576) {
    				attr_dev(textarea, "max", /*max*/ ctx[20]);
    			}

    			if (dirty[0] & /*maxlength*/ 8388608) {
    				attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
    			}

    			if (dirty[0] & /*min*/ 2097152) {
    				attr_dev(textarea, "min", /*min*/ ctx[21]);
    			}

    			if (dirty[0] & /*minlength*/ 16777216) {
    				attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
    			}

    			if (dirty[0] & /*step*/ 4194304) {
    				attr_dev(textarea, "step", /*step*/ ctx[22]);
    			}

    			if (dirty[0] & /*multiple*/ 33554432) {
    				attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
    			}

    			if (dirty[0] & /*readonly*/ 128) {
    				prop_dev(textarea, "readOnly", /*readonly*/ ctx[7]);
    			}

    			if (dirty[0] & /*required*/ 256) {
    				prop_dev(textarea, "required", /*required*/ ctx[8]);
    			}

    			if (dirty[0] & /*pattern*/ 134217728) {
    				attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);
    			}

    			if (dirty[0] & /*validate*/ 268435456 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined)) {
    				attr_dev(textarea, "validate", textarea_validate_value);
    			}

    			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(textarea, "data-validate", textarea_data_validate_value);
    			}

    			if (dirty[0] & /*validateOnBlur*/ 536870912 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
    			}

    			if (dirty[0] & /*tabindex*/ 1073741824) {
    				attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);
    			}

    			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33])) {
    				attr_dev(textarea, "data-error-message", textarea_data_error_message_value);
    			}

    			if (dirty[1] & /*inputClasses*/ 32768) {
    				attr_dev(textarea, "class", /*inputClasses*/ ctx[46]);
    			}

    			if (dirty[1] & /*inputValue*/ 262144) {
    				prop_dev(textarea, "value", /*inputValue*/ ctx[49]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea);
    			/*textarea_binding_1*/ ctx[82](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18$1.name,
    		type: "if",
    		source: "(646:40) ",
    		ctx
    	});

    	return block;
    }

    // (600:10) {#if type === 'select'}
    function create_if_block_17$1(ctx) {
    	let select;
    	let select_validate_value;
    	let select_data_validate_value;
    	let select_data_validate_on_blur_value;
    	let select_data_error_message_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[77].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[76], null);

    	const block = {
    		c: function create() {
    			select = element("select");
    			if (default_slot) default_slot.c();
    			attr_dev(select, "style", /*inputStyle*/ ctx[26]);
    			attr_dev(select, "name", /*name*/ ctx[5]);
    			attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
    			attr_dev(select, "id", /*inputId*/ ctx[11]);
    			attr_dev(select, "size", /*size*/ ctx[12]);
    			attr_dev(select, "accept", /*accept*/ ctx[13]);
    			attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
    			attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
    			attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
    			select.autofocus = /*autofocus*/ ctx[18];
    			attr_dev(select, "autosave", /*autosave*/ ctx[19]);
    			select.disabled = /*disabled*/ ctx[9];
    			attr_dev(select, "max", /*max*/ ctx[20]);
    			attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
    			attr_dev(select, "min", /*min*/ ctx[21]);
    			attr_dev(select, "minlength", /*minlength*/ ctx[24]);
    			attr_dev(select, "step", /*step*/ ctx[22]);
    			select.multiple = /*multiple*/ ctx[25];
    			attr_dev(select, "readonly", /*readonly*/ ctx[7]);
    			select.required = /*required*/ ctx[8];
    			attr_dev(select, "pattern", /*pattern*/ ctx[27]);

    			attr_dev(select, "validate", select_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined);

    			attr_dev(select, "data-validate", select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);

    			attr_dev(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33]);

    			attr_dev(select, "class", /*inputClasses*/ ctx[46]);
    			add_location(select, file$e, 600, 12, 17897);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);

    			if (default_slot) {
    				default_slot.m(select, null);
    			}

    			select_option(select, /*inputValue*/ ctx[49]);
    			/*select_binding_1*/ ctx[81](select);
    			current = true;
    			if (/*autofocus*/ ctx[18]) select.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "focus", /*onFocus*/ ctx[53], false, false, false),
    					listen_dev(select, "blur", /*onBlur*/ ctx[54], false, false, false),
    					listen_dev(select, "input", /*onInput*/ ctx[52], false, false, false),
    					listen_dev(select, "change", /*onChange*/ ctx[55], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[76], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty[0] & /*inputStyle*/ 67108864) {
    				attr_dev(select, "style", /*inputStyle*/ ctx[26]);
    			}

    			if (!current || dirty[0] & /*name*/ 32) {
    				attr_dev(select, "name", /*name*/ ctx[5]);
    			}

    			if (!current || dirty[0] & /*placeholder*/ 1024) {
    				attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
    			}

    			if (!current || dirty[0] & /*inputId*/ 2048) {
    				attr_dev(select, "id", /*inputId*/ ctx[11]);
    			}

    			if (!current || dirty[0] & /*size*/ 4096) {
    				attr_dev(select, "size", /*size*/ ctx[12]);
    			}

    			if (!current || dirty[0] & /*accept*/ 8192) {
    				attr_dev(select, "accept", /*accept*/ ctx[13]);
    			}

    			if (!current || dirty[0] & /*autocomplete*/ 16384) {
    				attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
    			}

    			if (!current || dirty[0] & /*autocorrect*/ 32768) {
    				attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
    			}

    			if (!current || dirty[0] & /*autocapitalize*/ 65536) {
    				attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			}

    			if (!current || dirty[0] & /*spellcheck*/ 131072) {
    				attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
    			}

    			if (!current || dirty[0] & /*autofocus*/ 262144) {
    				prop_dev(select, "autofocus", /*autofocus*/ ctx[18]);
    			}

    			if (!current || dirty[0] & /*autosave*/ 524288) {
    				attr_dev(select, "autosave", /*autosave*/ ctx[19]);
    			}

    			if (!current || dirty[0] & /*disabled*/ 512) {
    				prop_dev(select, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (!current || dirty[0] & /*max*/ 1048576) {
    				attr_dev(select, "max", /*max*/ ctx[20]);
    			}

    			if (!current || dirty[0] & /*maxlength*/ 8388608) {
    				attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
    			}

    			if (!current || dirty[0] & /*min*/ 2097152) {
    				attr_dev(select, "min", /*min*/ ctx[21]);
    			}

    			if (!current || dirty[0] & /*minlength*/ 16777216) {
    				attr_dev(select, "minlength", /*minlength*/ ctx[24]);
    			}

    			if (!current || dirty[0] & /*step*/ 4194304) {
    				attr_dev(select, "step", /*step*/ ctx[22]);
    			}

    			if (!current || dirty[0] & /*multiple*/ 33554432) {
    				prop_dev(select, "multiple", /*multiple*/ ctx[25]);
    			}

    			if (!current || dirty[0] & /*readonly*/ 128) {
    				attr_dev(select, "readonly", /*readonly*/ ctx[7]);
    			}

    			if (!current || dirty[0] & /*required*/ 256) {
    				prop_dev(select, "required", /*required*/ ctx[8]);
    			}

    			if (!current || dirty[0] & /*pattern*/ 134217728) {
    				attr_dev(select, "pattern", /*pattern*/ ctx[27]);
    			}

    			if (!current || dirty[0] & /*validate*/ 268435456 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined)) {
    				attr_dev(select, "validate", select_validate_value);
    			}

    			if (!current || dirty[0] & /*validate, validateOnBlur*/ 805306368 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(select, "data-validate", select_data_validate_value);
    			}

    			if (!current || dirty[0] & /*validateOnBlur*/ 536870912 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value);
    			}

    			if (!current || dirty[0] & /*tabindex*/ 1073741824) {
    				attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);
    			}

    			if (!current || dirty[1] & /*errorMessageForce, errorMessage*/ 12 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33])) {
    				attr_dev(select, "data-error-message", select_data_error_message_value);
    			}

    			if (!current || dirty[1] & /*inputClasses*/ 32768) {
    				attr_dev(select, "class", /*inputClasses*/ ctx[46]);
    			}

    			if (!current || dirty[1] & /*inputValue*/ 262144) {
    				select_option(select, /*inputValue*/ ctx[49]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			if (default_slot) default_slot.d(detaching);
    			/*select_binding_1*/ ctx[81](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17$1.name,
    		type: "if",
    		source: "(600:10) {#if type === 'select'}",
    		ctx
    	});

    	return block;
    }

    // (753:8) {#if hasErrorMessage && errorMessageForce}
    function create_if_block_15$1(ctx) {
    	let div;
    	let t0_value = plainText(/*errorMessage*/ ctx[33]) + "";
    	let t0;
    	let t1;
    	let current;
    	const error_message_slot_template = /*#slots*/ ctx[77]["error-message"];
    	const error_message_slot = create_slot(error_message_slot_template, ctx, /*$$scope*/ ctx[76], get_error_message_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (error_message_slot) error_message_slot.c();
    			attr_dev(div, "class", "item-input-error-message");
    			add_location(div, file$e, 753, 10, 22840);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (error_message_slot) {
    				error_message_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[1] & /*errorMessage*/ 4) && t0_value !== (t0_value = plainText(/*errorMessage*/ ctx[33]) + "")) set_data_dev(t0, t0_value);

    			if (error_message_slot) {
    				if (error_message_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						error_message_slot,
    						error_message_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(error_message_slot_template, /*$$scope*/ ctx[76], dirty, get_error_message_slot_changes_1),
    						get_error_message_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(error_message_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(error_message_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (error_message_slot) error_message_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15$1.name,
    		type: "if",
    		source: "(753:8) {#if hasErrorMessage && errorMessageForce}",
    		ctx
    	});

    	return block;
    }

    // (759:8) {#if clearButton}
    function create_if_block_14$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "input-clear-button");
    			add_location(span, file$e, 758, 25, 23015);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14$1.name,
    		type: "if",
    		source: "(759:8) {#if clearButton}",
    		ctx
    	});

    	return block;
    }

    // (760:8) {#if typeof info !== 'undefined' || hasInfoSlots}
    function create_if_block_13$1(ctx) {
    	let div;
    	let t0_value = plainText(/*info*/ ctx[35]) + "";
    	let t0;
    	let t1;
    	let current;
    	const info_slot_template = /*#slots*/ ctx[77].info;
    	const info_slot = create_slot(info_slot_template, ctx, /*$$scope*/ ctx[76], get_info_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (info_slot) info_slot.c();
    			attr_dev(div, "class", "item-input-info");
    			add_location(div, file$e, 760, 10, 23124);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (info_slot) {
    				info_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[1] & /*info*/ 16) && t0_value !== (t0_value = plainText(/*info*/ ctx[35]) + "")) set_data_dev(t0, t0_value);

    			if (info_slot) {
    				if (info_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						info_slot,
    						info_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(info_slot_template, /*$$scope*/ ctx[76], dirty, get_info_slot_changes_1),
    						get_info_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(info_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (info_slot) info_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13$1.name,
    		type: "if",
    		source: "(760:8) {#if typeof info !== 'undefined' || hasInfoSlots}",
    		ctx
    	});

    	return block;
    }

    // (378:6) {#if isSortable && isSortableOpposite}
    function create_if_block_12$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$e, 378, 8, 10554);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12$1.name,
    		type: "if",
    		source: "(378:6) {#if isSortable && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (382:6) {#if media || hasMediaSlots}
    function create_if_block_10$1(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[1] !== 'undefined' && create_if_block_11$1(ctx);
    	const media_slot_template = /*#slots*/ ctx[77].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[76], get_media_slot_context$1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$e, 382, 8, 10643);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[1] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_11$1(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[76], dirty, get_media_slot_changes$1),
    						get_media_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$1.name,
    		type: "if",
    		source: "(382:6) {#if media || hasMediaSlots}",
    		ctx
    	});

    	return block;
    }

    // (384:10) {#if typeof media !== 'undefined'}
    function create_if_block_11$1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[1])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$e, 383, 44, 10712);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 2 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[1])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11$1.name,
    		type: "if",
    		source: "(384:10) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (390:8) {#if typeof label !== 'undefined' || hasLabelSlots}
    function create_if_block_9$1(ctx) {
    	let div;
    	let t0_value = plainText(/*label*/ ctx[36]) + "";
    	let t0;
    	let t1;
    	let current;
    	const label_slot_template = /*#slots*/ ctx[77].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[76], get_label_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (label_slot) label_slot.c();
    			attr_dev(div, "class", /*labelClasses*/ ctx[44]);
    			add_location(div, file$e, 390, 10, 10933);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (label_slot) {
    				label_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[1] & /*label*/ 32) && t0_value !== (t0_value = plainText(/*label*/ ctx[36]) + "")) set_data_dev(t0, t0_value);

    			if (label_slot) {
    				if (label_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[76], dirty, get_label_slot_changes),
    						get_label_slot_context
    					);
    				}
    			}

    			if (!current || dirty[1] & /*labelClasses*/ 8192) {
    				attr_dev(div, "class", /*labelClasses*/ ctx[44]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (label_slot) label_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$1.name,
    		type: "if",
    		source: "(390:8) {#if typeof label !== 'undefined' || hasLabelSlots}",
    		ctx
    	});

    	return block;
    }

    // (397:10) {#if input}
    function create_if_block_5$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_6$1, create_if_block_7$1, create_if_block_8$1, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*type*/ ctx[4] === 'select') return 0;
    		if (/*type*/ ctx[4] === 'textarea') return 1;
    		if (/*type*/ ctx[4] === 'texteditor') return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(397:10) {#if input}",
    		ctx
    	});

    	return block;
    }

    // (500:12) {:else}
    function create_else_block$4(ctx) {
    	let input_1;
    	let input_1_validate_value;
    	let input_1_data_validate_value;
    	let input_1_data_validate_on_blur_value;
    	let input_1_data_error_message_value;
    	let input_1_value_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
    			attr_dev(input_1, "name", /*name*/ ctx[5]);
    			attr_dev(input_1, "type", /*inputType*/ ctx[40]);
    			attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
    			attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
    			attr_dev(input_1, "id", /*inputId*/ ctx[11]);
    			attr_dev(input_1, "size", /*size*/ ctx[12]);
    			attr_dev(input_1, "accept", /*accept*/ ctx[13]);
    			attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
    			attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
    			attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
    			input_1.autofocus = /*autofocus*/ ctx[18];
    			attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
    			input_1.disabled = /*disabled*/ ctx[9];
    			attr_dev(input_1, "max", /*max*/ ctx[20]);
    			attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
    			attr_dev(input_1, "min", /*min*/ ctx[21]);
    			attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
    			attr_dev(input_1, "step", /*step*/ ctx[22]);
    			input_1.multiple = /*multiple*/ ctx[25];
    			input_1.readOnly = /*readonly*/ ctx[7];
    			input_1.required = /*required*/ ctx[8];
    			attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);

    			attr_dev(input_1, "validate", input_1_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined);

    			attr_dev(input_1, "data-validate", input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);

    			attr_dev(input_1, "data-error-message", input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33]);

    			attr_dev(input_1, "class", /*inputClasses*/ ctx[46]);

    			input_1.value = input_1_value_value = /*type*/ ctx[4] === 'datepicker' || /*type*/ ctx[4] === 'colorpicker' || /*type*/ ctx[4] === 'file'
    			? ''
    			: /*inputValue*/ ctx[49];

    			add_location(input_1, file$e, 500, 14, 14658);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    			/*input_1_binding*/ ctx[80](input_1);
    			if (/*autofocus*/ ctx[18]) input_1.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(input_1, "focus", /*onFocus*/ ctx[53], false, false, false),
    					listen_dev(input_1, "blur", /*onBlur*/ ctx[54], false, false, false),
    					listen_dev(input_1, "input", /*onInput*/ ctx[52], false, false, false),
    					listen_dev(input_1, "change", /*onChange*/ ctx[55], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*inputStyle*/ 67108864) {
    				attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
    			}

    			if (dirty[0] & /*name*/ 32) {
    				attr_dev(input_1, "name", /*name*/ ctx[5]);
    			}

    			if (dirty[1] & /*inputType*/ 512) {
    				attr_dev(input_1, "type", /*inputType*/ ctx[40]);
    			}

    			if (dirty[0] & /*inputmode*/ 64) {
    				attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
    			}

    			if (dirty[0] & /*placeholder*/ 1024) {
    				attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
    			}

    			if (dirty[0] & /*inputId*/ 2048) {
    				attr_dev(input_1, "id", /*inputId*/ ctx[11]);
    			}

    			if (dirty[0] & /*size*/ 4096) {
    				attr_dev(input_1, "size", /*size*/ ctx[12]);
    			}

    			if (dirty[0] & /*accept*/ 8192) {
    				attr_dev(input_1, "accept", /*accept*/ ctx[13]);
    			}

    			if (dirty[0] & /*autocomplete*/ 16384) {
    				attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
    			}

    			if (dirty[0] & /*autocorrect*/ 32768) {
    				attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
    			}

    			if (dirty[0] & /*autocapitalize*/ 65536) {
    				attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			}

    			if (dirty[0] & /*spellcheck*/ 131072) {
    				attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
    			}

    			if (dirty[0] & /*autofocus*/ 262144) {
    				prop_dev(input_1, "autofocus", /*autofocus*/ ctx[18]);
    			}

    			if (dirty[0] & /*autosave*/ 524288) {
    				attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
    			}

    			if (dirty[0] & /*disabled*/ 512) {
    				prop_dev(input_1, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*max*/ 1048576) {
    				attr_dev(input_1, "max", /*max*/ ctx[20]);
    			}

    			if (dirty[0] & /*maxlength*/ 8388608) {
    				attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
    			}

    			if (dirty[0] & /*min*/ 2097152) {
    				attr_dev(input_1, "min", /*min*/ ctx[21]);
    			}

    			if (dirty[0] & /*minlength*/ 16777216) {
    				attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
    			}

    			if (dirty[0] & /*step*/ 4194304) {
    				attr_dev(input_1, "step", /*step*/ ctx[22]);
    			}

    			if (dirty[0] & /*multiple*/ 33554432) {
    				prop_dev(input_1, "multiple", /*multiple*/ ctx[25]);
    			}

    			if (dirty[0] & /*readonly*/ 128) {
    				prop_dev(input_1, "readOnly", /*readonly*/ ctx[7]);
    			}

    			if (dirty[0] & /*required*/ 256) {
    				prop_dev(input_1, "required", /*required*/ ctx[8]);
    			}

    			if (dirty[0] & /*pattern*/ 134217728) {
    				attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);
    			}

    			if (dirty[0] & /*validate*/ 268435456 && input_1_validate_value !== (input_1_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined)) {
    				attr_dev(input_1, "validate", input_1_validate_value);
    			}

    			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && input_1_data_validate_value !== (input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(input_1, "data-validate", input_1_data_validate_value);
    			}

    			if (dirty[0] & /*validateOnBlur*/ 536870912 && input_1_data_validate_on_blur_value !== (input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value);
    			}

    			if (dirty[0] & /*tabindex*/ 1073741824) {
    				attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);
    			}

    			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && input_1_data_error_message_value !== (input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33])) {
    				attr_dev(input_1, "data-error-message", input_1_data_error_message_value);
    			}

    			if (dirty[1] & /*inputClasses*/ 32768) {
    				attr_dev(input_1, "class", /*inputClasses*/ ctx[46]);
    			}

    			if (dirty[0] & /*type*/ 16 | dirty[1] & /*inputValue*/ 262144 && input_1_value_value !== (input_1_value_value = /*type*/ ctx[4] === 'datepicker' || /*type*/ ctx[4] === 'colorpicker' || /*type*/ ctx[4] === 'file'
    			? ''
    			: /*inputValue*/ ctx[49]) && input_1.value !== input_1_value_value) {
    				prop_dev(input_1, "value", input_1_value_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    			/*input_1_binding*/ ctx[80](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(500:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (489:44) 
    function create_if_block_8$1(ctx) {
    	let texteditor;
    	let current;

    	const texteditor_spread_levels = [
    		{
    			value: typeof /*value*/ ctx[0] === 'undefined'
    			? ''
    			: /*value*/ ctx[0]
    		},
    		{ resizable: /*resizable*/ ctx[31] },
    		{ placeholder: /*placeholder*/ ctx[10] },
    		{ onTextEditorFocus: /*onFocus*/ ctx[53] },
    		{ onTextEditorBlur: /*onBlur*/ ctx[54] },
    		{ onTextEditorInput: /*onInput*/ ctx[52] },
    		{ onTextEditorChange: /*onChange*/ ctx[55] },
    		/*textEditorParams*/ ctx[37]
    	];

    	let texteditor_props = {};

    	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
    		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
    	}

    	texteditor = new Text_editor({ props: texteditor_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(texteditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(texteditor, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const texteditor_changes = (dirty[0] & /*value, placeholder*/ 1025 | dirty[1] & /*resizable, onFocus, onBlur, onInput, onChange, textEditorParams*/ 31457345)
    			? get_spread_update(texteditor_spread_levels, [
    					dirty[0] & /*value*/ 1 && {
    						value: typeof /*value*/ ctx[0] === 'undefined'
    						? ''
    						: /*value*/ ctx[0]
    					},
    					dirty[1] & /*resizable*/ 1 && { resizable: /*resizable*/ ctx[31] },
    					dirty[0] & /*placeholder*/ 1024 && { placeholder: /*placeholder*/ ctx[10] },
    					dirty[1] & /*onFocus*/ 4194304 && { onTextEditorFocus: /*onFocus*/ ctx[53] },
    					dirty[1] & /*onBlur*/ 8388608 && { onTextEditorBlur: /*onBlur*/ ctx[54] },
    					dirty[1] & /*onInput*/ 2097152 && { onTextEditorInput: /*onInput*/ ctx[52] },
    					dirty[1] & /*onChange*/ 16777216 && { onTextEditorChange: /*onChange*/ ctx[55] },
    					dirty[1] & /*textEditorParams*/ 64 && get_spread_object(/*textEditorParams*/ ctx[37])
    				])
    			: {};

    			texteditor.$set(texteditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(texteditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(texteditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(texteditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(489:44) ",
    		ctx
    	});

    	return block;
    }

    // (444:42) 
    function create_if_block_7$1(ctx) {
    	let textarea;
    	let textarea_validate_value;
    	let textarea_data_validate_value;
    	let textarea_data_validate_on_blur_value;
    	let textarea_data_error_message_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			textarea = element("textarea");
    			attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
    			attr_dev(textarea, "name", /*name*/ ctx[5]);
    			attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
    			attr_dev(textarea, "id", /*inputId*/ ctx[11]);
    			attr_dev(textarea, "size", /*size*/ ctx[12]);
    			attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
    			attr_dev(textarea, "accept", /*accept*/ ctx[13]);
    			attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
    			attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
    			attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
    			textarea.autofocus = /*autofocus*/ ctx[18];
    			attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
    			textarea.disabled = /*disabled*/ ctx[9];
    			attr_dev(textarea, "max", /*max*/ ctx[20]);
    			attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
    			attr_dev(textarea, "min", /*min*/ ctx[21]);
    			attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
    			attr_dev(textarea, "step", /*step*/ ctx[22]);
    			attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
    			textarea.readOnly = /*readonly*/ ctx[7];
    			textarea.required = /*required*/ ctx[8];
    			attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);

    			attr_dev(textarea, "validate", textarea_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined);

    			attr_dev(textarea, "data-validate", textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);

    			attr_dev(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33]);

    			attr_dev(textarea, "class", /*inputClasses*/ ctx[46]);
    			textarea.value = /*inputValue*/ ctx[49];
    			add_location(textarea, file$e, 444, 14, 12720);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, textarea, anchor);
    			/*textarea_binding*/ ctx[79](textarea);
    			if (/*autofocus*/ ctx[18]) textarea.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "focus", /*onFocus*/ ctx[53], false, false, false),
    					listen_dev(textarea, "blur", /*onBlur*/ ctx[54], false, false, false),
    					listen_dev(textarea, "input", /*onInput*/ ctx[52], false, false, false),
    					listen_dev(textarea, "change", /*onChange*/ ctx[55], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*inputStyle*/ 67108864) {
    				attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
    			}

    			if (dirty[0] & /*name*/ 32) {
    				attr_dev(textarea, "name", /*name*/ ctx[5]);
    			}

    			if (dirty[0] & /*placeholder*/ 1024) {
    				attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
    			}

    			if (dirty[0] & /*inputId*/ 2048) {
    				attr_dev(textarea, "id", /*inputId*/ ctx[11]);
    			}

    			if (dirty[0] & /*size*/ 4096) {
    				attr_dev(textarea, "size", /*size*/ ctx[12]);
    			}

    			if (dirty[0] & /*inputmode*/ 64) {
    				attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
    			}

    			if (dirty[0] & /*accept*/ 8192) {
    				attr_dev(textarea, "accept", /*accept*/ ctx[13]);
    			}

    			if (dirty[0] & /*autocomplete*/ 16384) {
    				attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
    			}

    			if (dirty[0] & /*autocorrect*/ 32768) {
    				attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
    			}

    			if (dirty[0] & /*autocapitalize*/ 65536) {
    				attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			}

    			if (dirty[0] & /*spellcheck*/ 131072) {
    				attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
    			}

    			if (dirty[0] & /*autofocus*/ 262144) {
    				prop_dev(textarea, "autofocus", /*autofocus*/ ctx[18]);
    			}

    			if (dirty[0] & /*autosave*/ 524288) {
    				attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
    			}

    			if (dirty[0] & /*disabled*/ 512) {
    				prop_dev(textarea, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*max*/ 1048576) {
    				attr_dev(textarea, "max", /*max*/ ctx[20]);
    			}

    			if (dirty[0] & /*maxlength*/ 8388608) {
    				attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
    			}

    			if (dirty[0] & /*min*/ 2097152) {
    				attr_dev(textarea, "min", /*min*/ ctx[21]);
    			}

    			if (dirty[0] & /*minlength*/ 16777216) {
    				attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
    			}

    			if (dirty[0] & /*step*/ 4194304) {
    				attr_dev(textarea, "step", /*step*/ ctx[22]);
    			}

    			if (dirty[0] & /*multiple*/ 33554432) {
    				attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
    			}

    			if (dirty[0] & /*readonly*/ 128) {
    				prop_dev(textarea, "readOnly", /*readonly*/ ctx[7]);
    			}

    			if (dirty[0] & /*required*/ 256) {
    				prop_dev(textarea, "required", /*required*/ ctx[8]);
    			}

    			if (dirty[0] & /*pattern*/ 134217728) {
    				attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);
    			}

    			if (dirty[0] & /*validate*/ 268435456 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined)) {
    				attr_dev(textarea, "validate", textarea_validate_value);
    			}

    			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(textarea, "data-validate", textarea_data_validate_value);
    			}

    			if (dirty[0] & /*validateOnBlur*/ 536870912 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
    			}

    			if (dirty[0] & /*tabindex*/ 1073741824) {
    				attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);
    			}

    			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33])) {
    				attr_dev(textarea, "data-error-message", textarea_data_error_message_value);
    			}

    			if (dirty[1] & /*inputClasses*/ 32768) {
    				attr_dev(textarea, "class", /*inputClasses*/ ctx[46]);
    			}

    			if (dirty[1] & /*inputValue*/ 262144) {
    				prop_dev(textarea, "value", /*inputValue*/ ctx[49]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea);
    			/*textarea_binding*/ ctx[79](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(444:42) ",
    		ctx
    	});

    	return block;
    }

    // (398:12) {#if type === 'select'}
    function create_if_block_6$1(ctx) {
    	let select;
    	let select_validate_value;
    	let select_data_validate_value;
    	let select_data_validate_on_blur_value;
    	let select_data_error_message_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[77].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[76], null);

    	const block = {
    		c: function create() {
    			select = element("select");
    			if (default_slot) default_slot.c();
    			attr_dev(select, "style", /*inputStyle*/ ctx[26]);
    			attr_dev(select, "name", /*name*/ ctx[5]);
    			attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
    			attr_dev(select, "id", /*inputId*/ ctx[11]);
    			attr_dev(select, "size", /*size*/ ctx[12]);
    			attr_dev(select, "accept", /*accept*/ ctx[13]);
    			attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
    			attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
    			attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
    			select.autofocus = /*autofocus*/ ctx[18];
    			attr_dev(select, "autosave", /*autosave*/ ctx[19]);
    			select.disabled = /*disabled*/ ctx[9];
    			attr_dev(select, "max", /*max*/ ctx[20]);
    			attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
    			attr_dev(select, "min", /*min*/ ctx[21]);
    			attr_dev(select, "minlength", /*minlength*/ ctx[24]);
    			attr_dev(select, "step", /*step*/ ctx[22]);
    			select.multiple = /*multiple*/ ctx[25];
    			attr_dev(select, "readonly", /*readonly*/ ctx[7]);
    			select.required = /*required*/ ctx[8];
    			attr_dev(select, "pattern", /*pattern*/ ctx[27]);

    			attr_dev(select, "validate", select_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined);

    			attr_dev(select, "data-validate", select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined);

    			attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);

    			attr_dev(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33]);

    			attr_dev(select, "class", /*inputClasses*/ ctx[46]);
    			add_location(select, file$e, 398, 14, 11167);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);

    			if (default_slot) {
    				default_slot.m(select, null);
    			}

    			select_option(select, /*inputValue*/ ctx[49]);
    			/*select_binding*/ ctx[78](select);
    			current = true;
    			if (/*autofocus*/ ctx[18]) select.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "focus", /*onFocus*/ ctx[53], false, false, false),
    					listen_dev(select, "blur", /*onBlur*/ ctx[54], false, false, false),
    					listen_dev(select, "input", /*onInput*/ ctx[52], false, false, false),
    					listen_dev(select, "change", /*onChange*/ ctx[55], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[76], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty[0] & /*inputStyle*/ 67108864) {
    				attr_dev(select, "style", /*inputStyle*/ ctx[26]);
    			}

    			if (!current || dirty[0] & /*name*/ 32) {
    				attr_dev(select, "name", /*name*/ ctx[5]);
    			}

    			if (!current || dirty[0] & /*placeholder*/ 1024) {
    				attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
    			}

    			if (!current || dirty[0] & /*inputId*/ 2048) {
    				attr_dev(select, "id", /*inputId*/ ctx[11]);
    			}

    			if (!current || dirty[0] & /*size*/ 4096) {
    				attr_dev(select, "size", /*size*/ ctx[12]);
    			}

    			if (!current || dirty[0] & /*accept*/ 8192) {
    				attr_dev(select, "accept", /*accept*/ ctx[13]);
    			}

    			if (!current || dirty[0] & /*autocomplete*/ 16384) {
    				attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
    			}

    			if (!current || dirty[0] & /*autocorrect*/ 32768) {
    				attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
    			}

    			if (!current || dirty[0] & /*autocapitalize*/ 65536) {
    				attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
    			}

    			if (!current || dirty[0] & /*spellcheck*/ 131072) {
    				attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
    			}

    			if (!current || dirty[0] & /*autofocus*/ 262144) {
    				prop_dev(select, "autofocus", /*autofocus*/ ctx[18]);
    			}

    			if (!current || dirty[0] & /*autosave*/ 524288) {
    				attr_dev(select, "autosave", /*autosave*/ ctx[19]);
    			}

    			if (!current || dirty[0] & /*disabled*/ 512) {
    				prop_dev(select, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (!current || dirty[0] & /*max*/ 1048576) {
    				attr_dev(select, "max", /*max*/ ctx[20]);
    			}

    			if (!current || dirty[0] & /*maxlength*/ 8388608) {
    				attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
    			}

    			if (!current || dirty[0] & /*min*/ 2097152) {
    				attr_dev(select, "min", /*min*/ ctx[21]);
    			}

    			if (!current || dirty[0] & /*minlength*/ 16777216) {
    				attr_dev(select, "minlength", /*minlength*/ ctx[24]);
    			}

    			if (!current || dirty[0] & /*step*/ 4194304) {
    				attr_dev(select, "step", /*step*/ ctx[22]);
    			}

    			if (!current || dirty[0] & /*multiple*/ 33554432) {
    				prop_dev(select, "multiple", /*multiple*/ ctx[25]);
    			}

    			if (!current || dirty[0] & /*readonly*/ 128) {
    				attr_dev(select, "readonly", /*readonly*/ ctx[7]);
    			}

    			if (!current || dirty[0] & /*required*/ 256) {
    				prop_dev(select, "required", /*required*/ ctx[8]);
    			}

    			if (!current || dirty[0] & /*pattern*/ 134217728) {
    				attr_dev(select, "pattern", /*pattern*/ ctx[27]);
    			}

    			if (!current || dirty[0] & /*validate*/ 268435456 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[28] === 'string' && /*validate*/ ctx[28].length
    			? /*validate*/ ctx[28]
    			: undefined)) {
    				attr_dev(select, "validate", select_validate_value);
    			}

    			if (!current || dirty[0] & /*validate, validateOnBlur*/ 805306368 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === '' || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(select, "data-validate", select_data_validate_value);
    			}

    			if (!current || dirty[0] & /*validateOnBlur*/ 536870912 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ''
    			? true
    			: undefined)) {
    				attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value);
    			}

    			if (!current || dirty[0] & /*tabindex*/ 1073741824) {
    				attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);
    			}

    			if (!current || dirty[1] & /*errorMessageForce, errorMessage*/ 12 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[34]
    			? undefined
    			: /*errorMessage*/ ctx[33])) {
    				attr_dev(select, "data-error-message", select_data_error_message_value);
    			}

    			if (!current || dirty[1] & /*inputClasses*/ 32768) {
    				attr_dev(select, "class", /*inputClasses*/ ctx[46]);
    			}

    			if (!current || dirty[1] & /*inputValue*/ 262144) {
    				select_option(select, /*inputValue*/ ctx[49]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			if (default_slot) default_slot.d(detaching);
    			/*select_binding*/ ctx[78](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(398:12) {#if type === 'select'}",
    		ctx
    	});

    	return block;
    }

    // (551:10) {#if hasErrorMessage && errorMessageForce}
    function create_if_block_4$1(ctx) {
    	let div;
    	let t0_value = plainText(/*errorMessage*/ ctx[33]) + "";
    	let t0;
    	let t1;
    	let current;
    	const error_message_slot_template = /*#slots*/ ctx[77]["error-message"];
    	const error_message_slot = create_slot(error_message_slot_template, ctx, /*$$scope*/ ctx[76], get_error_message_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (error_message_slot) error_message_slot.c();
    			attr_dev(div, "class", "item-input-error-message");
    			add_location(div, file$e, 551, 12, 16416);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (error_message_slot) {
    				error_message_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[1] & /*errorMessage*/ 4) && t0_value !== (t0_value = plainText(/*errorMessage*/ ctx[33]) + "")) set_data_dev(t0, t0_value);

    			if (error_message_slot) {
    				if (error_message_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						error_message_slot,
    						error_message_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(error_message_slot_template, /*$$scope*/ ctx[76], dirty, get_error_message_slot_changes),
    						get_error_message_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(error_message_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(error_message_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (error_message_slot) error_message_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(551:10) {#if hasErrorMessage && errorMessageForce}",
    		ctx
    	});

    	return block;
    }

    // (557:10) {#if clearButton}
    function create_if_block_3$4(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "input-clear-button");
    			add_location(span, file$e, 556, 27, 16601);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(557:10) {#if clearButton}",
    		ctx
    	});

    	return block;
    }

    // (558:10) {#if typeof info !== 'undefined' || hasInfoSlots}
    function create_if_block_2$5(ctx) {
    	let div;
    	let t0_value = plainText(/*info*/ ctx[35]) + "";
    	let t0;
    	let t1;
    	let current;
    	const info_slot_template = /*#slots*/ ctx[77].info;
    	const info_slot = create_slot(info_slot_template, ctx, /*$$scope*/ ctx[76], get_info_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (info_slot) info_slot.c();
    			attr_dev(div, "class", "item-input-info");
    			add_location(div, file$e, 558, 12, 16714);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (info_slot) {
    				info_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[1] & /*info*/ 16) && t0_value !== (t0_value = plainText(/*info*/ ctx[35]) + "")) set_data_dev(t0, t0_value);

    			if (info_slot) {
    				if (info_slot.p && (!current || dirty[2] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						info_slot,
    						info_slot_template,
    						ctx,
    						/*$$scope*/ ctx[76],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[76])
    						: get_slot_changes(info_slot_template, /*$$scope*/ ctx[76], dirty, get_info_slot_changes),
    						get_info_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(info_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (info_slot) info_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(558:10) {#if typeof info !== 'undefined' || hasInfoSlots}",
    		ctx
    	});

    	return block;
    }

    // (571:4) {#if isSortable && !isSortableOpposite}
    function create_if_block_1$6(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$e, 571, 6, 17063);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(571:4) {#if isSortable && !isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$9, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*wrap*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let isSortable;
    	let isSortableOpposite;
    	let inputType;
    	let needsValue;
    	let inputValue;
    	let hasInfoSlots;
    	let hasErrorSlots;
    	let hasMediaSlots;
    	let hasLabelSlots;
    	let hasErrorMessage;
    	let inputClasses;
    	let itemContentClasses;
    	let labelClasses;
    	let inputWrapClasses;
    	let classes;

    	const omit_props_names = [
    		"class","sortable","sortableOpposite","media","dropdown","wrap","input","type","name","value","inputmode","readonly","required","disabled","placeholder","inputId","size","accept","autocomplete","autocorrect","autocapitalize","spellcheck","autofocus","autosave","max","min","step","maxlength","minlength","multiple","inputStyle","pattern","validate","validateOnBlur","onValidate","tabindex","resizable","clearButton","noFormStoreData","noStoreData","ignoreStoreData","errorMessage","errorMessageForce","info","outline","label","inlineLabel","floatingLabel","calendarParams","colorPickerParams","textEditorParams","calendarInstance","colorPickerInstance"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;

    	validate_slots('List_input', slots, [
    		'root-start','content-start','media','inner-start','label','default','input','error-message','info','inner','inner-end','content','content-end','root','root-end'
    	]);

    	const $$slots = compute_slots(slots);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { sortable = undefined } = $$props;
    	let { sortableOpposite = undefined } = $$props;
    	let { media = undefined } = $$props;
    	let { dropdown = 'auto' } = $$props;
    	let { wrap = true } = $$props;
    	let { input = true } = $$props;
    	let { type = 'text' } = $$props;
    	let { name = undefined } = $$props;
    	let { value = undefined } = $$props;
    	let { inputmode = undefined } = $$props;
    	let { readonly = undefined } = $$props;
    	let { required = undefined } = $$props;
    	let { disabled = undefined } = $$props;
    	let { placeholder = undefined } = $$props;
    	let { inputId = undefined } = $$props;
    	let { size = undefined } = $$props;
    	let { accept = undefined } = $$props;
    	let { autocomplete = undefined } = $$props;
    	let { autocorrect = undefined } = $$props;
    	let { autocapitalize = undefined } = $$props;
    	let { spellcheck = undefined } = $$props;
    	let { autofocus = undefined } = $$props;
    	let { autosave = undefined } = $$props;
    	let { max = undefined } = $$props;
    	let { min = undefined } = $$props;
    	let { step = undefined } = $$props;
    	let { maxlength = undefined } = $$props;
    	let { minlength = undefined } = $$props;
    	let { multiple = undefined } = $$props;
    	let { inputStyle = undefined } = $$props;
    	let { pattern = undefined } = $$props;
    	let { validate = undefined } = $$props;
    	let { validateOnBlur = undefined } = $$props;
    	let { onValidate = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { resizable = undefined } = $$props;
    	let { clearButton = undefined } = $$props;
    	let { noFormStoreData = undefined } = $$props;
    	let { noStoreData = undefined } = $$props;
    	let { ignoreStoreData = undefined } = $$props;
    	let { errorMessage = undefined } = $$props;
    	let { errorMessageForce = undefined } = $$props;
    	let { info = undefined } = $$props;
    	let { outline = undefined } = $$props;
    	let { label = undefined } = $$props;
    	let { inlineLabel = undefined } = $$props;
    	let { floatingLabel = undefined } = $$props;
    	let { calendarParams = undefined } = $$props;
    	let { colorPickerParams = undefined } = $$props;
    	let { textEditorParams = undefined } = $$props;

    	// State
    	let inputEl;

    	let inputFocused = false;
    	let inputInvalid = false;
    	let updateInputOnDidUpdate = false;
    	let f7Calendar;
    	let f7ColorPicker;

    	function calendarInstance() {
    		return f7Calendar;
    	}

    	function colorPickerInstance() {
    		return f7ColorPicker;
    	}

    	let ListContext = getReactiveContext('ListContext', newValue => {
    		$$invalidate(74, ListContext = newValue || {});
    	}) || {};

    	function domValue() {
    		if (!inputEl) return undefined;
    		return inputEl.value;
    	}

    	function inputHasValue() {
    		if (type === 'datepicker' && Array.isArray(value) && value.length === 0) {
    			return false;
    		}

    		const domV = domValue();

    		return typeof value === 'undefined'
    		? domV || domV === 0
    		: value || value === 0;
    	}

    	function validateInput() {
    		if (!app$1.f7 || !inputEl) return;
    		const validity = inputEl.validity;
    		if (!validity) return;

    		if (!validity.valid) {
    			if (onValidate) onValidate(false);

    			if (inputInvalid !== true) {
    				$$invalidate(73, inputInvalid = true);
    			}
    		} else {
    			if (onValidate) onValidate(true);

    			if (inputInvalid !== false) {
    				$$invalidate(73, inputInvalid = false);
    			}
    		}
    	}

    	let initialWatched = false;

    	function watchValue() {
    		if (!initialWatched) {
    			initialWatched = true;
    			return;
    		}

    		if (type === 'range' || type === 'toggle') return;
    		if (!app$1.f7) return;
    		updateInputOnDidUpdate = true;

    		if (f7Calendar) {
    			f7Calendar.setValue(value);
    		}

    		if (f7ColorPicker) {
    			f7ColorPicker.setValue(value);
    		}
    	}

    	function watchColorPickerParams() {
    		if (!app$1.f7 || !f7ColorPicker) return;
    		extend(f7ColorPicker.params, colorPickerParams || {});
    	}

    	function watchCalendarParams() {
    		if (!app$1.f7 || !f7Calendar) return;
    		extend(f7Calendar.params, calendarParams || {});
    	}

    	function onTextareaResize(event) {
    		emit('textareaResize', [event]);
    	}

    	function onInputNotEmpty(event) {
    		emit('inputNotEmpty', [event]);
    	}

    	function onInputEmpty(event) {
    		emit('inputEmpty', [event]);
    	}

    	function onInputClear(event) {
    		emit('inputClear', [event]);
    	}

    	function onInput(...args) {
    		emit('input', [...args]);

    		if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && inputEl) {
    			validateInput();
    		}

    		if (inputEl && type !== 'texteditor' && type !== 'colorpicker' && type !== 'datepicker') {
    			$$invalidate(0, value = inputEl.value);
    		}
    	}

    	function onFocus(...args) {
    		emit('focus', [...args]);
    		$$invalidate(72, inputFocused = true);
    	}

    	function onBlur(...args) {
    		emit('blur', [...args]);

    		if ((validate || validate === '' || validateOnBlur || validateOnBlur === '') && inputEl) {
    			validateInput();
    		}

    		$$invalidate(72, inputFocused = false);
    	}

    	function onChange(...args) {
    		emit('change', [...args]);

    		if (type === 'texteditor') {
    			emit('textEditorChange', [args[0]]);
    			$$invalidate(0, value = args[1]);
    		}
    	}

    	onMount(() => {
    		f7ready(() => {
    			if (type === 'range' || type === 'toggle') return;
    			if (!inputEl) return;
    			inputEl.addEventListener('input:notempty', onInputNotEmpty, false);

    			if (type === 'textarea' && resizable) {
    				inputEl.addEventListener('textarea:resize', onTextareaResize, false);
    			}

    			if (clearButton) {
    				inputEl.addEventListener('input:empty', onInputEmpty, false);
    				inputEl.addEventListener('input:clear', onInputClear, false);
    			}

    			if (type === 'datepicker') {
    				f7Calendar = app$1.f7.calendar.create({
    					inputEl,
    					value,
    					on: {
    						change(calendar, calendarValue) {
    							emit('calendarChange', [calendarValue]);
    							$$invalidate(0, value = calendarValue);
    						}
    					},
    					...calendarParams || {}
    				});
    			}

    			if (type === 'colorpicker') {
    				f7ColorPicker = app$1.f7.colorPicker.create({
    					inputEl,
    					value,
    					on: {
    						change(colorPicker, colorPickerValue) {
    							emit('colorPickerChange', [colorPickerValue]);
    							$$invalidate(0, value = colorPickerValue);
    						}
    					},
    					...colorPickerParams || {}
    				});
    			}

    			app$1.f7.input.checkEmptyState(inputEl);

    			if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && typeof value !== 'undefined' && value !== null && value !== '') {
    				setTimeout(
    					() => {
    						validateInput();
    					},
    					0
    				);
    			}

    			if (resizable) {
    				app$1.f7.input.resizeTextarea(inputEl);
    			}
    		});
    	});

    	afterUpdate(() => {
    		if (!app$1.f7) return;

    		if (updateInputOnDidUpdate) {
    			if (!inputEl) return;
    			updateInputOnDidUpdate = false;
    			app$1.f7.input.checkEmptyState(inputEl);

    			if (validate && !validateOnBlur) {
    				validateInput();
    			}

    			if (resizable) {
    				app$1.f7.input.resizeTextarea(inputEl);
    			}
    		}
    	});

    	onDestroy(() => {
    		if (type === 'range' || type === 'toggle') return;
    		if (!inputEl) return;
    		inputEl.removeEventListener('input:notempty', onInputNotEmpty, false);

    		if (type === 'textarea' && resizable) {
    			inputEl.removeEventListener('textarea:resize', onTextareaResize, false);
    		}

    		if (clearButton) {
    			inputEl.removeEventListener('input:empty', onInputEmpty, false);
    			inputEl.removeEventListener('input:clear', onInputClear, false);
    		}

    		if (f7Calendar && f7Calendar.destroy) {
    			f7Calendar.destroy();
    		}

    		if (f7ColorPicker && f7ColorPicker.destroy) {
    			f7ColorPicker.destroy();
    		}

    		f7Calendar = null;
    		f7ColorPicker = null;
    	});

    	function select_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(41, inputEl);
    		});
    	}

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(41, inputEl);
    		});
    	}

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(41, inputEl);
    		});
    	}

    	function select_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(41, inputEl);
    		});
    	}

    	function textarea_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(41, inputEl);
    		});
    	}

    	function input_1_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(41, inputEl);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(100, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(56, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(57, className = $$new_props.class);
    		if ('sortable' in $$new_props) $$invalidate(58, sortable = $$new_props.sortable);
    		if ('sortableOpposite' in $$new_props) $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
    		if ('media' in $$new_props) $$invalidate(1, media = $$new_props.media);
    		if ('dropdown' in $$new_props) $$invalidate(60, dropdown = $$new_props.dropdown);
    		if ('wrap' in $$new_props) $$invalidate(2, wrap = $$new_props.wrap);
    		if ('input' in $$new_props) $$invalidate(3, input = $$new_props.input);
    		if ('type' in $$new_props) $$invalidate(4, type = $$new_props.type);
    		if ('name' in $$new_props) $$invalidate(5, name = $$new_props.name);
    		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ('inputmode' in $$new_props) $$invalidate(6, inputmode = $$new_props.inputmode);
    		if ('readonly' in $$new_props) $$invalidate(7, readonly = $$new_props.readonly);
    		if ('required' in $$new_props) $$invalidate(8, required = $$new_props.required);
    		if ('disabled' in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
    		if ('placeholder' in $$new_props) $$invalidate(10, placeholder = $$new_props.placeholder);
    		if ('inputId' in $$new_props) $$invalidate(11, inputId = $$new_props.inputId);
    		if ('size' in $$new_props) $$invalidate(12, size = $$new_props.size);
    		if ('accept' in $$new_props) $$invalidate(13, accept = $$new_props.accept);
    		if ('autocomplete' in $$new_props) $$invalidate(14, autocomplete = $$new_props.autocomplete);
    		if ('autocorrect' in $$new_props) $$invalidate(15, autocorrect = $$new_props.autocorrect);
    		if ('autocapitalize' in $$new_props) $$invalidate(16, autocapitalize = $$new_props.autocapitalize);
    		if ('spellcheck' in $$new_props) $$invalidate(17, spellcheck = $$new_props.spellcheck);
    		if ('autofocus' in $$new_props) $$invalidate(18, autofocus = $$new_props.autofocus);
    		if ('autosave' in $$new_props) $$invalidate(19, autosave = $$new_props.autosave);
    		if ('max' in $$new_props) $$invalidate(20, max = $$new_props.max);
    		if ('min' in $$new_props) $$invalidate(21, min = $$new_props.min);
    		if ('step' in $$new_props) $$invalidate(22, step = $$new_props.step);
    		if ('maxlength' in $$new_props) $$invalidate(23, maxlength = $$new_props.maxlength);
    		if ('minlength' in $$new_props) $$invalidate(24, minlength = $$new_props.minlength);
    		if ('multiple' in $$new_props) $$invalidate(25, multiple = $$new_props.multiple);
    		if ('inputStyle' in $$new_props) $$invalidate(26, inputStyle = $$new_props.inputStyle);
    		if ('pattern' in $$new_props) $$invalidate(27, pattern = $$new_props.pattern);
    		if ('validate' in $$new_props) $$invalidate(28, validate = $$new_props.validate);
    		if ('validateOnBlur' in $$new_props) $$invalidate(29, validateOnBlur = $$new_props.validateOnBlur);
    		if ('onValidate' in $$new_props) $$invalidate(61, onValidate = $$new_props.onValidate);
    		if ('tabindex' in $$new_props) $$invalidate(30, tabindex = $$new_props.tabindex);
    		if ('resizable' in $$new_props) $$invalidate(31, resizable = $$new_props.resizable);
    		if ('clearButton' in $$new_props) $$invalidate(32, clearButton = $$new_props.clearButton);
    		if ('noFormStoreData' in $$new_props) $$invalidate(62, noFormStoreData = $$new_props.noFormStoreData);
    		if ('noStoreData' in $$new_props) $$invalidate(63, noStoreData = $$new_props.noStoreData);
    		if ('ignoreStoreData' in $$new_props) $$invalidate(64, ignoreStoreData = $$new_props.ignoreStoreData);
    		if ('errorMessage' in $$new_props) $$invalidate(33, errorMessage = $$new_props.errorMessage);
    		if ('errorMessageForce' in $$new_props) $$invalidate(34, errorMessageForce = $$new_props.errorMessageForce);
    		if ('info' in $$new_props) $$invalidate(35, info = $$new_props.info);
    		if ('outline' in $$new_props) $$invalidate(65, outline = $$new_props.outline);
    		if ('label' in $$new_props) $$invalidate(36, label = $$new_props.label);
    		if ('inlineLabel' in $$new_props) $$invalidate(66, inlineLabel = $$new_props.inlineLabel);
    		if ('floatingLabel' in $$new_props) $$invalidate(67, floatingLabel = $$new_props.floatingLabel);
    		if ('calendarParams' in $$new_props) $$invalidate(68, calendarParams = $$new_props.calendarParams);
    		if ('colorPickerParams' in $$new_props) $$invalidate(69, colorPickerParams = $$new_props.colorPickerParams);
    		if ('textEditorParams' in $$new_props) $$invalidate(37, textEditorParams = $$new_props.textEditorParams);
    		if ('$$scope' in $$new_props) $$invalidate(76, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		afterUpdate,
    		onDestroy,
    		colorClasses,
    		classNames,
    		extend,
    		plainText,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		getReactiveContext,
    		TextEditor: Text_editor,
    		emit,
    		className,
    		sortable,
    		sortableOpposite,
    		media,
    		dropdown,
    		wrap,
    		input,
    		type,
    		name,
    		value,
    		inputmode,
    		readonly,
    		required,
    		disabled,
    		placeholder,
    		inputId,
    		size,
    		accept,
    		autocomplete,
    		autocorrect,
    		autocapitalize,
    		spellcheck,
    		autofocus,
    		autosave,
    		max,
    		min,
    		step,
    		maxlength,
    		minlength,
    		multiple,
    		inputStyle,
    		pattern,
    		validate,
    		validateOnBlur,
    		onValidate,
    		tabindex,
    		resizable,
    		clearButton,
    		noFormStoreData,
    		noStoreData,
    		ignoreStoreData,
    		errorMessage,
    		errorMessageForce,
    		info,
    		outline,
    		label,
    		inlineLabel,
    		floatingLabel,
    		calendarParams,
    		colorPickerParams,
    		textEditorParams,
    		inputEl,
    		inputFocused,
    		inputInvalid,
    		updateInputOnDidUpdate,
    		f7Calendar,
    		f7ColorPicker,
    		calendarInstance,
    		colorPickerInstance,
    		ListContext,
    		domValue,
    		inputHasValue,
    		validateInput,
    		initialWatched,
    		watchValue,
    		watchColorPickerParams,
    		watchCalendarParams,
    		onTextareaResize,
    		onInputNotEmpty,
    		onInputEmpty,
    		onInputClear,
    		onInput,
    		onFocus,
    		onBlur,
    		onChange,
    		classes,
    		inputWrapClasses,
    		labelClasses,
    		hasErrorMessage,
    		hasInfoSlots,
    		itemContentClasses,
    		inputType,
    		inputClasses,
    		hasErrorSlots,
    		hasLabelSlots,
    		hasMediaSlots,
    		inputValue,
    		needsValue,
    		isSortableOpposite,
    		isSortable
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(100, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(57, className = $$new_props.className);
    		if ('sortable' in $$props) $$invalidate(58, sortable = $$new_props.sortable);
    		if ('sortableOpposite' in $$props) $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
    		if ('media' in $$props) $$invalidate(1, media = $$new_props.media);
    		if ('dropdown' in $$props) $$invalidate(60, dropdown = $$new_props.dropdown);
    		if ('wrap' in $$props) $$invalidate(2, wrap = $$new_props.wrap);
    		if ('input' in $$props) $$invalidate(3, input = $$new_props.input);
    		if ('type' in $$props) $$invalidate(4, type = $$new_props.type);
    		if ('name' in $$props) $$invalidate(5, name = $$new_props.name);
    		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
    		if ('inputmode' in $$props) $$invalidate(6, inputmode = $$new_props.inputmode);
    		if ('readonly' in $$props) $$invalidate(7, readonly = $$new_props.readonly);
    		if ('required' in $$props) $$invalidate(8, required = $$new_props.required);
    		if ('disabled' in $$props) $$invalidate(9, disabled = $$new_props.disabled);
    		if ('placeholder' in $$props) $$invalidate(10, placeholder = $$new_props.placeholder);
    		if ('inputId' in $$props) $$invalidate(11, inputId = $$new_props.inputId);
    		if ('size' in $$props) $$invalidate(12, size = $$new_props.size);
    		if ('accept' in $$props) $$invalidate(13, accept = $$new_props.accept);
    		if ('autocomplete' in $$props) $$invalidate(14, autocomplete = $$new_props.autocomplete);
    		if ('autocorrect' in $$props) $$invalidate(15, autocorrect = $$new_props.autocorrect);
    		if ('autocapitalize' in $$props) $$invalidate(16, autocapitalize = $$new_props.autocapitalize);
    		if ('spellcheck' in $$props) $$invalidate(17, spellcheck = $$new_props.spellcheck);
    		if ('autofocus' in $$props) $$invalidate(18, autofocus = $$new_props.autofocus);
    		if ('autosave' in $$props) $$invalidate(19, autosave = $$new_props.autosave);
    		if ('max' in $$props) $$invalidate(20, max = $$new_props.max);
    		if ('min' in $$props) $$invalidate(21, min = $$new_props.min);
    		if ('step' in $$props) $$invalidate(22, step = $$new_props.step);
    		if ('maxlength' in $$props) $$invalidate(23, maxlength = $$new_props.maxlength);
    		if ('minlength' in $$props) $$invalidate(24, minlength = $$new_props.minlength);
    		if ('multiple' in $$props) $$invalidate(25, multiple = $$new_props.multiple);
    		if ('inputStyle' in $$props) $$invalidate(26, inputStyle = $$new_props.inputStyle);
    		if ('pattern' in $$props) $$invalidate(27, pattern = $$new_props.pattern);
    		if ('validate' in $$props) $$invalidate(28, validate = $$new_props.validate);
    		if ('validateOnBlur' in $$props) $$invalidate(29, validateOnBlur = $$new_props.validateOnBlur);
    		if ('onValidate' in $$props) $$invalidate(61, onValidate = $$new_props.onValidate);
    		if ('tabindex' in $$props) $$invalidate(30, tabindex = $$new_props.tabindex);
    		if ('resizable' in $$props) $$invalidate(31, resizable = $$new_props.resizable);
    		if ('clearButton' in $$props) $$invalidate(32, clearButton = $$new_props.clearButton);
    		if ('noFormStoreData' in $$props) $$invalidate(62, noFormStoreData = $$new_props.noFormStoreData);
    		if ('noStoreData' in $$props) $$invalidate(63, noStoreData = $$new_props.noStoreData);
    		if ('ignoreStoreData' in $$props) $$invalidate(64, ignoreStoreData = $$new_props.ignoreStoreData);
    		if ('errorMessage' in $$props) $$invalidate(33, errorMessage = $$new_props.errorMessage);
    		if ('errorMessageForce' in $$props) $$invalidate(34, errorMessageForce = $$new_props.errorMessageForce);
    		if ('info' in $$props) $$invalidate(35, info = $$new_props.info);
    		if ('outline' in $$props) $$invalidate(65, outline = $$new_props.outline);
    		if ('label' in $$props) $$invalidate(36, label = $$new_props.label);
    		if ('inlineLabel' in $$props) $$invalidate(66, inlineLabel = $$new_props.inlineLabel);
    		if ('floatingLabel' in $$props) $$invalidate(67, floatingLabel = $$new_props.floatingLabel);
    		if ('calendarParams' in $$props) $$invalidate(68, calendarParams = $$new_props.calendarParams);
    		if ('colorPickerParams' in $$props) $$invalidate(69, colorPickerParams = $$new_props.colorPickerParams);
    		if ('textEditorParams' in $$props) $$invalidate(37, textEditorParams = $$new_props.textEditorParams);
    		if ('inputEl' in $$props) $$invalidate(41, inputEl = $$new_props.inputEl);
    		if ('inputFocused' in $$props) $$invalidate(72, inputFocused = $$new_props.inputFocused);
    		if ('inputInvalid' in $$props) $$invalidate(73, inputInvalid = $$new_props.inputInvalid);
    		if ('updateInputOnDidUpdate' in $$props) updateInputOnDidUpdate = $$new_props.updateInputOnDidUpdate;
    		if ('f7Calendar' in $$props) f7Calendar = $$new_props.f7Calendar;
    		if ('f7ColorPicker' in $$props) f7ColorPicker = $$new_props.f7ColorPicker;
    		if ('ListContext' in $$props) $$invalidate(74, ListContext = $$new_props.ListContext);
    		if ('initialWatched' in $$props) initialWatched = $$new_props.initialWatched;
    		if ('classes' in $$props) $$invalidate(42, classes = $$new_props.classes);
    		if ('inputWrapClasses' in $$props) $$invalidate(43, inputWrapClasses = $$new_props.inputWrapClasses);
    		if ('labelClasses' in $$props) $$invalidate(44, labelClasses = $$new_props.labelClasses);
    		if ('hasErrorMessage' in $$props) $$invalidate(38, hasErrorMessage = $$new_props.hasErrorMessage);
    		if ('hasInfoSlots' in $$props) $$invalidate(39, hasInfoSlots = $$new_props.hasInfoSlots);
    		if ('itemContentClasses' in $$props) $$invalidate(45, itemContentClasses = $$new_props.itemContentClasses);
    		if ('inputType' in $$props) $$invalidate(40, inputType = $$new_props.inputType);
    		if ('inputClasses' in $$props) $$invalidate(46, inputClasses = $$new_props.inputClasses);
    		if ('hasErrorSlots' in $$props) $$invalidate(75, hasErrorSlots = $$new_props.hasErrorSlots);
    		if ('hasLabelSlots' in $$props) $$invalidate(47, hasLabelSlots = $$new_props.hasLabelSlots);
    		if ('hasMediaSlots' in $$props) $$invalidate(48, hasMediaSlots = $$new_props.hasMediaSlots);
    		if ('inputValue' in $$props) $$invalidate(49, inputValue = $$new_props.inputValue);
    		if ('needsValue' in $$props) needsValue = $$new_props.needsValue;
    		if ('isSortableOpposite' in $$props) $$invalidate(50, isSortableOpposite = $$new_props.isSortableOpposite);
    		if ('isSortable' in $$props) $$invalidate(51, isSortable = $$new_props.isSortable);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[1] & /*sortable*/ 134217728 | $$self.$$.dirty[2] & /*ListContext*/ 4096) {
    			$$invalidate(51, isSortable = sortable === true || sortable === false
    			? sortable
    			: ListContext.listIsSortable);
    		}

    		if ($$self.$$.dirty[1] & /*sortableOpposite*/ 268435456 | $$self.$$.dirty[2] & /*ListContext*/ 4096) {
    			$$invalidate(50, isSortableOpposite = sortableOpposite || ListContext.listIsSortableOpposite);
    		}

    		if ($$self.$$.dirty[0] & /*value*/ 1) {
    			watchValue();
    		}

    		if ($$self.$$.dirty[2] & /*colorPickerParams*/ 128) {
    			watchColorPickerParams();
    		}

    		if ($$self.$$.dirty[2] & /*calendarParams*/ 64) {
    			watchCalendarParams();
    		}

    		if ($$self.$$.dirty[0] & /*type*/ 16) {
    			$$invalidate(40, inputType = type === 'datepicker' || type === 'colorpicker'
    			? 'text'
    			: type);
    		}

    		if ($$self.$$.dirty[0] & /*type*/ 16) {
    			needsValue = type !== 'file' && type !== 'datepicker' && type !== 'colorpicker';
    		}

    		if ($$self.$$.dirty[0] & /*value*/ 1) {
    			$$invalidate(49, inputValue = (() => {
    				let v;

    				if (typeof value !== 'undefined') {
    					v = value;
    				} else {
    					v = domValue();
    				}

    				if (typeof v === 'undefined' || v === null) return '';
    				return v;
    			})());
    		}

    		if ($$self.$$.dirty[1] & /*errorMessage*/ 4 | $$self.$$.dirty[2] & /*hasErrorSlots*/ 8192) {
    			$$invalidate(38, hasErrorMessage = !!errorMessage || hasErrorSlots);
    		}

    		if ($$self.$$.dirty[1] & /*inputType, resizable, errorMessage, errorMessageForce*/ 525 | $$self.$$.dirty[2] & /*noFormStoreData, noStoreData, ignoreStoreData, inputInvalid, inputFocused*/ 3079) {
    			$$invalidate(46, inputClasses = classNames({
    				resizable: inputType === 'textarea' && resizable,
    				'no-store-data': noFormStoreData || noStoreData || ignoreStoreData,
    				'input-invalid': errorMessage && errorMessageForce || inputInvalid,
    				'input-with-value': inputHasValue(),
    				'input-focused': inputFocused
    			}));
    		}

    		$$invalidate(45, itemContentClasses = classNames('item-content item-input', !wrap && className, !wrap && { disabled }, !wrap && colorClasses($$props), {
    			'inline-label': inlineLabel,
    			'item-input-outline': outline,
    			'item-input-focused': inputFocused,
    			'item-input-with-info': !!info || hasInfoSlots,
    			'item-input-with-value': inputHasValue(),
    			'item-input-with-error-message': hasErrorMessage && errorMessageForce || inputInvalid,
    			'item-input-invalid': hasErrorMessage && errorMessageForce || inputInvalid
    		}));

    		if ($$self.$$.dirty[2] & /*floatingLabel*/ 32) {
    			$$invalidate(44, labelClasses = classNames('item-title item-label', { 'item-floating-label': floatingLabel }));
    		}

    		if ($$self.$$.dirty[0] & /*type*/ 16 | $$self.$$.dirty[1] & /*dropdown*/ 536870912) {
    			$$invalidate(43, inputWrapClasses = classNames('item-input-wrap', {
    				'input-dropdown': dropdown === 'auto' ? type === 'select' : dropdown
    			}));
    		}

    		$$invalidate(42, classes = classNames(className, { disabled }, colorClasses($$props)));
    	};

    	$$invalidate(39, hasInfoSlots = $$slots.info);
    	$$invalidate(75, hasErrorSlots = $$slots['error-message']);
    	$$invalidate(48, hasMediaSlots = $$slots.media);
    	$$invalidate(47, hasLabelSlots = $$slots.label);
    	$$props = exclude_internal_props($$props);

    	return [
    		value,
    		media,
    		wrap,
    		input,
    		type,
    		name,
    		inputmode,
    		readonly,
    		required,
    		disabled,
    		placeholder,
    		inputId,
    		size,
    		accept,
    		autocomplete,
    		autocorrect,
    		autocapitalize,
    		spellcheck,
    		autofocus,
    		autosave,
    		max,
    		min,
    		step,
    		maxlength,
    		minlength,
    		multiple,
    		inputStyle,
    		pattern,
    		validate,
    		validateOnBlur,
    		tabindex,
    		resizable,
    		clearButton,
    		errorMessage,
    		errorMessageForce,
    		info,
    		label,
    		textEditorParams,
    		hasErrorMessage,
    		hasInfoSlots,
    		inputType,
    		inputEl,
    		classes,
    		inputWrapClasses,
    		labelClasses,
    		itemContentClasses,
    		inputClasses,
    		hasLabelSlots,
    		hasMediaSlots,
    		inputValue,
    		isSortableOpposite,
    		isSortable,
    		onInput,
    		onFocus,
    		onBlur,
    		onChange,
    		$$restProps,
    		className,
    		sortable,
    		sortableOpposite,
    		dropdown,
    		onValidate,
    		noFormStoreData,
    		noStoreData,
    		ignoreStoreData,
    		outline,
    		inlineLabel,
    		floatingLabel,
    		calendarParams,
    		colorPickerParams,
    		calendarInstance,
    		colorPickerInstance,
    		inputFocused,
    		inputInvalid,
    		ListContext,
    		hasErrorSlots,
    		$$scope,
    		slots,
    		select_binding,
    		textarea_binding,
    		input_1_binding,
    		select_binding_1,
    		textarea_binding_1,
    		input_1_binding_1
    	];
    }

    class List_input extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$g,
    			create_fragment$h,
    			safe_not_equal,
    			{
    				class: 57,
    				sortable: 58,
    				sortableOpposite: 59,
    				media: 1,
    				dropdown: 60,
    				wrap: 2,
    				input: 3,
    				type: 4,
    				name: 5,
    				value: 0,
    				inputmode: 6,
    				readonly: 7,
    				required: 8,
    				disabled: 9,
    				placeholder: 10,
    				inputId: 11,
    				size: 12,
    				accept: 13,
    				autocomplete: 14,
    				autocorrect: 15,
    				autocapitalize: 16,
    				spellcheck: 17,
    				autofocus: 18,
    				autosave: 19,
    				max: 20,
    				min: 21,
    				step: 22,
    				maxlength: 23,
    				minlength: 24,
    				multiple: 25,
    				inputStyle: 26,
    				pattern: 27,
    				validate: 28,
    				validateOnBlur: 29,
    				onValidate: 61,
    				tabindex: 30,
    				resizable: 31,
    				clearButton: 32,
    				noFormStoreData: 62,
    				noStoreData: 63,
    				ignoreStoreData: 64,
    				errorMessage: 33,
    				errorMessageForce: 34,
    				info: 35,
    				outline: 65,
    				label: 36,
    				inlineLabel: 66,
    				floatingLabel: 67,
    				calendarParams: 68,
    				colorPickerParams: 69,
    				textEditorParams: 37,
    				calendarInstance: 70,
    				colorPickerInstance: 71
    			},
    			null,
    			[-1, -1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List_input",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get class() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortable() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortable(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortableOpposite() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortableOpposite(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get media() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set media(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dropdown() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dropdown(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrap() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrap(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputmode() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputmode(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readonly() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readonly(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputId() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputId(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accept() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accept(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autocomplete() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autocomplete(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autocorrect() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autocorrect(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autocapitalize() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autocapitalize(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get spellcheck() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set spellcheck(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autofocus() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autofocus(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autosave() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autosave(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get step() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set step(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxlength() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxlength(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minlength() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minlength(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiple() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiple(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputStyle() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputStyle(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pattern() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pattern(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get validate() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set validate(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get validateOnBlur() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set validateOnBlur(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onValidate() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onValidate(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resizable() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resizable(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get clearButton() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set clearButton(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noFormStoreData() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noFormStoreData(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noStoreData() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noStoreData(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ignoreStoreData() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ignoreStoreData(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get errorMessage() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errorMessage(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get errorMessageForce() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errorMessageForce(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get info() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set info(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outline() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outline(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inlineLabel() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inlineLabel(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get floatingLabel() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set floatingLabel(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get calendarParams() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set calendarParams(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get colorPickerParams() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colorPickerParams(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get textEditorParams() {
    		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set textEditorParams(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get calendarInstance() {
    		return this.$$.ctx[70];
    	}

    	set calendarInstance(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get colorPickerInstance() {
    		return this.$$.ctx[71];
    	}

    	set colorPickerInstance(value) {
    		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/list-item.svelte generated by Svelte v3.44.0 */
    const file$d = "node_modules/framework7-svelte/esm/svelte/list-item.svelte";
    const get_root_end_slot_changes = dirty => ({});
    const get_root_end_slot_context = ctx => ({});
    const get_root_slot_changes = dirty => ({});
    const get_root_slot_context = ctx => ({});
    const get_content_end_slot_changes_5 = dirty => ({});
    const get_content_end_slot_context_5 = ctx => ({});
    const get_content_slot_changes_5 = dirty => ({});
    const get_content_slot_context_5 = ctx => ({});
    const get_inner_end_slot_changes_5 = dirty => ({});
    const get_inner_end_slot_context_5 = ctx => ({});
    const get_inner_slot_changes_11 = dirty => ({});
    const get_inner_slot_context_11 = ctx => ({});
    const get_after_end_slot_changes_11 = dirty => ({});
    const get_after_end_slot_context_11 = ctx => ({});
    const get_after_slot_changes_11 = dirty => ({});
    const get_after_slot_context_11 = ctx => ({});
    const get_after_start_slot_changes_11 = dirty => ({});
    const get_after_start_slot_context_11 = ctx => ({});
    const get_after_title_slot_changes_11 = dirty => ({});
    const get_after_title_slot_context_11 = ctx => ({});
    const get_footer_slot_changes_11 = dirty => ({});
    const get_footer_slot_context_11 = ctx => ({});
    const get_title_slot_changes_11 = dirty => ({});
    const get_title_slot_context_11 = ctx => ({});
    const get_header_slot_changes_11 = dirty => ({});
    const get_header_slot_context_11 = ctx => ({});
    const get_before_title_slot_changes_11 = dirty => ({});
    const get_before_title_slot_context_11 = ctx => ({});
    const get_footer_slot_changes_10 = dirty => ({});
    const get_footer_slot_context_10 = ctx => ({});
    const get_inner_slot_changes_10 = dirty => ({});
    const get_inner_slot_context_10 = ctx => ({});
    const get_text_slot_changes_5 = dirty => ({});
    const get_text_slot_context_5 = ctx => ({});
    const get_subtitle_slot_changes_5 = dirty => ({});
    const get_subtitle_slot_context_5 = ctx => ({});
    const get_after_end_slot_changes_10 = dirty => ({});
    const get_after_end_slot_context_10 = ctx => ({});
    const get_after_slot_changes_10 = dirty => ({});
    const get_after_slot_context_10 = ctx => ({});
    const get_after_start_slot_changes_10 = dirty => ({});
    const get_after_start_slot_context_10 = ctx => ({});
    const get_after_title_slot_changes_10 = dirty => ({});
    const get_after_title_slot_context_10 = ctx => ({});
    const get_title_slot_changes_10 = dirty => ({});
    const get_title_slot_context_10 = ctx => ({});
    const get_before_title_slot_changes_10 = dirty => ({});
    const get_before_title_slot_context_10 = ctx => ({});
    const get_header_slot_changes_10 = dirty => ({});
    const get_header_slot_context_10 = ctx => ({});
    const get_inner_start_slot_changes_5 = dirty => ({});
    const get_inner_start_slot_context_5 = ctx => ({});
    const get_media_slot_changes_5 = dirty => ({});
    const get_media_slot_context_5 = ctx => ({});
    const get_content_start_slot_changes_5 = dirty => ({});
    const get_content_start_slot_context_5 = ctx => ({});
    const get_content_end_slot_changes_4 = dirty => ({});
    const get_content_end_slot_context_4 = ctx => ({});
    const get_content_slot_changes_4 = dirty => ({});
    const get_content_slot_context_4 = ctx => ({});
    const get_inner_end_slot_changes_4 = dirty => ({});
    const get_inner_end_slot_context_4 = ctx => ({});
    const get_inner_slot_changes_9 = dirty => ({});
    const get_inner_slot_context_9 = ctx => ({});
    const get_after_end_slot_changes_9 = dirty => ({});
    const get_after_end_slot_context_9 = ctx => ({});
    const get_after_slot_changes_9 = dirty => ({});
    const get_after_slot_context_9 = ctx => ({});
    const get_after_start_slot_changes_9 = dirty => ({});
    const get_after_start_slot_context_9 = ctx => ({});
    const get_after_title_slot_changes_9 = dirty => ({});
    const get_after_title_slot_context_9 = ctx => ({});
    const get_footer_slot_changes_9 = dirty => ({});
    const get_footer_slot_context_9 = ctx => ({});
    const get_title_slot_changes_9 = dirty => ({});
    const get_title_slot_context_9 = ctx => ({});
    const get_header_slot_changes_9 = dirty => ({});
    const get_header_slot_context_9 = ctx => ({});
    const get_before_title_slot_changes_9 = dirty => ({});
    const get_before_title_slot_context_9 = ctx => ({});
    const get_footer_slot_changes_8 = dirty => ({});
    const get_footer_slot_context_8 = ctx => ({});
    const get_inner_slot_changes_8 = dirty => ({});
    const get_inner_slot_context_8 = ctx => ({});
    const get_text_slot_changes_4 = dirty => ({});
    const get_text_slot_context_4 = ctx => ({});
    const get_subtitle_slot_changes_4 = dirty => ({});
    const get_subtitle_slot_context_4 = ctx => ({});
    const get_after_end_slot_changes_8 = dirty => ({});
    const get_after_end_slot_context_8 = ctx => ({});
    const get_after_slot_changes_8 = dirty => ({});
    const get_after_slot_context_8 = ctx => ({});
    const get_after_start_slot_changes_8 = dirty => ({});
    const get_after_start_slot_context_8 = ctx => ({});
    const get_after_title_slot_changes_8 = dirty => ({});
    const get_after_title_slot_context_8 = ctx => ({});
    const get_title_slot_changes_8 = dirty => ({});
    const get_title_slot_context_8 = ctx => ({});
    const get_before_title_slot_changes_8 = dirty => ({});
    const get_before_title_slot_context_8 = ctx => ({});
    const get_header_slot_changes_8 = dirty => ({});
    const get_header_slot_context_8 = ctx => ({});
    const get_inner_start_slot_changes_4 = dirty => ({});
    const get_inner_start_slot_context_4 = ctx => ({});
    const get_media_slot_changes_4 = dirty => ({});
    const get_media_slot_context_4 = ctx => ({});
    const get_content_start_slot_changes_4 = dirty => ({});
    const get_content_start_slot_context_4 = ctx => ({});
    const get_content_end_slot_changes_3 = dirty => ({});
    const get_content_end_slot_context_3 = ctx => ({});
    const get_content_slot_changes_3 = dirty => ({});
    const get_content_slot_context_3 = ctx => ({});
    const get_inner_end_slot_changes_3 = dirty => ({});
    const get_inner_end_slot_context_3 = ctx => ({});
    const get_inner_slot_changes_7 = dirty => ({});
    const get_inner_slot_context_7 = ctx => ({});
    const get_after_end_slot_changes_7 = dirty => ({});
    const get_after_end_slot_context_7 = ctx => ({});
    const get_after_slot_changes_7 = dirty => ({});
    const get_after_slot_context_7 = ctx => ({});
    const get_after_start_slot_changes_7 = dirty => ({});
    const get_after_start_slot_context_7 = ctx => ({});
    const get_after_title_slot_changes_7 = dirty => ({});
    const get_after_title_slot_context_7 = ctx => ({});
    const get_footer_slot_changes_7 = dirty => ({});
    const get_footer_slot_context_7 = ctx => ({});
    const get_title_slot_changes_7 = dirty => ({});
    const get_title_slot_context_7 = ctx => ({});
    const get_header_slot_changes_7 = dirty => ({});
    const get_header_slot_context_7 = ctx => ({});
    const get_before_title_slot_changes_7 = dirty => ({});
    const get_before_title_slot_context_7 = ctx => ({});
    const get_footer_slot_changes_6 = dirty => ({});
    const get_footer_slot_context_6 = ctx => ({});
    const get_inner_slot_changes_6 = dirty => ({});
    const get_inner_slot_context_6 = ctx => ({});
    const get_text_slot_changes_3 = dirty => ({});
    const get_text_slot_context_3 = ctx => ({});
    const get_subtitle_slot_changes_3 = dirty => ({});
    const get_subtitle_slot_context_3 = ctx => ({});
    const get_after_end_slot_changes_6 = dirty => ({});
    const get_after_end_slot_context_6 = ctx => ({});
    const get_after_slot_changes_6 = dirty => ({});
    const get_after_slot_context_6 = ctx => ({});
    const get_after_start_slot_changes_6 = dirty => ({});
    const get_after_start_slot_context_6 = ctx => ({});
    const get_after_title_slot_changes_6 = dirty => ({});
    const get_after_title_slot_context_6 = ctx => ({});
    const get_title_slot_changes_6 = dirty => ({});
    const get_title_slot_context_6 = ctx => ({});
    const get_before_title_slot_changes_6 = dirty => ({});
    const get_before_title_slot_context_6 = ctx => ({});
    const get_header_slot_changes_6 = dirty => ({});
    const get_header_slot_context_6 = ctx => ({});
    const get_inner_start_slot_changes_3 = dirty => ({});
    const get_inner_start_slot_context_3 = ctx => ({});
    const get_media_slot_changes_3 = dirty => ({});
    const get_media_slot_context_3 = ctx => ({});
    const get_content_start_slot_changes_3 = dirty => ({});
    const get_content_start_slot_context_3 = ctx => ({});
    const get_content_end_slot_changes_2 = dirty => ({});
    const get_content_end_slot_context_2 = ctx => ({});
    const get_content_slot_changes_2 = dirty => ({});
    const get_content_slot_context_2 = ctx => ({});
    const get_inner_end_slot_changes_2 = dirty => ({});
    const get_inner_end_slot_context_2 = ctx => ({});
    const get_inner_slot_changes_5 = dirty => ({});
    const get_inner_slot_context_5 = ctx => ({});
    const get_after_end_slot_changes_5 = dirty => ({});
    const get_after_end_slot_context_5 = ctx => ({});
    const get_after_slot_changes_5 = dirty => ({});
    const get_after_slot_context_5 = ctx => ({});
    const get_after_start_slot_changes_5 = dirty => ({});
    const get_after_start_slot_context_5 = ctx => ({});
    const get_after_title_slot_changes_5 = dirty => ({});
    const get_after_title_slot_context_5 = ctx => ({});
    const get_footer_slot_changes_5 = dirty => ({});
    const get_footer_slot_context_5 = ctx => ({});
    const get_title_slot_changes_5 = dirty => ({});
    const get_title_slot_context_5 = ctx => ({});
    const get_header_slot_changes_5 = dirty => ({});
    const get_header_slot_context_5 = ctx => ({});
    const get_before_title_slot_changes_5 = dirty => ({});
    const get_before_title_slot_context_5 = ctx => ({});
    const get_footer_slot_changes_4 = dirty => ({});
    const get_footer_slot_context_4 = ctx => ({});
    const get_inner_slot_changes_4 = dirty => ({});
    const get_inner_slot_context_4 = ctx => ({});
    const get_text_slot_changes_2 = dirty => ({});
    const get_text_slot_context_2 = ctx => ({});
    const get_subtitle_slot_changes_2 = dirty => ({});
    const get_subtitle_slot_context_2 = ctx => ({});
    const get_after_end_slot_changes_4 = dirty => ({});
    const get_after_end_slot_context_4 = ctx => ({});
    const get_after_slot_changes_4 = dirty => ({});
    const get_after_slot_context_4 = ctx => ({});
    const get_after_start_slot_changes_4 = dirty => ({});
    const get_after_start_slot_context_4 = ctx => ({});
    const get_after_title_slot_changes_4 = dirty => ({});
    const get_after_title_slot_context_4 = ctx => ({});
    const get_title_slot_changes_4 = dirty => ({});
    const get_title_slot_context_4 = ctx => ({});
    const get_before_title_slot_changes_4 = dirty => ({});
    const get_before_title_slot_context_4 = ctx => ({});
    const get_header_slot_changes_4 = dirty => ({});
    const get_header_slot_context_4 = ctx => ({});
    const get_inner_start_slot_changes_2 = dirty => ({});
    const get_inner_start_slot_context_2 = ctx => ({});
    const get_media_slot_changes_2 = dirty => ({});
    const get_media_slot_context_2 = ctx => ({});
    const get_content_start_slot_changes_2 = dirty => ({});
    const get_content_start_slot_context_2 = ctx => ({});
    const get_content_end_slot_changes_1 = dirty => ({});
    const get_content_end_slot_context_1 = ctx => ({});
    const get_content_slot_changes_1 = dirty => ({});
    const get_content_slot_context_1 = ctx => ({});
    const get_inner_end_slot_changes_1 = dirty => ({});
    const get_inner_end_slot_context_1 = ctx => ({});
    const get_inner_slot_changes_3 = dirty => ({});
    const get_inner_slot_context_3 = ctx => ({});
    const get_after_end_slot_changes_3 = dirty => ({});
    const get_after_end_slot_context_3 = ctx => ({});
    const get_after_slot_changes_3 = dirty => ({});
    const get_after_slot_context_3 = ctx => ({});
    const get_after_start_slot_changes_3 = dirty => ({});
    const get_after_start_slot_context_3 = ctx => ({});
    const get_after_title_slot_changes_3 = dirty => ({});
    const get_after_title_slot_context_3 = ctx => ({});
    const get_footer_slot_changes_3 = dirty => ({});
    const get_footer_slot_context_3 = ctx => ({});
    const get_title_slot_changes_3 = dirty => ({});
    const get_title_slot_context_3 = ctx => ({});
    const get_header_slot_changes_3 = dirty => ({});
    const get_header_slot_context_3 = ctx => ({});
    const get_before_title_slot_changes_3 = dirty => ({});
    const get_before_title_slot_context_3 = ctx => ({});
    const get_footer_slot_changes_2 = dirty => ({});
    const get_footer_slot_context_2 = ctx => ({});
    const get_inner_slot_changes_2 = dirty => ({});
    const get_inner_slot_context_2 = ctx => ({});
    const get_text_slot_changes_1 = dirty => ({});
    const get_text_slot_context_1 = ctx => ({});
    const get_subtitle_slot_changes_1 = dirty => ({});
    const get_subtitle_slot_context_1 = ctx => ({});
    const get_after_end_slot_changes_2 = dirty => ({});
    const get_after_end_slot_context_2 = ctx => ({});
    const get_after_slot_changes_2 = dirty => ({});
    const get_after_slot_context_2 = ctx => ({});
    const get_after_start_slot_changes_2 = dirty => ({});
    const get_after_start_slot_context_2 = ctx => ({});
    const get_after_title_slot_changes_2 = dirty => ({});
    const get_after_title_slot_context_2 = ctx => ({});
    const get_title_slot_changes_2 = dirty => ({});
    const get_title_slot_context_2 = ctx => ({});
    const get_before_title_slot_changes_2 = dirty => ({});
    const get_before_title_slot_context_2 = ctx => ({});
    const get_header_slot_changes_2 = dirty => ({});
    const get_header_slot_context_2 = ctx => ({});
    const get_inner_start_slot_changes_1 = dirty => ({});
    const get_inner_start_slot_context_1 = ctx => ({});
    const get_media_slot_changes_1 = dirty => ({});
    const get_media_slot_context_1 = ctx => ({});
    const get_content_start_slot_changes_1 = dirty => ({});
    const get_content_start_slot_context_1 = ctx => ({});
    const get_content_end_slot_changes = dirty => ({});
    const get_content_end_slot_context = ctx => ({});
    const get_content_slot_changes = dirty => ({});
    const get_content_slot_context = ctx => ({});
    const get_inner_end_slot_changes = dirty => ({});
    const get_inner_end_slot_context = ctx => ({});
    const get_inner_slot_changes_1 = dirty => ({});
    const get_inner_slot_context_1 = ctx => ({});
    const get_after_end_slot_changes_1 = dirty => ({});
    const get_after_end_slot_context_1 = ctx => ({});
    const get_after_slot_changes_1 = dirty => ({});
    const get_after_slot_context_1 = ctx => ({});
    const get_after_start_slot_changes_1 = dirty => ({});
    const get_after_start_slot_context_1 = ctx => ({});
    const get_after_title_slot_changes_1 = dirty => ({});
    const get_after_title_slot_context_1 = ctx => ({});
    const get_footer_slot_changes_1 = dirty => ({});
    const get_footer_slot_context_1 = ctx => ({});
    const get_title_slot_changes_1 = dirty => ({});
    const get_title_slot_context_1 = ctx => ({});
    const get_header_slot_changes_1 = dirty => ({});
    const get_header_slot_context_1 = ctx => ({});
    const get_before_title_slot_changes_1 = dirty => ({});
    const get_before_title_slot_context_1 = ctx => ({});
    const get_footer_slot_changes = dirty => ({});
    const get_footer_slot_context = ctx => ({});
    const get_inner_slot_changes = dirty => ({});
    const get_inner_slot_context = ctx => ({});
    const get_text_slot_changes = dirty => ({});
    const get_text_slot_context = ctx => ({});
    const get_subtitle_slot_changes = dirty => ({});
    const get_subtitle_slot_context = ctx => ({});
    const get_after_end_slot_changes = dirty => ({});
    const get_after_end_slot_context = ctx => ({});
    const get_after_slot_changes = dirty => ({});
    const get_after_slot_context = ctx => ({});
    const get_after_start_slot_changes = dirty => ({});
    const get_after_start_slot_context = ctx => ({});
    const get_after_title_slot_changes = dirty => ({});
    const get_after_title_slot_context = ctx => ({});
    const get_title_slot_changes$1 = dirty => ({});
    const get_title_slot_context$1 = ctx => ({});
    const get_before_title_slot_changes = dirty => ({});
    const get_before_title_slot_context = ctx => ({});
    const get_header_slot_changes = dirty => ({});
    const get_header_slot_context = ctx => ({});
    const get_inner_start_slot_changes = dirty => ({});
    const get_inner_start_slot_context = ctx => ({});
    const get_media_slot_changes = dirty => ({});
    const get_media_slot_context = ctx => ({});
    const get_content_start_slot_changes = dirty => ({});
    const get_content_start_slot_context = ctx => ({});
    const get_root_start_slot_changes = dirty => ({});
    const get_root_start_slot_context = ctx => ({});

    // (341:0) {:else}
    function create_else_block$3(ctx) {
    	let li;
    	let t0;
    	let current_block_type_index;
    	let if_block0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let useTooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	const root_start_slot_template = /*#slots*/ ctx[69]["root-start"];
    	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[83], get_root_start_slot_context);
    	const if_block_creators = [create_if_block_4, create_if_block_67, create_else_block_7];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*swipeout*/ ctx[14]) return 0;
    		if (/*isLink*/ ctx[38]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && !/*isSortableOpposite*/ ctx[44] && create_if_block_3$3(ctx);
    	let if_block2 = (/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_2$4(ctx);
    	const root_slot_template = /*#slots*/ ctx[69].root;
    	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[83], get_root_slot_context);
    	const root_end_slot_template = /*#slots*/ ctx[69]["root-end"];
    	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[83], get_root_end_slot_context);

    	let li_levels = [
    		{ class: /*liClasses*/ ctx[42] },
    		{
    			"data-virtual-list-index": /*virtualListIndex*/ ctx[24]
    		},
    		restProps(/*$$restProps*/ ctx[48])
    	];

    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (root_start_slot) root_start_slot.c();
    			t0 = space();
    			if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (root_slot) root_slot.c();
    			t4 = space();
    			if (root_end_slot) root_end_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$d, 341, 2, 9886);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (root_start_slot) {
    				root_start_slot.m(li, null);
    			}

    			append_dev(li, t0);
    			if_blocks[current_block_type_index].m(li, null);
    			append_dev(li, t1);
    			if (if_block1) if_block1.m(li, null);
    			append_dev(li, t2);
    			if (if_block2) if_block2.m(li, null);
    			append_dev(li, t3);

    			if (root_slot) {
    				root_slot.m(li, null);
    			}

    			append_dev(li, t4);

    			if (root_end_slot) {
    				root_end_slot.m(li, null);
    			}

    			/*li_binding_2*/ ctx[82](li);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(useTooltip_action = useTooltip.call(null, li, {
    					tooltip: /*tooltip*/ ctx[7],
    					tooltipTrigger: /*tooltipTrigger*/ ctx[8]
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (root_start_slot) {
    				if (root_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						root_start_slot,
    						root_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(root_start_slot_template, /*$$scope*/ ctx[83], dirty, get_root_start_slot_changes),
    						get_root_start_slot_context
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(li, t1);
    			}

    			if (/*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && !/*isSortableOpposite*/ ctx[44]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_3$3(ctx);
    					if_block1.c();
    					if_block1.m(li, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2$4(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(li, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (root_slot) {
    				if (root_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						root_slot,
    						root_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(root_slot_template, /*$$scope*/ ctx[83], dirty, get_root_slot_changes),
    						get_root_slot_context
    					);
    				}
    			}

    			if (root_end_slot) {
    				if (root_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						root_end_slot,
    						root_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(root_end_slot_template, /*$$scope*/ ctx[83], dirty, get_root_end_slot_changes),
    						get_root_end_slot_context
    					);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				(!current || dirty[1] & /*liClasses*/ 2048) && { class: /*liClasses*/ ctx[42] },
    				(!current || dirty[0] & /*virtualListIndex*/ 16777216) && {
    					"data-virtual-list-index": /*virtualListIndex*/ ctx[24]
    				},
    				dirty[1] & /*$$restProps*/ 131072 && restProps(/*$$restProps*/ ctx[48])
    			]));

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 384) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[7],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[8]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(root_start_slot, local);
    			transition_in(if_block0);
    			transition_in(if_block2);
    			transition_in(root_slot, local);
    			transition_in(root_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(root_start_slot, local);
    			transition_out(if_block0);
    			transition_out(if_block2);
    			transition_out(root_slot, local);
    			transition_out(root_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (root_start_slot) root_start_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (root_slot) root_slot.d(detaching);
    			if (root_end_slot) root_end_slot.d(detaching);
    			/*li_binding_2*/ ctx[82](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(341:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (329:19) 
    function create_if_block_1$5(ctx) {
    	let li;
    	let t0_value = plainText(/*title*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let useTooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	let li_levels = [
    		{ class: /*liClasses*/ ctx[42] },
    		{
    			"data-virtual-list-index": /*virtualListIndex*/ ctx[24]
    		},
    		restProps(/*$$restProps*/ ctx[48])
    	];

    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			t0 = text(t0_value);
    			t1 = space();
    			if (default_slot) default_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$d, 329, 2, 9632);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t0);
    			append_dev(li, t1);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			/*li_binding_1*/ ctx[71](li);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li, "click", /*onClick*/ ctx[46], false, false, false),
    					action_destroyer(useTooltip_action = useTooltip.call(null, li, {
    						tooltip: /*tooltip*/ ctx[7],
    						tooltipTrigger: /*tooltipTrigger*/ ctx[8]
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				(!current || dirty[1] & /*liClasses*/ 2048) && { class: /*liClasses*/ ctx[42] },
    				(!current || dirty[0] & /*virtualListIndex*/ 16777216) && {
    					"data-virtual-list-index": /*virtualListIndex*/ ctx[24]
    				},
    				dirty[1] & /*$$restProps*/ 131072 && restProps(/*$$restProps*/ ctx[48])
    			]));

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 384) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[7],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[8]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    			/*li_binding_1*/ ctx[71](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(329:19) ",
    		ctx
    	});

    	return block;
    }

    // (318:0) {#if divider || groupTitle}
    function create_if_block$8(ctx) {
    	let li;
    	let span;
    	let useTooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	let li_levels = [
    		{ class: /*liClasses*/ ctx[42] },
    		{
    			"data-virtual-list-index": /*virtualListIndex*/ ctx[24]
    		},
    		restProps(/*$$restProps*/ ctx[48])
    	];

    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			span = element("span");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			add_location(span, file$d, 326, 4, 9557);
    			set_attributes(li, li_data);
    			add_location(li, file$d, 318, 2, 9353);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, span);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(span, null);
    			}

    			/*li_binding*/ ctx[70](li);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li, "click", /*onClick*/ ctx[46], false, false, false),
    					action_destroyer(useTooltip_action = useTooltip.call(null, li, {
    						tooltip: /*tooltip*/ ctx[7],
    						tooltipTrigger: /*tooltipTrigger*/ ctx[8]
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*title*/ 2)) {
    					default_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1] : dirty);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				(!current || dirty[1] & /*liClasses*/ 2048) && { class: /*liClasses*/ ctx[42] },
    				(!current || dirty[0] & /*virtualListIndex*/ 16777216) && {
    					"data-virtual-list-index": /*virtualListIndex*/ ctx[24]
    				},
    				dirty[1] & /*$$restProps*/ 131072 && restProps(/*$$restProps*/ ctx[48])
    			]));

    			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 384) useTooltip_action.update.call(null, {
    				tooltip: /*tooltip*/ ctx[7],
    				tooltipTrigger: /*tooltipTrigger*/ ctx[8]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			/*li_binding*/ ctx[70](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(318:0) {#if divider || groupTitle}",
    		ctx
    	});

    	return block;
    }

    // (838:4) {:else}
    function create_else_block_7(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_88, create_else_block_9];
    	const if_blocks = [];

    	function select_block_type_8(ctx, dirty) {
    		if (/*checkbox*/ ctx[17] || /*radio*/ ctx[18]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_8(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_8(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_7.name,
    		type: "else",
    		source: "(838:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (716:21) 
    function create_if_block_67(ctx) {
    	let a;
    	let div1;
    	let t0;
    	let t1;
    	let t2;
    	let div0;
    	let t3;
    	let current_block_type_index;
    	let if_block2;
    	let t4;
    	let t5;
    	let t6;
    	let useRouteProps_action;
    	let current;
    	let mounted;
    	let dispose;
    	const content_start_slot_template = /*#slots*/ ctx[69]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[83], get_content_start_slot_context_3);
    	let if_block0 = /*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44] && create_if_block_87(ctx);
    	let if_block1 = /*hasMedia*/ ctx[37] && create_if_block_85(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[69]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_start_slot_context_3);
    	const if_block_creators = [create_if_block_68, create_else_block_6];
    	const if_blocks = [];

    	function select_block_type_7(ctx, dirty) {
    		if (/*isMedia*/ ctx[26]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_7(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const inner_end_slot_template = /*#slots*/ ctx[69]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_end_slot_context_3);
    	const content_slot_template = /*#slots*/ ctx[69].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[83], get_content_slot_context_3);
    	const content_end_slot_template = /*#slots*/ ctx[69]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[83], get_content_end_slot_context_3);
    	let a_levels = [{ class: /*linkClasses*/ ctx[40] }, /*linkAttrs*/ ctx[39]];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			div1 = element("div");
    			if (content_start_slot) content_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div0 = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t3 = space();
    			if_block2.c();
    			t4 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t5 = space();
    			if (content_slot) content_slot.c();
    			t6 = space();
    			if (content_end_slot) content_end_slot.c();
    			attr_dev(div0, "class", "item-inner");
    			add_location(div0, file$d, 737, 10, 24957);
    			attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			add_location(div1, file$d, 724, 8, 24508);
    			set_attributes(a, a_data);
    			add_location(a, file$d, 716, 6, 24309);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, div1);

    			if (content_start_slot) {
    				content_start_slot.m(div1, null);
    			}

    			append_dev(div1, t0);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, div0);

    			if (inner_start_slot) {
    				inner_start_slot.m(div0, null);
    			}

    			append_dev(div0, t3);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div0, t4);

    			if (inner_end_slot) {
    				inner_end_slot.m(div0, null);
    			}

    			/*div0_binding_2*/ ctx[77](div0);
    			append_dev(div1, t5);

    			if (content_slot) {
    				content_slot.m(div1, null);
    			}

    			append_dev(div1, t6);

    			if (content_end_slot) {
    				content_end_slot.m(div1, null);
    			}

    			/*a_binding_1*/ ctx[78](a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[25])),
    					listen_dev(a, "click", /*onClick*/ ctx[46], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[83], dirty, get_content_start_slot_changes_3),
    						get_content_start_slot_context_3
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_87(ctx);
    					if_block0.c();
    					if_block0.m(div1, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*hasMedia*/ ctx[37]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasMedia*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_85(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_start_slot_changes_3),
    						get_inner_start_slot_context_3
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_7(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div0, t4);
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_end_slot_changes_3),
    						get_inner_end_slot_context_3
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[83], dirty, get_content_slot_changes_3),
    						get_content_slot_context_3
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[83], dirty, get_content_end_slot_changes_3),
    						get_content_end_slot_context_3
    					);
    				}
    			}

    			if (!current || dirty[1] & /*contentClasses*/ 1024) {
    				attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty[1] & /*linkClasses*/ 512) && { class: /*linkClasses*/ ctx[40] },
    				dirty[1] & /*linkAttrs*/ 256 && /*linkAttrs*/ ctx[39]
    			]));

    			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 33554432) useRouteProps_action.update.call(null, /*routeProps*/ ctx[25]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			/*div0_binding_2*/ ctx[77](null);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    			/*a_binding_1*/ ctx[78](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_67.name,
    		type: "if",
    		source: "(716:21) ",
    		ctx
    	});

    	return block;
    }

    // (350:4) {#if swipeout}
    function create_if_block_4(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block_5, create_else_block_2$1];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*isLink*/ ctx[38]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "swipeout-content");
    			add_location(div, file$d, 350, 6, 10119);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(350:4) {#if swipeout}",
    		ctx
    	});

    	return block;
    }

    // (964:6) {:else}
    function create_else_block_9(ctx) {
    	let div1;
    	let t0;
    	let t1;
    	let t2;
    	let div0;
    	let t3;
    	let current_block_type_index;
    	let if_block2;
    	let t4;
    	let t5;
    	let t6;
    	let current;
    	let mounted;
    	let dispose;
    	const content_start_slot_template = /*#slots*/ ctx[69]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[83], get_content_start_slot_context_5);
    	let if_block0 = /*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44] && create_if_block_128(ctx);
    	let if_block1 = /*hasMedia*/ ctx[37] && create_if_block_126(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[69]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_start_slot_context_5);
    	const if_block_creators = [create_if_block_109, create_else_block_10];
    	const if_blocks = [];

    	function select_block_type_10(ctx, dirty) {
    		if (/*isMedia*/ ctx[26]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_10(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const inner_end_slot_template = /*#slots*/ ctx[69]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_end_slot_context_5);
    	const content_slot_template = /*#slots*/ ctx[69].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[83], get_content_slot_context_5);
    	const content_end_slot_template = /*#slots*/ ctx[69]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[83], get_content_end_slot_context_5);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (content_start_slot) content_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div0 = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t3 = space();
    			if_block2.c();
    			t4 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t5 = space();
    			if (content_slot) content_slot.c();
    			t6 = space();
    			if (content_end_slot) content_end_slot.c();
    			attr_dev(div0, "class", "item-inner");
    			add_location(div0, file$d, 977, 10, 33409);
    			attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			add_location(div1, file$d, 964, 8, 32941);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);

    			if (content_start_slot) {
    				content_start_slot.m(div1, null);
    			}

    			append_dev(div1, t0);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, div0);

    			if (inner_start_slot) {
    				inner_start_slot.m(div0, null);
    			}

    			append_dev(div0, t3);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div0, t4);

    			if (inner_end_slot) {
    				inner_end_slot.m(div0, null);
    			}

    			/*div0_binding_3*/ ctx[81](div0);
    			append_dev(div1, t5);

    			if (content_slot) {
    				content_slot.m(div1, null);
    			}

    			append_dev(div1, t6);

    			if (content_end_slot) {
    				content_end_slot.m(div1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", /*onClick*/ ctx[46], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[83], dirty, get_content_start_slot_changes_5),
    						get_content_start_slot_context_5
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_128(ctx);
    					if_block0.c();
    					if_block0.m(div1, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*hasMedia*/ ctx[37]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasMedia*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_126(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_start_slot_changes_5),
    						get_inner_start_slot_context_5
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_10(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div0, t4);
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_end_slot_changes_5),
    						get_inner_end_slot_context_5
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[83], dirty, get_content_slot_changes_5),
    						get_content_slot_context_5
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[83], dirty, get_content_end_slot_changes_5),
    						get_content_end_slot_context_5
    					);
    				}
    			}

    			if (!current || dirty[1] & /*contentClasses*/ 1024) {
    				attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			/*div0_binding_3*/ ctx[81](null);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_9.name,
    		type: "else",
    		source: "(964:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (840:6) {#if checkbox || radio}
    function create_if_block_88(ctx) {
    	let label;
    	let t0;
    	let t1;
    	let input;
    	let input_value_value;
    	let input_type_value;
    	let t2;
    	let i;
    	let i_class_value;
    	let t3;
    	let t4;
    	let div;
    	let t5;
    	let current_block_type_index;
    	let if_block2;
    	let t6;
    	let t7;
    	let t8;
    	let current;
    	let mounted;
    	let dispose;
    	const content_start_slot_template = /*#slots*/ ctx[69]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[83], get_content_start_slot_context_4);
    	let if_block0 = /*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44] && create_if_block_108(ctx);
    	let if_block1 = /*hasMedia*/ ctx[37] && create_if_block_106(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[69]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_start_slot_context_4);
    	const if_block_creators = [create_if_block_89, create_else_block_8];
    	const if_blocks = [];

    	function select_block_type_9(ctx, dirty) {
    		if (/*isMedia*/ ctx[26]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_9(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const inner_end_slot_template = /*#slots*/ ctx[69]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_end_slot_context_4);
    	const content_slot_template = /*#slots*/ ctx[69].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[83], get_content_slot_context_4);
    	const content_end_slot_template = /*#slots*/ ctx[69]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[83], get_content_end_slot_context_4);

    	const block = {
    		c: function create() {
    			label = element("label");
    			if (content_start_slot) content_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			i = element("i");
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			div = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t5 = space();
    			if_block2.c();
    			t6 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t7 = space();
    			if (content_slot) content_slot.c();
    			t8 = space();
    			if (content_end_slot) content_end_slot.c();

    			input.value = input_value_value = typeof /*value*/ ctx[20] === 'undefined'
    			? ''
    			: /*value*/ ctx[20];

    			attr_dev(input, "name", /*name*/ ctx[19]);
    			input.checked = /*checked*/ ctx[0];
    			input.readOnly = /*readonly*/ ctx[21];
    			input.disabled = /*disabled*/ ctx[23];
    			input.required = /*required*/ ctx[22];
    			attr_dev(input, "type", input_type_value = /*radio*/ ctx[18] ? 'radio' : 'checkbox');
    			add_location(input, file$d, 845, 10, 28807);
    			attr_dev(i, "class", i_class_value = `icon icon-${/*radio*/ ctx[18] ? 'radio' : 'checkbox'}`);
    			add_location(i, file$d, 856, 10, 29122);
    			attr_dev(div, "class", "item-inner");
    			add_location(div, file$d, 865, 10, 29428);
    			attr_dev(label, "class", /*contentClasses*/ ctx[41]);
    			add_location(label, file$d, 840, 8, 28575);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);

    			if (content_start_slot) {
    				content_start_slot.m(label, null);
    			}

    			append_dev(label, t0);
    			if (if_block0) if_block0.m(label, null);
    			append_dev(label, t1);
    			append_dev(label, input);
    			/*input_binding_1*/ ctx[79](input);
    			append_dev(label, t2);
    			append_dev(label, i);
    			append_dev(label, t3);
    			if (if_block1) if_block1.m(label, null);
    			append_dev(label, t4);
    			append_dev(label, div);

    			if (inner_start_slot) {
    				inner_start_slot.m(div, null);
    			}

    			append_dev(div, t5);
    			if_blocks[current_block_type_index].m(div, null);
    			append_dev(div, t6);

    			if (inner_end_slot) {
    				inner_end_slot.m(div, null);
    			}

    			/*div_binding_1*/ ctx[80](div);
    			append_dev(label, t7);

    			if (content_slot) {
    				content_slot.m(label, null);
    			}

    			append_dev(label, t8);

    			if (content_end_slot) {
    				content_end_slot.m(label, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*onChange*/ ctx[47], false, false, false),
    					listen_dev(label, "click", /*onClick*/ ctx[46], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[83], dirty, get_content_start_slot_changes_4),
    						get_content_start_slot_context_4
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_108(ctx);
    					if_block0.c();
    					if_block0.m(label, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty[0] & /*value*/ 1048576 && input_value_value !== (input_value_value = typeof /*value*/ ctx[20] === 'undefined'
    			? ''
    			: /*value*/ ctx[20]) && input.value !== input_value_value) {
    				prop_dev(input, "value", input_value_value);
    			}

    			if (!current || dirty[0] & /*name*/ 524288) {
    				attr_dev(input, "name", /*name*/ ctx[19]);
    			}

    			if (!current || dirty[0] & /*checked*/ 1) {
    				prop_dev(input, "checked", /*checked*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*readonly*/ 2097152) {
    				prop_dev(input, "readOnly", /*readonly*/ ctx[21]);
    			}

    			if (!current || dirty[0] & /*disabled*/ 8388608) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[23]);
    			}

    			if (!current || dirty[0] & /*required*/ 4194304) {
    				prop_dev(input, "required", /*required*/ ctx[22]);
    			}

    			if (!current || dirty[0] & /*radio*/ 262144 && input_type_value !== (input_type_value = /*radio*/ ctx[18] ? 'radio' : 'checkbox')) {
    				attr_dev(input, "type", input_type_value);
    			}

    			if (!current || dirty[0] & /*radio*/ 262144 && i_class_value !== (i_class_value = `icon icon-${/*radio*/ ctx[18] ? 'radio' : 'checkbox'}`)) {
    				attr_dev(i, "class", i_class_value);
    			}

    			if (/*hasMedia*/ ctx[37]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasMedia*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_106(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(label, t4);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_start_slot_changes_4),
    						get_inner_start_slot_context_4
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_9(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div, t6);
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_end_slot_changes_4),
    						get_inner_end_slot_context_4
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[83], dirty, get_content_slot_changes_4),
    						get_content_slot_context_4
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[83], dirty, get_content_end_slot_changes_4),
    						get_content_end_slot_context_4
    					);
    				}
    			}

    			if (!current || dirty[1] & /*contentClasses*/ 1024) {
    				attr_dev(label, "class", /*contentClasses*/ ctx[41]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			/*input_binding_1*/ ctx[79](null);
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			/*div_binding_1*/ ctx[80](null);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_88.name,
    		type: "if",
    		source: "(840:6) {#if checkbox || radio}",
    		ctx
    	});

    	return block;
    }

    // (967:10) {#if isSortable && sortable !== false && isSortableOpposite}
    function create_if_block_128(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$d, 967, 12, 33112);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_128.name,
    		type: "if",
    		source: "(967:10) {#if isSortable && sortable !== false && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (970:10) {#if hasMedia}
    function create_if_block_126(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[3] !== 'undefined' && create_if_block_127(ctx);
    	const media_slot_template = /*#slots*/ ctx[69].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[83], get_media_slot_context_5);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$d, 970, 12, 33198);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[3] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_127(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[83], dirty, get_media_slot_changes_5),
    						get_media_slot_context_5
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_126.name,
    		type: "if",
    		source: "(970:10) {#if hasMedia}",
    		ctx
    	});

    	return block;
    }

    // (972:14) {#if typeof media !== 'undefined'}
    function create_if_block_127(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$d, 972, 16, 33288);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 8 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_127.name,
    		type: "if",
    		source: "(972:14) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (1032:12) {:else}
    function create_else_block_10(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block2_anchor;
    	let current;
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_11);
    	let if_block0 = (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) && create_if_block_123(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_11);
    	let if_block1 = /*hasAfter*/ ctx[31] && create_if_block_120(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_11);
    	let if_block2 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_119(ctx);

    	const block = {
    		c: function create() {
    			if (before_title_slot) before_title_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (after_title_slot) after_title_slot.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (inner_slot) inner_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (before_title_slot) {
    				before_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (after_title_slot) {
    				after_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t4, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_11),
    						get_before_title_slot_context_11
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 56) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_123(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_11),
    						get_after_title_slot_context_11
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_120(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_11),
    						get_inner_slot_context_11
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_119(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_title_slot, local);
    			transition_in(if_block0);
    			transition_in(after_title_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_slot, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_title_slot, local);
    			transition_out(if_block0);
    			transition_out(after_title_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_slot, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_10.name,
    		type: "else",
    		source: "(1032:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (980:12) {#if isMedia}
    function create_if_block_109(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let if_block6_anchor;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_118(ctx);
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_10);
    	let if_block1 = /*hasTitle*/ ctx[36] && create_if_block_117(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_10);
    	let if_block2 = /*hasAfter*/ ctx[31] && create_if_block_114(ctx);
    	let if_block3 = /*hasSubtitle*/ ctx[33] && create_if_block_113(ctx);
    	let if_block4 = /*hasText*/ ctx[32] && create_if_block_112(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_10);
    	let if_block5 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_111(ctx);
    	let if_block6 = /*hasFooter*/ ctx[34] && create_if_block_110(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (before_title_slot) before_title_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_title_slot) after_title_slot.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (inner_slot) inner_slot.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    			attr_dev(div, "class", "item-title-row");
    			add_location(div, file$d, 986, 14, 33728);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			if (before_title_slot) {
    				before_title_slot.m(div, null);
    			}

    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_title_slot) {
    				after_title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block2) if_block2.m(div, null);
    			insert_dev(target, t4, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t6, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t7, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_118(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_10),
    						get_before_title_slot_context_10
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_117(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_10),
    						get_after_title_slot_context_10
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_114(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*hasSubtitle*/ ctx[33]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[1] & /*hasSubtitle*/ 4) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_113(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t5.parentNode, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*hasText*/ ctx[32]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasText*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_112(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t6.parentNode, t6);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_10),
    						get_inner_slot_context_10
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_111(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t8.parentNode, t8);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_110(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(before_title_slot, local);
    			transition_in(if_block1);
    			transition_in(after_title_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(inner_slot, local);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(before_title_slot, local);
    			transition_out(if_block1);
    			transition_out(after_title_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(inner_slot, local);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t4);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_109.name,
    		type: "if",
    		source: "(980:12) {#if isMedia}",
    		ctx
    	});

    	return block;
    }

    // (1034:14) {#if hasTitle || hasHeader || hasFooter}
    function create_if_block_123(ctx) {
    	let div;
    	let t0;
    	let t1_value = plainText(/*title*/ ctx[1]) + "";
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_125(ctx);
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_11);
    	let if_block1 = /*hasFooter*/ ctx[34] && create_if_block_124(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			if (title_slot) title_slot.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$d, 1034, 16, 35463);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_125(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*title*/ 2) && t1_value !== (t1_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t1, t1_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_11),
    						get_title_slot_context_11
    					);
    				}
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_124(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(title_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(title_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (title_slot) title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_123.name,
    		type: "if",
    		source: "(1034:14) {#if hasTitle || hasHeader || hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (1036:18) {#if hasHeader}
    function create_if_block_125(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_11);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$d, 1036, 20, 35542);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_11),
    						get_header_slot_context_11
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_125.name,
    		type: "if",
    		source: "(1036:18) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (1044:18) {#if hasFooter}
    function create_if_block_124(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_11);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$d, 1044, 20, 35837);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_11),
    						get_footer_slot_context_11
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_124.name,
    		type: "if",
    		source: "(1044:18) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (1053:14) {#if hasAfter}
    function create_if_block_120(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_11);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_122(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_121(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_11);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_11);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$d, 1053, 16, 36131);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_11),
    						get_after_start_slot_context_11
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_122(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_121(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_11),
    						get_after_slot_context_11
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_11),
    						get_after_end_slot_context_11
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_120.name,
    		type: "if",
    		source: "(1053:14) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (1056:18) {#if typeof after !== 'undefined'}
    function create_if_block_122(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$d, 1056, 20, 36275);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_122.name,
    		type: "if",
    		source: "(1056:18) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (1059:18) {#if typeof badge !== 'undefined'}
    function create_if_block_121(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_121.name,
    		type: "if",
    		source: "(1059:18) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (1060:20) <Badge color={badgeColor}>
    function create_default_slot_11(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(1060:20) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (1067:14) {#if !(swipeout || accordionItem)}
    function create_if_block_119(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_119.name,
    		type: "if",
    		source: "(1067:14) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (981:14) {#if hasHeader}
    function create_if_block_118(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_10);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$d, 981, 16, 33566);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_10),
    						get_header_slot_context_10
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_118.name,
    		type: "if",
    		source: "(981:14) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (989:16) {#if hasTitle}
    function create_if_block_117(ctx) {
    	let div;
    	let t0_value = plainText(/*title*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_10);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (title_slot) title_slot.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$d, 989, 18, 33851);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_10),
    						get_title_slot_context_10
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_117.name,
    		type: "if",
    		source: "(989:16) {#if hasTitle}",
    		ctx
    	});

    	return block;
    }

    // (996:16) {#if hasAfter}
    function create_if_block_114(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_10);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_116(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_115(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_10);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_10);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$d, 996, 18, 34097);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_10),
    						get_after_start_slot_context_10
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_116(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_115(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_10),
    						get_after_slot_context_10
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_10),
    						get_after_end_slot_context_10
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_114.name,
    		type: "if",
    		source: "(996:16) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (999:20) {#if typeof after !== 'undefined'}
    function create_if_block_116(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$d, 999, 22, 34247);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_116.name,
    		type: "if",
    		source: "(999:20) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (1002:20) {#if typeof badge !== 'undefined'}
    function create_if_block_115(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_115.name,
    		type: "if",
    		source: "(1002:20) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (1003:22) <Badge color={badgeColor}>
    function create_default_slot_10(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(1003:22) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (1010:14) {#if hasSubtitle}
    function create_if_block_113(ctx) {
    	let div;
    	let t0_value = plainText(/*subtitle*/ ctx[4]) + "";
    	let t0;
    	let t1;
    	let current;
    	const subtitle_slot_template = /*#slots*/ ctx[69].subtitle;
    	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[83], get_subtitle_slot_context_5);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (subtitle_slot) subtitle_slot.c();
    			attr_dev(div, "class", "item-subtitle");
    			add_location(div, file$d, 1010, 16, 34665);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (subtitle_slot) {
    				subtitle_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*subtitle*/ 16) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

    			if (subtitle_slot) {
    				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						subtitle_slot,
    						subtitle_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[83], dirty, get_subtitle_slot_changes_5),
    						get_subtitle_slot_context_5
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(subtitle_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(subtitle_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (subtitle_slot) subtitle_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_113.name,
    		type: "if",
    		source: "(1010:14) {#if hasSubtitle}",
    		ctx
    	});

    	return block;
    }

    // (1016:14) {#if hasText}
    function create_if_block_112(ctx) {
    	let div;
    	let t0_value = plainText(/*text*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const text_slot_template = /*#slots*/ ctx[69].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[83], get_text_slot_context_5);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (text_slot) text_slot.c();
    			attr_dev(div, "class", "item-text");
    			add_location(div, file$d, 1016, 16, 34863);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[83], dirty, get_text_slot_changes_5),
    						get_text_slot_context_5
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (text_slot) text_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_112.name,
    		type: "if",
    		source: "(1016:14) {#if hasText}",
    		ctx
    	});

    	return block;
    }

    // (1023:14) {#if !(swipeout || accordionItem)}
    function create_if_block_111(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_111.name,
    		type: "if",
    		source: "(1023:14) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (1026:14) {#if hasFooter}
    function create_if_block_110(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_10);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$d, 1026, 16, 35181);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_10),
    						get_footer_slot_context_10
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_110.name,
    		type: "if",
    		source: "(1026:14) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (843:10) {#if isSortable && sortable !== false && isSortableOpposite}
    function create_if_block_108(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$d, 843, 12, 28748);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_108.name,
    		type: "if",
    		source: "(843:10) {#if isSortable && sortable !== false && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (858:10) {#if hasMedia}
    function create_if_block_106(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[3] !== 'undefined' && create_if_block_107(ctx);
    	const media_slot_template = /*#slots*/ ctx[69].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[83], get_media_slot_context_4);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$d, 858, 12, 29217);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[3] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_107(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[83], dirty, get_media_slot_changes_4),
    						get_media_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_106.name,
    		type: "if",
    		source: "(858:10) {#if hasMedia}",
    		ctx
    	});

    	return block;
    }

    // (860:14) {#if typeof media !== 'undefined'}
    function create_if_block_107(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$d, 860, 16, 29307);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 8 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_107.name,
    		type: "if",
    		source: "(860:14) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (920:12) {:else}
    function create_else_block_8(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block2_anchor;
    	let current;
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_9);
    	let if_block0 = (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) && create_if_block_103(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_9);
    	let if_block1 = /*hasAfter*/ ctx[31] && create_if_block_100(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_9);
    	let if_block2 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_99(ctx);

    	const block = {
    		c: function create() {
    			if (before_title_slot) before_title_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (after_title_slot) after_title_slot.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (inner_slot) inner_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (before_title_slot) {
    				before_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (after_title_slot) {
    				after_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t4, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_9),
    						get_before_title_slot_context_9
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 56) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_103(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_9),
    						get_after_title_slot_context_9
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_100(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_9),
    						get_inner_slot_context_9
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_99(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_title_slot, local);
    			transition_in(if_block0);
    			transition_in(after_title_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_slot, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_title_slot, local);
    			transition_out(if_block0);
    			transition_out(after_title_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_slot, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_8.name,
    		type: "else",
    		source: "(920:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (868:12) {#if isMedia}
    function create_if_block_89(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let if_block6_anchor;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_98(ctx);
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_8);
    	let if_block1 = /*hasTitle*/ ctx[36] && create_if_block_97(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_8);
    	let if_block2 = /*hasAfter*/ ctx[31] && create_if_block_94(ctx);
    	let if_block3 = /*hasSubtitle*/ ctx[33] && create_if_block_93(ctx);
    	let if_block4 = /*hasText*/ ctx[32] && create_if_block_92(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_8);
    	let if_block5 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_91(ctx);
    	let if_block6 = /*hasFooter*/ ctx[34] && create_if_block_90(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (before_title_slot) before_title_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_title_slot) after_title_slot.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (inner_slot) inner_slot.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    			attr_dev(div, "class", "item-title-row");
    			add_location(div, file$d, 874, 14, 29747);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			if (before_title_slot) {
    				before_title_slot.m(div, null);
    			}

    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_title_slot) {
    				after_title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block2) if_block2.m(div, null);
    			insert_dev(target, t4, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t6, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t7, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_98(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_8),
    						get_before_title_slot_context_8
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_97(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_8),
    						get_after_title_slot_context_8
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_94(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*hasSubtitle*/ ctx[33]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[1] & /*hasSubtitle*/ 4) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_93(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t5.parentNode, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*hasText*/ ctx[32]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasText*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_92(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t6.parentNode, t6);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_8),
    						get_inner_slot_context_8
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_91(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t8.parentNode, t8);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_90(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(before_title_slot, local);
    			transition_in(if_block1);
    			transition_in(after_title_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(inner_slot, local);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(before_title_slot, local);
    			transition_out(if_block1);
    			transition_out(after_title_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(inner_slot, local);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t4);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_89.name,
    		type: "if",
    		source: "(868:12) {#if isMedia}",
    		ctx
    	});

    	return block;
    }

    // (922:14) {#if hasTitle || hasHeader || hasFooter}
    function create_if_block_103(ctx) {
    	let div;
    	let t0;
    	let t1_value = plainText(/*title*/ ctx[1]) + "";
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_105(ctx);
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_9);
    	let if_block1 = /*hasFooter*/ ctx[34] && create_if_block_104(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			if (title_slot) title_slot.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$d, 922, 16, 31482);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_105(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*title*/ 2) && t1_value !== (t1_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t1, t1_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_9),
    						get_title_slot_context_9
    					);
    				}
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_104(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(title_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(title_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (title_slot) title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_103.name,
    		type: "if",
    		source: "(922:14) {#if hasTitle || hasHeader || hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (924:18) {#if hasHeader}
    function create_if_block_105(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_9);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$d, 924, 20, 31561);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_9),
    						get_header_slot_context_9
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_105.name,
    		type: "if",
    		source: "(924:18) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (932:18) {#if hasFooter}
    function create_if_block_104(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_9);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$d, 932, 20, 31856);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_9),
    						get_footer_slot_context_9
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_104.name,
    		type: "if",
    		source: "(932:18) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (941:14) {#if hasAfter}
    function create_if_block_100(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_9);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_102(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_101(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_9);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_9);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$d, 941, 16, 32150);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_9),
    						get_after_start_slot_context_9
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_102(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_101(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_9),
    						get_after_slot_context_9
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_9),
    						get_after_end_slot_context_9
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_100.name,
    		type: "if",
    		source: "(941:14) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (944:18) {#if typeof after !== 'undefined'}
    function create_if_block_102(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$d, 944, 20, 32294);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_102.name,
    		type: "if",
    		source: "(944:18) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (947:18) {#if typeof badge !== 'undefined'}
    function create_if_block_101(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_101.name,
    		type: "if",
    		source: "(947:18) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (948:20) <Badge color={badgeColor}>
    function create_default_slot_9(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(948:20) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (955:14) {#if !(swipeout || accordionItem)}
    function create_if_block_99(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_99.name,
    		type: "if",
    		source: "(955:14) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (869:14) {#if hasHeader}
    function create_if_block_98(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_8);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$d, 869, 16, 29585);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_8),
    						get_header_slot_context_8
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_98.name,
    		type: "if",
    		source: "(869:14) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (877:16) {#if hasTitle}
    function create_if_block_97(ctx) {
    	let div;
    	let t0_value = plainText(/*title*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_8);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (title_slot) title_slot.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$d, 877, 18, 29870);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_8),
    						get_title_slot_context_8
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_97.name,
    		type: "if",
    		source: "(877:16) {#if hasTitle}",
    		ctx
    	});

    	return block;
    }

    // (884:16) {#if hasAfter}
    function create_if_block_94(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_8);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_96(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_95(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_8);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_8);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$d, 884, 18, 30116);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_8),
    						get_after_start_slot_context_8
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_96(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_95(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_8),
    						get_after_slot_context_8
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_8),
    						get_after_end_slot_context_8
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_94.name,
    		type: "if",
    		source: "(884:16) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (887:20) {#if typeof after !== 'undefined'}
    function create_if_block_96(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$d, 887, 22, 30266);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_96.name,
    		type: "if",
    		source: "(887:20) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (890:20) {#if typeof badge !== 'undefined'}
    function create_if_block_95(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_95.name,
    		type: "if",
    		source: "(890:20) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (891:22) <Badge color={badgeColor}>
    function create_default_slot_8(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(891:22) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (898:14) {#if hasSubtitle}
    function create_if_block_93(ctx) {
    	let div;
    	let t0_value = plainText(/*subtitle*/ ctx[4]) + "";
    	let t0;
    	let t1;
    	let current;
    	const subtitle_slot_template = /*#slots*/ ctx[69].subtitle;
    	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[83], get_subtitle_slot_context_4);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (subtitle_slot) subtitle_slot.c();
    			attr_dev(div, "class", "item-subtitle");
    			add_location(div, file$d, 898, 16, 30684);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (subtitle_slot) {
    				subtitle_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*subtitle*/ 16) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

    			if (subtitle_slot) {
    				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						subtitle_slot,
    						subtitle_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[83], dirty, get_subtitle_slot_changes_4),
    						get_subtitle_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(subtitle_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(subtitle_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (subtitle_slot) subtitle_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_93.name,
    		type: "if",
    		source: "(898:14) {#if hasSubtitle}",
    		ctx
    	});

    	return block;
    }

    // (904:14) {#if hasText}
    function create_if_block_92(ctx) {
    	let div;
    	let t0_value = plainText(/*text*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const text_slot_template = /*#slots*/ ctx[69].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[83], get_text_slot_context_4);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (text_slot) text_slot.c();
    			attr_dev(div, "class", "item-text");
    			add_location(div, file$d, 904, 16, 30882);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[83], dirty, get_text_slot_changes_4),
    						get_text_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (text_slot) text_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_92.name,
    		type: "if",
    		source: "(904:14) {#if hasText}",
    		ctx
    	});

    	return block;
    }

    // (911:14) {#if !(swipeout || accordionItem)}
    function create_if_block_91(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_91.name,
    		type: "if",
    		source: "(911:14) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (914:14) {#if hasFooter}
    function create_if_block_90(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_8);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$d, 914, 16, 31200);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_8),
    						get_footer_slot_context_8
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_90.name,
    		type: "if",
    		source: "(914:14) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (727:10) {#if isSortable && sortable !== false && isSortableOpposite}
    function create_if_block_87(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$d, 727, 12, 24660);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_87.name,
    		type: "if",
    		source: "(727:10) {#if isSortable && sortable !== false && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (730:10) {#if hasMedia}
    function create_if_block_85(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[3] !== 'undefined' && create_if_block_86(ctx);
    	const media_slot_template = /*#slots*/ ctx[69].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[83], get_media_slot_context_3);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$d, 730, 12, 24746);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[3] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_86(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[83], dirty, get_media_slot_changes_3),
    						get_media_slot_context_3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_85.name,
    		type: "if",
    		source: "(730:10) {#if hasMedia}",
    		ctx
    	});

    	return block;
    }

    // (732:14) {#if typeof media !== 'undefined'}
    function create_if_block_86(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$d, 732, 16, 24836);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 8 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_86.name,
    		type: "if",
    		source: "(732:14) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (792:12) {:else}
    function create_else_block_6(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block2_anchor;
    	let current;
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_7);
    	let if_block0 = (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) && create_if_block_82(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_7);
    	let if_block1 = /*hasAfter*/ ctx[31] && create_if_block_79(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_7);
    	let if_block2 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_78(ctx);

    	const block = {
    		c: function create() {
    			if (before_title_slot) before_title_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (after_title_slot) after_title_slot.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (inner_slot) inner_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (before_title_slot) {
    				before_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (after_title_slot) {
    				after_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t4, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_7),
    						get_before_title_slot_context_7
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 56) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_82(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_7),
    						get_after_title_slot_context_7
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_79(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_7),
    						get_inner_slot_context_7
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_78(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_title_slot, local);
    			transition_in(if_block0);
    			transition_in(after_title_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_slot, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_title_slot, local);
    			transition_out(if_block0);
    			transition_out(after_title_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_slot, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_6.name,
    		type: "else",
    		source: "(792:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (740:12) {#if isMedia}
    function create_if_block_68(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let if_block6_anchor;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_77(ctx);
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_6);
    	let if_block1 = /*hasTitle*/ ctx[36] && create_if_block_76(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_6);
    	let if_block2 = /*hasAfter*/ ctx[31] && create_if_block_73(ctx);
    	let if_block3 = /*hasSubtitle*/ ctx[33] && create_if_block_72(ctx);
    	let if_block4 = /*hasText*/ ctx[32] && create_if_block_71(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_6);
    	let if_block5 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_70(ctx);
    	let if_block6 = /*hasFooter*/ ctx[34] && create_if_block_69(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (before_title_slot) before_title_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_title_slot) after_title_slot.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (inner_slot) inner_slot.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    			attr_dev(div, "class", "item-title-row");
    			add_location(div, file$d, 746, 14, 25276);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			if (before_title_slot) {
    				before_title_slot.m(div, null);
    			}

    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_title_slot) {
    				after_title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block2) if_block2.m(div, null);
    			insert_dev(target, t4, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t6, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t7, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_77(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_6),
    						get_before_title_slot_context_6
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_76(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_6),
    						get_after_title_slot_context_6
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_73(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*hasSubtitle*/ ctx[33]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[1] & /*hasSubtitle*/ 4) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_72(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t5.parentNode, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*hasText*/ ctx[32]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasText*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_71(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t6.parentNode, t6);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_6),
    						get_inner_slot_context_6
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_70(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t8.parentNode, t8);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_69(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(before_title_slot, local);
    			transition_in(if_block1);
    			transition_in(after_title_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(inner_slot, local);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(before_title_slot, local);
    			transition_out(if_block1);
    			transition_out(after_title_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(inner_slot, local);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t4);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_68.name,
    		type: "if",
    		source: "(740:12) {#if isMedia}",
    		ctx
    	});

    	return block;
    }

    // (794:14) {#if hasTitle || hasHeader || hasFooter}
    function create_if_block_82(ctx) {
    	let div;
    	let t0;
    	let t1_value = plainText(/*title*/ ctx[1]) + "";
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_84(ctx);
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_7);
    	let if_block1 = /*hasFooter*/ ctx[34] && create_if_block_83(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			if (title_slot) title_slot.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$d, 794, 16, 27011);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_84(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*title*/ 2) && t1_value !== (t1_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t1, t1_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_7),
    						get_title_slot_context_7
    					);
    				}
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_83(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(title_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(title_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (title_slot) title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_82.name,
    		type: "if",
    		source: "(794:14) {#if hasTitle || hasHeader || hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (796:18) {#if hasHeader}
    function create_if_block_84(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_7);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$d, 796, 20, 27090);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_7),
    						get_header_slot_context_7
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_84.name,
    		type: "if",
    		source: "(796:18) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (804:18) {#if hasFooter}
    function create_if_block_83(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_7);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$d, 804, 20, 27385);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_7),
    						get_footer_slot_context_7
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_83.name,
    		type: "if",
    		source: "(804:18) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (813:14) {#if hasAfter}
    function create_if_block_79(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_7);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_81(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_80(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_7);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_7);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$d, 813, 16, 27679);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_7),
    						get_after_start_slot_context_7
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_81(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_80(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_7),
    						get_after_slot_context_7
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_7),
    						get_after_end_slot_context_7
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_79.name,
    		type: "if",
    		source: "(813:14) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (816:18) {#if typeof after !== 'undefined'}
    function create_if_block_81(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$d, 816, 20, 27823);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_81.name,
    		type: "if",
    		source: "(816:18) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (819:18) {#if typeof badge !== 'undefined'}
    function create_if_block_80(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_80.name,
    		type: "if",
    		source: "(819:18) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (820:20) <Badge color={badgeColor}>
    function create_default_slot_7(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(820:20) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (827:14) {#if !(swipeout || accordionItem)}
    function create_if_block_78(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_78.name,
    		type: "if",
    		source: "(827:14) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (741:14) {#if hasHeader}
    function create_if_block_77(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_6);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$d, 741, 16, 25114);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_6),
    						get_header_slot_context_6
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_77.name,
    		type: "if",
    		source: "(741:14) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (749:16) {#if hasTitle}
    function create_if_block_76(ctx) {
    	let div;
    	let t0_value = plainText(/*title*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_6);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (title_slot) title_slot.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$d, 749, 18, 25399);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_6),
    						get_title_slot_context_6
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_76.name,
    		type: "if",
    		source: "(749:16) {#if hasTitle}",
    		ctx
    	});

    	return block;
    }

    // (756:16) {#if hasAfter}
    function create_if_block_73(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_6);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_75(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_74(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_6);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_6);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$d, 756, 18, 25645);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_6),
    						get_after_start_slot_context_6
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_75(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_74(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_6),
    						get_after_slot_context_6
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_6),
    						get_after_end_slot_context_6
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_73.name,
    		type: "if",
    		source: "(756:16) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (759:20) {#if typeof after !== 'undefined'}
    function create_if_block_75(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$d, 759, 22, 25795);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_75.name,
    		type: "if",
    		source: "(759:20) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (762:20) {#if typeof badge !== 'undefined'}
    function create_if_block_74(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_74.name,
    		type: "if",
    		source: "(762:20) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (763:22) <Badge color={badgeColor}>
    function create_default_slot_6$1(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(763:22) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (770:14) {#if hasSubtitle}
    function create_if_block_72(ctx) {
    	let div;
    	let t0_value = plainText(/*subtitle*/ ctx[4]) + "";
    	let t0;
    	let t1;
    	let current;
    	const subtitle_slot_template = /*#slots*/ ctx[69].subtitle;
    	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[83], get_subtitle_slot_context_3);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (subtitle_slot) subtitle_slot.c();
    			attr_dev(div, "class", "item-subtitle");
    			add_location(div, file$d, 770, 16, 26213);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (subtitle_slot) {
    				subtitle_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*subtitle*/ 16) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

    			if (subtitle_slot) {
    				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						subtitle_slot,
    						subtitle_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[83], dirty, get_subtitle_slot_changes_3),
    						get_subtitle_slot_context_3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(subtitle_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(subtitle_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (subtitle_slot) subtitle_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_72.name,
    		type: "if",
    		source: "(770:14) {#if hasSubtitle}",
    		ctx
    	});

    	return block;
    }

    // (776:14) {#if hasText}
    function create_if_block_71(ctx) {
    	let div;
    	let t0_value = plainText(/*text*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const text_slot_template = /*#slots*/ ctx[69].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[83], get_text_slot_context_3);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (text_slot) text_slot.c();
    			attr_dev(div, "class", "item-text");
    			add_location(div, file$d, 776, 16, 26411);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[83], dirty, get_text_slot_changes_3),
    						get_text_slot_context_3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (text_slot) text_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_71.name,
    		type: "if",
    		source: "(776:14) {#if hasText}",
    		ctx
    	});

    	return block;
    }

    // (783:14) {#if !(swipeout || accordionItem)}
    function create_if_block_70(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_70.name,
    		type: "if",
    		source: "(783:14) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (786:14) {#if hasFooter}
    function create_if_block_69(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_6);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$d, 786, 16, 26729);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_6),
    						get_footer_slot_context_6
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_69.name,
    		type: "if",
    		source: "(786:14) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (474:8) {:else}
    function create_else_block_2$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_26, create_else_block_4];
    	const if_blocks = [];

    	function select_block_type_4(ctx, dirty) {
    		if (/*checkbox*/ ctx[17] || /*radio*/ ctx[18]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_4(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_4(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(474:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (352:8) {#if isLink}
    function create_if_block_5(ctx) {
    	let a;
    	let div1;
    	let t0;
    	let t1;
    	let t2;
    	let div0;
    	let t3;
    	let current_block_type_index;
    	let if_block2;
    	let t4;
    	let t5;
    	let t6;
    	let useRouteProps_action;
    	let current;
    	let mounted;
    	let dispose;
    	const content_start_slot_template = /*#slots*/ ctx[69]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[83], get_content_start_slot_context);
    	let if_block0 = /*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44] && create_if_block_25(ctx);
    	let if_block1 = /*hasMedia*/ ctx[37] && create_if_block_23(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[69]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_start_slot_context);
    	const if_block_creators = [create_if_block_6, create_else_block_1$1];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*isMedia*/ ctx[26]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_3(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const inner_end_slot_template = /*#slots*/ ctx[69]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_end_slot_context);
    	const content_slot_template = /*#slots*/ ctx[69].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[83], get_content_slot_context);
    	const content_end_slot_template = /*#slots*/ ctx[69]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[83], get_content_end_slot_context);
    	let a_levels = [{ class: /*linkClasses*/ ctx[40] }, /*linkAttrs*/ ctx[39]];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			div1 = element("div");
    			if (content_start_slot) content_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div0 = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t3 = space();
    			if_block2.c();
    			t4 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t5 = space();
    			if (content_slot) content_slot.c();
    			t6 = space();
    			if (content_end_slot) content_end_slot.c();
    			attr_dev(div0, "class", "item-inner");
    			add_location(div0, file$d, 373, 14, 10913);
    			attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			add_location(div1, file$d, 360, 12, 10412);
    			set_attributes(a, a_data);
    			add_location(a, file$d, 352, 10, 10181);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, div1);

    			if (content_start_slot) {
    				content_start_slot.m(div1, null);
    			}

    			append_dev(div1, t0);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, div0);

    			if (inner_start_slot) {
    				inner_start_slot.m(div0, null);
    			}

    			append_dev(div0, t3);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div0, t4);

    			if (inner_end_slot) {
    				inner_end_slot.m(div0, null);
    			}

    			/*div0_binding*/ ctx[72](div0);
    			append_dev(div1, t5);

    			if (content_slot) {
    				content_slot.m(div1, null);
    			}

    			append_dev(div1, t6);

    			if (content_end_slot) {
    				content_end_slot.m(div1, null);
    			}

    			/*a_binding*/ ctx[73](a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[25])),
    					listen_dev(a, "click", /*onClick*/ ctx[46], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[83], dirty, get_content_start_slot_changes),
    						get_content_start_slot_context
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_25(ctx);
    					if_block0.c();
    					if_block0.m(div1, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*hasMedia*/ ctx[37]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasMedia*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_23(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_start_slot_changes),
    						get_inner_start_slot_context
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div0, t4);
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_end_slot_changes),
    						get_inner_end_slot_context
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[83], dirty, get_content_slot_changes),
    						get_content_slot_context
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[83], dirty, get_content_end_slot_changes),
    						get_content_end_slot_context
    					);
    				}
    			}

    			if (!current || dirty[1] & /*contentClasses*/ 1024) {
    				attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty[1] & /*linkClasses*/ 512) && { class: /*linkClasses*/ ctx[40] },
    				dirty[1] & /*linkAttrs*/ 256 && /*linkAttrs*/ ctx[39]
    			]));

    			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 33554432) useRouteProps_action.update.call(null, /*routeProps*/ ctx[25]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			/*div0_binding*/ ctx[72](null);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    			/*a_binding*/ ctx[73](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(352:8) {#if isLink}",
    		ctx
    	});

    	return block;
    }

    // (600:10) {:else}
    function create_else_block_4(ctx) {
    	let div1;
    	let t0;
    	let t1;
    	let t2;
    	let div0;
    	let t3;
    	let current_block_type_index;
    	let if_block2;
    	let t4;
    	let t5;
    	let t6;
    	let current;
    	let mounted;
    	let dispose;
    	const content_start_slot_template = /*#slots*/ ctx[69]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[83], get_content_start_slot_context_2);
    	let if_block0 = /*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44] && create_if_block_66(ctx);
    	let if_block1 = /*hasMedia*/ ctx[37] && create_if_block_64(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[69]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_start_slot_context_2);
    	const if_block_creators = [create_if_block_47, create_else_block_5];
    	const if_blocks = [];

    	function select_block_type_6(ctx, dirty) {
    		if (/*isMedia*/ ctx[26]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_6(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const inner_end_slot_template = /*#slots*/ ctx[69]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_end_slot_context_2);
    	const content_slot_template = /*#slots*/ ctx[69].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[83], get_content_slot_context_2);
    	const content_end_slot_template = /*#slots*/ ctx[69]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[83], get_content_end_slot_context_2);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (content_start_slot) content_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div0 = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t3 = space();
    			if_block2.c();
    			t4 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t5 = space();
    			if (content_slot) content_slot.c();
    			t6 = space();
    			if (content_end_slot) content_end_slot.c();
    			attr_dev(div0, "class", "item-inner");
    			add_location(div0, file$d, 613, 14, 20325);
    			attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			add_location(div1, file$d, 600, 12, 19805);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);

    			if (content_start_slot) {
    				content_start_slot.m(div1, null);
    			}

    			append_dev(div1, t0);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, div0);

    			if (inner_start_slot) {
    				inner_start_slot.m(div0, null);
    			}

    			append_dev(div0, t3);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div0, t4);

    			if (inner_end_slot) {
    				inner_end_slot.m(div0, null);
    			}

    			/*div0_binding_1*/ ctx[76](div0);
    			append_dev(div1, t5);

    			if (content_slot) {
    				content_slot.m(div1, null);
    			}

    			append_dev(div1, t6);

    			if (content_end_slot) {
    				content_end_slot.m(div1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", /*onClick*/ ctx[46], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[83], dirty, get_content_start_slot_changes_2),
    						get_content_start_slot_context_2
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_66(ctx);
    					if_block0.c();
    					if_block0.m(div1, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*hasMedia*/ ctx[37]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasMedia*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_64(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_start_slot_changes_2),
    						get_inner_start_slot_context_2
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_6(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div0, t4);
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_end_slot_changes_2),
    						get_inner_end_slot_context_2
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[83], dirty, get_content_slot_changes_2),
    						get_content_slot_context_2
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[83], dirty, get_content_end_slot_changes_2),
    						get_content_end_slot_context_2
    					);
    				}
    			}

    			if (!current || dirty[1] & /*contentClasses*/ 1024) {
    				attr_dev(div1, "class", /*contentClasses*/ ctx[41]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			/*div0_binding_1*/ ctx[76](null);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4.name,
    		type: "else",
    		source: "(600:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (476:10) {#if checkbox || radio}
    function create_if_block_26(ctx) {
    	let label;
    	let t0;
    	let t1;
    	let input;
    	let input_value_value;
    	let input_type_value;
    	let t2;
    	let i;
    	let i_class_value;
    	let t3;
    	let t4;
    	let div;
    	let t5;
    	let current_block_type_index;
    	let if_block2;
    	let t6;
    	let t7;
    	let t8;
    	let current;
    	let mounted;
    	let dispose;
    	const content_start_slot_template = /*#slots*/ ctx[69]["content-start"];
    	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[83], get_content_start_slot_context_1);
    	let if_block0 = /*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44] && create_if_block_46(ctx);
    	let if_block1 = /*hasMedia*/ ctx[37] && create_if_block_44(ctx);
    	const inner_start_slot_template = /*#slots*/ ctx[69]["inner-start"];
    	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_start_slot_context_1);
    	const if_block_creators = [create_if_block_27, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type_5(ctx, dirty) {
    		if (/*isMedia*/ ctx[26]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_5(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const inner_end_slot_template = /*#slots*/ ctx[69]["inner-end"];
    	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_end_slot_context_1);
    	const content_slot_template = /*#slots*/ ctx[69].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[83], get_content_slot_context_1);
    	const content_end_slot_template = /*#slots*/ ctx[69]["content-end"];
    	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[83], get_content_end_slot_context_1);

    	const block = {
    		c: function create() {
    			label = element("label");
    			if (content_start_slot) content_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			i = element("i");
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			div = element("div");
    			if (inner_start_slot) inner_start_slot.c();
    			t5 = space();
    			if_block2.c();
    			t6 = space();
    			if (inner_end_slot) inner_end_slot.c();
    			t7 = space();
    			if (content_slot) content_slot.c();
    			t8 = space();
    			if (content_end_slot) content_end_slot.c();

    			input.value = input_value_value = typeof /*value*/ ctx[20] === 'undefined'
    			? ''
    			: /*value*/ ctx[20];

    			attr_dev(input, "name", /*name*/ ctx[19]);
    			input.checked = /*checked*/ ctx[0];
    			input.readOnly = /*readonly*/ ctx[21];
    			input.disabled = /*disabled*/ ctx[23];
    			input.required = /*required*/ ctx[22];
    			attr_dev(input, "type", input_type_value = /*radio*/ ctx[18] ? 'radio' : 'checkbox');
    			add_location(input, file$d, 481, 14, 15195);
    			attr_dev(i, "class", i_class_value = `icon icon-${/*radio*/ ctx[18] ? 'radio' : 'checkbox'}`);
    			add_location(i, file$d, 492, 14, 15554);
    			attr_dev(div, "class", "item-inner");
    			add_location(div, file$d, 501, 14, 15896);
    			attr_dev(label, "class", /*contentClasses*/ ctx[41]);
    			add_location(label, file$d, 476, 12, 14943);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);

    			if (content_start_slot) {
    				content_start_slot.m(label, null);
    			}

    			append_dev(label, t0);
    			if (if_block0) if_block0.m(label, null);
    			append_dev(label, t1);
    			append_dev(label, input);
    			/*input_binding*/ ctx[74](input);
    			append_dev(label, t2);
    			append_dev(label, i);
    			append_dev(label, t3);
    			if (if_block1) if_block1.m(label, null);
    			append_dev(label, t4);
    			append_dev(label, div);

    			if (inner_start_slot) {
    				inner_start_slot.m(div, null);
    			}

    			append_dev(div, t5);
    			if_blocks[current_block_type_index].m(div, null);
    			append_dev(div, t6);

    			if (inner_end_slot) {
    				inner_end_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[75](div);
    			append_dev(label, t7);

    			if (content_slot) {
    				content_slot.m(label, null);
    			}

    			append_dev(label, t8);

    			if (content_end_slot) {
    				content_end_slot.m(label, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*onChange*/ ctx[47], false, false, false),
    					listen_dev(label, "click", /*onClick*/ ctx[46], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (content_start_slot) {
    				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_start_slot,
    						content_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[83], dirty, get_content_start_slot_changes_1),
    						get_content_start_slot_context_1
    					);
    				}
    			}

    			if (/*isSortable*/ ctx[45] && /*sortable*/ ctx[15] !== false && /*isSortableOpposite*/ ctx[44]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_46(ctx);
    					if_block0.c();
    					if_block0.m(label, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty[0] & /*value*/ 1048576 && input_value_value !== (input_value_value = typeof /*value*/ ctx[20] === 'undefined'
    			? ''
    			: /*value*/ ctx[20]) && input.value !== input_value_value) {
    				prop_dev(input, "value", input_value_value);
    			}

    			if (!current || dirty[0] & /*name*/ 524288) {
    				attr_dev(input, "name", /*name*/ ctx[19]);
    			}

    			if (!current || dirty[0] & /*checked*/ 1) {
    				prop_dev(input, "checked", /*checked*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*readonly*/ 2097152) {
    				prop_dev(input, "readOnly", /*readonly*/ ctx[21]);
    			}

    			if (!current || dirty[0] & /*disabled*/ 8388608) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[23]);
    			}

    			if (!current || dirty[0] & /*required*/ 4194304) {
    				prop_dev(input, "required", /*required*/ ctx[22]);
    			}

    			if (!current || dirty[0] & /*radio*/ 262144 && input_type_value !== (input_type_value = /*radio*/ ctx[18] ? 'radio' : 'checkbox')) {
    				attr_dev(input, "type", input_type_value);
    			}

    			if (!current || dirty[0] & /*radio*/ 262144 && i_class_value !== (i_class_value = `icon icon-${/*radio*/ ctx[18] ? 'radio' : 'checkbox'}`)) {
    				attr_dev(i, "class", i_class_value);
    			}

    			if (/*hasMedia*/ ctx[37]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasMedia*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_44(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(label, t4);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_start_slot) {
    				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_start_slot,
    						inner_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_start_slot_changes_1),
    						get_inner_start_slot_context_1
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_5(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div, t6);
    			}

    			if (inner_end_slot) {
    				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_end_slot,
    						inner_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_end_slot_changes_1),
    						get_inner_end_slot_context_1
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[83], dirty, get_content_slot_changes_1),
    						get_content_slot_context_1
    					);
    				}
    			}

    			if (content_end_slot) {
    				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						content_end_slot,
    						content_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[83], dirty, get_content_end_slot_changes_1),
    						get_content_end_slot_context_1
    					);
    				}
    			}

    			if (!current || dirty[1] & /*contentClasses*/ 1024) {
    				attr_dev(label, "class", /*contentClasses*/ ctx[41]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_start_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_start_slot, local);
    			transition_in(if_block2);
    			transition_in(inner_end_slot, local);
    			transition_in(content_slot, local);
    			transition_in(content_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_start_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_start_slot, local);
    			transition_out(if_block2);
    			transition_out(inner_end_slot, local);
    			transition_out(content_slot, local);
    			transition_out(content_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (content_start_slot) content_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			/*input_binding*/ ctx[74](null);
    			if (if_block1) if_block1.d();
    			if (inner_start_slot) inner_start_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (inner_end_slot) inner_end_slot.d(detaching);
    			/*div_binding*/ ctx[75](null);
    			if (content_slot) content_slot.d(detaching);
    			if (content_end_slot) content_end_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_26.name,
    		type: "if",
    		source: "(476:10) {#if checkbox || radio}",
    		ctx
    	});

    	return block;
    }

    // (603:14) {#if isSortable && sortable !== false && isSortableOpposite}
    function create_if_block_66(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$d, 603, 16, 19988);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_66.name,
    		type: "if",
    		source: "(603:14) {#if isSortable && sortable !== false && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (606:14) {#if hasMedia}
    function create_if_block_64(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[3] !== 'undefined' && create_if_block_65(ctx);
    	const media_slot_template = /*#slots*/ ctx[69].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[83], get_media_slot_context_2);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$d, 606, 16, 20086);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[3] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_65(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[83], dirty, get_media_slot_changes_2),
    						get_media_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_64.name,
    		type: "if",
    		source: "(606:14) {#if hasMedia}",
    		ctx
    	});

    	return block;
    }

    // (608:18) {#if typeof media !== 'undefined'}
    function create_if_block_65(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$d, 608, 20, 20184);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 8 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_65.name,
    		type: "if",
    		source: "(608:18) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (668:16) {:else}
    function create_else_block_5(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block2_anchor;
    	let current;
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_5);
    	let if_block0 = (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) && create_if_block_61(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_5);
    	let if_block1 = /*hasAfter*/ ctx[31] && create_if_block_58(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_5);
    	let if_block2 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_57(ctx);

    	const block = {
    		c: function create() {
    			if (before_title_slot) before_title_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (after_title_slot) after_title_slot.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (inner_slot) inner_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (before_title_slot) {
    				before_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (after_title_slot) {
    				after_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t4, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_5),
    						get_before_title_slot_context_5
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 56) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_61(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_5),
    						get_after_title_slot_context_5
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_58(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_5),
    						get_inner_slot_context_5
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_57(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_title_slot, local);
    			transition_in(if_block0);
    			transition_in(after_title_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_slot, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_title_slot, local);
    			transition_out(if_block0);
    			transition_out(after_title_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_slot, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_5.name,
    		type: "else",
    		source: "(668:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (616:16) {#if isMedia}
    function create_if_block_47(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let if_block6_anchor;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_56(ctx);
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_4);
    	let if_block1 = /*hasTitle*/ ctx[36] && create_if_block_55(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_4);
    	let if_block2 = /*hasAfter*/ ctx[31] && create_if_block_52(ctx);
    	let if_block3 = /*hasSubtitle*/ ctx[33] && create_if_block_51(ctx);
    	let if_block4 = /*hasText*/ ctx[32] && create_if_block_50(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_4);
    	let if_block5 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_49(ctx);
    	let if_block6 = /*hasFooter*/ ctx[34] && create_if_block_48(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (before_title_slot) before_title_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_title_slot) after_title_slot.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (inner_slot) inner_slot.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    			attr_dev(div, "class", "item-title-row");
    			add_location(div, file$d, 622, 18, 20680);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			if (before_title_slot) {
    				before_title_slot.m(div, null);
    			}

    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_title_slot) {
    				after_title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block2) if_block2.m(div, null);
    			insert_dev(target, t4, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t6, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t7, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_56(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_4),
    						get_before_title_slot_context_4
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_55(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_4),
    						get_after_title_slot_context_4
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_52(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*hasSubtitle*/ ctx[33]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[1] & /*hasSubtitle*/ 4) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_51(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t5.parentNode, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*hasText*/ ctx[32]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasText*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_50(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t6.parentNode, t6);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_4),
    						get_inner_slot_context_4
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_49(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t8.parentNode, t8);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_48(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(before_title_slot, local);
    			transition_in(if_block1);
    			transition_in(after_title_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(inner_slot, local);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(before_title_slot, local);
    			transition_out(if_block1);
    			transition_out(after_title_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(inner_slot, local);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t4);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_47.name,
    		type: "if",
    		source: "(616:16) {#if isMedia}",
    		ctx
    	});

    	return block;
    }

    // (670:18) {#if hasTitle || hasHeader || hasFooter}
    function create_if_block_61(ctx) {
    	let div;
    	let t0;
    	let t1_value = plainText(/*title*/ ctx[1]) + "";
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_63(ctx);
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_5);
    	let if_block1 = /*hasFooter*/ ctx[34] && create_if_block_62(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			if (title_slot) title_slot.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$d, 670, 20, 22607);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_63(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*title*/ 2) && t1_value !== (t1_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t1, t1_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_5),
    						get_title_slot_context_5
    					);
    				}
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_62(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(title_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(title_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (title_slot) title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_61.name,
    		type: "if",
    		source: "(670:18) {#if hasTitle || hasHeader || hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (672:22) {#if hasHeader}
    function create_if_block_63(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_5);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$d, 672, 24, 22694);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_5),
    						get_header_slot_context_5
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_63.name,
    		type: "if",
    		source: "(672:22) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (680:22) {#if hasFooter}
    function create_if_block_62(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_5);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$d, 680, 24, 23021);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_5),
    						get_footer_slot_context_5
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_62.name,
    		type: "if",
    		source: "(680:22) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (689:18) {#if hasAfter}
    function create_if_block_58(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_5);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_60(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_59(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_5);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_5);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$d, 689, 20, 23351);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_5),
    						get_after_start_slot_context_5
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_60(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_59(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_5),
    						get_after_slot_context_5
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_5),
    						get_after_end_slot_context_5
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_58.name,
    		type: "if",
    		source: "(689:18) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (692:22) {#if typeof after !== 'undefined'}
    function create_if_block_60(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$d, 692, 24, 23507);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_60.name,
    		type: "if",
    		source: "(692:22) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (695:22) {#if typeof badge !== 'undefined'}
    function create_if_block_59(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_59.name,
    		type: "if",
    		source: "(695:22) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (696:24) <Badge color={badgeColor}>
    function create_default_slot_5$1(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(696:24) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (703:18) {#if !(swipeout || accordionItem)}
    function create_if_block_57(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_57.name,
    		type: "if",
    		source: "(703:18) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (617:18) {#if hasHeader}
    function create_if_block_56(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_4);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$d, 617, 20, 20498);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_4),
    						get_header_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_56.name,
    		type: "if",
    		source: "(617:18) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (625:20) {#if hasTitle}
    function create_if_block_55(ctx) {
    	let div;
    	let t0_value = plainText(/*title*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_4);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (title_slot) title_slot.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$d, 625, 22, 20815);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_4),
    						get_title_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_55.name,
    		type: "if",
    		source: "(625:20) {#if hasTitle}",
    		ctx
    	});

    	return block;
    }

    // (632:20) {#if hasAfter}
    function create_if_block_52(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_4);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_54(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_53(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_4);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_4);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$d, 632, 22, 21089);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_4),
    						get_after_start_slot_context_4
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_54(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_53(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_4),
    						get_after_slot_context_4
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_4),
    						get_after_end_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_52.name,
    		type: "if",
    		source: "(632:20) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (635:24) {#if typeof after !== 'undefined'}
    function create_if_block_54(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$d, 635, 26, 21251);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_54.name,
    		type: "if",
    		source: "(635:24) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (638:24) {#if typeof badge !== 'undefined'}
    function create_if_block_53(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_53.name,
    		type: "if",
    		source: "(638:24) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (639:26) <Badge color={badgeColor}>
    function create_default_slot_4$1(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(639:26) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (646:18) {#if hasSubtitle}
    function create_if_block_51(ctx) {
    	let div;
    	let t0_value = plainText(/*subtitle*/ ctx[4]) + "";
    	let t0;
    	let t1;
    	let current;
    	const subtitle_slot_template = /*#slots*/ ctx[69].subtitle;
    	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[83], get_subtitle_slot_context_2);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (subtitle_slot) subtitle_slot.c();
    			attr_dev(div, "class", "item-subtitle");
    			add_location(div, file$d, 646, 20, 21713);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (subtitle_slot) {
    				subtitle_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*subtitle*/ 16) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

    			if (subtitle_slot) {
    				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						subtitle_slot,
    						subtitle_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[83], dirty, get_subtitle_slot_changes_2),
    						get_subtitle_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(subtitle_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(subtitle_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (subtitle_slot) subtitle_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_51.name,
    		type: "if",
    		source: "(646:18) {#if hasSubtitle}",
    		ctx
    	});

    	return block;
    }

    // (652:18) {#if hasText}
    function create_if_block_50(ctx) {
    	let div;
    	let t0_value = plainText(/*text*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const text_slot_template = /*#slots*/ ctx[69].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[83], get_text_slot_context_2);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (text_slot) text_slot.c();
    			attr_dev(div, "class", "item-text");
    			add_location(div, file$d, 652, 20, 21935);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[83], dirty, get_text_slot_changes_2),
    						get_text_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (text_slot) text_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_50.name,
    		type: "if",
    		source: "(652:18) {#if hasText}",
    		ctx
    	});

    	return block;
    }

    // (659:18) {#if !(swipeout || accordionItem)}
    function create_if_block_49(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_49.name,
    		type: "if",
    		source: "(659:18) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (662:18) {#if hasFooter}
    function create_if_block_48(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_4);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$d, 662, 20, 22293);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_4),
    						get_footer_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_48.name,
    		type: "if",
    		source: "(662:18) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (479:14) {#if isSortable && sortable !== false && isSortableOpposite}
    function create_if_block_46(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$d, 479, 16, 15128);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_46.name,
    		type: "if",
    		source: "(479:14) {#if isSortable && sortable !== false && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (494:14) {#if hasMedia}
    function create_if_block_44(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[3] !== 'undefined' && create_if_block_45(ctx);
    	const media_slot_template = /*#slots*/ ctx[69].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[83], get_media_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$d, 494, 16, 15657);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[3] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_45(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[83], dirty, get_media_slot_changes_1),
    						get_media_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_44.name,
    		type: "if",
    		source: "(494:14) {#if hasMedia}",
    		ctx
    	});

    	return block;
    }

    // (496:18) {#if typeof media !== 'undefined'}
    function create_if_block_45(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$d, 496, 20, 15755);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 8 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_45.name,
    		type: "if",
    		source: "(496:18) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (556:16) {:else}
    function create_else_block_3(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block2_anchor;
    	let current;
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_3);
    	let if_block0 = (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) && create_if_block_41(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_3);
    	let if_block1 = /*hasAfter*/ ctx[31] && create_if_block_38(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_3);
    	let if_block2 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_37(ctx);

    	const block = {
    		c: function create() {
    			if (before_title_slot) before_title_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (after_title_slot) after_title_slot.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (inner_slot) inner_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (before_title_slot) {
    				before_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (after_title_slot) {
    				after_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t4, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_3),
    						get_before_title_slot_context_3
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 56) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_41(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_3),
    						get_after_title_slot_context_3
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_38(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_3),
    						get_inner_slot_context_3
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_37(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_title_slot, local);
    			transition_in(if_block0);
    			transition_in(after_title_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_slot, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_title_slot, local);
    			transition_out(if_block0);
    			transition_out(after_title_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_slot, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(556:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (504:16) {#if isMedia}
    function create_if_block_27(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let if_block6_anchor;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_36(ctx);
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_2);
    	let if_block1 = /*hasTitle*/ ctx[36] && create_if_block_35(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_2);
    	let if_block2 = /*hasAfter*/ ctx[31] && create_if_block_32(ctx);
    	let if_block3 = /*hasSubtitle*/ ctx[33] && create_if_block_31(ctx);
    	let if_block4 = /*hasText*/ ctx[32] && create_if_block_30(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_2);
    	let if_block5 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_29(ctx);
    	let if_block6 = /*hasFooter*/ ctx[34] && create_if_block_28(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (before_title_slot) before_title_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_title_slot) after_title_slot.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (inner_slot) inner_slot.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    			attr_dev(div, "class", "item-title-row");
    			add_location(div, file$d, 510, 18, 16251);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			if (before_title_slot) {
    				before_title_slot.m(div, null);
    			}

    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_title_slot) {
    				after_title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block2) if_block2.m(div, null);
    			insert_dev(target, t4, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t6, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t7, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_36(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_2),
    						get_before_title_slot_context_2
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_35(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_2),
    						get_after_title_slot_context_2
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_32(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*hasSubtitle*/ ctx[33]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[1] & /*hasSubtitle*/ 4) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_31(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t5.parentNode, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*hasText*/ ctx[32]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasText*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_30(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t6.parentNode, t6);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_2),
    						get_inner_slot_context_2
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_29(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t8.parentNode, t8);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_28(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(before_title_slot, local);
    			transition_in(if_block1);
    			transition_in(after_title_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(inner_slot, local);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(before_title_slot, local);
    			transition_out(if_block1);
    			transition_out(after_title_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(inner_slot, local);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t4);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_27.name,
    		type: "if",
    		source: "(504:16) {#if isMedia}",
    		ctx
    	});

    	return block;
    }

    // (558:18) {#if hasTitle || hasHeader || hasFooter}
    function create_if_block_41(ctx) {
    	let div;
    	let t0;
    	let t1_value = plainText(/*title*/ ctx[1]) + "";
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_43(ctx);
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_3);
    	let if_block1 = /*hasFooter*/ ctx[34] && create_if_block_42(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			if (title_slot) title_slot.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$d, 558, 20, 18178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_43(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*title*/ 2) && t1_value !== (t1_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t1, t1_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_3),
    						get_title_slot_context_3
    					);
    				}
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_42(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(title_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(title_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (title_slot) title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_41.name,
    		type: "if",
    		source: "(558:18) {#if hasTitle || hasHeader || hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (560:22) {#if hasHeader}
    function create_if_block_43(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_3);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$d, 560, 24, 18265);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_3),
    						get_header_slot_context_3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_43.name,
    		type: "if",
    		source: "(560:22) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (568:22) {#if hasFooter}
    function create_if_block_42(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_3);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$d, 568, 24, 18592);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_3),
    						get_footer_slot_context_3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_42.name,
    		type: "if",
    		source: "(568:22) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (577:18) {#if hasAfter}
    function create_if_block_38(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_3);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_40(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_39(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_3);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_3);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$d, 577, 20, 18922);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_3),
    						get_after_start_slot_context_3
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_40(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_39(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_3),
    						get_after_slot_context_3
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_3),
    						get_after_end_slot_context_3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_38.name,
    		type: "if",
    		source: "(577:18) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (580:22) {#if typeof after !== 'undefined'}
    function create_if_block_40(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$d, 580, 24, 19078);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_40.name,
    		type: "if",
    		source: "(580:22) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (583:22) {#if typeof badge !== 'undefined'}
    function create_if_block_39(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_39.name,
    		type: "if",
    		source: "(583:22) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (584:24) <Badge color={badgeColor}>
    function create_default_slot_3$1(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(584:24) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (591:18) {#if !(swipeout || accordionItem)}
    function create_if_block_37(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_37.name,
    		type: "if",
    		source: "(591:18) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (505:18) {#if hasHeader}
    function create_if_block_36(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_2);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$d, 505, 20, 16069);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_2),
    						get_header_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_36.name,
    		type: "if",
    		source: "(505:18) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (513:20) {#if hasTitle}
    function create_if_block_35(ctx) {
    	let div;
    	let t0_value = plainText(/*title*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_2);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (title_slot) title_slot.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$d, 513, 22, 16386);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_2),
    						get_title_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_35.name,
    		type: "if",
    		source: "(513:20) {#if hasTitle}",
    		ctx
    	});

    	return block;
    }

    // (520:20) {#if hasAfter}
    function create_if_block_32(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_2);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_34(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_33(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_2);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_2);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$d, 520, 22, 16660);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_2),
    						get_after_start_slot_context_2
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_34(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_33(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_2),
    						get_after_slot_context_2
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_2),
    						get_after_end_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_32.name,
    		type: "if",
    		source: "(520:20) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (523:24) {#if typeof after !== 'undefined'}
    function create_if_block_34(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$d, 523, 26, 16822);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_34.name,
    		type: "if",
    		source: "(523:24) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (526:24) {#if typeof badge !== 'undefined'}
    function create_if_block_33(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_33.name,
    		type: "if",
    		source: "(526:24) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (527:26) <Badge color={badgeColor}>
    function create_default_slot_2$4(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(527:26) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (534:18) {#if hasSubtitle}
    function create_if_block_31(ctx) {
    	let div;
    	let t0_value = plainText(/*subtitle*/ ctx[4]) + "";
    	let t0;
    	let t1;
    	let current;
    	const subtitle_slot_template = /*#slots*/ ctx[69].subtitle;
    	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[83], get_subtitle_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (subtitle_slot) subtitle_slot.c();
    			attr_dev(div, "class", "item-subtitle");
    			add_location(div, file$d, 534, 20, 17284);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (subtitle_slot) {
    				subtitle_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*subtitle*/ 16) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

    			if (subtitle_slot) {
    				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						subtitle_slot,
    						subtitle_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[83], dirty, get_subtitle_slot_changes_1),
    						get_subtitle_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(subtitle_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(subtitle_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (subtitle_slot) subtitle_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_31.name,
    		type: "if",
    		source: "(534:18) {#if hasSubtitle}",
    		ctx
    	});

    	return block;
    }

    // (540:18) {#if hasText}
    function create_if_block_30(ctx) {
    	let div;
    	let t0_value = plainText(/*text*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const text_slot_template = /*#slots*/ ctx[69].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[83], get_text_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (text_slot) text_slot.c();
    			attr_dev(div, "class", "item-text");
    			add_location(div, file$d, 540, 20, 17506);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[83], dirty, get_text_slot_changes_1),
    						get_text_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (text_slot) text_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_30.name,
    		type: "if",
    		source: "(540:18) {#if hasText}",
    		ctx
    	});

    	return block;
    }

    // (547:18) {#if !(swipeout || accordionItem)}
    function create_if_block_29(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_29.name,
    		type: "if",
    		source: "(547:18) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (550:18) {#if hasFooter}
    function create_if_block_28(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_2);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$d, 550, 20, 17864);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_2),
    						get_footer_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_28.name,
    		type: "if",
    		source: "(550:18) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (363:14) {#if isSortable && sortable !== false && isSortableOpposite}
    function create_if_block_25(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$d, 363, 16, 10576);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_25.name,
    		type: "if",
    		source: "(363:14) {#if isSortable && sortable !== false && isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (366:14) {#if hasMedia}
    function create_if_block_23(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = typeof /*media*/ ctx[3] !== 'undefined' && create_if_block_24(ctx);
    	const media_slot_template = /*#slots*/ ctx[69].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[83], get_media_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "item-media");
    			add_location(div, file$d, 366, 16, 10674);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*media*/ ctx[3] !== 'undefined') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_24(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (media_slot) {
    				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[83], dirty, get_media_slot_changes),
    						get_media_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_23.name,
    		type: "if",
    		source: "(366:14) {#if hasMedia}",
    		ctx
    	});

    	return block;
    }

    // (368:18) {#if typeof media !== 'undefined'}
    function create_if_block_24(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			add_location(img, file$d, 368, 20, 10772);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*media*/ 8 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_24.name,
    		type: "if",
    		source: "(368:18) {#if typeof media !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (428:16) {:else}
    function create_else_block_1$1(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block2_anchor;
    	let current;
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context_1);
    	let if_block0 = (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) && create_if_block_20(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context_1);
    	let if_block1 = /*hasAfter*/ ctx[31] && create_if_block_17(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context_1);
    	let if_block2 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_16(ctx);

    	const block = {
    		c: function create() {
    			if (before_title_slot) before_title_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (after_title_slot) after_title_slot.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (inner_slot) inner_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (before_title_slot) {
    				before_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (after_title_slot) {
    				after_title_slot.m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t4, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes_1),
    						get_before_title_slot_context_1
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36] || /*hasHeader*/ ctx[35] || /*hasFooter*/ ctx[34]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 56) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_20(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes_1),
    						get_after_title_slot_context_1
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_17(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes_1),
    						get_inner_slot_context_1
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_16(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_title_slot, local);
    			transition_in(if_block0);
    			transition_in(after_title_slot, local);
    			transition_in(if_block1);
    			transition_in(inner_slot, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_title_slot, local);
    			transition_out(if_block0);
    			transition_out(after_title_slot, local);
    			transition_out(if_block1);
    			transition_out(inner_slot, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(428:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (376:16) {#if isMedia}
    function create_if_block_6(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let if_block6_anchor;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_15(ctx);
    	const before_title_slot_template = /*#slots*/ ctx[69]["before-title"];
    	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[83], get_before_title_slot_context);
    	let if_block1 = /*hasTitle*/ ctx[36] && create_if_block_14(ctx);
    	const after_title_slot_template = /*#slots*/ ctx[69]["after-title"];
    	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[83], get_after_title_slot_context);
    	let if_block2 = /*hasAfter*/ ctx[31] && create_if_block_11(ctx);
    	let if_block3 = /*hasSubtitle*/ ctx[33] && create_if_block_10(ctx);
    	let if_block4 = /*hasText*/ ctx[32] && create_if_block_9(ctx);
    	const inner_slot_template = /*#slots*/ ctx[69].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[83], get_inner_slot_context);
    	let if_block5 = !(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16]) && create_if_block_8(ctx);
    	let if_block6 = /*hasFooter*/ ctx[34] && create_if_block_7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (before_title_slot) before_title_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_title_slot) after_title_slot.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (inner_slot) inner_slot.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    			attr_dev(div, "class", "item-title-row");
    			add_location(div, file$d, 382, 18, 11268);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			if (before_title_slot) {
    				before_title_slot.m(div, null);
    			}

    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_title_slot) {
    				after_title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block2) if_block2.m(div, null);
    			insert_dev(target, t4, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t6, anchor);

    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			insert_dev(target, t7, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_15(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (before_title_slot) {
    				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						before_title_slot,
    						before_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[83], dirty, get_before_title_slot_changes),
    						get_before_title_slot_context
    					);
    				}
    			}

    			if (/*hasTitle*/ ctx[36]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasTitle*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_14(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_title_slot) {
    				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_title_slot,
    						after_title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[83], dirty, get_after_title_slot_changes),
    						get_after_title_slot_context
    					);
    				}
    			}

    			if (/*hasAfter*/ ctx[31]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*hasAfter*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_11(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*hasSubtitle*/ ctx[33]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[1] & /*hasSubtitle*/ 4) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_10(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t5.parentNode, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*hasText*/ ctx[32]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*hasText*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_9(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t6.parentNode, t6);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[83], dirty, get_inner_slot_changes),
    						get_inner_slot_context
    					);
    				}
    			}

    			if (!(/*swipeout*/ ctx[14] || /*accordionItem*/ ctx[16])) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*swipeout, accordionItem*/ 81920) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_8(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t8.parentNode, t8);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_7(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(before_title_slot, local);
    			transition_in(if_block1);
    			transition_in(after_title_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(inner_slot, local);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(before_title_slot, local);
    			transition_out(if_block1);
    			transition_out(after_title_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(inner_slot, local);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (before_title_slot) before_title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			if (after_title_slot) after_title_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t4);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (inner_slot) inner_slot.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(376:16) {#if isMedia}",
    		ctx
    	});

    	return block;
    }

    // (430:18) {#if hasTitle || hasHeader || hasFooter}
    function create_if_block_20(ctx) {
    	let div;
    	let t0;
    	let t1_value = plainText(/*title*/ ctx[1]) + "";
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let if_block0 = /*hasHeader*/ ctx[35] && create_if_block_22(ctx);
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context_1);
    	let if_block1 = /*hasFooter*/ ctx[34] && create_if_block_21(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			if (title_slot) title_slot.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$d, 430, 20, 13195);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasHeader*/ ctx[35]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[1] & /*hasHeader*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_22(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*title*/ 2) && t1_value !== (t1_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t1, t1_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes_1),
    						get_title_slot_context_1
    					);
    				}
    			}

    			if (/*hasFooter*/ ctx[34]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*hasFooter*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_21(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(title_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(title_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (title_slot) title_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_20.name,
    		type: "if",
    		source: "(430:18) {#if hasTitle || hasHeader || hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (432:22) {#if hasHeader}
    function create_if_block_22(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$d, 432, 24, 13282);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes_1),
    						get_header_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_22.name,
    		type: "if",
    		source: "(432:22) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (440:22) {#if hasFooter}
    function create_if_block_21(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$d, 440, 24, 13609);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes_1),
    						get_footer_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_21.name,
    		type: "if",
    		source: "(440:22) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (449:18) {#if hasAfter}
    function create_if_block_17(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context_1);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_19(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_18(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context_1);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$d, 449, 20, 13939);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes_1),
    						get_after_start_slot_context_1
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_19(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_18(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes_1),
    						get_after_slot_context_1
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes_1),
    						get_after_end_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17.name,
    		type: "if",
    		source: "(449:18) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (452:22) {#if typeof after !== 'undefined'}
    function create_if_block_19(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$d, 452, 24, 14095);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19.name,
    		type: "if",
    		source: "(452:22) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (455:22) {#if typeof badge !== 'undefined'}
    function create_if_block_18(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18.name,
    		type: "if",
    		source: "(455:22) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (456:24) <Badge color={badgeColor}>
    function create_default_slot_1$5(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(456:24) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (463:18) {#if !(swipeout || accordionItem)}
    function create_if_block_16(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16.name,
    		type: "if",
    		source: "(463:18) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (377:18) {#if hasHeader}
    function create_if_block_15(ctx) {
    	let div;
    	let t0_value = plainText(/*header*/ ctx[5]) + "";
    	let t0;
    	let t1;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[69].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[83], get_header_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "item-header");
    			add_location(div, file$d, 377, 20, 11086);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[83], dirty, get_header_slot_changes),
    						get_header_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15.name,
    		type: "if",
    		source: "(377:18) {#if hasHeader}",
    		ctx
    	});

    	return block;
    }

    // (385:20) {#if hasTitle}
    function create_if_block_14(ctx) {
    	let div;
    	let t0_value = plainText(/*title*/ ctx[1]) + "";
    	let t0;
    	let t1;
    	let current;
    	const title_slot_template = /*#slots*/ ctx[69].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[83], get_title_slot_context$1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (title_slot) title_slot.c();
    			attr_dev(div, "class", "item-title");
    			add_location(div, file$d, 385, 22, 11403);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (title_slot) {
    				title_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[83], dirty, get_title_slot_changes$1),
    						get_title_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(385:20) {#if hasTitle}",
    		ctx
    	});

    	return block;
    }

    // (392:20) {#if hasAfter}
    function create_if_block_11(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	const after_start_slot_template = /*#slots*/ ctx[69]["after-start"];
    	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[83], get_after_start_slot_context);
    	let if_block0 = typeof /*after*/ ctx[9] !== 'undefined' && create_if_block_13(ctx);
    	let if_block1 = typeof /*badge*/ ctx[10] !== 'undefined' && create_if_block_12(ctx);
    	const after_slot_template = /*#slots*/ ctx[69].after;
    	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[83], get_after_slot_context);
    	const after_end_slot_template = /*#slots*/ ctx[69]["after-end"];
    	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[83], get_after_end_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (after_start_slot) after_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (after_slot) after_slot.c();
    			t3 = space();
    			if (after_end_slot) after_end_slot.c();
    			attr_dev(div, "class", "item-after");
    			add_location(div, file$d, 392, 22, 11677);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (after_start_slot) {
    				after_start_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);

    			if (after_slot) {
    				after_slot.m(div, null);
    			}

    			append_dev(div, t3);

    			if (after_end_slot) {
    				after_end_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (after_start_slot) {
    				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_start_slot,
    						after_start_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[83], dirty, get_after_start_slot_changes),
    						get_after_start_slot_context
    					);
    				}
    			}

    			if (typeof /*after*/ ctx[9] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_13(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*badge*/ ctx[10] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*badge*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_12(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (after_slot) {
    				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_slot,
    						after_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[83], dirty, get_after_slot_changes),
    						get_after_slot_context
    					);
    				}
    			}

    			if (after_end_slot) {
    				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						after_end_slot,
    						after_end_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[83], dirty, get_after_end_slot_changes),
    						get_after_end_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(after_start_slot, local);
    			transition_in(if_block1);
    			transition_in(after_slot, local);
    			transition_in(after_end_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(after_start_slot, local);
    			transition_out(if_block1);
    			transition_out(after_slot, local);
    			transition_out(after_end_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (after_start_slot) after_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (after_slot) after_slot.d(detaching);
    			if (after_end_slot) after_end_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(392:20) {#if hasAfter}",
    		ctx
    	});

    	return block;
    }

    // (395:24) {#if typeof after !== 'undefined'}
    function create_if_block_13(ctx) {
    	let span;
    	let t_value = plainText(/*after*/ ctx[9]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$d, 395, 26, 11839);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*after*/ 512 && t_value !== (t_value = plainText(/*after*/ ctx[9]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(395:24) {#if typeof after !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (398:24) {#if typeof badge !== 'undefined'}
    function create_if_block_12(ctx) {
    	let badge_1;
    	let current;

    	badge_1 = new Badge({
    			props: {
    				color: /*badgeColor*/ ctx[11],
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_1_changes = {};
    			if (dirty[0] & /*badgeColor*/ 2048) badge_1_changes.color = /*badgeColor*/ ctx[11];

    			if (dirty[0] & /*badge*/ 1024 | dirty[2] & /*$$scope*/ 2097152) {
    				badge_1_changes.$$scope = { dirty, ctx };
    			}

    			badge_1.$set(badge_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(398:24) {#if typeof badge !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (399:26) <Badge color={badgeColor}>
    function create_default_slot$8(ctx) {
    	let t_value = plainText(/*badge*/ ctx[10]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*badge*/ 1024 && t_value !== (t_value = plainText(/*badge*/ ctx[10]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(399:26) <Badge color={badgeColor}>",
    		ctx
    	});

    	return block;
    }

    // (406:18) {#if hasSubtitle}
    function create_if_block_10(ctx) {
    	let div;
    	let t0_value = plainText(/*subtitle*/ ctx[4]) + "";
    	let t0;
    	let t1;
    	let current;
    	const subtitle_slot_template = /*#slots*/ ctx[69].subtitle;
    	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[83], get_subtitle_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (subtitle_slot) subtitle_slot.c();
    			attr_dev(div, "class", "item-subtitle");
    			add_location(div, file$d, 406, 20, 12301);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (subtitle_slot) {
    				subtitle_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*subtitle*/ 16) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

    			if (subtitle_slot) {
    				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						subtitle_slot,
    						subtitle_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[83], dirty, get_subtitle_slot_changes),
    						get_subtitle_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(subtitle_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(subtitle_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (subtitle_slot) subtitle_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(406:18) {#if hasSubtitle}",
    		ctx
    	});

    	return block;
    }

    // (412:18) {#if hasText}
    function create_if_block_9(ctx) {
    	let div;
    	let t0_value = plainText(/*text*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let current;
    	const text_slot_template = /*#slots*/ ctx[69].text;
    	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[83], get_text_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (text_slot) text_slot.c();
    			attr_dev(div, "class", "item-text");
    			add_location(div, file$d, 412, 20, 12523);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (text_slot) {
    				text_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

    			if (text_slot) {
    				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						text_slot,
    						text_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[83], dirty, get_text_slot_changes),
    						get_text_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (text_slot) text_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(412:18) {#if hasText}",
    		ctx
    	});

    	return block;
    }

    // (419:18) {#if !(swipeout || accordionItem)}
    function create_if_block_8(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(419:18) {#if !(swipeout || accordionItem)}",
    		ctx
    	});

    	return block;
    }

    // (422:18) {#if hasFooter}
    function create_if_block_7(ctx) {
    	let div;
    	let t0_value = plainText(/*footer*/ ctx[6]) + "";
    	let t0;
    	let t1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[69].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[83], get_footer_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "item-footer");
    			add_location(div, file$d, 422, 20, 12881);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[83], dirty, get_footer_slot_changes),
    						get_footer_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(422:18) {#if hasFooter}",
    		ctx
    	});

    	return block;
    }

    // (1079:4) {#if isSortable && sortable !== false && !isSortableOpposite}
    function create_if_block_3$3(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "sortable-handler");
    			add_location(div, file$d, 1079, 6, 37024);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(1079:4) {#if isSortable && sortable !== false && !isSortableOpposite}",
    		ctx
    	});

    	return block;
    }

    // (1082:4) {#if swipeout || accordionItem}
    function create_if_block_2$4(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[69].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[83], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[83],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[83])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[83], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(1082:4) {#if swipeout || accordionItem}",
    		ctx
    	});

    	return block;
    }

    // (327:16) {plainText(title)}
    function fallback_block(ctx) {
    	let t_value = plainText(/*title*/ ctx[1]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*title*/ 2 && t_value !== (t_value = plainText(/*title*/ ctx[1]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(327:16) {plainText(title)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$8, create_if_block_1$5, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*divider*/ ctx[12] || /*groupTitle*/ ctx[13]) return 0;
    		if (/*isSimple*/ ctx[43]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let isMedia;
    	let isSortable;
    	let isSortableOpposite;
    	let isSimple;
    	let liClasses;
    	let contentClasses;
    	let linkClasses;
    	let linkAttrs;
    	let isLink;
    	let hasMedia;
    	let hasTitle;
    	let hasHeader;
    	let hasFooter;
    	let hasSubtitle;
    	let hasText;
    	let hasAfter;

    	const omit_props_names = [
    		"class","title","text","media","subtitle","header","footer","tooltip","tooltipTrigger","link","tabLink","tabLinkActive","selected","href","target","after","badge","badgeColor","mediaItem","mediaList","divider","groupTitle","swipeout","swipeoutOpened","sortable","sortableOpposite","accordionItem","accordionItemOpened","smartSelect","smartSelectParams","noChevron","chevronCenter","checkbox","radio","radioIcon","checked","indeterminate","name","value","readonly","required","disabled","virtualListIndex","routeProps","smartSelectInstance"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;

    	validate_slots('List_item', slots, [
    		'default','root-start','content-start','media','inner-start','header','before-title','title','after-title','after-start','after','after-end','subtitle','text','inner','footer','inner-end','content','content-end','root','root-end'
    	]);

    	const $$slots = compute_slots(slots);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { title = undefined } = $$props;
    	let { text = undefined } = $$props;
    	let { media = undefined } = $$props;
    	let { subtitle = undefined } = $$props;
    	let { header = undefined } = $$props;
    	let { footer = undefined } = $$props;
    	let { tooltip = undefined } = $$props;
    	let { tooltipTrigger = undefined } = $$props;
    	let { link = undefined } = $$props;
    	let { tabLink = undefined } = $$props;
    	let { tabLinkActive = false } = $$props;
    	let { selected = false } = $$props;
    	let { href = undefined } = $$props;
    	let { target = undefined } = $$props;
    	let { after = undefined } = $$props;
    	let { badge = undefined } = $$props;
    	let { badgeColor = undefined } = $$props;
    	let { mediaItem = false } = $$props;
    	let { mediaList = false } = $$props;
    	let { divider = false } = $$props;
    	let { groupTitle = false } = $$props;
    	let { swipeout = false } = $$props;
    	let { swipeoutOpened = false } = $$props;
    	let { sortable = undefined } = $$props;
    	let { sortableOpposite = undefined } = $$props;
    	let { accordionItem = false } = $$props;
    	let { accordionItemOpened = false } = $$props;
    	let { smartSelect = false } = $$props;
    	let { smartSelectParams = undefined } = $$props;
    	let { noChevron = undefined } = $$props;
    	let { chevronCenter = undefined } = $$props;
    	let { checkbox = undefined } = $$props;
    	let { radio = undefined } = $$props;
    	let { radioIcon = undefined } = $$props;
    	let { checked = undefined } = $$props;
    	let { indeterminate = undefined } = $$props;
    	let { name = undefined } = $$props;
    	let { value = undefined } = $$props;
    	let { readonly = undefined } = $$props;
    	let { required = undefined } = $$props;
    	let { disabled = undefined } = $$props;
    	let { virtualListIndex = undefined } = $$props;
    	let { routeProps = undefined } = $$props;
    	let el;
    	let linkEl;
    	let innerEl;
    	let inputEl;
    	let f7SmartSelect;

    	function smartSelectInstance() {
    		return f7SmartSelect;
    	}

    	let ListContext = getReactiveContext('ListContext', value => {
    		$$invalidate(68, ListContext = value || {});
    	}) || {};

    	/* eslint-enable no-undef */
    	let initialWatchedOpened = false;

    	function watchSwipeoutOpened(opened) {
    		if (!initialWatchedOpened) {
    			initialWatchedOpened = true;
    			return;
    		}

    		if (!swipeout) return;

    		if (opened) {
    			app$1.f7.swipeout.open(el);
    		} else {
    			app$1.f7.swipeout.close(el);
    		}
    	}

    	function onClick(event) {
    		if (event.target.tagName.toLowerCase() !== 'input') {
    			emit('click', event);
    		}
    	}

    	function onSwipeoutOverswipeEnter(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutOverswipeEnter');
    	}

    	function onSwipeoutOverswipeExit(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutOverswipeExit');
    	}

    	function onSwipeoutDeleted(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutDeleted');
    	}

    	function onSwipeoutDelete(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutDelete');
    	}

    	function onSwipeoutClose(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutClose');
    	}

    	function onSwipeoutClosed(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutClosed');
    	}

    	function onSwipeoutOpen(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutOpen');
    	}

    	function onSwipeoutOpened(eventEl) {
    		if (eventEl !== el) return;
    		emit('swipeoutOpened');
    	}

    	function onSwipeout(eventEl, progress) {
    		if (eventEl !== el) return;
    		emit('swipeout', progress);
    	}

    	function onAccBeforeClose(eventEl, prevent) {
    		if (eventEl !== el) return;
    		emit('accordionBeforeClose', [prevent]);
    	}

    	function onAccClose(eventEl) {
    		if (eventEl !== el) return;
    		emit('accordionClose');
    	}

    	function onAccClosed(eventEl) {
    		if (eventEl !== el) return;
    		emit('accordionClosed');
    	}

    	function onAccBeforeOpen(eventEl, prevent) {
    		if (eventEl !== el) return;
    		emit('accordionBeforeOpen', [prevent]);
    	}

    	function onAccOpen(eventEl) {
    		if (eventEl !== el) return;
    		emit('accordionOpen');
    	}

    	function onAccOpened(eventEl) {
    		if (eventEl !== el) return;
    		emit('accordionOpened');
    	}

    	function onChange(event) {
    		emit('change', [event]);
    		$$invalidate(0, checked = event.target.checked);
    	}

    	useSmartSelect(
    		{ smartSelect, smartSelectParams },
    		instance => {
    			f7SmartSelect = instance;
    		},
    		() => linkEl
    	);

    	onMount(() => {
    		if (indeterminate && inputEl) {
    			$$invalidate(30, inputEl.indeterminate = true, inputEl);
    		}

    		f7ready(() => {
    			if (swipeout) {
    				app$1.f7.on('swipeoutOpen', onSwipeoutOpen);
    				app$1.f7.on('swipeoutOpened', onSwipeoutOpened);
    				app$1.f7.on('swipeoutClose', onSwipeoutClose);
    				app$1.f7.on('swipeoutClosed', onSwipeoutClosed);
    				app$1.f7.on('swipeoutDelete', onSwipeoutDelete);
    				app$1.f7.on('swipeoutDeleted', onSwipeoutDeleted);
    				app$1.f7.on('swipeoutOverswipeEnter', onSwipeoutOverswipeEnter);
    				app$1.f7.on('swipeoutOverswipeExit', onSwipeoutOverswipeExit);
    				app$1.f7.on('swipeout', onSwipeout);
    			}

    			if (accordionItem) {
    				app$1.f7.on('accordionBeforeOpen', onAccBeforeOpen);
    				app$1.f7.on('accordionOpen', onAccOpen);
    				app$1.f7.on('accordionOpened', onAccOpened);
    				app$1.f7.on('accordionBeforeClose', onAccBeforeClose);
    				app$1.f7.on('accordionClose', onAccClose);
    				app$1.f7.on('accordionClosed', onAccClosed);
    			}

    			if (swipeoutOpened) {
    				app$1.f7.swipeout.open(el);
    			}
    		});
    	});

    	afterUpdate(() => {
    		if (inputEl) {
    			$$invalidate(30, inputEl.indeterminate = indeterminate, inputEl);
    		}
    	});

    	onDestroy(() => {
    		if (!app$1.f7) return;

    		if (swipeout) {
    			app$1.f7.off('swipeoutOpen', onSwipeoutOpen);
    			app$1.f7.off('swipeoutOpened', onSwipeoutOpened);
    			app$1.f7.off('swipeoutClose', onSwipeoutClose);
    			app$1.f7.off('swipeoutClosed', onSwipeoutClosed);
    			app$1.f7.off('swipeoutDelete', onSwipeoutDelete);
    			app$1.f7.off('swipeoutDeleted', onSwipeoutDeleted);
    			app$1.f7.off('swipeoutOverswipeEnter', onSwipeoutOverswipeEnter);
    			app$1.f7.off('swipeoutOverswipeExit', onSwipeoutOverswipeExit);
    			app$1.f7.off('swipeout', onSwipeout);
    		}

    		if (accordionItem) {
    			app$1.f7.off('accordionBeforeOpen', onAccBeforeOpen);
    			app$1.f7.off('accordionOpen', onAccOpen);
    			app$1.f7.off('accordionOpened', onAccOpened);
    			app$1.f7.off('accordionBeforeClose', onAccBeforeClose);
    			app$1.f7.off('accordionClose', onAccClose);
    			app$1.f7.off('accordionClosed', onAccClosed);
    		}
    	});

    	function li_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(27, el);
    		});
    	}

    	function li_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(27, el);
    		});
    	}

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			innerEl = $$value;
    			$$invalidate(29, innerEl);
    		});
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			linkEl = $$value;
    			$$invalidate(28, linkEl);
    		});
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(30, inputEl);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			innerEl = $$value;
    			$$invalidate(29, innerEl);
    		});
    	}

    	function div0_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			innerEl = $$value;
    			$$invalidate(29, innerEl);
    		});
    	}

    	function div0_binding_2($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			innerEl = $$value;
    			$$invalidate(29, innerEl);
    		});
    	}

    	function a_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			linkEl = $$value;
    			$$invalidate(28, linkEl);
    		});
    	}

    	function input_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(30, inputEl);
    		});
    	}

    	function div_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			innerEl = $$value;
    			$$invalidate(29, innerEl);
    		});
    	}

    	function div0_binding_3($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			innerEl = $$value;
    			$$invalidate(29, innerEl);
    		});
    	}

    	function li_binding_2($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(27, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(104, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(48, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(49, className = $$new_props.class);
    		if ('title' in $$new_props) $$invalidate(1, title = $$new_props.title);
    		if ('text' in $$new_props) $$invalidate(2, text = $$new_props.text);
    		if ('media' in $$new_props) $$invalidate(3, media = $$new_props.media);
    		if ('subtitle' in $$new_props) $$invalidate(4, subtitle = $$new_props.subtitle);
    		if ('header' in $$new_props) $$invalidate(5, header = $$new_props.header);
    		if ('footer' in $$new_props) $$invalidate(6, footer = $$new_props.footer);
    		if ('tooltip' in $$new_props) $$invalidate(7, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$new_props) $$invalidate(8, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('link' in $$new_props) $$invalidate(50, link = $$new_props.link);
    		if ('tabLink' in $$new_props) $$invalidate(51, tabLink = $$new_props.tabLink);
    		if ('tabLinkActive' in $$new_props) $$invalidate(52, tabLinkActive = $$new_props.tabLinkActive);
    		if ('selected' in $$new_props) $$invalidate(53, selected = $$new_props.selected);
    		if ('href' in $$new_props) $$invalidate(54, href = $$new_props.href);
    		if ('target' in $$new_props) $$invalidate(55, target = $$new_props.target);
    		if ('after' in $$new_props) $$invalidate(9, after = $$new_props.after);
    		if ('badge' in $$new_props) $$invalidate(10, badge = $$new_props.badge);
    		if ('badgeColor' in $$new_props) $$invalidate(11, badgeColor = $$new_props.badgeColor);
    		if ('mediaItem' in $$new_props) $$invalidate(56, mediaItem = $$new_props.mediaItem);
    		if ('mediaList' in $$new_props) $$invalidate(57, mediaList = $$new_props.mediaList);
    		if ('divider' in $$new_props) $$invalidate(12, divider = $$new_props.divider);
    		if ('groupTitle' in $$new_props) $$invalidate(13, groupTitle = $$new_props.groupTitle);
    		if ('swipeout' in $$new_props) $$invalidate(14, swipeout = $$new_props.swipeout);
    		if ('swipeoutOpened' in $$new_props) $$invalidate(58, swipeoutOpened = $$new_props.swipeoutOpened);
    		if ('sortable' in $$new_props) $$invalidate(15, sortable = $$new_props.sortable);
    		if ('sortableOpposite' in $$new_props) $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
    		if ('accordionItem' in $$new_props) $$invalidate(16, accordionItem = $$new_props.accordionItem);
    		if ('accordionItemOpened' in $$new_props) $$invalidate(60, accordionItemOpened = $$new_props.accordionItemOpened);
    		if ('smartSelect' in $$new_props) $$invalidate(61, smartSelect = $$new_props.smartSelect);
    		if ('smartSelectParams' in $$new_props) $$invalidate(62, smartSelectParams = $$new_props.smartSelectParams);
    		if ('noChevron' in $$new_props) $$invalidate(63, noChevron = $$new_props.noChevron);
    		if ('chevronCenter' in $$new_props) $$invalidate(64, chevronCenter = $$new_props.chevronCenter);
    		if ('checkbox' in $$new_props) $$invalidate(17, checkbox = $$new_props.checkbox);
    		if ('radio' in $$new_props) $$invalidate(18, radio = $$new_props.radio);
    		if ('radioIcon' in $$new_props) $$invalidate(65, radioIcon = $$new_props.radioIcon);
    		if ('checked' in $$new_props) $$invalidate(0, checked = $$new_props.checked);
    		if ('indeterminate' in $$new_props) $$invalidate(66, indeterminate = $$new_props.indeterminate);
    		if ('name' in $$new_props) $$invalidate(19, name = $$new_props.name);
    		if ('value' in $$new_props) $$invalidate(20, value = $$new_props.value);
    		if ('readonly' in $$new_props) $$invalidate(21, readonly = $$new_props.readonly);
    		if ('required' in $$new_props) $$invalidate(22, required = $$new_props.required);
    		if ('disabled' in $$new_props) $$invalidate(23, disabled = $$new_props.disabled);
    		if ('virtualListIndex' in $$new_props) $$invalidate(24, virtualListIndex = $$new_props.virtualListIndex);
    		if ('routeProps' in $$new_props) $$invalidate(25, routeProps = $$new_props.routeProps);
    		if ('$$scope' in $$new_props) $$invalidate(83, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		afterUpdate,
    		colorClasses,
    		routerClasses,
    		routerAttrs,
    		actionsClasses,
    		actionsAttrs,
    		classNames,
    		plainText,
    		isStringProp,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		useTooltip,
    		useSmartSelect,
    		useRouteProps,
    		getReactiveContext,
    		Badge,
    		emit,
    		className,
    		title,
    		text,
    		media,
    		subtitle,
    		header,
    		footer,
    		tooltip,
    		tooltipTrigger,
    		link,
    		tabLink,
    		tabLinkActive,
    		selected,
    		href,
    		target,
    		after,
    		badge,
    		badgeColor,
    		mediaItem,
    		mediaList,
    		divider,
    		groupTitle,
    		swipeout,
    		swipeoutOpened,
    		sortable,
    		sortableOpposite,
    		accordionItem,
    		accordionItemOpened,
    		smartSelect,
    		smartSelectParams,
    		noChevron,
    		chevronCenter,
    		checkbox,
    		radio,
    		radioIcon,
    		checked,
    		indeterminate,
    		name,
    		value,
    		readonly,
    		required,
    		disabled,
    		virtualListIndex,
    		routeProps,
    		el,
    		linkEl,
    		innerEl,
    		inputEl,
    		f7SmartSelect,
    		smartSelectInstance,
    		ListContext,
    		initialWatchedOpened,
    		watchSwipeoutOpened,
    		onClick,
    		onSwipeoutOverswipeEnter,
    		onSwipeoutOverswipeExit,
    		onSwipeoutDeleted,
    		onSwipeoutDelete,
    		onSwipeoutClose,
    		onSwipeoutClosed,
    		onSwipeoutOpen,
    		onSwipeoutOpened,
    		onSwipeout,
    		onAccBeforeClose,
    		onAccClose,
    		onAccClosed,
    		onAccBeforeOpen,
    		onAccOpen,
    		onAccOpened,
    		onChange,
    		hasAfter,
    		hasText,
    		hasSubtitle,
    		hasFooter,
    		hasHeader,
    		hasTitle,
    		hasMedia,
    		isLink,
    		linkAttrs,
    		linkClasses,
    		contentClasses,
    		isMedia,
    		liClasses,
    		isSimple,
    		isSortableOpposite,
    		isSortable
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(104, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(49, className = $$new_props.className);
    		if ('title' in $$props) $$invalidate(1, title = $$new_props.title);
    		if ('text' in $$props) $$invalidate(2, text = $$new_props.text);
    		if ('media' in $$props) $$invalidate(3, media = $$new_props.media);
    		if ('subtitle' in $$props) $$invalidate(4, subtitle = $$new_props.subtitle);
    		if ('header' in $$props) $$invalidate(5, header = $$new_props.header);
    		if ('footer' in $$props) $$invalidate(6, footer = $$new_props.footer);
    		if ('tooltip' in $$props) $$invalidate(7, tooltip = $$new_props.tooltip);
    		if ('tooltipTrigger' in $$props) $$invalidate(8, tooltipTrigger = $$new_props.tooltipTrigger);
    		if ('link' in $$props) $$invalidate(50, link = $$new_props.link);
    		if ('tabLink' in $$props) $$invalidate(51, tabLink = $$new_props.tabLink);
    		if ('tabLinkActive' in $$props) $$invalidate(52, tabLinkActive = $$new_props.tabLinkActive);
    		if ('selected' in $$props) $$invalidate(53, selected = $$new_props.selected);
    		if ('href' in $$props) $$invalidate(54, href = $$new_props.href);
    		if ('target' in $$props) $$invalidate(55, target = $$new_props.target);
    		if ('after' in $$props) $$invalidate(9, after = $$new_props.after);
    		if ('badge' in $$props) $$invalidate(10, badge = $$new_props.badge);
    		if ('badgeColor' in $$props) $$invalidate(11, badgeColor = $$new_props.badgeColor);
    		if ('mediaItem' in $$props) $$invalidate(56, mediaItem = $$new_props.mediaItem);
    		if ('mediaList' in $$props) $$invalidate(57, mediaList = $$new_props.mediaList);
    		if ('divider' in $$props) $$invalidate(12, divider = $$new_props.divider);
    		if ('groupTitle' in $$props) $$invalidate(13, groupTitle = $$new_props.groupTitle);
    		if ('swipeout' in $$props) $$invalidate(14, swipeout = $$new_props.swipeout);
    		if ('swipeoutOpened' in $$props) $$invalidate(58, swipeoutOpened = $$new_props.swipeoutOpened);
    		if ('sortable' in $$props) $$invalidate(15, sortable = $$new_props.sortable);
    		if ('sortableOpposite' in $$props) $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
    		if ('accordionItem' in $$props) $$invalidate(16, accordionItem = $$new_props.accordionItem);
    		if ('accordionItemOpened' in $$props) $$invalidate(60, accordionItemOpened = $$new_props.accordionItemOpened);
    		if ('smartSelect' in $$props) $$invalidate(61, smartSelect = $$new_props.smartSelect);
    		if ('smartSelectParams' in $$props) $$invalidate(62, smartSelectParams = $$new_props.smartSelectParams);
    		if ('noChevron' in $$props) $$invalidate(63, noChevron = $$new_props.noChevron);
    		if ('chevronCenter' in $$props) $$invalidate(64, chevronCenter = $$new_props.chevronCenter);
    		if ('checkbox' in $$props) $$invalidate(17, checkbox = $$new_props.checkbox);
    		if ('radio' in $$props) $$invalidate(18, radio = $$new_props.radio);
    		if ('radioIcon' in $$props) $$invalidate(65, radioIcon = $$new_props.radioIcon);
    		if ('checked' in $$props) $$invalidate(0, checked = $$new_props.checked);
    		if ('indeterminate' in $$props) $$invalidate(66, indeterminate = $$new_props.indeterminate);
    		if ('name' in $$props) $$invalidate(19, name = $$new_props.name);
    		if ('value' in $$props) $$invalidate(20, value = $$new_props.value);
    		if ('readonly' in $$props) $$invalidate(21, readonly = $$new_props.readonly);
    		if ('required' in $$props) $$invalidate(22, required = $$new_props.required);
    		if ('disabled' in $$props) $$invalidate(23, disabled = $$new_props.disabled);
    		if ('virtualListIndex' in $$props) $$invalidate(24, virtualListIndex = $$new_props.virtualListIndex);
    		if ('routeProps' in $$props) $$invalidate(25, routeProps = $$new_props.routeProps);
    		if ('el' in $$props) $$invalidate(27, el = $$new_props.el);
    		if ('linkEl' in $$props) $$invalidate(28, linkEl = $$new_props.linkEl);
    		if ('innerEl' in $$props) $$invalidate(29, innerEl = $$new_props.innerEl);
    		if ('inputEl' in $$props) $$invalidate(30, inputEl = $$new_props.inputEl);
    		if ('f7SmartSelect' in $$props) f7SmartSelect = $$new_props.f7SmartSelect;
    		if ('ListContext' in $$props) $$invalidate(68, ListContext = $$new_props.ListContext);
    		if ('initialWatchedOpened' in $$props) initialWatchedOpened = $$new_props.initialWatchedOpened;
    		if ('hasAfter' in $$props) $$invalidate(31, hasAfter = $$new_props.hasAfter);
    		if ('hasText' in $$props) $$invalidate(32, hasText = $$new_props.hasText);
    		if ('hasSubtitle' in $$props) $$invalidate(33, hasSubtitle = $$new_props.hasSubtitle);
    		if ('hasFooter' in $$props) $$invalidate(34, hasFooter = $$new_props.hasFooter);
    		if ('hasHeader' in $$props) $$invalidate(35, hasHeader = $$new_props.hasHeader);
    		if ('hasTitle' in $$props) $$invalidate(36, hasTitle = $$new_props.hasTitle);
    		if ('hasMedia' in $$props) $$invalidate(37, hasMedia = $$new_props.hasMedia);
    		if ('isLink' in $$props) $$invalidate(38, isLink = $$new_props.isLink);
    		if ('linkAttrs' in $$props) $$invalidate(39, linkAttrs = $$new_props.linkAttrs);
    		if ('linkClasses' in $$props) $$invalidate(40, linkClasses = $$new_props.linkClasses);
    		if ('contentClasses' in $$props) $$invalidate(41, contentClasses = $$new_props.contentClasses);
    		if ('isMedia' in $$props) $$invalidate(26, isMedia = $$new_props.isMedia);
    		if ('liClasses' in $$props) $$invalidate(42, liClasses = $$new_props.liClasses);
    		if ('isSimple' in $$props) $$invalidate(43, isSimple = $$new_props.isSimple);
    		if ('isSortableOpposite' in $$props) $$invalidate(44, isSortableOpposite = $$new_props.isSortableOpposite);
    		if ('isSortable' in $$props) $$invalidate(45, isSortable = $$new_props.isSortable);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[1] & /*mediaList, mediaItem*/ 100663296 | $$self.$$.dirty[2] & /*ListContext*/ 64) {
    			$$invalidate(26, isMedia = mediaList || mediaItem || ListContext.listIsMedia);
    		}

    		if ($$self.$$.dirty[0] & /*sortable*/ 32768 | $$self.$$.dirty[2] & /*ListContext*/ 64) {
    			$$invalidate(45, isSortable = sortable === true || sortable === false
    			? sortable
    			: ListContext.listIsSortable);
    		}

    		if ($$self.$$.dirty[1] & /*sortableOpposite*/ 268435456 | $$self.$$.dirty[2] & /*ListContext*/ 64) {
    			$$invalidate(44, isSortableOpposite = sortableOpposite || ListContext.listIsSortableOpposite);
    		}

    		if ($$self.$$.dirty[2] & /*ListContext*/ 64) {
    			$$invalidate(43, isSimple = ListContext.listIsSimple);
    		}

    		$$invalidate(42, liClasses = classNames(
    			className,
    			{
    				'item-divider': divider,
    				'list-group-title': groupTitle,
    				'media-item': isMedia,
    				swipeout,
    				'accordion-item': accordionItem,
    				'accordion-item-opened': accordionItemOpened,
    				disabled: disabled && !(radio || checkbox),
    				'no-chevron': noChevron,
    				'chevron-center': chevronCenter,
    				'disallow-sorting': sortable === false
    			},
    			colorClasses($$props)
    		));

    		$$invalidate(41, contentClasses = classNames(
    			className,
    			'item-content',
    			{
    				'item-checkbox': checkbox,
    				'item-radio': radio,
    				'item-radio-icon-start': radio && radioIcon === 'start',
    				'item-radio-icon-end': radio && radioIcon === 'end'
    			},
    			colorClasses($$props)
    		));

    		$$invalidate(40, linkClasses = classNames(
    			{
    				'item-link': true,
    				'smart-select': smartSelect,
    				'tab-link': tabLink || tabLink === '',
    				'tab-link-active': tabLinkActive,
    				'item-selected': selected
    			},
    			routerClasses($$props),
    			actionsClasses($$props)
    		));

    		$$invalidate(39, linkAttrs = {
    			href: link === true ? '' : link || href,
    			target,
    			'data-tab': isStringProp(tabLink) && tabLink || undefined,
    			...routerAttrs($$props),
    			...actionsAttrs($$props)
    		});

    		if ($$self.$$.dirty[0] & /*accordionItem*/ 65536 | $$self.$$.dirty[1] & /*link, href, smartSelect*/ 1082654720) {
    			$$invalidate(38, isLink = link || href || smartSelect || accordionItem);
    		}

    		if ($$self.$$.dirty[0] & /*media*/ 8) {
    			/* eslint-disable no-undef */
    			$$invalidate(37, hasMedia = typeof media !== 'undefined' || $$slots.media);
    		}

    		if ($$self.$$.dirty[0] & /*title*/ 2) {
    			$$invalidate(36, hasTitle = typeof title !== 'undefined' || $$slots.title);
    		}

    		if ($$self.$$.dirty[0] & /*header*/ 32) {
    			$$invalidate(35, hasHeader = typeof header !== 'undefined' || $$slots.header);
    		}

    		if ($$self.$$.dirty[0] & /*footer*/ 64) {
    			$$invalidate(34, hasFooter = typeof footer !== 'undefined' || $$slots.footer);
    		}

    		if ($$self.$$.dirty[0] & /*subtitle*/ 16) {
    			$$invalidate(33, hasSubtitle = typeof subtitle !== 'undefined' || $$slots.subtitle);
    		}

    		if ($$self.$$.dirty[0] & /*text*/ 4) {
    			$$invalidate(32, hasText = typeof text !== 'undefined' || $$slots.text);
    		}

    		if ($$self.$$.dirty[0] & /*after, badge*/ 1536) {
    			$$invalidate(31, hasAfter = typeof after !== 'undefined' || typeof badge !== 'undefined' || $$slots.after);
    		}

    		if ($$self.$$.dirty[1] & /*swipeoutOpened*/ 134217728) {
    			watchSwipeoutOpened(swipeoutOpened);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		checked,
    		title,
    		text,
    		media,
    		subtitle,
    		header,
    		footer,
    		tooltip,
    		tooltipTrigger,
    		after,
    		badge,
    		badgeColor,
    		divider,
    		groupTitle,
    		swipeout,
    		sortable,
    		accordionItem,
    		checkbox,
    		radio,
    		name,
    		value,
    		readonly,
    		required,
    		disabled,
    		virtualListIndex,
    		routeProps,
    		isMedia,
    		el,
    		linkEl,
    		innerEl,
    		inputEl,
    		hasAfter,
    		hasText,
    		hasSubtitle,
    		hasFooter,
    		hasHeader,
    		hasTitle,
    		hasMedia,
    		isLink,
    		linkAttrs,
    		linkClasses,
    		contentClasses,
    		liClasses,
    		isSimple,
    		isSortableOpposite,
    		isSortable,
    		onClick,
    		onChange,
    		$$restProps,
    		className,
    		link,
    		tabLink,
    		tabLinkActive,
    		selected,
    		href,
    		target,
    		mediaItem,
    		mediaList,
    		swipeoutOpened,
    		sortableOpposite,
    		accordionItemOpened,
    		smartSelect,
    		smartSelectParams,
    		noChevron,
    		chevronCenter,
    		radioIcon,
    		indeterminate,
    		smartSelectInstance,
    		ListContext,
    		slots,
    		li_binding,
    		li_binding_1,
    		div0_binding,
    		a_binding,
    		input_binding,
    		div_binding,
    		div0_binding_1,
    		div0_binding_2,
    		a_binding_1,
    		input_binding_1,
    		div_binding_1,
    		div0_binding_3,
    		li_binding_2,
    		$$scope
    	];
    }

    class List_item extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$f,
    			create_fragment$g,
    			safe_not_equal,
    			{
    				class: 49,
    				title: 1,
    				text: 2,
    				media: 3,
    				subtitle: 4,
    				header: 5,
    				footer: 6,
    				tooltip: 7,
    				tooltipTrigger: 8,
    				link: 50,
    				tabLink: 51,
    				tabLinkActive: 52,
    				selected: 53,
    				href: 54,
    				target: 55,
    				after: 9,
    				badge: 10,
    				badgeColor: 11,
    				mediaItem: 56,
    				mediaList: 57,
    				divider: 12,
    				groupTitle: 13,
    				swipeout: 14,
    				swipeoutOpened: 58,
    				sortable: 15,
    				sortableOpposite: 59,
    				accordionItem: 16,
    				accordionItemOpened: 60,
    				smartSelect: 61,
    				smartSelectParams: 62,
    				noChevron: 63,
    				chevronCenter: 64,
    				checkbox: 17,
    				radio: 18,
    				radioIcon: 65,
    				checked: 0,
    				indeterminate: 66,
    				name: 19,
    				value: 20,
    				readonly: 21,
    				required: 22,
    				disabled: 23,
    				virtualListIndex: 24,
    				routeProps: 25,
    				smartSelectInstance: 67
    			},
    			null,
    			[-1, -1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List_item",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get class() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get media() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set media(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitle() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitle(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get header() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set header(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get footer() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set footer(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipTrigger() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipTrigger(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get link() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set link(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabLink() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabLink(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabLinkActive() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabLinkActive(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get target() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set target(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get after() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set after(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get badge() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set badge(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get badgeColor() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set badgeColor(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mediaItem() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mediaItem(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mediaList() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mediaList(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get divider() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set divider(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupTitle() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupTitle(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get swipeout() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set swipeout(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get swipeoutOpened() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set swipeoutOpened(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortable() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortable(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortableOpposite() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortableOpposite(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accordionItem() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accordionItem(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accordionItemOpened() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accordionItemOpened(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smartSelect() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smartSelect(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smartSelectParams() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smartSelectParams(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noChevron() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noChevron(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get chevronCenter() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set chevronCenter(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checkbox() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checkbox(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radio() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radio(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radioIcon() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radioIcon(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checked() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checked(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indeterminate() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indeterminate(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readonly() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readonly(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get virtualListIndex() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set virtualListIndex(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get routeProps() {
    		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routeProps(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smartSelectInstance() {
    		return this.$$.ctx[67];
    	}

    	set smartSelectInstance(value) {
    		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/list.svelte generated by Svelte v3.44.0 */
    const file$c = "node_modules/framework7-svelte/esm/svelte/list.svelte";
    const get_after_list_slot_changes_1 = dirty => ({});
    const get_after_list_slot_context_1 = ctx => ({});
    const get_list_slot_changes_1 = dirty => ({});
    const get_list_slot_context_1 = ctx => ({});
    const get_before_list_slot_changes_1 = dirty => ({});
    const get_before_list_slot_context_1 = ctx => ({});
    const get_after_list_slot_changes = dirty => ({});
    const get_after_list_slot_context = ctx => ({});
    const get_list_slot_changes = dirty => ({});
    const get_list_slot_context = ctx => ({});
    const get_before_list_slot_changes = dirty => ({});
    const get_before_list_slot_context = ctx => ({});

    // (211:0) {:else}
    function create_else_block_1(ctx) {
    	let div;
    	let t0;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let div_data_sortable_move_elements_value;
    	let current;
    	const before_list_slot_template = /*#slots*/ ctx[44]["before-list"];
    	const before_list_slot = create_slot(before_list_slot_template, ctx, /*$$scope*/ ctx[43], get_before_list_slot_context_1);
    	const if_block_creators = [create_if_block_2$3, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*hasUlSlots*/ ctx[5] && /*ul*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const after_list_slot_template = /*#slots*/ ctx[44]["after-list"];
    	const after_list_slot = create_slot(after_list_slot_template, ctx, /*$$scope*/ ctx[43], get_after_list_slot_context_1);

    	let div_levels = [
    		{ class: /*classes*/ ctx[4] },
    		{
    			"data-sortable-move-elements": div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== 'undefined'
    			? /*sortableMoveElements*/ ctx[1].toString()
    			: undefined
    		},
    		restProps(/*$$restProps*/ ctx[7])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (before_list_slot) before_list_slot.c();
    			t0 = space();
    			if_block.c();
    			t1 = space();
    			if (after_list_slot) after_list_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$c, 211, 2, 6024);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (before_list_slot) {
    				before_list_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if_blocks[current_block_type_index].m(div, null);
    			append_dev(div, t1);

    			if (after_list_slot) {
    				after_list_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[46](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_list_slot) {
    				if (before_list_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						before_list_slot,
    						before_list_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(before_list_slot_template, /*$$scope*/ ctx[43], dirty, get_before_list_slot_changes_1),
    						get_before_list_slot_context_1
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, t1);
    			}

    			if (after_list_slot) {
    				if (after_list_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						after_list_slot,
    						after_list_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(after_list_slot_template, /*$$scope*/ ctx[43], dirty, get_after_list_slot_changes_1),
    						get_after_list_slot_context_1
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty[0] & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
    				(!current || dirty[0] & /*sortableMoveElements*/ 2 && div_data_sortable_move_elements_value !== (div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== 'undefined'
    				? /*sortableMoveElements*/ ctx[1].toString()
    				: undefined)) && {
    					"data-sortable-move-elements": div_data_sortable_move_elements_value
    				},
    				dirty[0] & /*$$restProps*/ 128 && restProps(/*$$restProps*/ ctx[7])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_list_slot, local);
    			transition_in(if_block);
    			transition_in(after_list_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_list_slot, local);
    			transition_out(if_block);
    			transition_out(after_list_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (before_list_slot) before_list_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (after_list_slot) after_list_slot.d(detaching);
    			/*div_binding*/ ctx[46](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(211:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (190:0) {#if form}
    function create_if_block$7(ctx) {
    	let form_1;
    	let t0;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let form_1_data_sortable_move_elements_value;
    	let current;
    	let mounted;
    	let dispose;
    	const before_list_slot_template = /*#slots*/ ctx[44]["before-list"];
    	const before_list_slot = create_slot(before_list_slot_template, ctx, /*$$scope*/ ctx[43], get_before_list_slot_context);
    	const if_block_creators = [create_if_block_1$4, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*hasUlSlots*/ ctx[5] && /*ul*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const after_list_slot_template = /*#slots*/ ctx[44]["after-list"];
    	const after_list_slot = create_slot(after_list_slot_template, ctx, /*$$scope*/ ctx[43], get_after_list_slot_context);

    	let form_1_levels = [
    		{ class: /*classes*/ ctx[4] },
    		{
    			"data-sortable-move-elements": form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== 'undefined'
    			? /*sortableMoveElements*/ ctx[1].toString()
    			: undefined
    		},
    		restProps(/*$$restProps*/ ctx[7])
    	];

    	let form_1_data = {};

    	for (let i = 0; i < form_1_levels.length; i += 1) {
    		form_1_data = assign(form_1_data, form_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			form_1 = element("form");
    			if (before_list_slot) before_list_slot.c();
    			t0 = space();
    			if_block.c();
    			t1 = space();
    			if (after_list_slot) after_list_slot.c();
    			set_attributes(form_1, form_1_data);
    			add_location(form_1, file$c, 190, 2, 5566);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form_1, anchor);

    			if (before_list_slot) {
    				before_list_slot.m(form_1, null);
    			}

    			append_dev(form_1, t0);
    			if_blocks[current_block_type_index].m(form_1, null);
    			append_dev(form_1, t1);

    			if (after_list_slot) {
    				after_list_slot.m(form_1, null);
    			}

    			/*form_1_binding*/ ctx[45](form_1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form_1, "submit", /*onSubmit*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (before_list_slot) {
    				if (before_list_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						before_list_slot,
    						before_list_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(before_list_slot_template, /*$$scope*/ ctx[43], dirty, get_before_list_slot_changes),
    						get_before_list_slot_context
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(form_1, t1);
    			}

    			if (after_list_slot) {
    				if (after_list_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						after_list_slot,
    						after_list_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(after_list_slot_template, /*$$scope*/ ctx[43], dirty, get_after_list_slot_changes),
    						get_after_list_slot_context
    					);
    				}
    			}

    			set_attributes(form_1, form_1_data = get_spread_update(form_1_levels, [
    				(!current || dirty[0] & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
    				(!current || dirty[0] & /*sortableMoveElements*/ 2 && form_1_data_sortable_move_elements_value !== (form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== 'undefined'
    				? /*sortableMoveElements*/ ctx[1].toString()
    				: undefined)) && {
    					"data-sortable-move-elements": form_1_data_sortable_move_elements_value
    				},
    				dirty[0] & /*$$restProps*/ 128 && restProps(/*$$restProps*/ ctx[7])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_list_slot, local);
    			transition_in(if_block);
    			transition_in(after_list_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_list_slot, local);
    			transition_out(if_block);
    			transition_out(after_list_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form_1);
    			if (before_list_slot) before_list_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (after_list_slot) after_list_slot.d(detaching);
    			/*form_1_binding*/ ctx[45](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(190:0) {#if form}",
    		ctx
    	});

    	return block;
    }

    // (226:4) {:else}
    function create_else_block_2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[44].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(226:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (221:4) {#if hasUlSlots && ul}
    function create_if_block_2$3(ctx) {
    	let ul_1;
    	let t;
    	let current;
    	const list_slot_template = /*#slots*/ ctx[44].list;
    	const list_slot = create_slot(list_slot_template, ctx, /*$$scope*/ ctx[43], get_list_slot_context_1);
    	const default_slot_template = /*#slots*/ ctx[44].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);

    	const block = {
    		c: function create() {
    			ul_1 = element("ul");
    			if (list_slot) list_slot.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			add_location(ul_1, file$c, 221, 6, 6305);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul_1, anchor);

    			if (list_slot) {
    				list_slot.m(ul_1, null);
    			}

    			append_dev(ul_1, t);

    			if (default_slot) {
    				default_slot.m(ul_1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (list_slot) {
    				if (list_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						list_slot,
    						list_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(list_slot_template, /*$$scope*/ ctx[43], dirty, get_list_slot_changes_1),
    						get_list_slot_context_1
    					);
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(list_slot, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(list_slot, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul_1);
    			if (list_slot) list_slot.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(221:4) {#if hasUlSlots && ul}",
    		ctx
    	});

    	return block;
    }

    // (206:4) {:else}
    function create_else_block$2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[44].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(206:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (201:4) {#if hasUlSlots && ul}
    function create_if_block_1$4(ctx) {
    	let ul_1;
    	let t;
    	let current;
    	const list_slot_template = /*#slots*/ ctx[44].list;
    	const list_slot = create_slot(list_slot_template, ctx, /*$$scope*/ ctx[43], get_list_slot_context);
    	const default_slot_template = /*#slots*/ ctx[44].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);

    	const block = {
    		c: function create() {
    			ul_1 = element("ul");
    			if (list_slot) list_slot.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			add_location(ul_1, file$c, 201, 6, 5873);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul_1, anchor);

    			if (list_slot) {
    				list_slot.m(ul_1, null);
    			}

    			append_dev(ul_1, t);

    			if (default_slot) {
    				default_slot.m(ul_1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (list_slot) {
    				if (list_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						list_slot,
    						list_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(list_slot_template, /*$$scope*/ ctx[43], dirty, get_list_slot_changes),
    						get_list_slot_context
    					);
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[43],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(list_slot, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(list_slot, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul_1);
    			if (list_slot) list_slot.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(201:4) {#if hasUlSlots && ul}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$7, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*form*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let hasUlSlots;
    	let classes;

    	const omit_props_names = [
    		"class","ul","inset","xsmallInset","smallInset","mediumInset","largeInset","xlargeInset","mediaList","sortable","sortableTapHold","sortableEnabled","sortableMoveElements","sortableOpposite","accordionList","accordionOpposite","contactsList","simpleList","linksList","menuList","noHairlines","noHairlinesBetween","noHairlinesMd","noHairlinesBetweenMd","noHairlinesIos","noHairlinesBetweenIos","noHairlinesAurora","noHairlinesBetweenAurora","noChevron","chevronCenter","tab","tabActive","form","formStoreData","inlineLabels","virtualList","virtualListParams","virtualListInstance"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('List', slots, ['before-list','list','default','after-list']);
    	const $$slots = compute_slots(slots);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { ul = true } = $$props;
    	let { inset = false } = $$props;
    	let { xsmallInset = false } = $$props;
    	let { smallInset = false } = $$props;
    	let { mediumInset = false } = $$props;
    	let { largeInset = false } = $$props;
    	let { xlargeInset = false } = $$props;
    	let { mediaList = false } = $$props;
    	let { sortable = false } = $$props;
    	let { sortableTapHold = false } = $$props;
    	let { sortableEnabled = false } = $$props;
    	let { sortableMoveElements = undefined } = $$props;
    	let { sortableOpposite = false } = $$props;
    	let { accordionList = false } = $$props;
    	let { accordionOpposite = false } = $$props;
    	let { contactsList = false } = $$props;
    	let { simpleList = false } = $$props;
    	let { linksList = false } = $$props;
    	let { menuList = false } = $$props;
    	let { noHairlines = false } = $$props;
    	let { noHairlinesBetween = false } = $$props;
    	let { noHairlinesMd = false } = $$props;
    	let { noHairlinesBetweenMd = false } = $$props;
    	let { noHairlinesIos = false } = $$props;
    	let { noHairlinesBetweenIos = false } = $$props;
    	let { noHairlinesAurora = false } = $$props;
    	let { noHairlinesBetweenAurora = false } = $$props;
    	let { noChevron = false } = $$props;
    	let { chevronCenter = false } = $$props;
    	let { tab = false } = $$props;
    	let { tabActive = false } = $$props;
    	let { form = false } = $$props;
    	let { formStoreData = false } = $$props;
    	let { inlineLabels = false } = $$props;
    	let { virtualList = false } = $$props;
    	let { virtualListParams = undefined } = $$props;
    	let el;
    	let f7VirtualList;

    	function virtualListInstance() {
    		return f7VirtualList;
    	}

    	setReactiveContext('ListContext', () => ({
    		listIsMedia: mediaList,
    		listIsSimple: simpleList,
    		listIsSortable: sortable,
    		listIsSortableOpposite: sortableOpposite
    	}));

    	function onSubmit(event) {
    		emit('submit', [event]);
    	}

    	function onSortableEnable(sortableEl) {
    		if (sortableEl !== el) return;
    		emit('sortableEnable');
    	}

    	function onSortableDisable(sortableEl) {
    		if (sortableEl !== el) return;
    		emit('sortableDisable');
    	}

    	function onSortableSort(listItemEl, sortData, listEl) {
    		if (listEl !== el) return;
    		emit('sortableSort', [sortData]);
    	}

    	useTab(() => el, emit);

    	onMount(() => {
    		f7ready(() => {
    			app$1.f7.on('sortableEnable', onSortableEnable);
    			app$1.f7.on('sortableDisable', onSortableDisable);
    			app$1.f7.on('sortableSort', onSortableSort);
    			if (!virtualList) return;
    			const vlParams = virtualListParams || {};
    			if (!vlParams.renderItem && !vlParams.renderExternal) return;

    			f7VirtualList = app$1.f7.virtualList.create(extend(
    				{
    					el,
    					on: {
    						itemBeforeInsert(itemEl, item) {
    							const vl = this;
    							emit('virtualItemBeforeInsert', [vl, itemEl, item]);
    						},
    						beforeClear(fragment) {
    							const vl = this;
    							emit('virtualBeforeClear', [vl, fragment]);
    						},
    						itemsBeforeInsert(fragment) {
    							const vl = this;
    							emit('virtualItemsBeforeInsert', [vl, fragment]);
    						},
    						itemsAfterInsert(fragment) {
    							const vl = this;
    							emit('virtualItemsAfterInsert', [vl, fragment]);
    						}
    					}
    				},
    				vlParams
    			));
    		});
    	});

    	onDestroy(() => {
    		if (!app$1.f7) return;
    		app$1.f7.off('sortableEnable', onSortableEnable);
    		app$1.f7.off('sortableDisable', onSortableDisable);
    		app$1.f7.off('sortableSort', onSortableSort);

    		if (f7VirtualList && f7VirtualList.destroy) {
    			f7VirtualList.destroy();
    			f7VirtualList = null;
    		}
    	});

    	function form_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(3, el);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(3, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(52, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
    		if ('ul' in $$new_props) $$invalidate(0, ul = $$new_props.ul);
    		if ('inset' in $$new_props) $$invalidate(9, inset = $$new_props.inset);
    		if ('xsmallInset' in $$new_props) $$invalidate(10, xsmallInset = $$new_props.xsmallInset);
    		if ('smallInset' in $$new_props) $$invalidate(11, smallInset = $$new_props.smallInset);
    		if ('mediumInset' in $$new_props) $$invalidate(12, mediumInset = $$new_props.mediumInset);
    		if ('largeInset' in $$new_props) $$invalidate(13, largeInset = $$new_props.largeInset);
    		if ('xlargeInset' in $$new_props) $$invalidate(14, xlargeInset = $$new_props.xlargeInset);
    		if ('mediaList' in $$new_props) $$invalidate(15, mediaList = $$new_props.mediaList);
    		if ('sortable' in $$new_props) $$invalidate(16, sortable = $$new_props.sortable);
    		if ('sortableTapHold' in $$new_props) $$invalidate(17, sortableTapHold = $$new_props.sortableTapHold);
    		if ('sortableEnabled' in $$new_props) $$invalidate(18, sortableEnabled = $$new_props.sortableEnabled);
    		if ('sortableMoveElements' in $$new_props) $$invalidate(1, sortableMoveElements = $$new_props.sortableMoveElements);
    		if ('sortableOpposite' in $$new_props) $$invalidate(19, sortableOpposite = $$new_props.sortableOpposite);
    		if ('accordionList' in $$new_props) $$invalidate(20, accordionList = $$new_props.accordionList);
    		if ('accordionOpposite' in $$new_props) $$invalidate(21, accordionOpposite = $$new_props.accordionOpposite);
    		if ('contactsList' in $$new_props) $$invalidate(22, contactsList = $$new_props.contactsList);
    		if ('simpleList' in $$new_props) $$invalidate(23, simpleList = $$new_props.simpleList);
    		if ('linksList' in $$new_props) $$invalidate(24, linksList = $$new_props.linksList);
    		if ('menuList' in $$new_props) $$invalidate(25, menuList = $$new_props.menuList);
    		if ('noHairlines' in $$new_props) $$invalidate(26, noHairlines = $$new_props.noHairlines);
    		if ('noHairlinesBetween' in $$new_props) $$invalidate(27, noHairlinesBetween = $$new_props.noHairlinesBetween);
    		if ('noHairlinesMd' in $$new_props) $$invalidate(28, noHairlinesMd = $$new_props.noHairlinesMd);
    		if ('noHairlinesBetweenMd' in $$new_props) $$invalidate(29, noHairlinesBetweenMd = $$new_props.noHairlinesBetweenMd);
    		if ('noHairlinesIos' in $$new_props) $$invalidate(30, noHairlinesIos = $$new_props.noHairlinesIos);
    		if ('noHairlinesBetweenIos' in $$new_props) $$invalidate(31, noHairlinesBetweenIos = $$new_props.noHairlinesBetweenIos);
    		if ('noHairlinesAurora' in $$new_props) $$invalidate(32, noHairlinesAurora = $$new_props.noHairlinesAurora);
    		if ('noHairlinesBetweenAurora' in $$new_props) $$invalidate(33, noHairlinesBetweenAurora = $$new_props.noHairlinesBetweenAurora);
    		if ('noChevron' in $$new_props) $$invalidate(34, noChevron = $$new_props.noChevron);
    		if ('chevronCenter' in $$new_props) $$invalidate(35, chevronCenter = $$new_props.chevronCenter);
    		if ('tab' in $$new_props) $$invalidate(36, tab = $$new_props.tab);
    		if ('tabActive' in $$new_props) $$invalidate(37, tabActive = $$new_props.tabActive);
    		if ('form' in $$new_props) $$invalidate(2, form = $$new_props.form);
    		if ('formStoreData' in $$new_props) $$invalidate(38, formStoreData = $$new_props.formStoreData);
    		if ('inlineLabels' in $$new_props) $$invalidate(39, inlineLabels = $$new_props.inlineLabels);
    		if ('virtualList' in $$new_props) $$invalidate(40, virtualList = $$new_props.virtualList);
    		if ('virtualListParams' in $$new_props) $$invalidate(41, virtualListParams = $$new_props.virtualListParams);
    		if ('$$scope' in $$new_props) $$invalidate(43, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		colorClasses,
    		classNames,
    		extend,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		useTab,
    		setReactiveContext,
    		emit,
    		className,
    		ul,
    		inset,
    		xsmallInset,
    		smallInset,
    		mediumInset,
    		largeInset,
    		xlargeInset,
    		mediaList,
    		sortable,
    		sortableTapHold,
    		sortableEnabled,
    		sortableMoveElements,
    		sortableOpposite,
    		accordionList,
    		accordionOpposite,
    		contactsList,
    		simpleList,
    		linksList,
    		menuList,
    		noHairlines,
    		noHairlinesBetween,
    		noHairlinesMd,
    		noHairlinesBetweenMd,
    		noHairlinesIos,
    		noHairlinesBetweenIos,
    		noHairlinesAurora,
    		noHairlinesBetweenAurora,
    		noChevron,
    		chevronCenter,
    		tab,
    		tabActive,
    		form,
    		formStoreData,
    		inlineLabels,
    		virtualList,
    		virtualListParams,
    		el,
    		f7VirtualList,
    		virtualListInstance,
    		onSubmit,
    		onSortableEnable,
    		onSortableDisable,
    		onSortableSort,
    		classes,
    		hasUlSlots
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(52, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(8, className = $$new_props.className);
    		if ('ul' in $$props) $$invalidate(0, ul = $$new_props.ul);
    		if ('inset' in $$props) $$invalidate(9, inset = $$new_props.inset);
    		if ('xsmallInset' in $$props) $$invalidate(10, xsmallInset = $$new_props.xsmallInset);
    		if ('smallInset' in $$props) $$invalidate(11, smallInset = $$new_props.smallInset);
    		if ('mediumInset' in $$props) $$invalidate(12, mediumInset = $$new_props.mediumInset);
    		if ('largeInset' in $$props) $$invalidate(13, largeInset = $$new_props.largeInset);
    		if ('xlargeInset' in $$props) $$invalidate(14, xlargeInset = $$new_props.xlargeInset);
    		if ('mediaList' in $$props) $$invalidate(15, mediaList = $$new_props.mediaList);
    		if ('sortable' in $$props) $$invalidate(16, sortable = $$new_props.sortable);
    		if ('sortableTapHold' in $$props) $$invalidate(17, sortableTapHold = $$new_props.sortableTapHold);
    		if ('sortableEnabled' in $$props) $$invalidate(18, sortableEnabled = $$new_props.sortableEnabled);
    		if ('sortableMoveElements' in $$props) $$invalidate(1, sortableMoveElements = $$new_props.sortableMoveElements);
    		if ('sortableOpposite' in $$props) $$invalidate(19, sortableOpposite = $$new_props.sortableOpposite);
    		if ('accordionList' in $$props) $$invalidate(20, accordionList = $$new_props.accordionList);
    		if ('accordionOpposite' in $$props) $$invalidate(21, accordionOpposite = $$new_props.accordionOpposite);
    		if ('contactsList' in $$props) $$invalidate(22, contactsList = $$new_props.contactsList);
    		if ('simpleList' in $$props) $$invalidate(23, simpleList = $$new_props.simpleList);
    		if ('linksList' in $$props) $$invalidate(24, linksList = $$new_props.linksList);
    		if ('menuList' in $$props) $$invalidate(25, menuList = $$new_props.menuList);
    		if ('noHairlines' in $$props) $$invalidate(26, noHairlines = $$new_props.noHairlines);
    		if ('noHairlinesBetween' in $$props) $$invalidate(27, noHairlinesBetween = $$new_props.noHairlinesBetween);
    		if ('noHairlinesMd' in $$props) $$invalidate(28, noHairlinesMd = $$new_props.noHairlinesMd);
    		if ('noHairlinesBetweenMd' in $$props) $$invalidate(29, noHairlinesBetweenMd = $$new_props.noHairlinesBetweenMd);
    		if ('noHairlinesIos' in $$props) $$invalidate(30, noHairlinesIos = $$new_props.noHairlinesIos);
    		if ('noHairlinesBetweenIos' in $$props) $$invalidate(31, noHairlinesBetweenIos = $$new_props.noHairlinesBetweenIos);
    		if ('noHairlinesAurora' in $$props) $$invalidate(32, noHairlinesAurora = $$new_props.noHairlinesAurora);
    		if ('noHairlinesBetweenAurora' in $$props) $$invalidate(33, noHairlinesBetweenAurora = $$new_props.noHairlinesBetweenAurora);
    		if ('noChevron' in $$props) $$invalidate(34, noChevron = $$new_props.noChevron);
    		if ('chevronCenter' in $$props) $$invalidate(35, chevronCenter = $$new_props.chevronCenter);
    		if ('tab' in $$props) $$invalidate(36, tab = $$new_props.tab);
    		if ('tabActive' in $$props) $$invalidate(37, tabActive = $$new_props.tabActive);
    		if ('form' in $$props) $$invalidate(2, form = $$new_props.form);
    		if ('formStoreData' in $$props) $$invalidate(38, formStoreData = $$new_props.formStoreData);
    		if ('inlineLabels' in $$props) $$invalidate(39, inlineLabels = $$new_props.inlineLabels);
    		if ('virtualList' in $$props) $$invalidate(40, virtualList = $$new_props.virtualList);
    		if ('virtualListParams' in $$props) $$invalidate(41, virtualListParams = $$new_props.virtualListParams);
    		if ('el' in $$props) $$invalidate(3, el = $$new_props.el);
    		if ('f7VirtualList' in $$props) f7VirtualList = $$new_props.f7VirtualList;
    		if ('classes' in $$props) $$invalidate(4, classes = $$new_props.classes);
    		if ('hasUlSlots' in $$props) $$invalidate(5, hasUlSlots = $$new_props.hasUlSlots);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(4, classes = classNames(
    			className,
    			'list',
    			{
    				inset,
    				'xsmall-inset': xsmallInset,
    				'small-inset': smallInset,
    				'medium-inset': mediumInset,
    				'large-inset': largeInset,
    				'xlarge-inset': xlargeInset,
    				'media-list': mediaList,
    				'simple-list': simpleList,
    				'links-list': linksList,
    				'menu-list': menuList,
    				sortable,
    				'sortable-tap-hold': sortableTapHold,
    				'sortable-enabled': sortableEnabled,
    				'sortable-opposite': sortableOpposite,
    				'accordion-list': accordionList,
    				'accordion-opposite': accordionOpposite,
    				'contacts-list': contactsList,
    				'virtual-list': virtualList,
    				tab,
    				'tab-active': tabActive,
    				'no-hairlines': noHairlines,
    				'no-hairlines-md': noHairlinesMd,
    				'no-hairlines-ios': noHairlinesIos,
    				'no-hairlines-aurora': noHairlinesAurora,
    				'no-hairlines-between': noHairlinesBetween,
    				'no-hairlines-between-md': noHairlinesBetweenMd,
    				'no-hairlines-between-ios': noHairlinesBetweenIos,
    				'no-hairlines-between-aurora': noHairlinesBetweenAurora,
    				'form-store-data': formStoreData,
    				'inline-labels': inlineLabels,
    				'no-chevron': noChevron,
    				'chevron-center': chevronCenter
    			},
    			colorClasses($$props)
    		));
    	};

    	$$invalidate(5, hasUlSlots = $$slots.default || $$slots.list);
    	$$props = exclude_internal_props($$props);

    	return [
    		ul,
    		sortableMoveElements,
    		form,
    		el,
    		classes,
    		hasUlSlots,
    		onSubmit,
    		$$restProps,
    		className,
    		inset,
    		xsmallInset,
    		smallInset,
    		mediumInset,
    		largeInset,
    		xlargeInset,
    		mediaList,
    		sortable,
    		sortableTapHold,
    		sortableEnabled,
    		sortableOpposite,
    		accordionList,
    		accordionOpposite,
    		contactsList,
    		simpleList,
    		linksList,
    		menuList,
    		noHairlines,
    		noHairlinesBetween,
    		noHairlinesMd,
    		noHairlinesBetweenMd,
    		noHairlinesIos,
    		noHairlinesBetweenIos,
    		noHairlinesAurora,
    		noHairlinesBetweenAurora,
    		noChevron,
    		chevronCenter,
    		tab,
    		tabActive,
    		formStoreData,
    		inlineLabels,
    		virtualList,
    		virtualListParams,
    		virtualListInstance,
    		$$scope,
    		slots,
    		form_1_binding,
    		div_binding
    	];
    }

    class List extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$e,
    			create_fragment$f,
    			safe_not_equal,
    			{
    				class: 8,
    				ul: 0,
    				inset: 9,
    				xsmallInset: 10,
    				smallInset: 11,
    				mediumInset: 12,
    				largeInset: 13,
    				xlargeInset: 14,
    				mediaList: 15,
    				sortable: 16,
    				sortableTapHold: 17,
    				sortableEnabled: 18,
    				sortableMoveElements: 1,
    				sortableOpposite: 19,
    				accordionList: 20,
    				accordionOpposite: 21,
    				contactsList: 22,
    				simpleList: 23,
    				linksList: 24,
    				menuList: 25,
    				noHairlines: 26,
    				noHairlinesBetween: 27,
    				noHairlinesMd: 28,
    				noHairlinesBetweenMd: 29,
    				noHairlinesIos: 30,
    				noHairlinesBetweenIos: 31,
    				noHairlinesAurora: 32,
    				noHairlinesBetweenAurora: 33,
    				noChevron: 34,
    				chevronCenter: 35,
    				tab: 36,
    				tabActive: 37,
    				form: 2,
    				formStoreData: 38,
    				inlineLabels: 39,
    				virtualList: 40,
    				virtualListParams: 41,
    				virtualListInstance: 42
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get class() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ul() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ul(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inset() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inset(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xsmallInset() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xsmallInset(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smallInset() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smallInset(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mediumInset() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mediumInset(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get largeInset() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set largeInset(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xlargeInset() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xlargeInset(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mediaList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mediaList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortable() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortable(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortableTapHold() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortableTapHold(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortableEnabled() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortableEnabled(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortableMoveElements() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortableMoveElements(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortableOpposite() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortableOpposite(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accordionList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accordionList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accordionOpposite() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accordionOpposite(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get contactsList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contactsList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get simpleList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set simpleList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get linksList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set linksList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get menuList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set menuList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlines() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlines(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesBetween() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesBetween(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesMd() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesMd(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesBetweenMd() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesBetweenMd(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesIos() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesIos(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesBetweenIos() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesBetweenIos(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesAurora() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesAurora(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairlinesBetweenAurora() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairlinesBetweenAurora(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noChevron() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noChevron(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get chevronCenter() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set chevronCenter(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tab() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tab(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabActive() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabActive(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get form() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set form(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get formStoreData() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set formStoreData(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inlineLabels() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inlineLabels(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get virtualList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set virtualList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get virtualListParams() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set virtualListParams(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get virtualListInstance() {
    		return this.$$.ctx[42];
    	}

    	set virtualListInstance(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/nav-left.svelte generated by Svelte v3.44.0 */
    const file$b = "node_modules/framework7-svelte/esm/svelte/nav-left.svelte";

    // (46:2) {#if backLink}
    function create_if_block$6(ctx) {
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				href: /*backLinkUrl*/ ctx[1] || '#',
    				back: true,
    				icon: "icon-back",
    				force: /*backLinkForce*/ ctx[2] || undefined,
    				class: !/*backLinkText*/ ctx[3] ? 'icon-only' : undefined,
    				text: /*backLinkText*/ ctx[3],
    				onClick: /*onBackClick*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*backLinkUrl*/ 2) link_changes.href = /*backLinkUrl*/ ctx[1] || '#';
    			if (dirty & /*backLinkForce*/ 4) link_changes.force = /*backLinkForce*/ ctx[2] || undefined;
    			if (dirty & /*backLinkText*/ 8) link_changes.class = !/*backLinkText*/ ctx[3] ? 'icon-only' : undefined;
    			if (dirty & /*backLinkText*/ 8) link_changes.text = /*backLinkText*/ ctx[3];
    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(46:2) {#if backLink}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block = /*backLink*/ ctx[0] && create_if_block$6(ctx);
    	const default_slot_template = /*#slots*/ ctx[13].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
    	let div_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$b, 44, 0, 1102);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*backLink*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*backLink*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[12],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
    				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let classes;
    	let needBackLinkText;
    	let backLinkText;
    	const omit_props_names = ["class","backLink","backLinkUrl","backLinkForce","backLinkShowText","sliding"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Nav_left', slots, ['default']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { backLink = undefined } = $$props;
    	let { backLinkUrl = undefined } = $$props;
    	let { backLinkForce = undefined } = $$props;
    	let { backLinkShowText = undefined } = $$props;
    	let { sliding = undefined } = $$props;

    	let theme = useTheme(t => {
    		$$invalidate(10, theme = t);
    	});

    	function onBackClick() {
    		emit('clickBack');
    		emit('backClick');
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(7, className = $$new_props.class);
    		if ('backLink' in $$new_props) $$invalidate(0, backLink = $$new_props.backLink);
    		if ('backLinkUrl' in $$new_props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
    		if ('backLinkForce' in $$new_props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
    		if ('backLinkShowText' in $$new_props) $$invalidate(8, backLinkShowText = $$new_props.backLinkShowText);
    		if ('sliding' in $$new_props) $$invalidate(9, sliding = $$new_props.sliding);
    		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		colorClasses,
    		classNames,
    		createEmitter,
    		restProps,
    		useTheme,
    		Link,
    		emit,
    		className,
    		backLink,
    		backLinkUrl,
    		backLinkForce,
    		backLinkShowText,
    		sliding,
    		theme,
    		onBackClick,
    		needBackLinkText,
    		backLinkText,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(7, className = $$new_props.className);
    		if ('backLink' in $$props) $$invalidate(0, backLink = $$new_props.backLink);
    		if ('backLinkUrl' in $$props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
    		if ('backLinkForce' in $$props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
    		if ('backLinkShowText' in $$props) $$invalidate(8, backLinkShowText = $$new_props.backLinkShowText);
    		if ('sliding' in $$props) $$invalidate(9, sliding = $$new_props.sliding);
    		if ('theme' in $$props) $$invalidate(10, theme = $$new_props.theme);
    		if ('needBackLinkText' in $$props) $$invalidate(11, needBackLinkText = $$new_props.needBackLinkText);
    		if ('backLinkText' in $$props) $$invalidate(3, backLinkText = $$new_props.backLinkText);
    		if ('classes' in $$props) $$invalidate(4, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(4, classes = classNames(className, 'left', { sliding }, colorClasses($$props)));

    		if ($$self.$$.dirty & /*backLinkShowText*/ 256) {
    			$$invalidate(11, needBackLinkText = backLinkShowText);
    		}

    		if ($$self.$$.dirty & /*needBackLinkText, theme*/ 3072) {
    			if (typeof needBackLinkText === 'undefined') $$invalidate(11, needBackLinkText = theme && !theme.md);
    		}

    		if ($$self.$$.dirty & /*backLink, needBackLinkText*/ 2049) {
    			$$invalidate(3, backLinkText = backLink !== true && needBackLinkText
    			? backLink
    			: undefined);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		backLink,
    		backLinkUrl,
    		backLinkForce,
    		backLinkText,
    		classes,
    		onBackClick,
    		$$restProps,
    		className,
    		backLinkShowText,
    		sliding,
    		theme,
    		needBackLinkText,
    		$$scope,
    		slots
    	];
    }

    class Nav_left extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$d, create_fragment$e, safe_not_equal, {
    			class: 7,
    			backLink: 0,
    			backLinkUrl: 1,
    			backLinkForce: 2,
    			backLinkShowText: 8,
    			sliding: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nav_left",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get class() {
    		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLink() {
    		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLink(value) {
    		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLinkUrl() {
    		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLinkUrl(value) {
    		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLinkForce() {
    		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLinkForce(value) {
    		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLinkShowText() {
    		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLinkShowText(value) {
    		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sliding() {
    		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sliding(value) {
    		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/nav-right.svelte generated by Svelte v3.44.0 */
    const file$a = "node_modules/framework7-svelte/esm/svelte/nav-right.svelte";

    function create_fragment$d(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
    	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$a, 20, 0, 385);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
    				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","sliding"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Nav_right', slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { sliding = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('sliding' in $$new_props) $$invalidate(3, sliding = $$new_props.sliding);
    		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		colorClasses,
    		classNames,
    		restProps,
    		className,
    		sliding,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('sliding' in $$props) $$invalidate(3, sliding = $$new_props.sliding);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(0, classes = classNames(className, 'right', { sliding }, colorClasses($$props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [classes, $$restProps, className, sliding, $$scope, slots];
    }

    class Nav_right extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$d, safe_not_equal, { class: 2, sliding: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nav_right",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get class() {
    		throw new Error("<Nav_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Nav_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sliding() {
    		throw new Error("<Nav_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sliding(value) {
    		throw new Error("<Nav_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/nav-title.svelte generated by Svelte v3.44.0 */
    const file$9 = "node_modules/framework7-svelte/esm/svelte/nav-title.svelte";

    // (24:2) {#if typeof title !== 'undefined'}
    function create_if_block_1$3(ctx) {
    	let t_value = plainText(/*title*/ ctx[0]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 1 && t_value !== (t_value = plainText(/*title*/ ctx[0]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(24:2) {#if typeof title !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    // (25:2) {#if typeof subtitle !== 'undefined'}
    function create_if_block$5(ctx) {
    	let span;
    	let t_value = plainText(/*subtitle*/ ctx[1]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "subtitle");
    			add_location(span, file$9, 24, 39, 612);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*subtitle*/ 2 && t_value !== (t_value = plainText(/*subtitle*/ ctx[1]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(25:2) {#if typeof subtitle !== 'undefined'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let current;
    	let if_block0 = typeof /*title*/ ctx[0] !== 'undefined' && create_if_block_1$3(ctx);
    	let if_block1 = typeof /*subtitle*/ ctx[1] !== 'undefined' && create_if_block$5(ctx);
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	let div_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$9, 22, 0, 463);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (typeof /*title*/ ctx[0] !== 'undefined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (typeof /*subtitle*/ ctx[1] !== 'undefined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$5(ctx);
    					if_block1.c();
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
    				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","title","subtitle","sliding"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Nav_title', slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { title = undefined } = $$props;
    	let { subtitle = undefined } = $$props;
    	let { sliding = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ('title' in $$new_props) $$invalidate(0, title = $$new_props.title);
    		if ('subtitle' in $$new_props) $$invalidate(1, subtitle = $$new_props.subtitle);
    		if ('sliding' in $$new_props) $$invalidate(5, sliding = $$new_props.sliding);
    		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		colorClasses,
    		classNames,
    		plainText,
    		restProps,
    		className,
    		title,
    		subtitle,
    		sliding,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(4, className = $$new_props.className);
    		if ('title' in $$props) $$invalidate(0, title = $$new_props.title);
    		if ('subtitle' in $$props) $$invalidate(1, subtitle = $$new_props.subtitle);
    		if ('sliding' in $$props) $$invalidate(5, sliding = $$new_props.sliding);
    		if ('classes' in $$props) $$invalidate(2, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(2, classes = classNames(className, 'title', { sliding }, colorClasses($$props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [title, subtitle, classes, $$restProps, className, sliding, $$scope, slots];
    }

    class Nav_title extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$b, create_fragment$c, safe_not_equal, {
    			class: 4,
    			title: 0,
    			subtitle: 1,
    			sliding: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nav_title",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get class() {
    		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitle() {
    		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitle(value) {
    		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sliding() {
    		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sliding(value) {
    		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/navbar.svelte generated by Svelte v3.44.0 */
    const file$8 = "node_modules/framework7-svelte/esm/svelte/navbar.svelte";
    const get_after_inner_slot_changes$1 = dirty => ({});
    const get_after_inner_slot_context$1 = ctx => ({});
    const get_title_large_slot_changes = dirty => ({});
    const get_title_large_slot_context = ctx => ({});
    const get_right_slot_changes = dirty => ({});
    const get_right_slot_context = ctx => ({});
    const get_nav_right_slot_changes = dirty => ({});
    const get_nav_right_slot_context = ctx => ({});
    const get_title_slot_changes = dirty => ({});
    const get_title_slot_context = ctx => ({});
    const get_left_slot_changes = dirty => ({});
    const get_left_slot_context = ctx => ({});
    const get_nav_left_slot_changes = dirty => ({});
    const get_nav_left_slot_context = ctx => ({});
    const get_before_inner_slot_changes$1 = dirty => ({});
    const get_before_inner_slot_context$1 = ctx => ({});

    // (197:4) {#if backLink || hasLeftSlots}
    function create_if_block_3$2(ctx) {
    	let navleft;
    	let current;

    	navleft = new Nav_left({
    			props: {
    				backLink: /*backLink*/ ctx[0],
    				backLinkUrl: /*backLinkUrl*/ ctx[1],
    				backLinkForce: /*backLinkForce*/ ctx[2],
    				backLinkShowText: /*backLinkShowText*/ ctx[3],
    				onBackClick: /*onBackClick*/ ctx[15],
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navleft.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navleft, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navleft_changes = {};
    			if (dirty[0] & /*backLink*/ 1) navleft_changes.backLink = /*backLink*/ ctx[0];
    			if (dirty[0] & /*backLinkUrl*/ 2) navleft_changes.backLinkUrl = /*backLinkUrl*/ ctx[1];
    			if (dirty[0] & /*backLinkForce*/ 4) navleft_changes.backLinkForce = /*backLinkForce*/ ctx[2];
    			if (dirty[0] & /*backLinkShowText*/ 8) navleft_changes.backLinkShowText = /*backLinkShowText*/ ctx[3];

    			if (dirty[1] & /*$$scope*/ 16384) {
    				navleft_changes.$$scope = { dirty, ctx };
    			}

    			navleft.$set(navleft_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navleft.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navleft.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navleft, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(197:4) {#if backLink || hasLeftSlots}",
    		ctx
    	});

    	return block;
    }

    // (198:6) <NavLeft {backLink} {backLinkUrl} {backLinkForce} {backLinkShowText} {onBackClick}>
    function create_default_slot_2$3(ctx) {
    	let t;
    	let current;
    	const nav_left_slot_template = /*#slots*/ ctx[43]["nav-left"];
    	const nav_left_slot = create_slot(nav_left_slot_template, ctx, /*$$scope*/ ctx[45], get_nav_left_slot_context);
    	const left_slot_template = /*#slots*/ ctx[43].left;
    	const left_slot = create_slot(left_slot_template, ctx, /*$$scope*/ ctx[45], get_left_slot_context);

    	const block = {
    		c: function create() {
    			if (nav_left_slot) nav_left_slot.c();
    			t = space();
    			if (left_slot) left_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (nav_left_slot) {
    				nav_left_slot.m(target, anchor);
    			}

    			insert_dev(target, t, anchor);

    			if (left_slot) {
    				left_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (nav_left_slot) {
    				if (nav_left_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						nav_left_slot,
    						nav_left_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(nav_left_slot_template, /*$$scope*/ ctx[45], dirty, get_nav_left_slot_changes),
    						get_nav_left_slot_context
    					);
    				}
    			}

    			if (left_slot) {
    				if (left_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						left_slot,
    						left_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(left_slot_template, /*$$scope*/ ctx[45], dirty, get_left_slot_changes),
    						get_left_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nav_left_slot, local);
    			transition_in(left_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nav_left_slot, local);
    			transition_out(left_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (nav_left_slot) nav_left_slot.d(detaching);
    			if (detaching) detach_dev(t);
    			if (left_slot) left_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(198:6) <NavLeft {backLink} {backLinkUrl} {backLinkForce} {backLinkShowText} {onBackClick}>",
    		ctx
    	});

    	return block;
    }

    // (203:4) {#if title || subtitle || hasTitleSlots}
    function create_if_block_2$2(ctx) {
    	let navtitle;
    	let current;

    	navtitle = new Nav_title({
    			props: {
    				title: /*title*/ ctx[4],
    				subtitle: /*subtitle*/ ctx[5],
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navtitle.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navtitle, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navtitle_changes = {};
    			if (dirty[0] & /*title*/ 16) navtitle_changes.title = /*title*/ ctx[4];
    			if (dirty[0] & /*subtitle*/ 32) navtitle_changes.subtitle = /*subtitle*/ ctx[5];

    			if (dirty[1] & /*$$scope*/ 16384) {
    				navtitle_changes.$$scope = { dirty, ctx };
    			}

    			navtitle.$set(navtitle_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navtitle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navtitle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navtitle, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(203:4) {#if title || subtitle || hasTitleSlots}",
    		ctx
    	});

    	return block;
    }

    // (204:6) <NavTitle {title} {subtitle}>
    function create_default_slot_1$4(ctx) {
    	let current;
    	const title_slot_template = /*#slots*/ ctx[43].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[45], get_title_slot_context);

    	const block = {
    		c: function create() {
    			if (title_slot) title_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (title_slot) {
    				title_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (title_slot) {
    				if (title_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[45], dirty, get_title_slot_changes),
    						get_title_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(204:6) <NavTitle {title} {subtitle}>",
    		ctx
    	});

    	return block;
    }

    // (208:4) {#if hasRightSlots}
    function create_if_block_1$2(ctx) {
    	let navright;
    	let current;

    	navright = new Nav_right({
    			props: {
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navright.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navright, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navright_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				navright_changes.$$scope = { dirty, ctx };
    			}

    			navright.$set(navright_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navright.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navright.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navright, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(208:4) {#if hasRightSlots}",
    		ctx
    	});

    	return block;
    }

    // (209:6) <NavRight>
    function create_default_slot$7(ctx) {
    	let t;
    	let current;
    	const nav_right_slot_template = /*#slots*/ ctx[43]["nav-right"];
    	const nav_right_slot = create_slot(nav_right_slot_template, ctx, /*$$scope*/ ctx[45], get_nav_right_slot_context);
    	const right_slot_template = /*#slots*/ ctx[43].right;
    	const right_slot = create_slot(right_slot_template, ctx, /*$$scope*/ ctx[45], get_right_slot_context);

    	const block = {
    		c: function create() {
    			if (nav_right_slot) nav_right_slot.c();
    			t = space();
    			if (right_slot) right_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (nav_right_slot) {
    				nav_right_slot.m(target, anchor);
    			}

    			insert_dev(target, t, anchor);

    			if (right_slot) {
    				right_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (nav_right_slot) {
    				if (nav_right_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						nav_right_slot,
    						nav_right_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(nav_right_slot_template, /*$$scope*/ ctx[45], dirty, get_nav_right_slot_changes),
    						get_nav_right_slot_context
    					);
    				}
    			}

    			if (right_slot) {
    				if (right_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						right_slot,
    						right_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(right_slot_template, /*$$scope*/ ctx[45], dirty, get_right_slot_changes),
    						get_right_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nav_right_slot, local);
    			transition_in(right_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nav_right_slot, local);
    			transition_out(right_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (nav_right_slot) nav_right_slot.d(detaching);
    			if (detaching) detach_dev(t);
    			if (right_slot) right_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(209:6) <NavRight>",
    		ctx
    	});

    	return block;
    }

    // (214:4) {#if largeTitle || hasTitleLargeSlots}
    function create_if_block$4(ctx) {
    	let div1;
    	let div0;
    	let t0_value = plainText(/*largeTitle*/ ctx[11]) + "";
    	let t0;
    	let t1;
    	let current;
    	const title_large_slot_template = /*#slots*/ ctx[43]["title-large"];
    	const title_large_slot = create_slot(title_large_slot_template, ctx, /*$$scope*/ ctx[45], get_title_large_slot_context);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (title_large_slot) title_large_slot.c();
    			attr_dev(div0, "class", "title-large-text");
    			add_location(div0, file$8, 215, 8, 6820);
    			attr_dev(div1, "class", "title-large");
    			add_location(div1, file$8, 214, 6, 6786);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div0, t1);

    			if (title_large_slot) {
    				title_large_slot.m(div0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*largeTitle*/ 2048) && t0_value !== (t0_value = plainText(/*largeTitle*/ ctx[11]) + "")) set_data_dev(t0, t0_value);

    			if (title_large_slot) {
    				if (title_large_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						title_large_slot,
    						title_large_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(title_large_slot_template, /*$$scope*/ ctx[45], dirty, get_title_large_slot_changes),
    						get_title_large_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_large_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_large_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (title_large_slot) title_large_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(214:4) {#if largeTitle || hasTitleLargeSlots}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let current;
    	const before_inner_slot_template = /*#slots*/ ctx[43]["before-inner"];
    	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[45], get_before_inner_slot_context$1);
    	let if_block0 = (/*backLink*/ ctx[0] || /*hasLeftSlots*/ ctx[14]) && create_if_block_3$2(ctx);
    	let if_block1 = (/*title*/ ctx[4] || /*subtitle*/ ctx[5] || /*hasTitleSlots*/ ctx[12]) && create_if_block_2$2(ctx);
    	let if_block2 = /*hasRightSlots*/ ctx[13] && create_if_block_1$2(ctx);
    	let if_block3 = (/*largeTitle*/ ctx[11] || /*hasTitleLargeSlots*/ ctx[10]) && create_if_block$4(ctx);
    	const default_slot_template = /*#slots*/ ctx[43].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[45], null);
    	const after_inner_slot_template = /*#slots*/ ctx[43]["after-inner"];
    	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[45], get_after_inner_slot_context$1);

    	let div2_levels = [
    		{ class: /*classes*/ ctx[9] },
    		{ "data-f7-slot": /*f7Slot*/ ctx[6] },
    		restProps(/*$$restProps*/ ctx[16])
    	];

    	let div2_data = {};

    	for (let i = 0; i < div2_levels.length; i += 1) {
    		div2_data = assign(div2_data, div2_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();
    			if (before_inner_slot) before_inner_slot.c();
    			t1 = space();
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (default_slot) default_slot.c();
    			t6 = space();
    			if (after_inner_slot) after_inner_slot.c();
    			attr_dev(div0, "class", "navbar-bg");
    			add_location(div0, file$8, 193, 2, 6165);
    			attr_dev(div1, "class", /*innerClasses*/ ctx[8]);
    			add_location(div1, file$8, 195, 2, 6224);
    			set_attributes(div2, div2_data);
    			add_location(div2, file$8, 192, 0, 6076);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t0);

    			if (before_inner_slot) {
    				before_inner_slot.m(div2, null);
    			}

    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t2);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t3);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div1, t4);
    			if (if_block3) if_block3.m(div1, null);
    			append_dev(div1, t5);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			append_dev(div2, t6);

    			if (after_inner_slot) {
    				after_inner_slot.m(div2, null);
    			}

    			/*div2_binding*/ ctx[44](div2);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (before_inner_slot) {
    				if (before_inner_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						before_inner_slot,
    						before_inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(before_inner_slot_template, /*$$scope*/ ctx[45], dirty, get_before_inner_slot_changes$1),
    						get_before_inner_slot_context$1
    					);
    				}
    			}

    			if (/*backLink*/ ctx[0] || /*hasLeftSlots*/ ctx[14]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*backLink, hasLeftSlots*/ 16385) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*title*/ ctx[4] || /*subtitle*/ ctx[5] || /*hasTitleSlots*/ ctx[12]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*title, subtitle, hasTitleSlots*/ 4144) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*hasRightSlots*/ ctx[13]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*hasRightSlots*/ 8192) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$2(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div1, t4);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*largeTitle*/ ctx[11] || /*hasTitleLargeSlots*/ ctx[10]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*largeTitle, hasTitleLargeSlots*/ 3072) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block$4(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div1, t5);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[45], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty[0] & /*innerClasses*/ 256) {
    				attr_dev(div1, "class", /*innerClasses*/ ctx[8]);
    			}

    			if (after_inner_slot) {
    				if (after_inner_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						after_inner_slot,
    						after_inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(after_inner_slot_template, /*$$scope*/ ctx[45], dirty, get_after_inner_slot_changes$1),
    						get_after_inner_slot_context$1
    					);
    				}
    			}

    			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
    				(!current || dirty[0] & /*classes*/ 512) && { class: /*classes*/ ctx[9] },
    				(!current || dirty[0] & /*f7Slot*/ 64) && { "data-f7-slot": /*f7Slot*/ ctx[6] },
    				dirty[0] & /*$$restProps*/ 65536 && restProps(/*$$restProps*/ ctx[16])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_inner_slot, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(default_slot, local);
    			transition_in(after_inner_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_inner_slot, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(default_slot, local);
    			transition_out(after_inner_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (before_inner_slot) before_inner_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (default_slot) default_slot.d(detaching);
    			if (after_inner_slot) after_inner_slot.d(detaching);
    			/*div2_binding*/ ctx[44](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let hasLeftSlots;
    	let hasRightSlots;
    	let hasTitleSlots;
    	let largeTitle;
    	let hasTitleLargeSlots;
    	let addLeftTitleClass;
    	let addCenterTitleClass;
    	let isLarge;
    	let isTransparent;
    	let isTransparentVisible;
    	let classes;
    	let innerClasses;

    	const omit_props_names = [
    		"class","backLink","backLinkUrl","backLinkForce","backLinkShowText","sliding","title","subtitle","hidden","noShadow","noHairline","innerClass","innerClassName","large","largeTransparent","transparent","titleLarge","f7Slot","hide","show","size"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;

    	validate_slots('Navbar', slots, [
    		'before-inner','nav-left','left','title','nav-right','right','title-large','default','after-inner'
    	]);

    	const $$slots = compute_slots(slots);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { backLink = undefined } = $$props;
    	let { backLinkUrl = undefined } = $$props;
    	let { backLinkForce = false } = $$props;
    	let { backLinkShowText = undefined } = $$props;
    	let { sliding = true } = $$props;
    	let { title = undefined } = $$props;
    	let { subtitle = undefined } = $$props;
    	let { hidden = false } = $$props;
    	let { noShadow = false } = $$props;
    	let { noHairline = false } = $$props;
    	let { innerClass = undefined } = $$props;
    	let { innerClassName = undefined } = $$props;
    	let { large = false } = $$props;
    	let { largeTransparent = false } = $$props;
    	let { transparent = false } = $$props;
    	let { titleLarge = undefined } = $$props;
    	let { f7Slot = 'fixed' } = $$props;
    	let el;

    	let theme = useTheme(t => {
    		$$invalidate(31, theme = t);
    	});

    	let routerPositionClass = '';
    	let largeCollapsed = false;
    	let routerNavbarRole = null;
    	let routerNavbarRoleDetailRoot = false;
    	let routerNavbarMasterStack = false;
    	let transparentVisible = false;

    	function hide(animate) {
    		app$1.f7.navbar.hide(el, animate);
    	}

    	function show(animate) {
    		app$1.f7.navbar.show(el, animate);
    	}

    	function size() {
    		app$1.f7.navbar.size(el);
    	}

    	function onHide(navbarEl) {
    		if (el !== navbarEl) return;
    		emit('navbarHide');
    	}

    	function onShow(navbarEl) {
    		if (el !== navbarEl) return;
    		emit('navbarShow');
    	}

    	function onNavbarTransparentShow(navbarEl) {
    		if (el !== navbarEl) return;
    		$$invalidate(37, transparentVisible = true);
    		emit('navbarTransparentShow');
    	}

    	function onNavbarTransparentHide(navbarEl) {
    		if (el !== navbarEl) return;
    		$$invalidate(37, transparentVisible = false);
    		emit('navbarTransparentHide');
    	}

    	function onExpand(navbarEl) {
    		if (el !== navbarEl) return;
    		$$invalidate(33, largeCollapsed = false);
    		emit('navbarExpand');
    	}

    	function onCollapse(navbarEl) {
    		if (el !== navbarEl) return;
    		$$invalidate(33, largeCollapsed = true);
    		emit('navbarCollapse');
    	}

    	function onNavbarPosition(navbarEl, position) {
    		if (el !== navbarEl) return;
    		$$invalidate(32, routerPositionClass = position ? `navbar-${position}` : position);
    	}

    	function onNavbarRole(navbarEl, rolesData) {
    		if (el !== navbarEl) return;
    		$$invalidate(34, routerNavbarRole = rolesData.role);
    		$$invalidate(35, routerNavbarRoleDetailRoot = rolesData.detailRoot);
    	}

    	function onNavbarMasterStack(navbarEl) {
    		if (el !== navbarEl) return;
    		$$invalidate(36, routerNavbarMasterStack = true);
    	}

    	function onNavbarMasterUnstack(navbarEl) {
    		if (el !== navbarEl) return;
    		$$invalidate(36, routerNavbarMasterStack = false);
    	}

    	function onBackClick() {
    		emit('clickBack');
    	}

    	function mountNavbar() {
    		app$1.f7.on('navbarShow', onShow);
    		app$1.f7.on('navbarHide', onHide);
    		app$1.f7.on('navbarCollapse', onCollapse);
    		app$1.f7.on('navbarExpand', onExpand);
    		app$1.f7.on('navbarPosition', onNavbarPosition);
    		app$1.f7.on('navbarRole', onNavbarRole);
    		app$1.f7.on('navbarMasterStack', onNavbarMasterStack);
    		app$1.f7.on('navbarMasterUnstack', onNavbarMasterUnstack);
    		app$1.f7.on('navbarTransparentShow', onNavbarTransparentShow);
    		app$1.f7.on('navbarTransparentHide', onNavbarTransparentHide);
    	}

    	function destroyNavbar() {
    		app$1.f7.off('navbarShow', onShow);
    		app$1.f7.off('navbarHide', onHide);
    		app$1.f7.off('navbarCollapse', onCollapse);
    		app$1.f7.off('navbarExpand', onExpand);
    		app$1.f7.off('navbarPosition', onNavbarPosition);
    		app$1.f7.off('navbarRole', onNavbarRole);
    		app$1.f7.off('navbarMasterStack', onNavbarMasterStack);
    		app$1.f7.off('navbarMasterUnstack', onNavbarMasterUnstack);
    		app$1.f7.off('navbarTransparentShow', onNavbarTransparentShow);
    		app$1.f7.off('navbarTransparentHide', onNavbarTransparentHide);
    	}

    	onMount(() => {
    		f7ready(() => {
    			mountNavbar();
    		});
    	});

    	afterUpdate(() => {
    		if (!app$1.f7) return;
    		app$1.f7.navbar.size(el);
    	});

    	onDestroy(() => {
    		if (!app$1.f7) return;
    		destroyNavbar();
    	});

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(7, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(59, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(17, className = $$new_props.class);
    		if ('backLink' in $$new_props) $$invalidate(0, backLink = $$new_props.backLink);
    		if ('backLinkUrl' in $$new_props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
    		if ('backLinkForce' in $$new_props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
    		if ('backLinkShowText' in $$new_props) $$invalidate(3, backLinkShowText = $$new_props.backLinkShowText);
    		if ('sliding' in $$new_props) $$invalidate(18, sliding = $$new_props.sliding);
    		if ('title' in $$new_props) $$invalidate(4, title = $$new_props.title);
    		if ('subtitle' in $$new_props) $$invalidate(5, subtitle = $$new_props.subtitle);
    		if ('hidden' in $$new_props) $$invalidate(19, hidden = $$new_props.hidden);
    		if ('noShadow' in $$new_props) $$invalidate(20, noShadow = $$new_props.noShadow);
    		if ('noHairline' in $$new_props) $$invalidate(21, noHairline = $$new_props.noHairline);
    		if ('innerClass' in $$new_props) $$invalidate(22, innerClass = $$new_props.innerClass);
    		if ('innerClassName' in $$new_props) $$invalidate(23, innerClassName = $$new_props.innerClassName);
    		if ('large' in $$new_props) $$invalidate(24, large = $$new_props.large);
    		if ('largeTransparent' in $$new_props) $$invalidate(25, largeTransparent = $$new_props.largeTransparent);
    		if ('transparent' in $$new_props) $$invalidate(26, transparent = $$new_props.transparent);
    		if ('titleLarge' in $$new_props) $$invalidate(27, titleLarge = $$new_props.titleLarge);
    		if ('f7Slot' in $$new_props) $$invalidate(6, f7Slot = $$new_props.f7Slot);
    		if ('$$scope' in $$new_props) $$invalidate(45, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		afterUpdate,
    		colorClasses,
    		classNames,
    		plainText,
    		createEmitter,
    		restProps,
    		f7ready,
    		app: app$1,
    		useTheme,
    		NavLeft: Nav_left,
    		NavTitle: Nav_title,
    		NavRight: Nav_right,
    		emit,
    		className,
    		backLink,
    		backLinkUrl,
    		backLinkForce,
    		backLinkShowText,
    		sliding,
    		title,
    		subtitle,
    		hidden,
    		noShadow,
    		noHairline,
    		innerClass,
    		innerClassName,
    		large,
    		largeTransparent,
    		transparent,
    		titleLarge,
    		f7Slot,
    		el,
    		theme,
    		routerPositionClass,
    		largeCollapsed,
    		routerNavbarRole,
    		routerNavbarRoleDetailRoot,
    		routerNavbarMasterStack,
    		transparentVisible,
    		hide,
    		show,
    		size,
    		onHide,
    		onShow,
    		onNavbarTransparentShow,
    		onNavbarTransparentHide,
    		onExpand,
    		onCollapse,
    		onNavbarPosition,
    		onNavbarRole,
    		onNavbarMasterStack,
    		onNavbarMasterUnstack,
    		onBackClick,
    		mountNavbar,
    		destroyNavbar,
    		addCenterTitleClass,
    		addLeftTitleClass,
    		innerClasses,
    		isTransparentVisible,
    		isTransparent,
    		isLarge,
    		classes,
    		hasTitleLargeSlots,
    		largeTitle,
    		hasTitleSlots,
    		hasRightSlots,
    		hasLeftSlots
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(59, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(17, className = $$new_props.className);
    		if ('backLink' in $$props) $$invalidate(0, backLink = $$new_props.backLink);
    		if ('backLinkUrl' in $$props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
    		if ('backLinkForce' in $$props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
    		if ('backLinkShowText' in $$props) $$invalidate(3, backLinkShowText = $$new_props.backLinkShowText);
    		if ('sliding' in $$props) $$invalidate(18, sliding = $$new_props.sliding);
    		if ('title' in $$props) $$invalidate(4, title = $$new_props.title);
    		if ('subtitle' in $$props) $$invalidate(5, subtitle = $$new_props.subtitle);
    		if ('hidden' in $$props) $$invalidate(19, hidden = $$new_props.hidden);
    		if ('noShadow' in $$props) $$invalidate(20, noShadow = $$new_props.noShadow);
    		if ('noHairline' in $$props) $$invalidate(21, noHairline = $$new_props.noHairline);
    		if ('innerClass' in $$props) $$invalidate(22, innerClass = $$new_props.innerClass);
    		if ('innerClassName' in $$props) $$invalidate(23, innerClassName = $$new_props.innerClassName);
    		if ('large' in $$props) $$invalidate(24, large = $$new_props.large);
    		if ('largeTransparent' in $$props) $$invalidate(25, largeTransparent = $$new_props.largeTransparent);
    		if ('transparent' in $$props) $$invalidate(26, transparent = $$new_props.transparent);
    		if ('titleLarge' in $$props) $$invalidate(27, titleLarge = $$new_props.titleLarge);
    		if ('f7Slot' in $$props) $$invalidate(6, f7Slot = $$new_props.f7Slot);
    		if ('el' in $$props) $$invalidate(7, el = $$new_props.el);
    		if ('theme' in $$props) $$invalidate(31, theme = $$new_props.theme);
    		if ('routerPositionClass' in $$props) $$invalidate(32, routerPositionClass = $$new_props.routerPositionClass);
    		if ('largeCollapsed' in $$props) $$invalidate(33, largeCollapsed = $$new_props.largeCollapsed);
    		if ('routerNavbarRole' in $$props) $$invalidate(34, routerNavbarRole = $$new_props.routerNavbarRole);
    		if ('routerNavbarRoleDetailRoot' in $$props) $$invalidate(35, routerNavbarRoleDetailRoot = $$new_props.routerNavbarRoleDetailRoot);
    		if ('routerNavbarMasterStack' in $$props) $$invalidate(36, routerNavbarMasterStack = $$new_props.routerNavbarMasterStack);
    		if ('transparentVisible' in $$props) $$invalidate(37, transparentVisible = $$new_props.transparentVisible);
    		if ('addCenterTitleClass' in $$props) $$invalidate(38, addCenterTitleClass = $$new_props.addCenterTitleClass);
    		if ('addLeftTitleClass' in $$props) $$invalidate(39, addLeftTitleClass = $$new_props.addLeftTitleClass);
    		if ('innerClasses' in $$props) $$invalidate(8, innerClasses = $$new_props.innerClasses);
    		if ('isTransparentVisible' in $$props) $$invalidate(40, isTransparentVisible = $$new_props.isTransparentVisible);
    		if ('isTransparent' in $$props) $$invalidate(41, isTransparent = $$new_props.isTransparent);
    		if ('isLarge' in $$props) $$invalidate(42, isLarge = $$new_props.isLarge);
    		if ('classes' in $$props) $$invalidate(9, classes = $$new_props.classes);
    		if ('hasTitleLargeSlots' in $$props) $$invalidate(10, hasTitleLargeSlots = $$new_props.hasTitleLargeSlots);
    		if ('largeTitle' in $$props) $$invalidate(11, largeTitle = $$new_props.largeTitle);
    		if ('hasTitleSlots' in $$props) $$invalidate(12, hasTitleSlots = $$new_props.hasTitleSlots);
    		if ('hasRightSlots' in $$props) $$invalidate(13, hasRightSlots = $$new_props.hasRightSlots);
    		if ('hasLeftSlots' in $$props) $$invalidate(14, hasLeftSlots = $$new_props.hasLeftSlots);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*titleLarge, large, title*/ 150994960) {
    			$$invalidate(11, largeTitle = titleLarge || large && title);
    		}

    		if ($$self.$$.dirty[1] & /*theme*/ 1) {
    			$$invalidate(39, addLeftTitleClass = theme && theme.ios && app$1.f7 && !app$1.f7.params.navbar.iosCenterTitle);
    		}

    		if ($$self.$$.dirty[1] & /*theme*/ 1) {
    			$$invalidate(38, addCenterTitleClass = theme && theme.md && app$1.f7 && app$1.f7.params.navbar.mdCenterTitle || theme && theme.aurora && app$1.f7 && app$1.f7.params.navbar.auroraCenterTitle);
    		}

    		if ($$self.$$.dirty[0] & /*large, largeTransparent*/ 50331648) {
    			$$invalidate(42, isLarge = large || largeTransparent);
    		}

    		if ($$self.$$.dirty[0] & /*transparent, largeTransparent*/ 100663296 | $$self.$$.dirty[1] & /*isLarge*/ 2048) {
    			$$invalidate(41, isTransparent = transparent || isLarge && largeTransparent);
    		}

    		if ($$self.$$.dirty[1] & /*isTransparent, transparentVisible*/ 1088) {
    			$$invalidate(40, isTransparentVisible = isTransparent && transparentVisible);
    		}

    		$$invalidate(9, classes = classNames(
    			className,
    			'navbar',
    			routerPositionClass,
    			{
    				'navbar-hidden': hidden,
    				'navbar-large': isLarge,
    				'navbar-large-collapsed': isLarge && largeCollapsed,
    				'navbar-transparent': isTransparent,
    				'navbar-transparent-visible': isTransparentVisible,
    				'navbar-master': routerNavbarRole === 'master',
    				'navbar-master-detail': routerNavbarRole === 'detail',
    				'navbar-master-detail-root': routerNavbarRoleDetailRoot === true,
    				'navbar-master-stacked': routerNavbarMasterStack === true,
    				'no-shadow': noShadow,
    				'no-hairline': noHairline
    			},
    			colorClasses($$props)
    		));

    		if ($$self.$$.dirty[0] & /*innerClass, innerClassName, sliding*/ 12845056 | $$self.$$.dirty[1] & /*addLeftTitleClass, addCenterTitleClass*/ 384) {
    			$$invalidate(8, innerClasses = classNames('navbar-inner', innerClass, innerClassName, {
    				sliding,
    				'navbar-inner-left-title': addLeftTitleClass,
    				'navbar-inner-centered-title': addCenterTitleClass
    			}));
    		}
    	};

    	$$invalidate(14, hasLeftSlots = $$slots['nav-left'] || $$slots['left']);

    	// eslint-disable-next-line
    	$$invalidate(13, hasRightSlots = $$slots['nav-right'] || $$slots['right']);

    	// eslint-disable-next-line
    	$$invalidate(12, hasTitleSlots = $$slots['title']);

    	// eslint-disable-next-line
    	$$invalidate(10, hasTitleLargeSlots = $$slots['title-large']);

    	$$props = exclude_internal_props($$props);

    	return [
    		backLink,
    		backLinkUrl,
    		backLinkForce,
    		backLinkShowText,
    		title,
    		subtitle,
    		f7Slot,
    		el,
    		innerClasses,
    		classes,
    		hasTitleLargeSlots,
    		largeTitle,
    		hasTitleSlots,
    		hasRightSlots,
    		hasLeftSlots,
    		onBackClick,
    		$$restProps,
    		className,
    		sliding,
    		hidden,
    		noShadow,
    		noHairline,
    		innerClass,
    		innerClassName,
    		large,
    		largeTransparent,
    		transparent,
    		titleLarge,
    		hide,
    		show,
    		size,
    		theme,
    		routerPositionClass,
    		largeCollapsed,
    		routerNavbarRole,
    		routerNavbarRoleDetailRoot,
    		routerNavbarMasterStack,
    		transparentVisible,
    		addCenterTitleClass,
    		addLeftTitleClass,
    		isTransparentVisible,
    		isTransparent,
    		isLarge,
    		slots,
    		div2_binding,
    		$$scope
    	];
    }

    class Navbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$a,
    			create_fragment$b,
    			safe_not_equal,
    			{
    				class: 17,
    				backLink: 0,
    				backLinkUrl: 1,
    				backLinkForce: 2,
    				backLinkShowText: 3,
    				sliding: 18,
    				title: 4,
    				subtitle: 5,
    				hidden: 19,
    				noShadow: 20,
    				noHairline: 21,
    				innerClass: 22,
    				innerClassName: 23,
    				large: 24,
    				largeTransparent: 25,
    				transparent: 26,
    				titleLarge: 27,
    				f7Slot: 6,
    				hide: 28,
    				show: 29,
    				size: 30
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navbar",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get class() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLink() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLink(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLinkUrl() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLinkUrl(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLinkForce() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLinkForce(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backLinkShowText() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backLinkShowText(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sliding() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sliding(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitle() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitle(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hidden() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hidden(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noShadow() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noShadow(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairline() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairline(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get innerClass() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set innerClass(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get innerClassName() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set innerClassName(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get large() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set large(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get largeTransparent() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set largeTransparent(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transparent() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transparent(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get titleLarge() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titleLarge(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get f7Slot() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set f7Slot(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hide() {
    		return this.$$.ctx[28];
    	}

    	set hide(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get show() {
    		return this.$$.ctx[29];
    	}

    	set show(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		return this.$$.ctx[30];
    	}

    	set size(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/page-content.svelte generated by Svelte v3.44.0 */
    const file$7 = "node_modules/framework7-svelte/esm/svelte/page-content.svelte";

    // (125:2) {#if ptr && ptrPreloader && !ptrBottom}
    function create_if_block_3$1(ctx) {
    	let div1;
    	let preloader;
    	let t;
    	let div0;
    	let current;
    	preloader = new Preloader({ $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(preloader.$$.fragment);
    			t = space();
    			div0 = element("div");
    			attr_dev(div0, "class", "ptr-arrow");
    			add_location(div0, file$7, 127, 6, 3529);
    			attr_dev(div1, "class", "ptr-preloader");
    			add_location(div1, file$7, 125, 4, 3475);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(preloader, div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(preloader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(preloader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(preloader);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(125:2) {#if ptr && ptrPreloader && !ptrBottom}",
    		ctx
    	});

    	return block;
    }

    // (131:2) {#if infinite && infiniteTop && infinitePreloader}
    function create_if_block_2$1(ctx) {
    	let preloader;
    	let current;

    	preloader = new Preloader({
    			props: { class: "infinite-scroll-preloader" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(preloader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(preloader, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(preloader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(preloader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(preloader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(131:2) {#if infinite && infiniteTop && infinitePreloader}",
    		ctx
    	});

    	return block;
    }

    // (135:2) {#if infinite && !infiniteTop && infinitePreloader}
    function create_if_block_1$1(ctx) {
    	let preloader;
    	let current;

    	preloader = new Preloader({
    			props: { class: "infinite-scroll-preloader" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(preloader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(preloader, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(preloader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(preloader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(preloader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(135:2) {#if infinite && !infiniteTop && infinitePreloader}",
    		ctx
    	});

    	return block;
    }

    // (138:2) {#if ptr && ptrPreloader && ptrBottom}
    function create_if_block$3(ctx) {
    	let div1;
    	let preloader;
    	let t;
    	let div0;
    	let current;
    	preloader = new Preloader({ $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(preloader.$$.fragment);
    			t = space();
    			div0 = element("div");
    			attr_dev(div0, "class", "ptr-arrow");
    			add_location(div0, file$7, 140, 6, 3911);
    			attr_dev(div1, "class", "ptr-preloader");
    			add_location(div1, file$7, 138, 4, 3857);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(preloader, div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(preloader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(preloader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(preloader);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(138:2) {#if ptr && ptrPreloader && ptrBottom}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let div_data_ptr_mousewheel_value;
    	let div_data_infinite_distance_value;
    	let current;
    	let if_block0 = /*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && !/*ptrBottom*/ ctx[3] && create_if_block_3$1(ctx);
    	let if_block1 = /*infinite*/ ctx[5] && /*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8] && create_if_block_2$1(ctx);
    	const default_slot_template = /*#slots*/ ctx[21].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
    	let if_block2 = /*infinite*/ ctx[5] && !/*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8] && create_if_block_1$1(ctx);
    	let if_block3 = /*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && /*ptrBottom*/ ctx[3] && create_if_block$3(ctx);

    	let div_levels = [
    		{ class: /*pageContentClasses*/ ctx[10] },
    		{
    			"data-ptr-distance": /*ptrDistance*/ ctx[1]
    		},
    		{
    			"data-ptr-mousewheel": div_data_ptr_mousewheel_value = /*ptrMousewheel*/ ctx[4] || undefined
    		},
    		{
    			"data-infinite-distance": div_data_infinite_distance_value = /*infiniteDistance*/ ctx[7] || undefined
    		},
    		restProps(/*$$restProps*/ ctx[11])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			set_attributes(div, div_data);
    			add_location(div, file$7, 116, 0, 3193);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t2);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t3);
    			if (if_block3) if_block3.m(div, null);
    			/*div_binding*/ ctx[22](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && !/*ptrBottom*/ ctx[3]) {
    				if (if_block0) {
    					if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/ 13) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*infinite*/ ctx[5] && /*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8]) {
    				if (if_block1) {
    					if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/ 352) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1048576)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[20],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*infinite*/ ctx[5] && !/*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8]) {
    				if (if_block2) {
    					if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/ 352) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && /*ptrBottom*/ ctx[3]) {
    				if (if_block3) {
    					if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/ 13) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block$3(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty[0] & /*pageContentClasses*/ 1024) && { class: /*pageContentClasses*/ ctx[10] },
    				(!current || dirty[0] & /*ptrDistance*/ 2) && {
    					"data-ptr-distance": /*ptrDistance*/ ctx[1]
    				},
    				(!current || dirty[0] & /*ptrMousewheel*/ 16 && div_data_ptr_mousewheel_value !== (div_data_ptr_mousewheel_value = /*ptrMousewheel*/ ctx[4] || undefined)) && {
    					"data-ptr-mousewheel": div_data_ptr_mousewheel_value
    				},
    				(!current || dirty[0] & /*infiniteDistance*/ 128 && div_data_infinite_distance_value !== (div_data_infinite_distance_value = /*infiniteDistance*/ ctx[7] || undefined)) && {
    					"data-infinite-distance": div_data_infinite_distance_value
    				},
    				dirty[0] & /*$$restProps*/ 2048 && restProps(/*$$restProps*/ ctx[11])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(default_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(default_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			/*div_binding*/ ctx[22](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let pageContentClasses;

    	const omit_props_names = [
    		"tab","tabActive","ptr","ptrDistance","ptrPreloader","ptrBottom","ptrMousewheel","infinite","infiniteTop","infiniteDistance","infinitePreloader","hideBarsOnScroll","hideNavbarOnScroll","hideToolbarOnScroll","messagesContent","loginScreen","class"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Page_content', slots, ['default']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { tab = false } = $$props;
    	let { tabActive = false } = $$props;
    	let { ptr = false } = $$props;
    	let { ptrDistance = undefined } = $$props;
    	let { ptrPreloader = true } = $$props;
    	let { ptrBottom = false } = $$props;
    	let { ptrMousewheel = false } = $$props;
    	let { infinite = false } = $$props;
    	let { infiniteTop = false } = $$props;
    	let { infiniteDistance = undefined } = $$props;
    	let { infinitePreloader = true } = $$props;
    	let { hideBarsOnScroll = false } = $$props;
    	let { hideNavbarOnScroll = false } = $$props;
    	let { hideToolbarOnScroll = false } = $$props;
    	let { messagesContent = false } = $$props;
    	let { loginScreen = false } = $$props;
    	let { class: className = undefined } = $$props;
    	let pageContentEl;

    	// Event handlers
    	function onPtrPullStart(ptrEl) {
    		if (ptrEl !== pageContentEl) return;
    		emit('ptrPullStart');
    	}

    	function onPtrPullMove(ptrEl) {
    		if (ptrEl !== pageContentEl) return;
    		emit('ptrPullMove');
    	}

    	function onPtrPullEnd(ptrEl) {
    		if (ptrEl !== pageContentEl) return;
    		emit('ptrPullEnd');
    	}

    	function onPtrRefresh(ptrEl, done) {
    		if (ptrEl !== pageContentEl) return;
    		emit('ptrRefresh', [done]);
    	}

    	function onPtrDone(ptrEl) {
    		if (ptrEl !== pageContentEl) return;
    		emit('ptrDone');
    	}

    	function onInfinite(infEl) {
    		if (infEl !== pageContentEl) return;
    		emit('infinite');
    	}

    	function mountPageContent() {
    		if (ptr) {
    			app$1.f7.on('ptrPullStart', onPtrPullStart);
    			app$1.f7.on('ptrPullMove', onPtrPullMove);
    			app$1.f7.on('ptrPullEnd', onPtrPullEnd);
    			app$1.f7.on('ptrRefresh', onPtrRefresh);
    			app$1.f7.on('ptrDone', onPtrDone);
    		}

    		if (infinite) {
    			app$1.f7.on('infinite', onInfinite);
    		}
    	}

    	function destroyPageContent() {
    		if (ptr) {
    			app$1.f7.off('ptrPullStart', onPtrPullStart);
    			app$1.f7.off('ptrPullMove', onPtrPullMove);
    			app$1.f7.off('ptrPullEnd', onPtrPullEnd);
    			app$1.f7.off('ptrRefresh', onPtrRefresh);
    			app$1.f7.off('ptrDone', onPtrDone);
    		}

    		if (infinite) {
    			app$1.f7.off('infinite', onInfinite);
    		}
    	}

    	useTab(() => pageContentEl, emit);

    	onMount(() => {
    		f7ready(() => {
    			mountPageContent();
    		});
    	});

    	onDestroy(() => {
    		if (!app$1.f7) return;
    		destroyPageContent();
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			pageContentEl = $$value;
    			$$invalidate(9, pageContentEl);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('tab' in $$new_props) $$invalidate(12, tab = $$new_props.tab);
    		if ('tabActive' in $$new_props) $$invalidate(13, tabActive = $$new_props.tabActive);
    		if ('ptr' in $$new_props) $$invalidate(0, ptr = $$new_props.ptr);
    		if ('ptrDistance' in $$new_props) $$invalidate(1, ptrDistance = $$new_props.ptrDistance);
    		if ('ptrPreloader' in $$new_props) $$invalidate(2, ptrPreloader = $$new_props.ptrPreloader);
    		if ('ptrBottom' in $$new_props) $$invalidate(3, ptrBottom = $$new_props.ptrBottom);
    		if ('ptrMousewheel' in $$new_props) $$invalidate(4, ptrMousewheel = $$new_props.ptrMousewheel);
    		if ('infinite' in $$new_props) $$invalidate(5, infinite = $$new_props.infinite);
    		if ('infiniteTop' in $$new_props) $$invalidate(6, infiniteTop = $$new_props.infiniteTop);
    		if ('infiniteDistance' in $$new_props) $$invalidate(7, infiniteDistance = $$new_props.infiniteDistance);
    		if ('infinitePreloader' in $$new_props) $$invalidate(8, infinitePreloader = $$new_props.infinitePreloader);
    		if ('hideBarsOnScroll' in $$new_props) $$invalidate(14, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
    		if ('hideNavbarOnScroll' in $$new_props) $$invalidate(15, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
    		if ('hideToolbarOnScroll' in $$new_props) $$invalidate(16, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
    		if ('messagesContent' in $$new_props) $$invalidate(17, messagesContent = $$new_props.messagesContent);
    		if ('loginScreen' in $$new_props) $$invalidate(18, loginScreen = $$new_props.loginScreen);
    		if ('class' in $$new_props) $$invalidate(19, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		createEventDispatcher,
    		restProps,
    		colorClasses,
    		classNames,
    		createEmitter,
    		app: app$1,
    		f7ready,
    		useTab,
    		Preloader,
    		emit,
    		tab,
    		tabActive,
    		ptr,
    		ptrDistance,
    		ptrPreloader,
    		ptrBottom,
    		ptrMousewheel,
    		infinite,
    		infiniteTop,
    		infiniteDistance,
    		infinitePreloader,
    		hideBarsOnScroll,
    		hideNavbarOnScroll,
    		hideToolbarOnScroll,
    		messagesContent,
    		loginScreen,
    		className,
    		pageContentEl,
    		onPtrPullStart,
    		onPtrPullMove,
    		onPtrPullEnd,
    		onPtrRefresh,
    		onPtrDone,
    		onInfinite,
    		mountPageContent,
    		destroyPageContent,
    		pageContentClasses
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
    		if ('tab' in $$props) $$invalidate(12, tab = $$new_props.tab);
    		if ('tabActive' in $$props) $$invalidate(13, tabActive = $$new_props.tabActive);
    		if ('ptr' in $$props) $$invalidate(0, ptr = $$new_props.ptr);
    		if ('ptrDistance' in $$props) $$invalidate(1, ptrDistance = $$new_props.ptrDistance);
    		if ('ptrPreloader' in $$props) $$invalidate(2, ptrPreloader = $$new_props.ptrPreloader);
    		if ('ptrBottom' in $$props) $$invalidate(3, ptrBottom = $$new_props.ptrBottom);
    		if ('ptrMousewheel' in $$props) $$invalidate(4, ptrMousewheel = $$new_props.ptrMousewheel);
    		if ('infinite' in $$props) $$invalidate(5, infinite = $$new_props.infinite);
    		if ('infiniteTop' in $$props) $$invalidate(6, infiniteTop = $$new_props.infiniteTop);
    		if ('infiniteDistance' in $$props) $$invalidate(7, infiniteDistance = $$new_props.infiniteDistance);
    		if ('infinitePreloader' in $$props) $$invalidate(8, infinitePreloader = $$new_props.infinitePreloader);
    		if ('hideBarsOnScroll' in $$props) $$invalidate(14, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
    		if ('hideNavbarOnScroll' in $$props) $$invalidate(15, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
    		if ('hideToolbarOnScroll' in $$props) $$invalidate(16, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
    		if ('messagesContent' in $$props) $$invalidate(17, messagesContent = $$new_props.messagesContent);
    		if ('loginScreen' in $$props) $$invalidate(18, loginScreen = $$new_props.loginScreen);
    		if ('className' in $$props) $$invalidate(19, className = $$new_props.className);
    		if ('pageContentEl' in $$props) $$invalidate(9, pageContentEl = $$new_props.pageContentEl);
    		if ('pageContentClasses' in $$props) $$invalidate(10, pageContentClasses = $$new_props.pageContentClasses);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(10, pageContentClasses = classNames(
    			className,
    			'page-content',
    			{
    				tab,
    				'tab-active': tabActive,
    				'ptr-content': ptr,
    				'ptr-bottom': ptrBottom,
    				'infinite-scroll-content': infinite,
    				'infinite-scroll-top': infiniteTop,
    				'hide-bars-on-scroll': hideBarsOnScroll,
    				'hide-navbar-on-scroll': hideNavbarOnScroll,
    				'hide-toolbar-on-scroll': hideToolbarOnScroll,
    				'messages-content': messagesContent,
    				'login-screen-content': loginScreen
    			},
    			colorClasses($$props)
    		));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		ptr,
    		ptrDistance,
    		ptrPreloader,
    		ptrBottom,
    		ptrMousewheel,
    		infinite,
    		infiniteTop,
    		infiniteDistance,
    		infinitePreloader,
    		pageContentEl,
    		pageContentClasses,
    		$$restProps,
    		tab,
    		tabActive,
    		hideBarsOnScroll,
    		hideNavbarOnScroll,
    		hideToolbarOnScroll,
    		messagesContent,
    		loginScreen,
    		className,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class Page_content extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$9,
    			create_fragment$a,
    			safe_not_equal,
    			{
    				tab: 12,
    				tabActive: 13,
    				ptr: 0,
    				ptrDistance: 1,
    				ptrPreloader: 2,
    				ptrBottom: 3,
    				ptrMousewheel: 4,
    				infinite: 5,
    				infiniteTop: 6,
    				infiniteDistance: 7,
    				infinitePreloader: 8,
    				hideBarsOnScroll: 14,
    				hideNavbarOnScroll: 15,
    				hideToolbarOnScroll: 16,
    				messagesContent: 17,
    				loginScreen: 18,
    				class: 19
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Page_content",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get tab() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tab(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabActive() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabActive(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptr() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptr(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrDistance() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrDistance(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrPreloader() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrPreloader(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrBottom() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrBottom(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrMousewheel() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrMousewheel(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infinite() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infinite(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infiniteTop() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infiniteTop(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infiniteDistance() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infiniteDistance(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infinitePreloader() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infinitePreloader(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideBarsOnScroll() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideBarsOnScroll(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideNavbarOnScroll() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideNavbarOnScroll(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideToolbarOnScroll() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideToolbarOnScroll(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get messagesContent() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set messagesContent(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loginScreen() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loginScreen(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/page.svelte generated by Svelte v3.44.0 */
    const file$6 = "node_modules/framework7-svelte/esm/svelte/page.svelte";
    const get_static_slot_changes_1 = dirty => ({});
    const get_static_slot_context_1 = ctx => ({});
    const get_static_slot_changes = dirty => ({});
    const get_static_slot_context = ctx => ({});
    const get_fixed_slot_changes = dirty => ({});
    const get_fixed_slot_context = ctx => ({});

    // (342:2) {:else}
    function create_else_block$1(ctx) {
    	let t;
    	let current;
    	const static_slot_template = /*#slots*/ ctx[46].static;
    	const static_slot = create_slot(static_slot_template, ctx, /*$$scope*/ ctx[48], get_static_slot_context_1);
    	const default_slot_template = /*#slots*/ ctx[46].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[48], null);

    	const block = {
    		c: function create() {
    			if (static_slot) static_slot.c();
    			t = space();
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (static_slot) {
    				static_slot.m(target, anchor);
    			}

    			insert_dev(target, t, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (static_slot) {
    				if (static_slot.p && (!current || dirty[1] & /*$$scope*/ 131072)) {
    					update_slot_base(
    						static_slot,
    						static_slot_template,
    						ctx,
    						/*$$scope*/ ctx[48],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[48])
    						: get_slot_changes(static_slot_template, /*$$scope*/ ctx[48], dirty, get_static_slot_changes_1),
    						get_static_slot_context_1
    					);
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[48],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[48])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[48], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(static_slot, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(static_slot, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (static_slot) static_slot.d(detaching);
    			if (detaching) detach_dev(t);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(342:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (316:2) {#if pageContent}
    function create_if_block$2(ctx) {
    	let pagecontent;
    	let current;

    	pagecontent = new Page_content({
    			props: {
    				ptr: /*ptr*/ ctx[2],
    				ptrDistance: /*ptrDistance*/ ctx[3],
    				ptrPreloader: /*ptrPreloader*/ ctx[4],
    				ptrBottom: /*ptrBottom*/ ctx[5],
    				ptrMousewheel: /*ptrMousewheel*/ ctx[6],
    				infinite: /*infinite*/ ctx[7],
    				infiniteTop: /*infiniteTop*/ ctx[8],
    				infiniteDistance: /*infiniteDistance*/ ctx[9],
    				infinitePreloader: /*infinitePreloader*/ ctx[10],
    				hideBarsOnScroll: /*hideBarsOnScroll*/ ctx[11],
    				hideNavbarOnScroll: /*hideNavbarOnScroll*/ ctx[12],
    				hideToolbarOnScroll: /*hideToolbarOnScroll*/ ctx[13],
    				messagesContent: /*messagesContent*/ ctx[14],
    				loginScreen: /*loginScreen*/ ctx[15],
    				onPtrPullStart: /*onPtrPullStart*/ ctx[18],
    				onPtrPullMove: /*onPtrPullMove*/ ctx[19],
    				onPtrPullEnd: /*onPtrPullEnd*/ ctx[20],
    				onPtrRefresh: /*onPtrRefresh*/ ctx[21],
    				onPtrDone: /*onPtrDone*/ ctx[22],
    				onInfinite: /*onInfinite*/ ctx[23],
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pagecontent.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagecontent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pagecontent_changes = {};
    			if (dirty[0] & /*ptr*/ 4) pagecontent_changes.ptr = /*ptr*/ ctx[2];
    			if (dirty[0] & /*ptrDistance*/ 8) pagecontent_changes.ptrDistance = /*ptrDistance*/ ctx[3];
    			if (dirty[0] & /*ptrPreloader*/ 16) pagecontent_changes.ptrPreloader = /*ptrPreloader*/ ctx[4];
    			if (dirty[0] & /*ptrBottom*/ 32) pagecontent_changes.ptrBottom = /*ptrBottom*/ ctx[5];
    			if (dirty[0] & /*ptrMousewheel*/ 64) pagecontent_changes.ptrMousewheel = /*ptrMousewheel*/ ctx[6];
    			if (dirty[0] & /*infinite*/ 128) pagecontent_changes.infinite = /*infinite*/ ctx[7];
    			if (dirty[0] & /*infiniteTop*/ 256) pagecontent_changes.infiniteTop = /*infiniteTop*/ ctx[8];
    			if (dirty[0] & /*infiniteDistance*/ 512) pagecontent_changes.infiniteDistance = /*infiniteDistance*/ ctx[9];
    			if (dirty[0] & /*infinitePreloader*/ 1024) pagecontent_changes.infinitePreloader = /*infinitePreloader*/ ctx[10];
    			if (dirty[0] & /*hideBarsOnScroll*/ 2048) pagecontent_changes.hideBarsOnScroll = /*hideBarsOnScroll*/ ctx[11];
    			if (dirty[0] & /*hideNavbarOnScroll*/ 4096) pagecontent_changes.hideNavbarOnScroll = /*hideNavbarOnScroll*/ ctx[12];
    			if (dirty[0] & /*hideToolbarOnScroll*/ 8192) pagecontent_changes.hideToolbarOnScroll = /*hideToolbarOnScroll*/ ctx[13];
    			if (dirty[0] & /*messagesContent*/ 16384) pagecontent_changes.messagesContent = /*messagesContent*/ ctx[14];
    			if (dirty[0] & /*loginScreen*/ 32768) pagecontent_changes.loginScreen = /*loginScreen*/ ctx[15];

    			if (dirty[1] & /*$$scope*/ 131072) {
    				pagecontent_changes.$$scope = { dirty, ctx };
    			}

    			pagecontent.$set(pagecontent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagecontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagecontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagecontent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(316:2) {#if pageContent}",
    		ctx
    	});

    	return block;
    }

    // (317:4) <PageContent       {ptr}       {ptrDistance}       {ptrPreloader}       {ptrBottom}       {ptrMousewheel}       {infinite}       {infiniteTop}       {infiniteDistance}       {infinitePreloader}       {hideBarsOnScroll}       {hideNavbarOnScroll}       {hideToolbarOnScroll}       {messagesContent}       {loginScreen}       {onPtrPullStart}       {onPtrPullMove}       {onPtrPullEnd}       {onPtrRefresh}       {onPtrDone}       {onInfinite}     >
    function create_default_slot$6(ctx) {
    	let t;
    	let current;
    	const static_slot_template = /*#slots*/ ctx[46].static;
    	const static_slot = create_slot(static_slot_template, ctx, /*$$scope*/ ctx[48], get_static_slot_context);
    	const default_slot_template = /*#slots*/ ctx[46].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[48], null);

    	const block = {
    		c: function create() {
    			if (static_slot) static_slot.c();
    			t = space();
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (static_slot) {
    				static_slot.m(target, anchor);
    			}

    			insert_dev(target, t, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (static_slot) {
    				if (static_slot.p && (!current || dirty[1] & /*$$scope*/ 131072)) {
    					update_slot_base(
    						static_slot,
    						static_slot_template,
    						ctx,
    						/*$$scope*/ ctx[48],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[48])
    						: get_slot_changes(static_slot_template, /*$$scope*/ ctx[48], dirty, get_static_slot_changes),
    						get_static_slot_context
    					);
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[48],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[48])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[48], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(static_slot, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(static_slot, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (static_slot) static_slot.d(detaching);
    			if (detaching) detach_dev(t);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(317:4) <PageContent       {ptr}       {ptrDistance}       {ptrPreloader}       {ptrBottom}       {ptrMousewheel}       {infinite}       {infiniteTop}       {infiniteDistance}       {infinitePreloader}       {hideBarsOnScroll}       {hideNavbarOnScroll}       {hideToolbarOnScroll}       {messagesContent}       {loginScreen}       {onPtrPullStart}       {onPtrPullMove}       {onPtrPullEnd}       {onPtrRefresh}       {onPtrDone}       {onInfinite}     >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let div;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const fixed_slot_template = /*#slots*/ ctx[46].fixed;
    	const fixed_slot = create_slot(fixed_slot_template, ctx, /*$$scope*/ ctx[48], get_fixed_slot_context);
    	const if_block_creators = [create_if_block$2, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*pageContent*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	let div_levels = [
    		{ class: /*classes*/ ctx[17] },
    		{ "data-name": /*name*/ ctx[0] },
    		restProps(/*$$restProps*/ ctx[24])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (fixed_slot) fixed_slot.c();
    			t = space();
    			if_block.c();
    			set_attributes(div, div_data);
    			add_location(div, file$6, 313, 0, 9751);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (fixed_slot) {
    				fixed_slot.m(div, null);
    			}

    			append_dev(div, t);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding*/ ctx[47](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (fixed_slot) {
    				if (fixed_slot.p && (!current || dirty[1] & /*$$scope*/ 131072)) {
    					update_slot_base(
    						fixed_slot,
    						fixed_slot_template,
    						ctx,
    						/*$$scope*/ ctx[48],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[48])
    						: get_slot_changes(fixed_slot_template, /*$$scope*/ ctx[48], dirty, get_fixed_slot_changes),
    						get_fixed_slot_context
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty[0] & /*classes*/ 131072) && { class: /*classes*/ ctx[17] },
    				(!current || dirty[0] & /*name*/ 1) && { "data-name": /*name*/ ctx[0] },
    				dirty[0] & /*$$restProps*/ 16777216 && restProps(/*$$restProps*/ ctx[24])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fixed_slot, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fixed_slot, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (fixed_slot) fixed_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			/*div_binding*/ ctx[47](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let forceSubnavbar;
    	let forceNavbarLarge;
    	let classes;

    	const omit_props_names = [
    		"name","stacked","withSubnavbar","subnavbar","withNavbarLarge","navbarLarge","noNavbar","noToolbar","tabs","pageContent","noSwipeback","ptr","ptrDistance","ptrPreloader","ptrBottom","ptrMousewheel","infinite","infiniteTop","infiniteDistance","infinitePreloader","hideBarsOnScroll","hideNavbarOnScroll","hideToolbarOnScroll","messagesContent","loginScreen","class"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Page', slots, ['fixed','static','default']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { name = undefined } = $$props;
    	let { stacked = undefined } = $$props;
    	let { withSubnavbar = undefined } = $$props;
    	let { subnavbar = undefined } = $$props;
    	let { withNavbarLarge = undefined } = $$props;
    	let { navbarLarge = undefined } = $$props;
    	let { noNavbar = undefined } = $$props;
    	let { noToolbar = undefined } = $$props;
    	let { tabs = undefined } = $$props;
    	let { pageContent = true } = $$props;
    	let { noSwipeback = undefined } = $$props;
    	let { ptr = undefined } = $$props;
    	let { ptrDistance = undefined } = $$props;
    	let { ptrPreloader = true } = $$props;
    	let { ptrBottom = undefined } = $$props;
    	let { ptrMousewheel = undefined } = $$props;
    	let { infinite = undefined } = $$props;
    	let { infiniteTop = undefined } = $$props;
    	let { infiniteDistance = undefined } = $$props;
    	let { infinitePreloader = true } = $$props;
    	let { hideBarsOnScroll = undefined } = $$props;
    	let { hideNavbarOnScroll = undefined } = $$props;
    	let { hideToolbarOnScroll = undefined } = $$props;
    	let { messagesContent = undefined } = $$props;
    	let { loginScreen = undefined } = $$props;
    	let { class: className = undefined } = $$props;

    	// State
    	let el;

    	let hasSubnavbar = false;
    	let hasNavbarLarge = false;
    	let hasNavbarLargeCollapsed = false;
    	let hasCardExpandableOpened = false;
    	let routerPositionClass = '';
    	let routerForceUnstack = false;
    	let routerPageRole = null;
    	let routerPageRoleDetailRoot = false;
    	let routerPageMasterStack = false;

    	// Handlers
    	function onPtrPullStart() {
    		emit('ptrPullStart');
    	}

    	function onPtrPullMove() {
    		emit('ptrPullMove');
    	}

    	function onPtrPullEnd() {
    		emit('ptrPullEnd');
    	}

    	function onPtrRefresh(done) {
    		emit('ptrRefresh', [done]);
    	}

    	function onPtrDone() {
    		emit('ptrDone');
    	}

    	function onInfinite() {
    		emit('infinite');
    	}

    	// Main Page Events
    	function onPageMounted(page) {
    		if (el !== page.el) return;
    		emit('pageMounted', [page]);
    	}

    	function onPageInit(page) {
    		if (el !== page.el) return;

    		if (typeof withSubnavbar === 'undefined' && typeof subnavbar === 'undefined') {
    			if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find('.subnavbar').length || page.$el.children('.navbar').find('.subnavbar').length) {
    				$$invalidate(35, hasSubnavbar = true);
    			}
    		}

    		if (typeof withNavbarLarge === 'undefined' && typeof navbarLarge === 'undefined') {
    			if (page.$navbarEl && page.$navbarEl.hasClass('navbar-large') || page.$el.children('.navbar-large').length) {
    				$$invalidate(36, hasNavbarLarge = true);
    			}
    		}

    		emit('pageInit', [page]);
    	}

    	function onPageReinit(page) {
    		if (el !== page.el) return;
    		emit('pageReinit', [page]);
    	}

    	function onPageBeforeIn(page) {
    		if (el !== page.el) return;

    		if (!page.swipeBack) {
    			if (page.from === 'next') {
    				$$invalidate(39, routerPositionClass = 'page-next');
    			}

    			if (page.from === 'previous') {
    				$$invalidate(39, routerPositionClass = 'page-previous');
    			}
    		}

    		emit('pageBeforeIn', [page]);
    	}

    	function onPageBeforeOut(page) {
    		if (el !== page.el) return;
    		emit('pageBeforeOut', [page]);
    	}

    	function onPageAfterOut(page) {
    		if (el !== page.el) return;

    		if (page.to === 'next') {
    			$$invalidate(39, routerPositionClass = 'page-next');
    		}

    		if (page.to === 'previous') {
    			$$invalidate(39, routerPositionClass = 'page-previous');
    		}

    		emit('pageAfterOut', [page]);
    	}

    	function onPageAfterIn(page) {
    		if (el !== page.el) return;
    		$$invalidate(39, routerPositionClass = 'page-current');
    		emit('pageAfterIn', [page]);
    	}

    	function onPageBeforeRemove(page) {
    		if (el !== page.el) return;

    		if (page.$navbarEl && page.$navbarEl[0] && page.$navbarEl.parent()[0] && page.$navbarEl.parent()[0] !== el) {
    			page.$el.prepend(page.$navbarEl);
    		}

    		emit('pageBeforeRemove', [page]);
    	}

    	function onPageBeforeUnmount(page) {
    		if (el !== page.el) return;
    		emit('pageBeforeUnmount', [page]);
    	}

    	// Helper events
    	function onPageStack(pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(40, routerForceUnstack = false);
    	}

    	function onPageUnstack(pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(40, routerForceUnstack = true);
    	}

    	function onPagePosition(pageEl, position) {
    		if (el !== pageEl) return;
    		$$invalidate(39, routerPositionClass = `page-${position}`);
    	}

    	function onPageRole(pageEl, rolesData) {
    		if (el !== pageEl) return;
    		$$invalidate(41, routerPageRole = rolesData.role);
    		$$invalidate(42, routerPageRoleDetailRoot = rolesData.detailRoot);
    	}

    	function onPageMasterStack(pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(43, routerPageMasterStack = true);
    	}

    	function onPageMasterUnstack(pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(43, routerPageMasterStack = false);
    	}

    	function onPageNavbarLargeCollapsed(pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(37, hasNavbarLargeCollapsed = true);
    	}

    	function onPageNavbarLargeExpanded(pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(37, hasNavbarLargeCollapsed = false);
    	}

    	function onCardOpened(cardEl, pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(38, hasCardExpandableOpened = true);
    	}

    	function onCardClose(cardEl, pageEl) {
    		if (el !== pageEl) return;
    		$$invalidate(38, hasCardExpandableOpened = false);
    	}

    	function onPageTabShow(pageEl) {
    		if (el !== pageEl) return;
    		emit('pageTabShow');
    	}

    	function onPageTabHide(pageEl) {
    		if (el !== pageEl) return;
    		emit('pageTabHide');
    	}

    	// Mount/destroy
    	function mountPage() {
    		app$1.f7.on('pageMounted', onPageMounted);
    		app$1.f7.on('pageInit', onPageInit);
    		app$1.f7.on('pageReinit', onPageReinit);
    		app$1.f7.on('pageBeforeIn', onPageBeforeIn);
    		app$1.f7.on('pageBeforeOut', onPageBeforeOut);
    		app$1.f7.on('pageAfterOut', onPageAfterOut);
    		app$1.f7.on('pageAfterIn', onPageAfterIn);
    		app$1.f7.on('pageBeforeRemove', onPageBeforeRemove);
    		app$1.f7.on('pageBeforeUnmount', onPageBeforeUnmount);
    		app$1.f7.on('pageStack', onPageStack);
    		app$1.f7.on('pageUnstack', onPageUnstack);
    		app$1.f7.on('pagePosition', onPagePosition);
    		app$1.f7.on('pageRole', onPageRole);
    		app$1.f7.on('pageMasterStack', onPageMasterStack);
    		app$1.f7.on('pageMasterUnstack', onPageMasterUnstack);
    		app$1.f7.on('pageNavbarLargeCollapsed', onPageNavbarLargeCollapsed);
    		app$1.f7.on('pageNavbarLargeExpanded', onPageNavbarLargeExpanded);
    		app$1.f7.on('cardOpened', onCardOpened);
    		app$1.f7.on('cardClose', onCardClose);
    		app$1.f7.on('pageTabShow', onPageTabShow);
    		app$1.f7.on('pageTabHide', onPageTabHide);
    	}

    	function destroyPage() {
    		app$1.f7.off('pageMounted', onPageMounted);
    		app$1.f7.off('pageInit', onPageInit);
    		app$1.f7.off('pageReinit', onPageReinit);
    		app$1.f7.off('pageBeforeIn', onPageBeforeIn);
    		app$1.f7.off('pageBeforeOut', onPageBeforeOut);
    		app$1.f7.off('pageAfterOut', onPageAfterOut);
    		app$1.f7.off('pageAfterIn', onPageAfterIn);
    		app$1.f7.off('pageBeforeRemove', onPageBeforeRemove);
    		app$1.f7.off('pageBeforeUnmount', onPageBeforeUnmount);
    		app$1.f7.off('pageStack', onPageStack);
    		app$1.f7.off('pageUnstack', onPageUnstack);
    		app$1.f7.off('pagePosition', onPagePosition);
    		app$1.f7.off('pageRole', onPageRole);
    		app$1.f7.off('pageMasterStack', onPageMasterStack);
    		app$1.f7.off('pageMasterUnstack', onPageMasterUnstack);
    		app$1.f7.off('pageNavbarLargeCollapsed', onPageNavbarLargeCollapsed);
    		app$1.f7.off('pageNavbarLargeExpanded', onPageNavbarLargeExpanded);
    		app$1.f7.off('cardOpened', onCardOpened);
    		app$1.f7.off('cardClose', onCardClose);
    		app$1.f7.off('pageTabShow', onPageTabShow);
    		app$1.f7.off('pageTabHide', onPageTabHide);
    	}

    	onMount(() => {
    		f7ready(() => {
    			if (el) {
    				const dom7 = app$1.f7.$;
    				const fixedEls = dom7(el).children('.page-content').children('[data-f7-slot="fixed"]');

    				if (fixedEls.length) {
    					for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
    						dom7(el).prepend(fixedEls[i]);
    					}
    				}
    			}

    			mountPage();
    		});
    	});

    	afterUpdate(() => {
    		if (el && app$1.f7) {
    			const dom7 = app$1.f7.$;
    			const fixedEls = dom7(el).children('.page-content').children('[data-f7-slot="fixed"]');

    			if (fixedEls.length) {
    				for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
    					dom7(el).prepend(fixedEls[i]);
    				}
    			}
    		}
    	});

    	onDestroy(() => {
    		if (!app$1.f7) return;
    		destroyPage();
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(16, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(73, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('name' in $$new_props) $$invalidate(0, name = $$new_props.name);
    		if ('stacked' in $$new_props) $$invalidate(25, stacked = $$new_props.stacked);
    		if ('withSubnavbar' in $$new_props) $$invalidate(26, withSubnavbar = $$new_props.withSubnavbar);
    		if ('subnavbar' in $$new_props) $$invalidate(27, subnavbar = $$new_props.subnavbar);
    		if ('withNavbarLarge' in $$new_props) $$invalidate(28, withNavbarLarge = $$new_props.withNavbarLarge);
    		if ('navbarLarge' in $$new_props) $$invalidate(29, navbarLarge = $$new_props.navbarLarge);
    		if ('noNavbar' in $$new_props) $$invalidate(30, noNavbar = $$new_props.noNavbar);
    		if ('noToolbar' in $$new_props) $$invalidate(31, noToolbar = $$new_props.noToolbar);
    		if ('tabs' in $$new_props) $$invalidate(32, tabs = $$new_props.tabs);
    		if ('pageContent' in $$new_props) $$invalidate(1, pageContent = $$new_props.pageContent);
    		if ('noSwipeback' in $$new_props) $$invalidate(33, noSwipeback = $$new_props.noSwipeback);
    		if ('ptr' in $$new_props) $$invalidate(2, ptr = $$new_props.ptr);
    		if ('ptrDistance' in $$new_props) $$invalidate(3, ptrDistance = $$new_props.ptrDistance);
    		if ('ptrPreloader' in $$new_props) $$invalidate(4, ptrPreloader = $$new_props.ptrPreloader);
    		if ('ptrBottom' in $$new_props) $$invalidate(5, ptrBottom = $$new_props.ptrBottom);
    		if ('ptrMousewheel' in $$new_props) $$invalidate(6, ptrMousewheel = $$new_props.ptrMousewheel);
    		if ('infinite' in $$new_props) $$invalidate(7, infinite = $$new_props.infinite);
    		if ('infiniteTop' in $$new_props) $$invalidate(8, infiniteTop = $$new_props.infiniteTop);
    		if ('infiniteDistance' in $$new_props) $$invalidate(9, infiniteDistance = $$new_props.infiniteDistance);
    		if ('infinitePreloader' in $$new_props) $$invalidate(10, infinitePreloader = $$new_props.infinitePreloader);
    		if ('hideBarsOnScroll' in $$new_props) $$invalidate(11, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
    		if ('hideNavbarOnScroll' in $$new_props) $$invalidate(12, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
    		if ('hideToolbarOnScroll' in $$new_props) $$invalidate(13, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
    		if ('messagesContent' in $$new_props) $$invalidate(14, messagesContent = $$new_props.messagesContent);
    		if ('loginScreen' in $$new_props) $$invalidate(15, loginScreen = $$new_props.loginScreen);
    		if ('class' in $$new_props) $$invalidate(34, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(48, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		afterUpdate,
    		onDestroy,
    		createEventDispatcher,
    		restProps,
    		colorClasses,
    		classNames,
    		createEmitter,
    		app: app$1,
    		f7ready,
    		PageContent: Page_content,
    		emit,
    		name,
    		stacked,
    		withSubnavbar,
    		subnavbar,
    		withNavbarLarge,
    		navbarLarge,
    		noNavbar,
    		noToolbar,
    		tabs,
    		pageContent,
    		noSwipeback,
    		ptr,
    		ptrDistance,
    		ptrPreloader,
    		ptrBottom,
    		ptrMousewheel,
    		infinite,
    		infiniteTop,
    		infiniteDistance,
    		infinitePreloader,
    		hideBarsOnScroll,
    		hideNavbarOnScroll,
    		hideToolbarOnScroll,
    		messagesContent,
    		loginScreen,
    		className,
    		el,
    		hasSubnavbar,
    		hasNavbarLarge,
    		hasNavbarLargeCollapsed,
    		hasCardExpandableOpened,
    		routerPositionClass,
    		routerForceUnstack,
    		routerPageRole,
    		routerPageRoleDetailRoot,
    		routerPageMasterStack,
    		onPtrPullStart,
    		onPtrPullMove,
    		onPtrPullEnd,
    		onPtrRefresh,
    		onPtrDone,
    		onInfinite,
    		onPageMounted,
    		onPageInit,
    		onPageReinit,
    		onPageBeforeIn,
    		onPageBeforeOut,
    		onPageAfterOut,
    		onPageAfterIn,
    		onPageBeforeRemove,
    		onPageBeforeUnmount,
    		onPageStack,
    		onPageUnstack,
    		onPagePosition,
    		onPageRole,
    		onPageMasterStack,
    		onPageMasterUnstack,
    		onPageNavbarLargeCollapsed,
    		onPageNavbarLargeExpanded,
    		onCardOpened,
    		onCardClose,
    		onPageTabShow,
    		onPageTabHide,
    		mountPage,
    		destroyPage,
    		forceNavbarLarge,
    		forceSubnavbar,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(73, $$props = assign(assign({}, $$props), $$new_props));
    		if ('name' in $$props) $$invalidate(0, name = $$new_props.name);
    		if ('stacked' in $$props) $$invalidate(25, stacked = $$new_props.stacked);
    		if ('withSubnavbar' in $$props) $$invalidate(26, withSubnavbar = $$new_props.withSubnavbar);
    		if ('subnavbar' in $$props) $$invalidate(27, subnavbar = $$new_props.subnavbar);
    		if ('withNavbarLarge' in $$props) $$invalidate(28, withNavbarLarge = $$new_props.withNavbarLarge);
    		if ('navbarLarge' in $$props) $$invalidate(29, navbarLarge = $$new_props.navbarLarge);
    		if ('noNavbar' in $$props) $$invalidate(30, noNavbar = $$new_props.noNavbar);
    		if ('noToolbar' in $$props) $$invalidate(31, noToolbar = $$new_props.noToolbar);
    		if ('tabs' in $$props) $$invalidate(32, tabs = $$new_props.tabs);
    		if ('pageContent' in $$props) $$invalidate(1, pageContent = $$new_props.pageContent);
    		if ('noSwipeback' in $$props) $$invalidate(33, noSwipeback = $$new_props.noSwipeback);
    		if ('ptr' in $$props) $$invalidate(2, ptr = $$new_props.ptr);
    		if ('ptrDistance' in $$props) $$invalidate(3, ptrDistance = $$new_props.ptrDistance);
    		if ('ptrPreloader' in $$props) $$invalidate(4, ptrPreloader = $$new_props.ptrPreloader);
    		if ('ptrBottom' in $$props) $$invalidate(5, ptrBottom = $$new_props.ptrBottom);
    		if ('ptrMousewheel' in $$props) $$invalidate(6, ptrMousewheel = $$new_props.ptrMousewheel);
    		if ('infinite' in $$props) $$invalidate(7, infinite = $$new_props.infinite);
    		if ('infiniteTop' in $$props) $$invalidate(8, infiniteTop = $$new_props.infiniteTop);
    		if ('infiniteDistance' in $$props) $$invalidate(9, infiniteDistance = $$new_props.infiniteDistance);
    		if ('infinitePreloader' in $$props) $$invalidate(10, infinitePreloader = $$new_props.infinitePreloader);
    		if ('hideBarsOnScroll' in $$props) $$invalidate(11, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
    		if ('hideNavbarOnScroll' in $$props) $$invalidate(12, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
    		if ('hideToolbarOnScroll' in $$props) $$invalidate(13, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
    		if ('messagesContent' in $$props) $$invalidate(14, messagesContent = $$new_props.messagesContent);
    		if ('loginScreen' in $$props) $$invalidate(15, loginScreen = $$new_props.loginScreen);
    		if ('className' in $$props) $$invalidate(34, className = $$new_props.className);
    		if ('el' in $$props) $$invalidate(16, el = $$new_props.el);
    		if ('hasSubnavbar' in $$props) $$invalidate(35, hasSubnavbar = $$new_props.hasSubnavbar);
    		if ('hasNavbarLarge' in $$props) $$invalidate(36, hasNavbarLarge = $$new_props.hasNavbarLarge);
    		if ('hasNavbarLargeCollapsed' in $$props) $$invalidate(37, hasNavbarLargeCollapsed = $$new_props.hasNavbarLargeCollapsed);
    		if ('hasCardExpandableOpened' in $$props) $$invalidate(38, hasCardExpandableOpened = $$new_props.hasCardExpandableOpened);
    		if ('routerPositionClass' in $$props) $$invalidate(39, routerPositionClass = $$new_props.routerPositionClass);
    		if ('routerForceUnstack' in $$props) $$invalidate(40, routerForceUnstack = $$new_props.routerForceUnstack);
    		if ('routerPageRole' in $$props) $$invalidate(41, routerPageRole = $$new_props.routerPageRole);
    		if ('routerPageRoleDetailRoot' in $$props) $$invalidate(42, routerPageRoleDetailRoot = $$new_props.routerPageRoleDetailRoot);
    		if ('routerPageMasterStack' in $$props) $$invalidate(43, routerPageMasterStack = $$new_props.routerPageMasterStack);
    		if ('forceNavbarLarge' in $$props) $$invalidate(44, forceNavbarLarge = $$new_props.forceNavbarLarge);
    		if ('forceSubnavbar' in $$props) $$invalidate(45, forceSubnavbar = $$new_props.forceSubnavbar);
    		if ('classes' in $$props) $$invalidate(17, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*subnavbar, withSubnavbar*/ 201326592 | $$self.$$.dirty[1] & /*hasSubnavbar*/ 16) {
    			$$invalidate(45, forceSubnavbar = typeof subnavbar === 'undefined' && typeof withSubnavbar === 'undefined'
    			? hasSubnavbar
    			: false);
    		}

    		if ($$self.$$.dirty[0] & /*navbarLarge, withNavbarLarge*/ 805306368 | $$self.$$.dirty[1] & /*hasNavbarLarge*/ 32) {
    			$$invalidate(44, forceNavbarLarge = typeof navbarLarge === 'undefined' && typeof withNavbarLarge === 'undefined'
    			? hasNavbarLarge
    			: false);
    		}

    		$$invalidate(17, classes = classNames(
    			className,
    			'page',
    			routerPositionClass,
    			{
    				stacked: stacked && !routerForceUnstack,
    				tabs,
    				'page-with-subnavbar': subnavbar || withSubnavbar || forceSubnavbar,
    				'page-with-navbar-large': navbarLarge || withNavbarLarge || forceNavbarLarge,
    				'no-navbar': noNavbar,
    				'no-toolbar': noToolbar,
    				'no-swipeback': noSwipeback,
    				'page-master': routerPageRole === 'master',
    				'page-master-detail': routerPageRole === 'detail',
    				'page-master-detail-root': routerPageRoleDetailRoot === true,
    				'page-master-stacked': routerPageMasterStack === true,
    				'page-with-navbar-large-collapsed': hasNavbarLargeCollapsed === true,
    				'page-with-card-opened': hasCardExpandableOpened === true,
    				'login-screen-page': loginScreen
    			},
    			colorClasses($$props)
    		));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		name,
    		pageContent,
    		ptr,
    		ptrDistance,
    		ptrPreloader,
    		ptrBottom,
    		ptrMousewheel,
    		infinite,
    		infiniteTop,
    		infiniteDistance,
    		infinitePreloader,
    		hideBarsOnScroll,
    		hideNavbarOnScroll,
    		hideToolbarOnScroll,
    		messagesContent,
    		loginScreen,
    		el,
    		classes,
    		onPtrPullStart,
    		onPtrPullMove,
    		onPtrPullEnd,
    		onPtrRefresh,
    		onPtrDone,
    		onInfinite,
    		$$restProps,
    		stacked,
    		withSubnavbar,
    		subnavbar,
    		withNavbarLarge,
    		navbarLarge,
    		noNavbar,
    		noToolbar,
    		tabs,
    		noSwipeback,
    		className,
    		hasSubnavbar,
    		hasNavbarLarge,
    		hasNavbarLargeCollapsed,
    		hasCardExpandableOpened,
    		routerPositionClass,
    		routerForceUnstack,
    		routerPageRole,
    		routerPageRoleDetailRoot,
    		routerPageMasterStack,
    		forceNavbarLarge,
    		forceSubnavbar,
    		slots,
    		div_binding,
    		$$scope
    	];
    }

    class Page extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$8,
    			create_fragment$9,
    			safe_not_equal,
    			{
    				name: 0,
    				stacked: 25,
    				withSubnavbar: 26,
    				subnavbar: 27,
    				withNavbarLarge: 28,
    				navbarLarge: 29,
    				noNavbar: 30,
    				noToolbar: 31,
    				tabs: 32,
    				pageContent: 1,
    				noSwipeback: 33,
    				ptr: 2,
    				ptrDistance: 3,
    				ptrPreloader: 4,
    				ptrBottom: 5,
    				ptrMousewheel: 6,
    				infinite: 7,
    				infiniteTop: 8,
    				infiniteDistance: 9,
    				infinitePreloader: 10,
    				hideBarsOnScroll: 11,
    				hideNavbarOnScroll: 12,
    				hideToolbarOnScroll: 13,
    				messagesContent: 14,
    				loginScreen: 15,
    				class: 34
    			},
    			null,
    			[-1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Page",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get name() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stacked() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stacked(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withSubnavbar() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withSubnavbar(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subnavbar() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subnavbar(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withNavbarLarge() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withNavbarLarge(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get navbarLarge() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set navbarLarge(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noNavbar() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noNavbar(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noToolbar() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noToolbar(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabs() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabs(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pageContent() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pageContent(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noSwipeback() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noSwipeback(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptr() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptr(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrDistance() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrDistance(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrPreloader() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrPreloader(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrBottom() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrBottom(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ptrMousewheel() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ptrMousewheel(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infinite() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infinite(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infiniteTop() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infiniteTop(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infiniteDistance() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infiniteDistance(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get infinitePreloader() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set infinitePreloader(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideBarsOnScroll() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideBarsOnScroll(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideNavbarOnScroll() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideNavbarOnScroll(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideToolbarOnScroll() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideToolbarOnScroll(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get messagesContent() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set messagesContent(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loginScreen() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loginScreen(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/router-context-provider.svelte generated by Svelte v3.44.0 */

    function create_fragment$8(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Router_context_provider', slots, ['default']);
    	let { route = undefined } = $$props;
    	let { router = undefined } = $$props;
    	setContext('RouterContext', { route, router });
    	const writable_props = ['route', 'router'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Router_context_provider> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('route' in $$props) $$invalidate(0, route = $$props.route);
    		if ('router' in $$props) $$invalidate(1, router = $$props.router);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ setContext, route, router });

    	$$self.$inject_state = $$props => {
    		if ('route' in $$props) $$invalidate(0, route = $$props.route);
    		if ('router' in $$props) $$invalidate(1, router = $$props.router);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [route, router, $$scope, slots];
    }

    class Router_context_provider extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$8, safe_not_equal, { route: 0, router: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router_context_provider",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get route() {
    		throw new Error("<Router_context_provider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set route(value) {
    		throw new Error("<Router_context_provider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get router() {
    		throw new Error("<Router_context_provider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set router(value) {
    		throw new Error("<Router_context_provider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/row.svelte generated by Svelte v3.44.0 */
    const file$5 = "node_modules/framework7-svelte/esm/svelte/row.svelte";

    // (58:22) 
    function create_if_block_2(ctx) {
    	let p;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let if_block = /*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2] && create_if_block_3(ctx);
    	let p_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
    	let p_data = {};

    	for (let i = 0; i < p_levels.length; i += 1) {
    		p_data = assign(p_data, p_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			p = element("p");
    			if (default_slot) default_slot.c();
    			t = space();
    			if (if_block) if_block.c();
    			set_attributes(p, p_data);
    			add_location(p, file$5, 58, 2, 1423);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);

    			if (default_slot) {
    				default_slot.m(p, null);
    			}

    			append_dev(p, t);
    			if (if_block) if_block.m(p, null);
    			/*p_binding*/ ctx[14](p);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(p, "click", /*onClick*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2]) {
    				if (if_block) ; else {
    					if_block = create_if_block_3(ctx);
    					if_block.c();
    					if_block.m(p, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			set_attributes(p, p_data = get_spread_update(p_levels, [
    				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
    				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (default_slot) default_slot.d(detaching);
    			if (if_block) if_block.d();
    			/*p_binding*/ ctx[14](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(58:22) ",
    		ctx
    	});

    	return block;
    }

    // (53:0) {#if tag === 'div'}
    function create_if_block$1(ctx) {
    	let div;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let if_block = /*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2] && create_if_block_1(ctx);
    	let div_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			t = space();
    			if (if_block) if_block.c();
    			set_attributes(div, div_data);
    			add_location(div, file$5, 53, 2, 1216);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			/*div_binding*/ ctx[13](div);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*onClick*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2]) {
    				if (if_block) ; else {
    					if_block = create_if_block_1(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
    				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			if (if_block) if_block.d();
    			/*div_binding*/ ctx[13](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(53:0) {#if tag === 'div'}",
    		ctx
    	});

    	return block;
    }

    // (61:4) {#if resizable && resizableHandler}
    function create_if_block_3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "resize-handler");
    			add_location(span, file$5, 60, 39, 1557);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(61:4) {#if resizable && resizableHandler}",
    		ctx
    	});

    	return block;
    }

    // (56:4) {#if resizable && resizableHandler}
    function create_if_block_1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "resize-handler");
    			add_location(span, file$5, 55, 39, 1352);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(56:4) {#if resizable && resizableHandler}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$1, create_if_block_2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*tag*/ ctx[0] === 'div') return 0;
    		if (/*tag*/ ctx[0] === 'p') return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","noGap","tag","resizable","resizableFixed","resizableAbsolute","resizableHandler"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Row', slots, ['default']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { noGap = false } = $$props;
    	let { tag = 'div' } = $$props;
    	let { resizable = false } = $$props;
    	let { resizableFixed = false } = $$props;
    	let { resizableAbsolute = false } = $$props;
    	let { resizableHandler = true } = $$props;
    	let el;

    	function onClick() {
    		emit('click');
    	}

    	function onResize(targetEl) {
    		if (el !== targetEl) return;
    		emit('gridResize');
    	}

    	onMount(() => {
    		f7ready(() => {
    			app$1.f7.on('gridResize', onResize);
    		});
    	});

    	onDestroy(() => {
    		if (!app$1.f7) return;
    		app$1.f7.off('gridResize', onResize);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(3, el);
    		});
    	}

    	function p_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(3, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(7, className = $$new_props.class);
    		if ('noGap' in $$new_props) $$invalidate(8, noGap = $$new_props.noGap);
    		if ('tag' in $$new_props) $$invalidate(0, tag = $$new_props.tag);
    		if ('resizable' in $$new_props) $$invalidate(1, resizable = $$new_props.resizable);
    		if ('resizableFixed' in $$new_props) $$invalidate(9, resizableFixed = $$new_props.resizableFixed);
    		if ('resizableAbsolute' in $$new_props) $$invalidate(10, resizableAbsolute = $$new_props.resizableAbsolute);
    		if ('resizableHandler' in $$new_props) $$invalidate(2, resizableHandler = $$new_props.resizableHandler);
    		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		colorClasses,
    		classNames,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		emit,
    		className,
    		noGap,
    		tag,
    		resizable,
    		resizableFixed,
    		resizableAbsolute,
    		resizableHandler,
    		el,
    		onClick,
    		onResize,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(17, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(7, className = $$new_props.className);
    		if ('noGap' in $$props) $$invalidate(8, noGap = $$new_props.noGap);
    		if ('tag' in $$props) $$invalidate(0, tag = $$new_props.tag);
    		if ('resizable' in $$props) $$invalidate(1, resizable = $$new_props.resizable);
    		if ('resizableFixed' in $$props) $$invalidate(9, resizableFixed = $$new_props.resizableFixed);
    		if ('resizableAbsolute' in $$props) $$invalidate(10, resizableAbsolute = $$new_props.resizableAbsolute);
    		if ('resizableHandler' in $$props) $$invalidate(2, resizableHandler = $$new_props.resizableHandler);
    		if ('el' in $$props) $$invalidate(3, el = $$new_props.el);
    		if ('classes' in $$props) $$invalidate(4, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(4, classes = classNames(
    			className,
    			'row',
    			{
    				'no-gap': noGap,
    				resizable,
    				'resizable-fixed': resizableFixed,
    				'resizable-absolute': resizableAbsolute
    			},
    			colorClasses($$props)
    		));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		tag,
    		resizable,
    		resizableHandler,
    		el,
    		classes,
    		onClick,
    		$$restProps,
    		className,
    		noGap,
    		resizableFixed,
    		resizableAbsolute,
    		$$scope,
    		slots,
    		div_binding,
    		p_binding
    	];
    }

    class Row extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$6, create_fragment$7, safe_not_equal, {
    			class: 7,
    			noGap: 8,
    			tag: 0,
    			resizable: 1,
    			resizableFixed: 9,
    			resizableAbsolute: 10,
    			resizableHandler: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Row",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get class() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noGap() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noGap(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tag() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tag(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resizable() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resizable(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resizableFixed() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resizableFixed(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resizableAbsolute() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resizableAbsolute(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resizableHandler() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resizableHandler(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/framework7-svelte/esm/svelte/toolbar.svelte generated by Svelte v3.44.0 */
    const file$4 = "node_modules/framework7-svelte/esm/svelte/toolbar.svelte";
    const get_after_inner_slot_changes = dirty => ({});
    const get_after_inner_slot_context = ctx => ({});
    const get_before_inner_slot_changes = dirty => ({});
    const get_before_inner_slot_context = ctx => ({});

    // (106:2) {:else}
    function create_else_block(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[24].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[23],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[23], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(106:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (102:2) {#if inner}
    function create_if_block(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[24].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "toolbar-inner");
    			add_location(div, file$4, 102, 4, 2741);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[23],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[23], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(102:2) {#if inner}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let div;
    	let t0;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let current;
    	const before_inner_slot_template = /*#slots*/ ctx[24]["before-inner"];
    	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[23], get_before_inner_slot_context);
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*inner*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const after_inner_slot_template = /*#slots*/ ctx[24]["after-inner"];
    	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[23], get_after_inner_slot_context);

    	let div_levels = [
    		{ class: /*classes*/ ctx[3] },
    		{ "data-f7-slot": /*f7Slot*/ ctx[1] },
    		restProps(/*$$restProps*/ ctx[4])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (before_inner_slot) before_inner_slot.c();
    			t0 = space();
    			if_block.c();
    			t1 = space();
    			if (after_inner_slot) after_inner_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$4, 99, 0, 2605);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (before_inner_slot) {
    				before_inner_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			if_blocks[current_block_type_index].m(div, null);
    			append_dev(div, t1);

    			if (after_inner_slot) {
    				after_inner_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[25](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (before_inner_slot) {
    				if (before_inner_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						before_inner_slot,
    						before_inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[23],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
    						: get_slot_changes(before_inner_slot_template, /*$$scope*/ ctx[23], dirty, get_before_inner_slot_changes),
    						get_before_inner_slot_context
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, t1);
    			}

    			if (after_inner_slot) {
    				if (after_inner_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						after_inner_slot,
    						after_inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[23],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
    						: get_slot_changes(after_inner_slot_template, /*$$scope*/ ctx[23], dirty, get_after_inner_slot_changes),
    						get_after_inner_slot_context
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
    				(!current || dirty & /*f7Slot*/ 2) && { "data-f7-slot": /*f7Slot*/ ctx[1] },
    				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(before_inner_slot, local);
    			transition_in(if_block);
    			transition_in(after_inner_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(before_inner_slot, local);
    			transition_out(if_block);
    			transition_out(after_inner_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (before_inner_slot) before_inner_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (after_inner_slot) after_inner_slot.d(detaching);
    			/*div_binding*/ ctx[25](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","tabbar","labels","scrollable","hidden","noShadow","noHairline","noBorder","position","topMd","topIos","topAurora","top","bottomMd","bottomIos","bottomAurora","bottom","inner","f7Slot"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Toolbar', slots, ['before-inner','default','after-inner']);
    	const emit = createEmitter(createEventDispatcher, $$props);
    	let { class: className = undefined } = $$props;
    	let { tabbar = false } = $$props;
    	let { labels = false } = $$props;
    	let { scrollable = false } = $$props;
    	let { hidden = false } = $$props;
    	let { noShadow = false } = $$props;
    	let { noHairline = false } = $$props;
    	let { noBorder = false } = $$props;
    	let { position = undefined } = $$props;
    	let { topMd = undefined } = $$props;
    	let { topIos = undefined } = $$props;
    	let { topAurora = undefined } = $$props;
    	let { top = undefined } = $$props;
    	let { bottomMd = undefined } = $$props;
    	let { bottomIos = undefined } = $$props;
    	let { bottomAurora = undefined } = $$props;
    	let { bottom = undefined } = $$props;
    	let { inner = true } = $$props;
    	let { f7Slot = 'fixed' } = $$props;
    	let el;

    	let theme = useTheme(t => {
    		$$invalidate(22, theme = t);
    	});

    	setReactiveContext('TabbarContext', () => ({ tabbarHasLabels: labels }));

    	function onShow(toolbarEl) {
    		if (el !== toolbarEl) return;
    		emit('toolbarShow');
    	}

    	function onHide(toolbarEl) {
    		if (el !== toolbarEl) return;
    		emit('toolbarHide');
    	}

    	onMount(() => {
    		f7ready(() => {
    			if (tabbar) app$1.f7.toolbar.setHighlight(el);
    			app$1.f7.on('toolbarShow', onShow);
    			app$1.f7.on('toolbarHide', onHide);
    		});
    	});

    	afterUpdate(() => {
    		if (tabbar && app$1.f7 && el) {
    			app$1.f7.toolbar.setHighlight(el);
    		}
    	});

    	onDestroy(() => {
    		if (!app$1.f7) return;
    		app$1.f7.off('toolbarShow', onShow);
    		app$1.f7.off('toolbarHide', onHide);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(2, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
    		if ('tabbar' in $$new_props) $$invalidate(6, tabbar = $$new_props.tabbar);
    		if ('labels' in $$new_props) $$invalidate(7, labels = $$new_props.labels);
    		if ('scrollable' in $$new_props) $$invalidate(8, scrollable = $$new_props.scrollable);
    		if ('hidden' in $$new_props) $$invalidate(9, hidden = $$new_props.hidden);
    		if ('noShadow' in $$new_props) $$invalidate(10, noShadow = $$new_props.noShadow);
    		if ('noHairline' in $$new_props) $$invalidate(11, noHairline = $$new_props.noHairline);
    		if ('noBorder' in $$new_props) $$invalidate(12, noBorder = $$new_props.noBorder);
    		if ('position' in $$new_props) $$invalidate(13, position = $$new_props.position);
    		if ('topMd' in $$new_props) $$invalidate(14, topMd = $$new_props.topMd);
    		if ('topIos' in $$new_props) $$invalidate(15, topIos = $$new_props.topIos);
    		if ('topAurora' in $$new_props) $$invalidate(16, topAurora = $$new_props.topAurora);
    		if ('top' in $$new_props) $$invalidate(17, top = $$new_props.top);
    		if ('bottomMd' in $$new_props) $$invalidate(18, bottomMd = $$new_props.bottomMd);
    		if ('bottomIos' in $$new_props) $$invalidate(19, bottomIos = $$new_props.bottomIos);
    		if ('bottomAurora' in $$new_props) $$invalidate(20, bottomAurora = $$new_props.bottomAurora);
    		if ('bottom' in $$new_props) $$invalidate(21, bottom = $$new_props.bottom);
    		if ('inner' in $$new_props) $$invalidate(0, inner = $$new_props.inner);
    		if ('f7Slot' in $$new_props) $$invalidate(1, f7Slot = $$new_props.f7Slot);
    		if ('$$scope' in $$new_props) $$invalidate(23, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		onDestroy,
    		afterUpdate,
    		colorClasses,
    		classNames,
    		createEmitter,
    		restProps,
    		app: app$1,
    		f7ready,
    		useTheme,
    		setReactiveContext,
    		emit,
    		className,
    		tabbar,
    		labels,
    		scrollable,
    		hidden,
    		noShadow,
    		noHairline,
    		noBorder,
    		position,
    		topMd,
    		topIos,
    		topAurora,
    		top,
    		bottomMd,
    		bottomIos,
    		bottomAurora,
    		bottom,
    		inner,
    		f7Slot,
    		el,
    		theme,
    		onShow,
    		onHide,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(29, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(5, className = $$new_props.className);
    		if ('tabbar' in $$props) $$invalidate(6, tabbar = $$new_props.tabbar);
    		if ('labels' in $$props) $$invalidate(7, labels = $$new_props.labels);
    		if ('scrollable' in $$props) $$invalidate(8, scrollable = $$new_props.scrollable);
    		if ('hidden' in $$props) $$invalidate(9, hidden = $$new_props.hidden);
    		if ('noShadow' in $$props) $$invalidate(10, noShadow = $$new_props.noShadow);
    		if ('noHairline' in $$props) $$invalidate(11, noHairline = $$new_props.noHairline);
    		if ('noBorder' in $$props) $$invalidate(12, noBorder = $$new_props.noBorder);
    		if ('position' in $$props) $$invalidate(13, position = $$new_props.position);
    		if ('topMd' in $$props) $$invalidate(14, topMd = $$new_props.topMd);
    		if ('topIos' in $$props) $$invalidate(15, topIos = $$new_props.topIos);
    		if ('topAurora' in $$props) $$invalidate(16, topAurora = $$new_props.topAurora);
    		if ('top' in $$props) $$invalidate(17, top = $$new_props.top);
    		if ('bottomMd' in $$props) $$invalidate(18, bottomMd = $$new_props.bottomMd);
    		if ('bottomIos' in $$props) $$invalidate(19, bottomIos = $$new_props.bottomIos);
    		if ('bottomAurora' in $$props) $$invalidate(20, bottomAurora = $$new_props.bottomAurora);
    		if ('bottom' in $$props) $$invalidate(21, bottom = $$new_props.bottom);
    		if ('inner' in $$props) $$invalidate(0, inner = $$new_props.inner);
    		if ('f7Slot' in $$props) $$invalidate(1, f7Slot = $$new_props.f7Slot);
    		if ('el' in $$props) $$invalidate(2, el = $$new_props.el);
    		if ('theme' in $$props) $$invalidate(22, theme = $$new_props.theme);
    		if ('classes' in $$props) $$invalidate(3, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(3, classes = classNames(
    			className,
    			'toolbar',
    			{
    				tabbar,
    				'toolbar-bottom': theme && theme.md && bottomMd || theme && theme.ios && bottomIos || theme && theme.aurora && bottomAurora || bottom || position === 'bottom',
    				'toolbar-top': theme && theme.md && topMd || theme && theme.ios && topIos || theme && theme.aurora && topAurora || top || position === 'top',
    				'tabbar-labels': labels,
    				'tabbar-scrollable': scrollable,
    				'toolbar-hidden': hidden,
    				'no-shadow': noShadow,
    				'no-hairline': noHairline || noBorder
    			},
    			colorClasses($$props)
    		));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		inner,
    		f7Slot,
    		el,
    		classes,
    		$$restProps,
    		className,
    		tabbar,
    		labels,
    		scrollable,
    		hidden,
    		noShadow,
    		noHairline,
    		noBorder,
    		position,
    		topMd,
    		topIos,
    		topAurora,
    		top,
    		bottomMd,
    		bottomIos,
    		bottomAurora,
    		bottom,
    		theme,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class Toolbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$5, create_fragment$6, safe_not_equal, {
    			class: 5,
    			tabbar: 6,
    			labels: 7,
    			scrollable: 8,
    			hidden: 9,
    			noShadow: 10,
    			noHairline: 11,
    			noBorder: 12,
    			position: 13,
    			topMd: 14,
    			topIos: 15,
    			topAurora: 16,
    			top: 17,
    			bottomMd: 18,
    			bottomIos: 19,
    			bottomAurora: 20,
    			bottom: 21,
    			inner: 0,
    			f7Slot: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Toolbar",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get class() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabbar() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabbar(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labels() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labels(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollable() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollable(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hidden() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hidden(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noShadow() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noShadow(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noHairline() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noHairline(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noBorder() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noBorder(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get position() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get topMd() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set topMd(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get topIos() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set topIos(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get topAurora() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set topAurora(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get top() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set top(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bottomMd() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bottomMd(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bottomIos() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bottomIos(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bottomAurora() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bottomAurora(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bottom() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bottom(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inner() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inner(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get f7Slot() {
    		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set f7Slot(value) {
    		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
    var getRouterInitialComponent = function getRouterInitialComponent(router, initialComponent) {
      var initialComponentData;

      var _router$getInitialUrl = router.getInitialUrl(),
          initialUrl = _router$getInitialUrl.initialUrl;

      var initialRoute = router.findMatchingRoute(initialUrl);
      var routeProps = {};

      if (initialRoute && initialRoute.route && initialRoute.route.options) {
        routeProps = initialRoute.route.options.props;
      }

      var isMasterRoute = function isMasterRoute(route) {
        if (route.master === true) return true;
        if (typeof route.master === 'function') return route.master(router.app);
        return false;
      };

      if (initialRoute && initialRoute.route && (initialRoute.route.component || initialRoute.route.asyncComponent) && !isMasterRoute(initialRoute.route)) {
        initialComponentData = {
          component: initialRoute.route.component || initialRoute.route.asyncComponent,
          initialComponent: initialComponent,
          id: getComponentId(),
          isAsync: !!initialRoute.route.asyncComponent,
          props: _extends({
            f7route: initialRoute,
            f7router: router
          }, initialRoute.params, routeProps)
        };
      }

      return {
        initialPage: initialComponentData,
        initialRoute: initialRoute
      };
    };

    /* node_modules/framework7-svelte/esm/svelte/view.svelte generated by Svelte v3.44.0 */
    const file$3 = "node_modules/framework7-svelte/esm/svelte/view.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[29] = list[i];
    	return child_ctx;
    }

    const get_default_slot_changes = dirty => ({ view: dirty[0] & /*f7View*/ 8 });
    const get_default_slot_context = ctx => ({ view: /*f7View*/ ctx[3] });

    // (194:4) <RouterContextProvider route={page.props.f7route} router={page.props.f7router}>
    function create_default_slot$5(ctx) {
    	let switch_instance;
    	let t;
    	let current;
    	const switch_instance_spread_levels = [/*page*/ ctx[29].props];
    	var switch_value = /*page*/ ctx[29].component;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty[0] & /*pages*/ 16)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*page*/ ctx[29].props)])
    			: {};

    			if (switch_value !== (switch_value = /*page*/ ctx[29].component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, t.parentNode, t);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (switch_instance) destroy_component(switch_instance, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(194:4) <RouterContextProvider route={page.props.f7route} router={page.props.f7router}>",
    		ctx
    	});

    	return block;
    }

    // (193:2) {#each pages as page (page.id)}
    function create_each_block(key_1, ctx) {
    	let first;
    	let routercontextprovider;
    	let current;

    	routercontextprovider = new Router_context_provider({
    			props: {
    				route: /*page*/ ctx[29].props.f7route,
    				router: /*page*/ ctx[29].props.f7router,
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(routercontextprovider.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(routercontextprovider, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const routercontextprovider_changes = {};
    			if (dirty[0] & /*pages*/ 16) routercontextprovider_changes.route = /*page*/ ctx[29].props.f7route;
    			if (dirty[0] & /*pages*/ 16) routercontextprovider_changes.router = /*page*/ ctx[29].props.f7router;

    			if (dirty[0] & /*$$scope, pages*/ 4112) {
    				routercontextprovider_changes.$$scope = { dirty, ctx };
    			}

    			routercontextprovider.$set(routercontextprovider_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(routercontextprovider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(routercontextprovider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(routercontextprovider, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(193:2) {#each pages as page (page.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div;
    	let t;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context);
    	let each_value = /*pages*/ ctx[4];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*page*/ ctx[29].id;
    	validate_each_keys(ctx, each_value, get_each_context, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", /*classes*/ ctx[5]);
    			attr_dev(div, "style", /*style*/ ctx[1]);
    			attr_dev(div, "id", /*id*/ ctx[0]);
    			add_location(div, file$3, 190, 0, 5403);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			/*div_binding*/ ctx[11](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope, f7View*/ 4104)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[12],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			}

    			if (dirty[0] & /*pages*/ 16) {
    				each_value = /*pages*/ ctx[4];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
    				check_outros();
    			}

    			if (!current || dirty[0] & /*classes*/ 32) {
    				attr_dev(div, "class", /*classes*/ ctx[5]);
    			}

    			if (!current || dirty[0] & /*style*/ 2) {
    				attr_dev(div, "style", /*style*/ ctx[1]);
    			}

    			if (!current || dirty[0] & /*id*/ 1) {
    				attr_dev(div, "id", /*id*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*div_binding*/ ctx[11](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance_1($$self, $$props, $$invalidate) {
    	let classes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('View', slots, ['default']);
    	let { id = undefined } = $$props;
    	let { style = undefined } = $$props;
    	let { init = true } = $$props;
    	let { url = undefined } = $$props;
    	let { class: className = undefined } = $$props;
    	const emit = createEmitter(createEventDispatcher, $$props);
    	const { main, tab, tabActive, browserHistoryInitialMatch = true } = $$props;
    	let initialPage;
    	let initialRoute;
    	let el;
    	let routerData;
    	let f7View;

    	function instance() {
    		return f7View;
    	}

    	function onViewInit(view) {
    		emit('viewInit', [view]);

    		if (!init) {
    			$$invalidate(3, f7View = view);
    			routerData.instance = view;
    		}
    	}

    	if (app$1.f7 && !f7View && init) {
    		const routerId = getRouterId();

    		f7View = app$1.f7.views.create(el, {
    			routerId,
    			init: false,
    			...noUndefinedProps($$props),
    			browserHistoryInitialMatch,
    			on: { init: onViewInit }
    		});

    		routerData = { routerId, instance: f7View };
    		app$1.f7routers.views.push(routerData);

    		if (f7View && f7View.router && (url || main)) {
    			const initialData = getRouterInitialComponent(f7View.router);
    			initialPage = initialData.initialPage;
    			initialRoute = initialData.initialRoute;

    			if (initialRoute && initialRoute.route && initialRoute.route.masterRoute) {
    				initialPage = undefined;
    				initialRoute = undefined;
    			}
    		}
    	}

    	let pages = initialPage ? [initialPage] : [];

    	function onResize(view, width) {
    		emit('viewResize', [width]);
    	}

    	function onSwipeBackMove(data) {
    		emit('swipeBackMove', [data]);
    	}

    	function onSwipeBackBeforeChange(data) {
    		emit('swipeBackBeforeChange', [data]);
    	}

    	function onSwipeBackAfterChange(data) {
    		emit('swipeBackAfterChange', [data]);
    	}

    	function onSwipeBackBeforeReset(data) {
    		emit('swipeBackBeforeReset', [data]);
    	}

    	function onSwipeBackAfterReset(data) {
    		emit('swipeBackAfterReset', [data]);
    	}

    	useTab(() => el, emit);

    	onMount(() => {
    		f7ready(() => {
    			if (f7View) {
    				routerData.el = el;
    				routerData.pages = pages;

    				routerData.setPages = newPages => {
    					tick().then(() => {
    						$$invalidate(4, pages = newPages);
    					});
    				};

    				if (initialPage && initialPage.isAsync && !initialPage.initialComponent) {
    					initialPage.component().then(() => {
    						setTimeout(
    							() => {
    								f7View.init(el);

    								if (initialPage) {
    									initialPage.el = f7View.router.currentPageEl;

    									if (initialRoute && initialRoute.route && initialRoute.route.keepAlive) {
    										initialRoute.route.keepAliveData = { pageEl: initialPage.el };
    									}
    								}
    							},
    							100
    						);
    					});
    				} else {
    					f7View.init(el);

    					if (initialPage) {
    						initialPage.el = f7View.router.currentPageEl;

    						if (initialRoute && initialRoute.route && initialRoute.route.keepAlive) {
    							initialRoute.route.keepAliveData = { pageEl: initialPage.el };
    						}
    					}
    				}
    			} else {
    				const routerId = getRouterId();

    				routerData = {
    					el,
    					routerId,
    					pages,
    					instance: f7View,
    					setPages(newPages) {
    						tick().then(() => {
    							$$invalidate(4, pages = newPages);
    						});
    					}
    				};

    				app$1.f7routers.views.push(routerData);

    				routerData.instance = app$1.f7.views.create(el, {
    					routerId,
    					...noUndefinedProps($$props),
    					browserHistoryInitialMatch,
    					on: { init: onViewInit }
    				});

    				$$invalidate(3, f7View = routerData.instance);
    			}

    			if (!init) return;
    			f7View.on('resize', onResize);
    			f7View.on('swipebackMove', onSwipeBackMove);
    			f7View.on('swipebackBeforeChange', onSwipeBackBeforeChange);
    			f7View.on('swipebackAfterChange', onSwipeBackAfterChange);
    			f7View.on('swipebackBeforeReset', onSwipeBackBeforeReset);
    			f7View.on('swipebackAfterReset', onSwipeBackAfterReset);
    		});
    	});

    	afterUpdate(() => {
    		if (!routerData) return;
    		app$1.f7events.emit('viewRouterDidUpdate', routerData);
    	});

    	onDestroy(() => {
    		if (f7View) {
    			f7View.off('resize', onResize);
    			f7View.off('swipebackMove', onSwipeBackMove);
    			f7View.off('swipebackBeforeChange', onSwipeBackBeforeChange);
    			f7View.off('swipebackAfterChange', onSwipeBackAfterChange);
    			f7View.off('swipebackBeforeReset', onSwipeBackBeforeReset);
    			f7View.off('swipebackAfterReset', onSwipeBackAfterReset);
    			if (f7View.destroy) f7View.destroy();
    			$$invalidate(3, f7View = null);
    		}

    		app$1.f7routers.views.splice(app$1.f7routers.views.indexOf(routerData), 1);
    		routerData = null;
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(2, el);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(28, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('id' in $$new_props) $$invalidate(0, id = $$new_props.id);
    		if ('style' in $$new_props) $$invalidate(1, style = $$new_props.style);
    		if ('init' in $$new_props) $$invalidate(6, init = $$new_props.init);
    		if ('url' in $$new_props) $$invalidate(7, url = $$new_props.url);
    		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		afterUpdate,
    		createEventDispatcher,
    		tick,
    		app: app$1,
    		f7ready,
    		colorClasses,
    		classNames,
    		noUndefinedProps,
    		createEmitter,
    		getRouterId,
    		getRouterInitialComponent,
    		useTab,
    		RouterContextProvider: Router_context_provider,
    		id,
    		style,
    		init,
    		url,
    		className,
    		emit,
    		main,
    		tab,
    		tabActive,
    		browserHistoryInitialMatch,
    		initialPage,
    		initialRoute,
    		el,
    		routerData,
    		f7View,
    		instance,
    		onViewInit,
    		pages,
    		onResize,
    		onSwipeBackMove,
    		onSwipeBackBeforeChange,
    		onSwipeBackAfterChange,
    		onSwipeBackBeforeReset,
    		onSwipeBackAfterReset,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(28, $$props = assign(assign({}, $$props), $$new_props));
    		if ('id' in $$props) $$invalidate(0, id = $$new_props.id);
    		if ('style' in $$props) $$invalidate(1, style = $$new_props.style);
    		if ('init' in $$props) $$invalidate(6, init = $$new_props.init);
    		if ('url' in $$props) $$invalidate(7, url = $$new_props.url);
    		if ('className' in $$props) $$invalidate(8, className = $$new_props.className);
    		if ('initialPage' in $$props) initialPage = $$new_props.initialPage;
    		if ('initialRoute' in $$props) initialRoute = $$new_props.initialRoute;
    		if ('el' in $$props) $$invalidate(2, el = $$new_props.el);
    		if ('routerData' in $$props) routerData = $$new_props.routerData;
    		if ('f7View' in $$props) $$invalidate(3, f7View = $$new_props.f7View);
    		if ('pages' in $$props) $$invalidate(4, pages = $$new_props.pages);
    		if ('classes' in $$props) $$invalidate(5, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(5, classes = classNames(
    			className,
    			'view',
    			{
    				'view-main': main,
    				'tab-active': tabActive,
    				tab
    			},
    			colorClasses($$props)
    		));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		id,
    		style,
    		el,
    		f7View,
    		pages,
    		classes,
    		init,
    		url,
    		className,
    		instance,
    		slots,
    		div_binding,
    		$$scope
    	];
    }

    class View extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance_1,
    			create_fragment$5,
    			safe_not_equal,
    			{
    				id: 0,
    				style: 1,
    				init: 6,
    				url: 7,
    				class: 8,
    				instance: 9
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "View",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get id() {
    		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get init() {
    		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set init(value) {
    		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get instance() {
    		return this.$$.ctx[9];
    	}

    	set instance(value) {
    		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/pages/MusicListPage.svelte generated by Svelte v3.44.0 */

    const file$2 = "src/pages/MusicListPage.svelte";

    // (11:6) <NavRight>
    function create_default_slot_6(ctx) {
    	let link0;
    	let t;
    	let link1;
    	let current;

    	link0 = new Link({
    			props: {
    				iconMd: "material:leak_add",
    				iconOnly: true,
    				href: "/rooms/"
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				iconMd: "material:settings",
    				iconOnly: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link0.$$.fragment);
    			t = space();
    			create_component(link1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(link1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(link1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(11:6) <NavRight>",
    		ctx
    	});

    	return block;
    }

    // (10:4) <Navbar title="Multiroom Audio">
    function create_default_slot_5(ctx) {
    	let navright;
    	let current;

    	navright = new Nav_right({
    			props: {
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navright.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navright, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navright_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				navright_changes.$$scope = { dirty, ctx };
    			}

    			navright.$set(navright_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navright.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navright.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navright, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(10:4) <Navbar title=\\\"Multiroom Audio\\\">",
    		ctx
    	});

    	return block;
    }

    // (17:4) <Toolbar bottom>
    function create_default_slot_4(ctx) {
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				iconMd: "material:play_arrow",
    				iconOnly: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(17:4) <Toolbar bottom>",
    		ctx
    	});

    	return block;
    }

    // (20:4) <BlockTitle>
    function create_default_slot_3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Connected speakers");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(20:4) <BlockTitle>",
    		ctx
    	});

    	return block;
    }

    // (31:4) <BlockTitle>
    function create_default_slot_2$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("SLAC song list");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(31:4) <BlockTitle>",
    		ctx
    	});

    	return block;
    }

    // (37:8) 
    function create_media_slot_2(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "slot", "media");
    			attr_dev(img, "alt", "");
    			if (!src_url_equal(img.src, img_src_value = "https://cdn.framework7.io/placeholder/fashion-88x88-4.jpg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "width", "44");
    			add_location(img, file$2, 36, 8, 1065);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_media_slot_2.name,
    		type: "slot",
    		source: "(37:8) ",
    		ctx
    	});

    	return block;
    }

    // (38:8) 
    function create_after_slot_2$1(ctx) {
    	let span;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				iconMd: "material:play_arrow",
    				iconOnly: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(link.$$.fragment);
    			attr_dev(span, "slot", "after");
    			add_location(span, file$2, 37, 8, 1175);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(link, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_after_slot_2$1.name,
    		type: "slot",
    		source: "(38:8) ",
    		ctx
    	});

    	return block;
    }

    // (46:8) 
    function create_media_slot_1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "slot", "media");
    			attr_dev(img, "alt", "");
    			if (!src_url_equal(img.src, img_src_value = "https://cdn.framework7.io/placeholder/fashion-88x88-5.jpg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "width", "44");
    			add_location(img, file$2, 45, 8, 1383);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_media_slot_1.name,
    		type: "slot",
    		source: "(46:8) ",
    		ctx
    	});

    	return block;
    }

    // (47:8) 
    function create_after_slot_1$1(ctx) {
    	let span;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				iconMd: "material:play_arrow",
    				iconOnly: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(link.$$.fragment);
    			attr_dev(span, "slot", "after");
    			add_location(span, file$2, 46, 8, 1493);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(link, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_after_slot_1$1.name,
    		type: "slot",
    		source: "(47:8) ",
    		ctx
    	});

    	return block;
    }

    // (55:8) 
    function create_media_slot(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "slot", "media");
    			attr_dev(img, "alt", "");
    			if (!src_url_equal(img.src, img_src_value = "https://cdn.framework7.io/placeholder/fashion-88x88-6.jpg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "width", "44");
    			add_location(img, file$2, 54, 8, 1705);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_media_slot.name,
    		type: "slot",
    		source: "(55:8) ",
    		ctx
    	});

    	return block;
    }

    // (56:8) 
    function create_after_slot$1(ctx) {
    	let span;
    	let link;
    	let current;

    	link = new Link({
    			props: {
    				iconMd: "material:play_arrow",
    				iconOnly: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(link.$$.fragment);
    			attr_dev(span, "slot", "after");
    			add_location(span, file$2, 55, 8, 1815);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(link, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_after_slot$1.name,
    		type: "slot",
    		source: "(56:8) ",
    		ctx
    	});

    	return block;
    }

    // (32:4) <List medial-list>
    function create_default_slot_1$3(ctx) {
    	let listitem0;
    	let t0;
    	let listitem1;
    	let t1;
    	let listitem2;
    	let current;

    	listitem0 = new List_item({
    			props: {
    				title: "Yellow Submarine",
    				subtitle: "Beatles",
    				$$slots: {
    					after: [create_after_slot_2$1],
    					media: [create_media_slot_2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	listitem1 = new List_item({
    			props: {
    				title: "Don't Stop Me Now",
    				subtitle: "Queen",
    				$$slots: {
    					after: [create_after_slot_1$1],
    					media: [create_media_slot_1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	listitem2 = new List_item({
    			props: {
    				title: "Billie Jean",
    				subtitle: "Michael Jackson",
    				$$slots: {
    					after: [create_after_slot$1],
    					media: [create_media_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(listitem0.$$.fragment);
    			t0 = space();
    			create_component(listitem1.$$.fragment);
    			t1 = space();
    			create_component(listitem2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(listitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(listitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(listitem2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listitem0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				listitem0_changes.$$scope = { dirty, ctx };
    			}

    			listitem0.$set(listitem0_changes);
    			const listitem1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				listitem1_changes.$$scope = { dirty, ctx };
    			}

    			listitem1.$set(listitem1_changes);
    			const listitem2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				listitem2_changes.$$scope = { dirty, ctx };
    			}

    			listitem2.$set(listitem2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listitem0.$$.fragment, local);
    			transition_in(listitem1.$$.fragment, local);
    			transition_in(listitem2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listitem0.$$.fragment, local);
    			transition_out(listitem1.$$.fragment, local);
    			transition_out(listitem2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(listitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(listitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(listitem2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(32:4) <List medial-list>",
    		ctx
    	});

    	return block;
    }

    // (8:0) <Page>
    function create_default_slot$4(ctx) {
    	let navbar;
    	let t0;
    	let toolbar;
    	let t1;
    	let blocktitle0;
    	let t2;
    	let div6;
    	let div0;
    	let link;
    	let t3;
    	let div1;
    	let t4;
    	let div2;
    	let t5;
    	let div3;
    	let t6;
    	let div4;
    	let t7;
    	let div5;
    	let t8;
    	let blocktitle1;
    	let t9;
    	let list;
    	let current;

    	navbar = new Navbar({
    			props: {
    				title: "Multiroom Audio",
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toolbar = new Toolbar({
    			props: {
    				bottom: true,
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	blocktitle0 = new Block_title({
    			props: {
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link = new Link({
    			props: { iconMd: "material:add", iconOnly: true },
    			$$inline: true
    		});

    	blocktitle1 = new Block_title({
    			props: {
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	list = new List({
    			props: {
    				"medial-list": true,
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			create_component(toolbar.$$.fragment);
    			t1 = space();
    			create_component(blocktitle0.$$.fragment);
    			t2 = space();
    			div6 = element("div");
    			div0 = element("div");
    			create_component(link.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			t4 = space();
    			div2 = element("div");
    			t5 = space();
    			div3 = element("div");
    			t6 = space();
    			div4 = element("div");
    			t7 = space();
    			div5 = element("div");
    			t8 = space();
    			create_component(blocktitle1.$$.fragment);
    			t9 = space();
    			create_component(list.$$.fragment);
    			attr_dev(div0, "class", "item svelte-1jnm0ir");
    			add_location(div0, file$2, 21, 6, 655);
    			attr_dev(div1, "class", "item svelte-1jnm0ir");
    			add_location(div1, file$2, 24, 6, 746);
    			attr_dev(div2, "class", "item svelte-1jnm0ir");
    			add_location(div2, file$2, 25, 6, 777);
    			attr_dev(div3, "class", "item svelte-1jnm0ir");
    			add_location(div3, file$2, 26, 6, 808);
    			attr_dev(div4, "class", "item svelte-1jnm0ir");
    			add_location(div4, file$2, 27, 6, 839);
    			attr_dev(div5, "class", "item svelte-1jnm0ir");
    			add_location(div5, file$2, 28, 6, 870);
    			attr_dev(div6, "class", "container svelte-1jnm0ir");
    			add_location(div6, file$2, 20, 4, 625);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(toolbar, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(blocktitle0, target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div0);
    			mount_component(link, div0, null);
    			append_dev(div6, t3);
    			append_dev(div6, div1);
    			append_dev(div6, t4);
    			append_dev(div6, div2);
    			append_dev(div6, t5);
    			append_dev(div6, div3);
    			append_dev(div6, t6);
    			append_dev(div6, div4);
    			append_dev(div6, t7);
    			append_dev(div6, div5);
    			insert_dev(target, t8, anchor);
    			mount_component(blocktitle1, target, anchor);
    			insert_dev(target, t9, anchor);
    			mount_component(list, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const toolbar_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				toolbar_changes.$$scope = { dirty, ctx };
    			}

    			toolbar.$set(toolbar_changes);
    			const blocktitle0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				blocktitle0_changes.$$scope = { dirty, ctx };
    			}

    			blocktitle0.$set(blocktitle0_changes);
    			const blocktitle1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				blocktitle1_changes.$$scope = { dirty, ctx };
    			}

    			blocktitle1.$set(blocktitle1_changes);
    			const list_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				list_changes.$$scope = { dirty, ctx };
    			}

    			list.$set(list_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(toolbar.$$.fragment, local);
    			transition_in(blocktitle0.$$.fragment, local);
    			transition_in(link.$$.fragment, local);
    			transition_in(blocktitle1.$$.fragment, local);
    			transition_in(list.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(toolbar.$$.fragment, local);
    			transition_out(blocktitle0.$$.fragment, local);
    			transition_out(link.$$.fragment, local);
    			transition_out(blocktitle1.$$.fragment, local);
    			transition_out(list.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(toolbar, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(blocktitle0, detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div6);
    			destroy_component(link);
    			if (detaching) detach_dev(t8);
    			destroy_component(blocktitle1, detaching);
    			if (detaching) detach_dev(t9);
    			destroy_component(list, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(8:0) <Page>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let page;
    	let current;

    	page = new Page({
    			props: {
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(page.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(page, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const page_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				page_changes.$$scope = { dirty, ctx };
    			}

    			page.$set(page_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(page.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(page.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(page, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MusicListPage', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MusicListPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Page,
    		Navbar,
    		Toolbar,
    		Link,
    		Block,
    		BlockTitle: Block_title,
    		Row,
    		Col,
    		Button,
    		NavRight: Nav_right,
    		Toggle,
    		ListItem: List_item,
    		List,
    		Card,
    		CardContent: Card_content,
    		CardHeader: Card_header
    	});

    	return [];
    }

    class MusicListPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MusicListPage",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src/pages/AboutPage.svelte generated by Svelte v3.44.0 */
    const file$1 = "src/pages/AboutPage.svelte";

    // (9:4) <Block strong>
    function create_default_slot_1$2(ctx) {
    	let p0;
    	let t1;
    	let p1;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "Sorry";
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "BELLA.";
    			add_location(p0, file$1, 9, 8, 192);
    			add_location(p1, file$1, 10, 8, 213);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(9:4) <Block strong>",
    		ctx
    	});

    	return block;
    }

    // (5:0) <Page>
    function create_default_slot$3(ctx) {
    	let navbar;
    	let t;
    	let block;
    	let current;

    	navbar = new Navbar({
    			props: { title: "About", backLink: "Back" },
    			$$inline: true
    		});

    	block = new Block({
    			props: {
    				strong: true,
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block_1 = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t = space();
    			create_component(block.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(block, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const block_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				block_changes.$$scope = { dirty, ctx };
    			}

    			block.$set(block_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(block.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(block.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(block, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(5:0) <Page>",
    		ctx
    	});

    	return block_1;
    }

    function create_fragment$3(ctx) {
    	let page;
    	let current;

    	page = new Page({
    			props: {
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(page.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(page, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const page_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				page_changes.$$scope = { dirty, ctx };
    			}

    			page.$set(page_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(page.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(page.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(page, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AboutPage', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AboutPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Page, Navbar, Block });
    	return [];
    }

    class AboutPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AboutPage",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src/pages/RoomsPage.svelte generated by Svelte v3.44.0 */
    const file = "src/pages/RoomsPage.svelte";

    // (8:4) <Fab position="right-bottom" href="/calibration/">
    function create_default_slot_2$1(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { md: "material:add" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(8:4) <Fab position=\\\"right-bottom\\\" href=\\\"/calibration/\\\">",
    		ctx
    	});

    	return block;
    }

    // (14:12) 
    function create_after_slot_2(ctx) {
    	let span;
    	let link;
    	let current;

    	link = new Link({
    			props: { iconMd: "material:delete", color: "red" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(link.$$.fragment);
    			attr_dev(span, "slot", "after");
    			add_location(span, file, 13, 12, 361);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(link, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_after_slot_2.name,
    		type: "slot",
    		source: "(14:12) ",
    		ctx
    	});

    	return block;
    }

    // (19:12) 
    function create_after_slot_1(ctx) {
    	let span;
    	let link;
    	let current;

    	link = new Link({
    			props: { iconMd: "material:delete", color: "red" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(link.$$.fragment);
    			attr_dev(span, "slot", "after");
    			add_location(span, file, 18, 12, 540);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(link, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_after_slot_1.name,
    		type: "slot",
    		source: "(19:12) ",
    		ctx
    	});

    	return block;
    }

    // (24:12) 
    function create_after_slot(ctx) {
    	let span;
    	let link;
    	let current;

    	link = new Link({
    			props: { iconMd: "material:delete", color: "red" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(link.$$.fragment);
    			attr_dev(span, "slot", "after");
    			add_location(span, file, 23, 12, 730);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(link, span, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_after_slot.name,
    		type: "slot",
    		source: "(24:12) ",
    		ctx
    	});

    	return block;
    }

    // (12:4) <List>
    function create_default_slot_1$1(ctx) {
    	let listitem0;
    	let t0;
    	let listitem1;
    	let t1;
    	let listitem2;
    	let current;

    	listitem0 = new List_item({
    			props: {
    				title: "Cucina",
    				$$slots: { after: [create_after_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	listitem1 = new List_item({
    			props: {
    				title: "Camera Luca",
    				$$slots: { after: [create_after_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	listitem2 = new List_item({
    			props: {
    				title: "Cammera Andrea",
    				$$slots: { after: [create_after_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(listitem0.$$.fragment);
    			t0 = space();
    			create_component(listitem1.$$.fragment);
    			t1 = space();
    			create_component(listitem2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(listitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(listitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(listitem2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listitem0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				listitem0_changes.$$scope = { dirty, ctx };
    			}

    			listitem0.$set(listitem0_changes);
    			const listitem1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				listitem1_changes.$$scope = { dirty, ctx };
    			}

    			listitem1.$set(listitem1_changes);
    			const listitem2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				listitem2_changes.$$scope = { dirty, ctx };
    			}

    			listitem2.$set(listitem2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listitem0.$$.fragment, local);
    			transition_in(listitem1.$$.fragment, local);
    			transition_in(listitem2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listitem0.$$.fragment, local);
    			transition_out(listitem1.$$.fragment, local);
    			transition_out(listitem2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(listitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(listitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(listitem2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(12:4) <List>",
    		ctx
    	});

    	return block;
    }

    // (5:0) <Page>
    function create_default_slot$2(ctx) {
    	let navbar;
    	let t0;
    	let fab;
    	let t1;
    	let list;
    	let current;

    	navbar = new Navbar({
    			props: { title: "House rooms", backLink: "Back" },
    			$$inline: true
    		});

    	fab = new Fab({
    			props: {
    				position: "right-bottom",
    				href: "/calibration/",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	list = new List({
    			props: {
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			create_component(fab.$$.fragment);
    			t1 = space();
    			create_component(list.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fab, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(list, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fab_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				fab_changes.$$scope = { dirty, ctx };
    			}

    			fab.$set(fab_changes);
    			const list_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				list_changes.$$scope = { dirty, ctx };
    			}

    			list.$set(list_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(fab.$$.fragment, local);
    			transition_in(list.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(fab.$$.fragment, local);
    			transition_out(list.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fab, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(list, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(5:0) <Page>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let page;
    	let current;

    	page = new Page({
    			props: {
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(page.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(page, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const page_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				page_changes.$$scope = { dirty, ctx };
    			}

    			page.$set(page_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(page.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(page.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(page, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RoomsPage', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RoomsPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Page,
    		Navbar,
    		Fab,
    		Icon,
    		Link,
    		ListItem: List_item,
    		List
    	});

    	return [];
    }

    class RoomsPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RoomsPage",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/pages/CalibrationPage.svelte generated by Svelte v3.44.0 */

    // (8:4) <Fab position="center-bottom" text="Save">
    function create_default_slot_2(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { md: "material:done" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(8:4) <Fab position=\\\"center-bottom\\\" text=\\\"Save\\\">",
    		ctx
    	});

    	return block;
    }

    // (12:6) <List noHairlinesMd>
    function create_default_slot_1(ctx) {
    	let listinput;
    	let current;

    	listinput = new List_input({
    			props: {
    				outline: true,
    				label: "Name",
    				floatingLabel: true,
    				type: "text",
    				placeholder: "Your name",
    				clearButton: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(listinput.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(listinput, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(listinput, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(12:6) <List noHairlinesMd>",
    		ctx
    	});

    	return block;
    }

    // (5:0) <Page>
    function create_default_slot$1(ctx) {
    	let navbar;
    	let t0;
    	let fab;
    	let t1;
    	let list;
    	let current;

    	navbar = new Navbar({
    			props: { title: "Add room", backLink: "Back" },
    			$$inline: true
    		});

    	fab = new Fab({
    			props: {
    				position: "center-bottom",
    				text: "Save",
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	list = new List({
    			props: {
    				noHairlinesMd: true,
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			create_component(fab.$$.fragment);
    			t1 = space();
    			create_component(list.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fab, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(list, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fab_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				fab_changes.$$scope = { dirty, ctx };
    			}

    			fab.$set(fab_changes);
    			const list_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				list_changes.$$scope = { dirty, ctx };
    			}

    			list.$set(list_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(fab.$$.fragment, local);
    			transition_in(list.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(fab.$$.fragment, local);
    			transition_out(list.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fab, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(list, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(5:0) <Page>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let page;
    	let current;

    	page = new Page({
    			props: {
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(page.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(page, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const page_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				page_changes.$$scope = { dirty, ctx };
    			}

    			page.$set(page_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(page.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(page.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(page, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CalibrationPage', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CalibrationPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Page, Navbar, Fab, Icon, List, ListInput: List_input });
    	return [];
    }

    class CalibrationPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CalibrationPage",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.44.0 */

    // (38:0) <App {...f7params}>
    function create_default_slot(ctx) {
    	let view;
    	let current;

    	view = new View({
    			props: {
    				url: "/calibration/",
    				class: "safe-areas"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(view.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(view, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(view.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(view.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(view, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(38:0) <App {...f7params}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let app;
    	let current;
    	const app_spread_levels = [/*f7params*/ ctx[0]];

    	let app_props = {
    		$$slots: { default: [create_default_slot] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < app_spread_levels.length; i += 1) {
    		app_props = assign(app_props, app_spread_levels[i]);
    	}

    	app = new App({ props: app_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(app.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(app, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const app_changes = (dirty & /*f7params*/ 1)
    			? get_spread_update(app_spread_levels, [get_spread_object(/*f7params*/ ctx[0])])
    			: {};

    			if (dirty & /*$$scope*/ 2) {
    				app_changes.$$scope = { dirty, ctx };
    			}

    			app.$set(app_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(app.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(app.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(app, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    async function hello() {
    	await JSInterface.printHello();
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);

    	const f7params = {
    		name: 'MultiRoomAudio',
    		id: 'it.unibo.sca.multiroomaudio',
    		// routes
    		routes: [
    			{ path: '/', component: MusicListPage },
    			{ path: '/rooms/', component: RoomsPage },
    			{
    				path: '/calibration/',
    				component: CalibrationPage,
    				main: true
    			},
    			{ path: '/about/', component: AboutPage }
    		]
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		App,
    		View,
    		MusicListPage,
    		AboutPage,
    		RoomsPage,
    		CalibrationPage,
    		f7params,
    		hello
    	});

    	return [f7params];
    }

    class App_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App_1",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    // Init plugin
    Framework7$1.use(Framework7Svelte);

    const app = new App_1({
    	target: document.getElementById('app'),
    });

    //document.addEventListener('contextmenu', event => event.preventDefault());

    return app;

})();
//# sourceMappingURL=bundle.js.map
